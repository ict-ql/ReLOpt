{"define dso_local i32 @readstat_get_row_count(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @readstat_get_row_count(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @readstat_get_row_count(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @readstat_get_row_count(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local void @trie_iterator_clear(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @trie_arr_clear(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @trie_iterator_clear(ptr noundef %0) {\nB:\n%1 = tail call i32 @trie_arr_clear(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @trie_iterator_clear(ptr noundef %0) {\nB:\n%1 = tail call i32 @trie_arr_clear(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @trie_iterator_clear(ptr noundef %0) {\nB:\n%1 = tail call i32 @trie_arr_clear(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @syscon_remove_symbol_name_from_table(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\n%8 = alloca i64, align 8\n%9 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%10 = load i32, ptr %3, align 4\n%11 = zext i32 %10 to i64\n%12 = call ptr @llvm.stacksave()\nstore ptr %12, ptr %7, align 8\n%13 = alloca i32, i64 %11, align 16\nstore i64 %11, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\nstore i32 0, ptr %5, align 4\nbr label %14\n\n14:\n%15 = load i32, ptr %5, align 4\n%16 = load i32, ptr %3, align 4\n%17 = icmp slt i32 %15, %16\nbr i1 %17, label %18, label %31\n\n18:\n%19 = load ptr, ptr %4, align 8\n%20 = load i32, ptr %5, align 4\n%21 = sext i32 %20 to i64\n%22 = getelementptr inbounds i8, ptr %19, i64 %21\n%23 = load i8, ptr %22, align 1\n%24 = sext i8 %23 to i32\n%25 = load i32, ptr %5, align 4\n%26 = sext i32 %25 to i64\n%27 = getelementptr inbounds i32, ptr %13, i64 %26\nstore i32 %24, ptr %27, align 4\nbr label %28\n\n28:\n%29 = load i32, ptr %5, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %5, align 4\nbr label %14\n\n31:\n%32 = load ptr, ptr %9, align 8\n%33 = call i32 @_ada_use_c2phc4c(i32 noundef 296, ptr noundef %3, ptr noundef %13, ptr noundef %32, i32 noundef 0)\nstore i32 %33, ptr %6, align 4\n%34 = load i32, ptr %6, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\n%35 = load ptr, ptr %7, align 8\ncall void @llvm.stackrestore(ptr %35)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %34\n}": {"base_truth": "define dso_local i32 @syscon_remove_symbol_name_from_table(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = zext i32 %0 to i64\n%4 = alloca i32, i64 %3, align 16\n%5 = icmp sgt i32 %0, 0\nbr i1 %5, label %B1, label %B7\n\nB1:\n%6 = icmp ult i32 %0, 32\nbr i1 %6, label %B5, label %B2\n\nB2:\n%7 = and i64 %3, 4294967264\nbr label %B3\n\nB3:\n%8 = phi i64 [ 0, %B2 ], [ %25, %B3 ]\n%9 = getelementptr inbounds i8, ptr %1, i64 %8\n%10 = load <8 x i8>, ptr %9, align 1\n%11 = getelementptr inbounds i8, ptr %9, i64 8\n%12 = load <8 x i8>, ptr %11, align 1\n%13 = getelementptr inbounds i8, ptr %9, i64 16\n%14 = load <8 x i8>, ptr %13, align 1\n%15 = getelementptr inbounds i8, ptr %9, i64 24\n%16 = load <8 x i8>, ptr %15, align 1\n%17 = sext <8 x i8> %10 to <8 x i32>\n%18 = sext <8 x i8> %12 to <8 x i32>\n%19 = sext <8 x i8> %14 to <8 x i32>\n%20 = sext <8 x i8> %16 to <8 x i32>\n%21 = getelementptr inbounds i32, ptr %4, i64 %8\nstore <8 x i32> %17, ptr %21, align 16\n%22 = getelementptr inbounds i32, ptr %21, i64 8\nstore <8 x i32> %18, ptr %22, align 16\n%23 = getelementptr inbounds i32, ptr %21, i64 16\nstore <8 x i32> %19, ptr %23, align 16\n%24 = getelementptr inbounds i32, ptr %21, i64 24\nstore <8 x i32> %20, ptr %24, align 16\n%25 = add nuw i64 %8, 32\n%26 = icmp eq i64 %25, %7\nbr i1 %26, label %B4, label %B3\n\nB4:\n%27 = icmp eq i64 %7, %3\nbr i1 %27, label %B7, label %B5\n\nB5:\n%28 = phi i64 [ 0, %B1 ], [ %7, %B4 ]\nbr label %B6\n\nB6:\n%29 = phi i64 [ %34, %B6 ], [ %28, %B5 ]\n%30 = getelementptr inbounds i8, ptr %1, i64 %29\n%31 = load i8, ptr %30, align 1\n%32 = sext i8 %31 to i32\n%33 = getelementptr inbounds i32, ptr %4, i64 %29\nstore i32 %32, ptr %33, align 4\n%34 = add nuw nsw i64 %29, 1\n%35 = icmp eq i64 %34, %3\nbr i1 %35, label %B7, label %B6\n\nB7:\n%36 = call i32 @_ada_use_c2phc4c(i32 noundef 296, ptr noundef nonnull %2, ptr noundef nonnull %4, ptr noundef undef, i32 noundef 0)\nret i32 %36\n}", "codellama": "define dso_local i32 @syscon_remove_symbol_name_from_table(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = zext i32 %0 to i64\n%4 = alloca i32, i64 %3, align 16\n%5 = icmp sgt i32 %0, 0\nbr i1 %5, label %B1, label %B7\n\nB1:\n%6 = icmp ult i32 %0, 32\nbr i1 %6, label %B5, label %B2\n\nB2:\n%7 = and i64 %3, 4294967264\nbr label %B3\n\nB3:\n%8 = phi i64 [ 0, %B2 ], [ %25, %B3 ]\n%9 = getelementptr inbounds i8, ptr %1, i64 %8\n%10 = load <8 x i8>, ptr %9, align 1\n%11 = getelementptr inbounds i8, ptr %9, i64 8\n%12 = load <8 x i8>, ptr %11, align 1\n%13 = getelementptr inbounds i8, ptr %9, i64 16\n%14 = load <8 x i8>, ptr %13, align 1\n%15 = getelementptr inbounds i8, ptr %9, i64 24\n%16 = load <8 x i8>, ptr %15, align 1\n%17 = sext <8 x i8> %10 to <8 x i32>\n%18 = sext <8 x i8> %12 to <8 x i32>\n%19 = sext <8 x i8> %14 to <8 x i32>\n%20 = sext <8 x i8> %16 to <8 x i32>\n%21 = getelementptr inbounds i32, ptr %4, i64 %8\nstore <8 x i32> %17, ptr %21, align 16\n%22 = getelementptr inbounds i32, ptr %21, i64 8\nstore <8 x i32> %18, ptr %22, align 16\n%23 = getelementptr inbounds i32, ptr %21, i64 16\nstore <8 x i32> %19, ptr %23, align 16\n%24 = getelementptr inbounds i32, ptr %21, i64 24\nstore <8 x i32> %20, ptr %24, align 16\n%25 = add nuw i64 %8, 32\n%26 = icmp eq i64 %25, %7\nbr i1 %26, label %B4, label %B3\n\nB4:\n%27 = icmp eq i64 %7, %3\nbr i1 %27, label %B7, label %B5\n\nB5:\n%28 = phi i64 [ 0, %B1 ], [ %7, %B4 ]\nbr label %B6\n\nB6:\n%29 = phi i64 [ %34, %B6 ], [ %28, %B5 ]\n%30 = getelementptr inbounds i8, ptr %1, i64 %29\n%31 = load i8, ptr %30, align 1\n%32 = sext i8 %31 to i32\n%33 = getelementptr inbounds i32, ptr %4, i64 %29\nstore i32 %32, ptr %33, align 4\n%34 = add nuw nsw i64 %29, 1\n%35 = icmp eq i64 %34, %3\nbr i1 %35, label %B7, label %B6\n\nB7:\n%36 = call i32 @_ada_use_c2phc4c(i32 noundef 296, ptr noundef nonnull %2, ptr noundef nonnull %4, ptr noundef undef, i32 noundef 0)\nret i32 %36\n}", "codegemma": "define dso_local i32 @syscon_remove_symbol_name_from_table(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = zext i32 %0 to i64\n%4 = alloca i32, i64 %3, align 16\n%5 = icmp sgt i32 %0, 0\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = zext i32 %0 to i64\n%7 = icmp ult i32 %0, 16\nbr i1 %7, label %B5, label %B2\n\nB2:\n%8 = and i64 %6, 4294967280\nbr label %B4\n\nB3:\n%9 = call i32 @_ada_use_c2phc4c(i32 noundef 296, ptr noundef nonnull %2, ptr noundef nonnull %4, ptr noundef undef, i32 noundef 0)\nbr label %B6\n\nB4:\n%10 = phi i64 [ 0, %B2 ], [ %14, %B4 ]\n%11 = getelementptr inbounds i8, ptr %1, i64 %10\n%12 = load i8, ptr %11, align 1\n%13 = getelementptr inbounds i32, ptr %4, i64 %10\nstore i32 sext i8 %12 to i32, ptr %13, align 4\n%14 = add nuw nsw i64 %10, 1\n%15 = icmp eq i64 %14, %8\nbr i1 %15, label %B5, label %B4\n\nB5:\n%16 = call i32 @_ada_use_c2phc4c(i32 noundef 296, ptr noundef nonnull %2, ptr noundef nonnull %4, ptr noundef undef, i32 noundef 0)\nbr label %B6\n\nB6:\n%17 = phi i32 [ %9, %B3 ], [ %16, %B5 ]\nret i32 %17\n}"}, "define internal i32 @handle_dots(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %5, align 4\n%7 = load i32, ptr @LAST_DOTDOT, align 4\n%8 = icmp eq i32 %6, %7\nbr i1 %8, label %9, label %31\n\n9:\n%10 = load ptr, ptr %4, align 8\n%11 = getelementptr inbounds %struct.nameidata ptr %10, i32 0, i32 1\n%12 = getelementptr inbounds %struct.TYPE_2__, ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\n%14 = icmp ne i32 %13, 0\nbr i1 %14, label %18, label %15\n\n15:\n%16 = load ptr, ptr %4, align 8\n%17 = call i32 @set_root(ptr noundef %16)\nbr label %18\n\n18:\n%19 = load ptr, ptr %4, align 8\n%20 = getelementptr inbounds %struct.nameidata ptr %19, i32 0, i32 0\n%21 = load i32, ptr %20, align 4\n%22 = load i32, ptr @LOOKUP_RCU, align 4\n%23 = and i32 %21, %22\n%24 = icmp ne i32 %23, 0\nbr i1 %24, label %25, label %28\n\n25:\n%26 = load ptr, ptr %4, align 8\n%27 = call i32 @follow_dotdot_rcu(ptr noundef %26)\nstore i32 %27, ptr %3, align 4\nbr label %32\n\n28:\n%29 = load ptr, ptr %4, align 8\n%30 = call i32 @follow_dotdot(ptr noundef %29)\nstore i32 %30, ptr %3, align 4\nbr label %32\n\n31:\nstore i32 0, ptr %3, align 4\nbr label %32\n\n32:\n%33 = load i32, ptr %3, align 4\nret i32 %33\n}": {"base_truth": "define internal i32 @handle_dots(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @LAST_DOTDOT, align 4\n%3 = icmp eq i32 %2, %1\nbr i1 %3, label %B1, label %B6\n\nB1:\n%4 = getelementptr inbounds %struct.nameidata, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B3\n\nB2:\n%7 = tail call i32 @set_root(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%8 = load i32, ptr %0, align 4\n%9 = load i32, ptr @LOOKUP_RCU, align 4\n%10 = and i32 %9, %8\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B5, label %B4\n\nB4:\n%12 = tail call i32 @follow_dotdot_rcu(ptr noundef nonnull %0)\nbr label %B6\n\nB5:\n%13 = tail call i32 @follow_dotdot(ptr noundef nonnull %0)\nbr label %B6\n\nB6:\n%14 = phi i32 [ %12, %B4 ], [ %13, %B5 ], [ 0, %B ]\nret i32 %14\n}", "codellama": "define internal i32 @handle_dots(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @LAST_DOTDOT, align 4\n%3 = icmp eq i32 %2, %1\nbr i1 %3, label %B1, label %B6\n\nB1:\n%4 = getelementptr inbounds %struct.nameidata, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B3\n\nB2:\n%7 = tail call i32 @set_root(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%8 = load i32, ptr %0, align 4\n%9 = load i32, ptr @LOOKUP_RCU, align 4\n%10 = and i32 %9, %8\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B5, label %B4\n\nB4:\n%12 = tail call i32 @follow_dotdot_rcu(ptr noundef nonnull %0)\nbr label %B6\n\nB5:\n%13 = tail call i32 @follow_dotdot(ptr noundef nonnull %0)\nbr label %B6\n\nB6:\n%14 = phi i32 [ %12, %B4 ], [ %13, %B5 ], [ 0, %B ], [ 0, %B5 ]\nret i32 %14\n}", "codegemma": "define internal i32 @handle_dots(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @LAST_DOTDOT, align 4\n%3 = icmp eq i32 %2, %1\nbr i1 %3, label %B1, label %B5\n\nB1:\n%4 = getelementptr inbounds %struct.nameidata, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B3\n\nB2:\n%7 = tail call i32 @set_root(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%8 = load i32, ptr %0, align 4\n%9 = load i32, ptr @LOOKUP_RCU, align 4\n%10 = and i32 %9, %8\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B4, label %B5\n\nB4:\n%12 = tail call i32 @follow_dotdot(ptr noundef nonnull %0)\nbr label %B5\n\nB5:\n%13 = phi i32 [ %12, %B4 ], [ 0, %B3 ], [ 0, %B ]\nret i32 %13\n}"}, "define dso_local i32 @foo() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 0, ptr %2, align 4\n%5 = call i32 @scanf(ptr noundef @.str, ptr noundef %1, ptr noundef %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr %2, align 4\n%8 = add nsw i32 %6, %7\nstore i32 %8, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 1, ptr %4, align 4\nbr label %9\n\n9:\n%10 = call i32 @printf(ptr noundef @.str.1)\n%11 = load i32, ptr %3, align 4\n%12 = icmp sgt i32 %11, 0\nbr i1 %12, label %13, label %16\n\n13:\n%14 = load i32, ptr %4, align 4\n%15 = add nsw i32 %14, 1\nstore i32 %15, ptr %4, align 4\nbr label %19\n\n16:\n%17 = load i32, ptr %4, align 4\n%18 = sub nsw i32 %17, 1\nstore i32 %18, ptr %4, align 4\nbr label %19\n\n19:\nbr label %20\n\n20:\nbr label %21\n\n21:\n%22 = load i32, ptr %1, align 4\n%23 = icmp sgt i32 %22, 0\nbr i1 %23, label %24, label %29\n\n24:\n%25 = load i32, ptr %4, align 4\n%26 = add nsw i32 %25, 1\nstore i32 %26, ptr %4, align 4\n%27 = load i32, ptr %1, align 4\n%28 = sub nsw i32 %27, 1\nstore i32 %28, ptr %1, align 4\nbr label %21\n\n29:\nbr label %30\n\n30:\n%31 = load i32, ptr %3, align 4\n%32 = load i32, ptr %2, align 4\n%33 = call i32 @afunc(i32 noundef %31, i32 noundef %32)\nswitch i32 %33, label %37 [\ni32 0, label %34\ni32 5, label %35\ni32 10, label %36\n]\n\n34:\nstore i32 0, ptr %2, align 4\nbr label %38\n\n35:\nstore i32 1, ptr %2, align 4\nbr label %38\n\n36:\nstore i32 2, ptr %2, align 4\nbr label %38\n\n37:\nstore i32 3, ptr %2, align 4\nbr label %38\n\n38:\n%39 = load i32, ptr %3, align 4\n%40 = icmp slt i32 %39, 0\nbr i1 %40, label %41, label %42\n\n41:\nbr label %9\n\n42:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 0\n}": {"base_truth": "define dso_local i32 @foo() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 0, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\n%2 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr %1, align 4\n%5 = add nsw i32 %4, %3\n%6 = freeze i32 %5\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B1, label %B9\n\nB1:\n%8 = call i32 @printf(ptr noundef nonnull @.str.1)\n%9 = load i32, ptr %0, align 4\n%10 = icmp sgt i32 %9, 0\nbr i1 %10, label %B2, label %B3\n\nB2:\nstore i32 0, ptr %0, align 4\nbr label %B3\n\nB3:\n%11 = load i32, ptr %1, align 4\n%12 = call i32 @afunc(i32 noundef %6, i32 noundef %11)\nswitch i32 %12, label %B7 [\ni32 0, label %B6\ni32 5, label %B5\ni32 10, label %B4\n]\n\nB4:\nstore i32 2, ptr %1, align 4\nbr label %B8\n\nB5:\nstore i32 1, ptr %1, align 4\nbr label %B8\n\nB6:\nstore i32 0, ptr %1, align 4\nbr label %B8\n\nB7:\nstore i32 3, ptr %1, align 4\nbr label %B8\n\nB8:\nbr label %B1\n\nB9:\n%13 = call i32 @printf(ptr noundef nonnull @.str.1)\n%14 = load i32, ptr %0, align 4\n%15 = icmp sgt i32 %14, 0\nbr i1 %15, label %B10, label %B11\n\nB10:\nstore i32 0, ptr %0, align 4\nbr label %B11\n\nB11:\n%16 = load i32, ptr %1, align 4\n%17 = call i32 @afunc(i32 noundef %6, i32 noundef %16)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @foo() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 0, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\n%2 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr %1, align 4\n%5 = add nsw i32 %4, %3\n%6 = call i32 @printf(ptr noundef nonnull @.str.1)\n%7 = icmp sgt i32 %5, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = phi i32 [ %11, %B1 ], [ 1, %B ]\n%9 = phi i32 [ %10, %B1 ], [ %5, %B ]\n%10 = add nsw i32 %9, -1\n%11 = add nuw nsw i32 %8, 1\n%12 = call i32 @printf(ptr noundef nonnull @.str.1)\n%13 = icmp sgt i32 %9, 1\nbr i1 %13, label %B1, label %B2\n\nB2:\n%14 = phi i32 [ %5, %B ], [ %10, %B1 ]\n%15 = phi i32 [ 1, %B ], [ %8, %B1 ]\n%16 = call i32 @afunc(i32 noundef %14, i32 noundef %4)\nswitch i32 %16, label %B4 [\ni32 0, label %B5\ni32 5, label %B3\ni32 10, label %B3\n]\n\nB3:\nbr label %B5\n\nB4:\nbr label %B5\n\nB5:\n%17 = phi i32 [ 3, %B4 ], [ 2, %B3 ], [ 0, %B2 ]\nstore i32 %17, ptr %1, align 4\n%18 = icmp slt i32 %14, 0\nbr i1 %18, label %B1, label %B6\n\nB6:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @foo() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 0, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\n%2 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr %1, align 4\n%5 = add nsw i32 %4, %3\n%6 = call i32 @printf(ptr noundef nonnull @.str.1)\n%7 = icmp sgt i32 %5, 0\n%8 = call i32 @printf(ptr noundef nonnull @.str.1)\n%9 = call i32 @printf(ptr noundef nonnull @.str.1)\n%10 = call i32 @printf(ptr noundef nonnull @.str.1)\n%11 = call i32 @printf(ptr noundef nonnull @.str.1)\n%12 = call i32 @printf(ptr noundef nonnull @.str.1)\n%13 = call i32 @printf(ptr noundef nonnull @.str.1)\n%14 = call i32 @printf(ptr noundef nonnull @.str.1)\n%15 = call i32 @printf(ptr noundef nonnull @.str.1)\n%16 = call i32 @printf(ptr noundef nonnull @.str.1)\n%17 = call i32 @printf(ptr noundef nonnull @.str.1)\n%18 = call i32 @printf(ptr noundef nonnull @.str.1)\n%19 = call i32 @printf(ptr noundef nonnull @.str.1)\n%20 = call i32 @printf(ptr noundef nonnull @.str.1)\n%21 = call i32 @printf(ptr noundef nonnull @.str.1)\n%22 = call i32 @printf(ptr noundef nonnull @.str.1)\n%23 = call i32 @printf(ptr noundef nonnull @.str.1)\n%24 = call i32 @printf(ptr noundef nonnull @.str.1)\n%25 = call i32 @printf(ptr noundef nonnull @.str.1)\n%26 = call i32 @printf(ptr noundef nonnull @.str.1)\n%27 = call i32 @printf(ptr noundef nonnull @.str.1)\n%28 = call i32 @printf(ptr noundef nonnull @.str.1)\n%29 = call i32 @printf(ptr noundef nonnull @.str.1)\n%30 = call i32 @printf(ptr noundef nonnull @.str.1)\n%31 = call i32 @printf(ptr noundef nonnull @.str.1)\n%32 = call i32 @printf(ptr noundef nonnull @.str.1)\n%33 = call i32 @printf(ptr noundef nonnull @.str.1)\n%34 = call i32 @printf(ptr noundef nonnull @.str.1)\n%35 = call i32 @printf(ptr noundef nonnull @.str.1)\n%36 = call i32 @printf(ptr noundef nonnull @.str.1)\n%37 = call i32 @printf(ptr noundef nonnull @.str.1)\n%38 = call i32 @printf(ptr noundef nonnull @.str.1)\n%39 = call i32 @printf(ptr noundef nonnull @.str.1)\n%40 = call i32 @printf(ptr noundef nonnull @.str.1)\n%41 = call i32 @printf(ptr noundef nonnull @.str.1)\n%42 = call i32 @printf(ptr noundef nonnull @.str.1)\n%43 = call i32 @printf(ptr noundef nonnull @.str.1)\n%44 = call i32 @printf(ptr noundef nonnull @.str.1)\n%45 = call i32 @printf(ptr noundef nonnull @.str.1)\n%46 = call i32 @printf(ptr noundef nonnull @.str.1)\n%47 = call i32 @printf(ptr noundef nonnull @.str.1)\n%48 = call i32 @printf(ptr noundef nonnull @.str.1)\n%49 = call i32 @printf(ptr noundef nonnull @.str.1)\n%50 = call i32 @printf(ptr noundef nonnull @.str.1)\n%51 = call i32 @printf(ptr noundef nonnull @.str.1)\n%52 = call i32 @printf(ptr noundef nonnull @.str.1)\n%53 = call i32 @printf(ptr noundef nonnull @.str.1)\n%54 = call i32 @printf(ptr noundef nonnull @.str.1)\n%55 = call i32 @printf(ptr noundef nonnull @.str.<eos>"}, "define dso_local i32 @aguri2_setup() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i64 0, ptr @flow_num6, align 8\nstore i64 0, ptr @flow_num, align 8\n%4 = load ptr, ptr @addr_src, align 8\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\n%7 = icmp sgt i32 %6, 254\nbr i1 %7, label %13, label %8\n\n8:\n%9 = load ptr, ptr @addr_dst, align 8\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = icmp sgt i32 %11, 254\nbr i1 %12, label %13, label %15\n\n13:\n%14 = call i32 @warnx(ptr noundef @.str)\nstore i32 0, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %70\n\n15:\n%16 = load ptr, ptr @addr_src, align 8\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = load ptr, ptr @addr_dst, align 8\n%20 = getelementptr inbounds %struct.TYPE_6__, ptr %19, i32 0, i32 0\n%21 = load i32, ptr %20, align 4\n%22 = mul nsw i32 %18, %21\nstore i32 %22, ptr %2, align 4\n%23 = load i32, ptr %2, align 4\n%24 = icmp sgt i32 %23, 0\nbr i1 %24, label %25, label %45\n\n25:\n%26 = load ptr, ptr @addr_src, align 8\n%27 = getelementptr inbounds %struct.TYPE_6__, ptr %26, i32 0, i32 1\n%28 = load i32, ptr %27, align 4\n%29 = load ptr, ptr @addr_src, align 8\n%30 = getelementptr inbounds %struct.TYPE_6__, ptr %29, i32 0, i32 0\n%31 = load i32, ptr %30, align 4\n%32 = load ptr, ptr @addr_dst, align 8\n%33 = getelementptr inbounds %struct.TYPE_6__, ptr %32, i32 0, i32 0\n%34 = load i32, ptr %33, align 4\n%35 = load i32, ptr %2, align 4\n%36 = load ptr, ptr @proto_src, align 8\n%37 = getelementptr inbounds %struct.TYPE_6__, ptr %36, i32 0, i32 0\n%38 = load i32, ptr %37, align 4\n%39 = load ptr, ptr @proto_dst, align 8\n%40 = getelementptr inbounds %struct.TYPE_6__, ptr %39, i32 0, i32 0\n%41 = load i32, ptr %40, align 4\n%42 = call i32 @printf(ptr noundef @.str.1, i32 noundef %28, i32 noundef %31, i32 noundef %34, i32 noundef %35, i32 noundef %38, i32 noundef %41)\n%43 = load i32, ptr %2, align 4\n%44 = call i32 @calloc(i32 noundef %43, i32 noundef 4)\nstore i32 %44, ptr @flow_matrix, align 4\nbr label %45\n\n45:\n%46 = load ptr, ptr @addr_src, align 8\n%47 = icmp ne ptr %46, null\nbr i1 %47, label %48, label %51\n\n48:\n%49 = load ptr, ptr @addr_src, align 8\n%50 = call i32 @tree_resetcount(ptr noundef %49)\nbr label %51\n\n51:\n%52 = load ptr, ptr @addr_dst, align 8\n%53 = icmp ne ptr %52, null\nbr i1 %53, label %54, label %57\n\n54:\n%55 = load ptr, ptr @addr_dst, align 8\n%56 = call i32 @tree_resetcount(ptr noundef %55)\nbr label %57\n\n57:\n%58 = load ptr, ptr @proto_src, align 8\n%59 = icmp ne ptr %58, null\nbr i1 %59, label %60, label %63\n\n60:\n%61 = load ptr, ptr @proto_src, align 8\n%62 = call i32 @tree_resetcount(ptr noundef %61)\nbr label %63\n\n63:\n%64 = load ptr, ptr @proto_dst, align 8\n%65 = icmp ne ptr %64, null\nbr i1 %65, label %66, label %69\n\n66:\n%67 = load ptr, ptr @proto_dst, align 8\n%68 = call i32 @tree_resetcount(ptr noundef %67)\nbr label %69\n\n69:\nstore i32 0, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %70\n\n70:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%71 = load i32, ptr %1, align 4\nret i32 %71\n}": {"base_truth": "define dso_local i32 @aguri2_setup() {\nB:\nstore i64 0, ptr @flow_num6, align 8\nstore i64 0, ptr @flow_num, align 8\n%0 = load ptr, ptr @addr_src, align 8\n%1 = load i32, ptr %0, align 4\n%2 = icmp sgt i32 %1, 254\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load ptr, ptr @addr_dst, align 8\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %4, 254\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @warnx(ptr noundef nonnull @.str)\nbr label %B12\n\nB3:\n%7 = mul nsw i32 %4, %1\n%8 = icmp sgt i32 %7, 0\nbr i1 %8, label %B4, label %B5\n\nB4:\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load ptr, ptr @proto_src, align 8\n%12 = load i32, ptr %11, align 4\n%13 = load ptr, ptr @proto_dst, align 8\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %10, i32 noundef %1, i32 noundef %4, i32 noundef %7, i32 noundef %12, i32 noundef %14)\n%16 = tail call i32 @calloc(i32 noundef %7, i32 noundef 4)\nstore i32 %16, ptr @flow_matrix, align 4\n%17 = load ptr, ptr @addr_src, align 8\n%18 = icmp eq ptr %17, null\nbr i1 %18, label %B6, label %B5\n\nB5:\n%19 = phi ptr [ %17, %B4 ], [ %0, %B3 ]\n%20 = tail call i32 @tree_resetcount(ptr noundef nonnull %19)\nbr label %B6\n\nB6:\n%21 = load ptr, ptr @addr_dst, align 8\n%22 = icmp eq ptr %21, null\nbr i1 %22, label %B8, label %B7\n\nB7:\n%23 = tail call i32 @tree_resetcount(ptr noundef nonnull %21)\nbr label %B8\n\nB8:\n%24 = load ptr, ptr @proto_src, align 8\n%25 = icmp eq ptr %24, null\nbr i1 %25, label %B10, label %B9\n\nB9:\n%26 = tail call i32 @tree_resetcount(ptr noundef nonnull %24)\nbr label %B10\n\nB10:\n%27 = load ptr, ptr @proto_dst, align 8\n%28 = icmp eq ptr %27, null\nbr i1 %28, label %B12, label %B11\n\nB11:\n%29 = tail call i32 @tree_resetcount(ptr noundef nonnull %27)\nbr label %B12\n\nB12:\nret i32 0\n}", "codellama": "define dso_local i32 @aguri2_setup() {\nB:\nstore i64 0, ptr @flow_num6, align 8\nstore i64 0, ptr @flow_num, align 8\n%0 = load ptr, ptr @addr_src, align 8\n%1 = load i32, ptr %0, align 4\n%2 = icmp sgt i32 %1, 254\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @warnx(ptr noundef nonnull @.str)\nbr label %B10\n\nB2:\n%4 = load ptr, ptr @addr_dst, align 8\n%5 = load i32, ptr %4, align 4\n%6 = icmp sgt i32 %5, 254\nbr i1 %6, label %B1, label %B3\n\nB3:\n%7 = mul nsw i32 %5, %1\n%8 = icmp sgt i32 %7, 0\nbr i1 %8, label %B4, label %B5\n\nB4:\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %10, i32 noundef %1, i32 noundef %5, i32 noundef %7, i32 noundef %1, i32 noundef %5)\n%12 = tail call i32 @calloc(i32 noundef %7, i32 noundef 4)\nstore i32 %12, ptr @flow_matrix, align 4\nbr label %B5\n\nB5:\n%13 = icmp eq ptr %0, null\nbr i1 %13, label %B7, label %B6\n\nB6:\n%14 = tail call i32 @tree_resetcount(ptr noundef nonnull %0)\nbr label %B7\n\nB7:\n%15 = icmp eq ptr %4, null\nbr i1 %15, label %B9, label %B8\n\nB8:\n%16 = tail call i32 @tree_resetcount(ptr noundef nonnull %4)\nbr label %B9\n\nB9:\n%17 = icmp eq ptr %8, null\nbr i1 %17, label %B10, label %B11\n\nB10:\nret i32 0\n\nB11:\n%18 = load ptr, ptr @proto_src, align 8\n%19 = icmp eq ptr %18, null\nbr i1 %19, label %B13, label %B12\n\nB12:\n%20 = tail call i32 @tree_resetcount(ptr noundef nonnull %18)\nbr label %B13\n\nB13:\n%21 = load ptr, ptr @proto_dst, align 8\n%22 = icmp eq ptr %21, null\nbr i1 %22, label %B10, label %B14\n\nB</s>", "codegemma": "define dso_local i32 @aguri2_setup() {\nB:\n%0 = load ptr, ptr @addr_src, align 8\n%1 = load i32, ptr %0, align 4\n%2 = icmp sgt i32 %1, 254\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = load ptr, ptr @addr_dst, align 8\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %4, 254\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = mul nsw i32 %4, %1\n%7 = icmp sgt i32 %6, 0\nbr i1 %7, label %B4, label %B5\n\nB3:\n%8 = tail call i32 @warnx(ptr noundef nonnull @.str)\nbr label %B11\n\nB4:\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load ptr, ptr @proto_src, align 8\n%12 = load i32, ptr %11, align 4\n%13 = load ptr, ptr @proto_dst, align 8\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %10, i32 noundef %1, i32 noundef %4, i32 noundef %6, i32 noundef %12, i32 noundef %14)\n%16 = tail call i32 @calloc(i32 noundef %6, i32 noundef 4)\nstore i32 %16, ptr @flow_matrix, align 4\nbr label %B5\n\nB5:\n%17 = load ptr, ptr @addr_src, align 8\n%18 = icmp eq ptr %17, null\nbr i1 %18, label %B7, label %B6\n\nB6:\n%19 = tail call i32 @tree_resetcount(ptr noundef nonnull %17)\nbr label %B7\n\nB7:\n%20 = load ptr, ptr @addr_dst, align 8\n%21 = icmp eq ptr %20, null\nbr i1 %21, label %B9, label %B8\n\nB8:\n%22 = tail call i32 @tree_resetcount(ptr noundef nonnull %20)\nbr label %B9\n\nB9:\n%23 = load ptr, ptr @proto_src, align 8\n%24 = icmp eq ptr %23, null\nbr i1 %24, label %B11, label %B10\n\nB10:\n%25 = tail call i32 @tree_resetcount(ptr noundef nonnull %23)\nbr label %B11\n\nB11:\n%26 = load ptr, ptr @proto_dst, align 8\n%27 = icmp eq ptr %26, null\nbr i1 %27, label %B13, label %B12\n\nB12:\n%28 = tail call i32 @tree_resetcount(ptr noundef nonnull %26)\nbr label<eos>"}, "define dso_local void @taDeleteWindow(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %9\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @free(ptr noundef %7)\nbr label %9\n\n9:\nret void\n}": {"base_truth": "define dso_local void @taDeleteWindow(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @taDeleteWindow(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @taDeleteWindow(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local nofpclass(nan inf) double @relative_norm(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca double, align 8\n%8 = alloca double, align 8\n%9 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\nstore double 0.000000e+00, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\nstore double 0.000000e+00, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\nstore i32 1, ptr %9, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %9, align 4\n%12 = load i32, ptr %6, align 4\n%13 = icmp sle i32 %11, %12\nbr i1 %13, label %14, label %31\n\n14:\n%15 = load ptr, ptr %4, align 8\n%16 = load i32, ptr %9, align 4\n%17 = sext i32 %16 to i64\n%18 = getelementptr inbounds double, ptr %15, i64 %17\n%19 = load double, ptr %18, align 8\n%20 = load ptr, ptr %4, align 8\n%21 = load i32, ptr %9, align 4\n%22 = sext i32 %21 to i64\n%23 = getelementptr inbounds double, ptr %20, i64 %22\n%24 = load double, ptr %23, align 8\n%25 = fmul fast double %19, %24\n%26 = load double, ptr %7, align 8\n%27 = fadd fast double %26, %25\nstore double %27, ptr %7, align 8\nbr label %28\n\n28:\n%29 = load i32, ptr %9, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %9, align 4\nbr label %10\n\n31:\nstore i32 1, ptr %9, align 4\nbr label %32\n\n32:\n%33 = load i32, ptr %9, align 4\n%34 = load i32, ptr %6, align 4\n%35 = icmp sle i32 %33, %34\nbr i1 %35, label %36, label %53\n\n36:\n%37 = load ptr, ptr %5, align 8\n%38 = load i32, ptr %9, align 4\n%39 = sext i32 %38 to i64\n%40 = getelementptr inbounds double, ptr %37, i64 %39\n%41 = load double, ptr %40, align 8\n%42 = load ptr, ptr %5, align 8\n%43 = load i32, ptr %9, align 4\n%44 = sext i32 %43 to i64\n%45 = getelementptr inbounds double, ptr %42, i64 %44\n%46 = load double, ptr %45, align 8\n%47 = fmul fast double %41, %46\n%48 = load double, ptr %8, align 8\n%49 = fadd fast double %48, %47\nstore double %49, ptr %8, align 8\nbr label %50\n\n50:\n%51 = load i32, ptr %9, align 4\n%52 = add nsw i32 %51, 1\nstore i32 %52, ptr %9, align 4\nbr label %32\n\n53:\n%54 = load double, ptr %7, align 8\n%55 = call fast double @llvm.sqrt.f64(double %54)\n%56 = load double, ptr %8, align 8\n%57 = call fast double @llvm.sqrt.f64(double %56)\n%58 = fdiv fast double %55, %57\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret double %58\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @relative_norm(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B15, label %B1\n\nB1:\n%4 = add nuw i32 %2, 1\n%5 = zext i32 %4 to i64\n%6 = add nsw i64 %5, -1\n%7 = icmp ult i32 %2, 16\nbr i1 %7, label %B5, label %B2\n\nB2:\n%8 = and i64 %6, -16\n%9 = or i64 %8, 1\nbr label %B3\n\nB3:\n%10 = phi i64 [ 0, %B2 ], [ %32, %B3 ]\n%11 = phi <4 x double> [ zeroinitializer, %B2 ], [ %28, %B3 ]\n%12 = phi <4 x double> [ zeroinitializer, %B2 ], [ %29, %B3 ]\n%13 = phi <4 x double> [ zeroinitializer, %B2 ], [ %30, %B3 ]\n%14 = phi <4 x double> [ zeroinitializer, %B2 ], [ %31, %B3 ]\n%15 = or i64 %10, 1\n%16 = getelementptr inbounds double, ptr %0, i64 %15\n%17 = load <4 x double>, ptr %16, align 8\n%18 = getelementptr inbounds double, ptr %16, i64 4\n%19 = load <4 x double>, ptr %18, align 8\n%20 = getelementptr inbounds double, ptr %16, i64 8\n%21 = load <4 x double>, ptr %20, align 8\n%22 = getelementptr inbounds double, ptr %16, i64 12\n%23 = load <4 x double>, ptr %22, align 8\n%24 = fmul fast <4 x double> %17, %17\n%25 = fmul fast <4 x double> %19, %19\n%26 = fmul fast <4 x double> %21, %21\n%27 = fmul fast <4 x double> %23, %23\n%28 = fadd fast <4 x double> %24, %11\n%29 = fadd fast <4 x double> %25, %12\n%30 = fadd fast <4 x double> %26, %13\n%31 = fadd fast <4 x double> %27, %14\n%32 = add nuw i64 %10, 16\n%33 = icmp eq i64 %32, %8\nbr i1 %33, label %B4, label %B3\n\nB4:\n%34 = fadd fast <4 x double> %29, %28\n%35 = fadd fast <4 x double> %30, %34\n%36 = fadd fast <4 x double> %31, %35\n%37 = tail call fast double @llvm.vector.reduce.fadd.v4f64(double -0.000000e+00, <4 x double> %36)\n%38 = icmp eq i64 %6, %8\nbr i1 %38, label %B6, label %B5\n\nB5:\n%39 = phi i64 [ 1, %B1 ], [ %9, %B4 ]\n%40 = phi double [ 0.000000e+00, %B1 ], [ %37, %B4 ]\nbr label %B12\n\nB6:\n%41 = phi double [ %37, %B4 ], [ %86, %B12 ]\n%42 = insertelement <2 x double> <double poison, double 0.000000e+00>, double %41, i64 0\nbr i1 %3, label %B15, label %B7\n\nB7:\n%43 = add nuw i32 %2, 1\n%44 = zext i32 %43 to i64\n%45 = add nsw i64 %5, -1\n%46 = icmp ult i32 %2, 16\nbr i1 %46, label %B11, label %B8\n\nB8:\n%47 = and i64 %45, -16\n%48 = or i64 %47, 1\nbr label %B9\n\nB9:\n%49 = phi i64 [ 0, %B8 ], [ %71, %B9 ]\n%50 = phi <4 x double> [ zeroinitializer, %B8 ], [ %67, %B9 ]\n%51 = phi <4 x double> [ zeroinitializer, %B8 ], [ %68, %B9 ]\n%52 = phi <4 x double> [ zeroinitializer, %B8 ], [ %69, %B9 ]\n%53 = phi <4 x double> [ zeroinitializer, %B8 ], [ %70, %B9 ]\n%54 = or i64 %49, 1\n%55 = getelementptr inbounds double, ptr %1, i64 %54\n%56 = load <4 x double>, ptr %55, align 8\n%57 = getelementptr inbounds double, ptr %55, i64 4\n%58 = load <4 x double>, ptr %57, align 8\n%59 = getelementptr inbounds double, ptr %55, i64 8\n%60 = load <4 x double>, ptr %59, align 8\n%61 = getelementptr inbounds double, ptr %55, i64 12\n%62 = load <4 x double>, ptr %61, align 8\n%63 = fmul fast <4 x double> %56, %56\n%64 = fmul fast <4 x double> %58, %58\n%65 = fmul fast <4 x double> %60, %60\n%66 = fmul fast <4 x double> %62, %62\n%67 = fadd fast <4 x double> %63, %50\n%68 = fadd fast <4 x double> %64, %51\n%69 = fadd fast <4 x double> %65, %52\n%70 = fadd fast <4 x double> %66, %53\n%71 = add nuw i64 %49, 16\n%72 = icmp eq i64 %71, %47\nbr i1 %72, label %B10, label %B9\n\nB10:\n%73 = fadd fast <4 x double> %68, %67\n%74 = fadd fast <4 x double> %69, %73\n%75 = fadd fast <4 x double> %70, %74\n%76 = tail call fast double @llvm.vector.reduce.fadd.v4f64(double -0.000000e+00, <4 x double> %75)\n%77 = icmp eq i64 %45, %47\n%78 = insertelement <2 x double> %42, double %76, i64 1\nbr i1 %77, label %B15, label %B11\n\nB11:\n%79 = phi i64 [ 1, %B7 ], [ %48, %B10 ]\n%80 = phi double [ 0.000000e+00, %B7 ], [ %76, %B10 ]\nbr label %B13\n\nB12:\n%81 = phi i64 [ %87, %B12 ], [ %39, %B5 ]\n%82 = phi double [ %86, %B12 ], [ %40, %B5 ]\n%83 = getelementptr inbounds double, ptr %0, i64 %81\n%84 = load double, ptr %83, align 8\n%85 = fmul fast double %84, %84\n%86 = fadd fast double %85, %82\n%87 = add nuw nsw i64 %81, 1\n%88 = icmp eq i64 %87, %5\nbr i1 %88, label %B6, label %B12\n\nB13:\n%89 = phi i64 [ %95, %B13 ], [ %79, %B11 ]\n%90 = phi double [ %94, %B13 ], [ %80, %B11 ]\n%91 = getelementptr inbounds double, ptr %1, i64 %89\n%92 = load double, ptr %91, align 8\n%93 = fmul fast double %92, %92\n%94 = fadd fast double %93, %90\n%95 = add nuw nsw i64 %89, 1\n%96 = icmp eq i64 %95, %44\nbr i1 %96, label %B14, label %B13\n\nB14:\n%97 = insertelement <2 x double> %42, double %94, i64 1\nbr label %B15\n\nB15:\n%98 = phi <2 x double> [ %42, %B6 ], [ zeroinitializer, %B ], [ %78, %B10 ], [ %97, %B14 ]\n%99 = tail call fast <2 x double> @llvm.sqrt.v2f64(<2 x double> %98)\n%100 = shufflevector <2 x double> %99, <2 x double> poison, <2 x i32> <i32 1, i32 poison>\n%101 = fdiv fast <2 x double> %99, %100\n%102 = extractelement <2 x double> %101, i64 0\nret double %102\n}", "codellama": "define dso_local nofpclass(nan inf) double @relative_norm(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = add nuw i32 %2, 1\n%5 = zext i32 %4 to i64\n%6 = add nuw nsw i32 %2, 1\n%7 = zext i32 %6 to i64\n%8 = add nuw nsw i32 %2, 2\n%9 = zext i32 %8 to i64\n%10 = add nuw nsw i32 %2, 3\n%11 = zext i32 %10 to i64\n%12 = add nuw nsw i32 %2, 4\n%13 = zext i32 %12 to i64\n%14 = add nuw nsw i32 %2, 5\n%15 = zext i32 %14 to i64\n%16 = add nuw nsw i32 %2, 6\n%17 = zext i32 %16 to i64\n%18 = add nuw nsw i32 %2, 7\n%19 = zext i32 %18 to i64\n%20 = add nuw nsw i32 %2, 8\n%21 = zext i32 %20 to i64\n%22 = add nuw nsw i32 %2, 9\n%23 = zext i32 %22 to i64\n%24 = add nuw nsw i32 %2, 10\n%25 = zext i32 %24 to i64\n%26 = add nuw nsw i32 %2, 11\n%27 = zext i32 %26 to i64\n%28 = add nuw nsw i32 %2, 12\n%29 = zext i32 %28 to i64\n%30 = add nuw nsw i32 %2, 13\n%31 = zext i32 %30 to i64\n%32 = add nuw nsw i32 %2, 14\n%33 = zext i32 %32 to i64\n%34 = add nuw nsw i32 %2, 15\n%35 = zext i32 %34 to i64\n%36 = add nuw nsw i32 %2, 16\n%37 = zext i32 %36 to i64\n%38 = add nuw nsw i32 %2, 17\n%39 = zext i32 %38 to i64\n%40 = add nuw nsw i32 %2, 18\n%41 = zext i32 %40 to i64\n%42 = add nuw nsw i32 %2, 19\n%43 = zext i32 %42 to i64\n%44 = add nuw nsw i32 %2, 20\n%45 = zext i32 %44 to i64\n%46 = add nuw nsw i32 %2, 21\n%47 = zext i32 %46 to i64\n%48 = add nuw nsw i32 %2, 22\n%49 = zext i32 %48 to i64\n%50 = add nuw nsw i32 %2, 23\n%51 = zext i32 %50 to i64\n%52 = add nuw nsw i32 %2, 24\n%53 = zext i32 %52 to i64\n%54 = add nuw nsw i32 %2, 25\n%55 = zext i32 %54 to i64\n%56 = add nuw nsw i32 %2, 26\n%57 = zext i32 %56 to i64\n%58 = add nuw nsw i32 %2, 27\n%59 = zext i32 %58 to i64\n%60 = add nuw nsw i32 %2, 28\n%61 = zext i32 %60 to i64\n%62 = add nuw nsw i32 %2, 29\n%63 = zext i32 %62 to i64\n%64 = add nuw nsw i32 %2, 30\n%65 = zext i32 %64 to i64\n</s>", "codegemma": "define dso_local nofpclass(nan inf) double @relative_norm(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B11, label %B1\n\nB1:\n%4 = zext i32 %2 to i64\n%5 = icmp ult i32 %2, 32\nbr i1 %5, label %B5, label %B2\n\nB2:\n%6 = and i64 %4, 4294967264\nbr label %B3\n\nB3:\n%7 = phi i64 [ 1, %B2 ], [ %13, %B3 ]\n%8 = phi <8 x double> [ zeroinitializer, %B2 ], [ %9, %B3 ]\n%9 = phi <8 x double> [ zeroinitializer, %B2 ], [ %10, %B3 ]\n%10 = phi <8 x double> [ zeroinitializer, %B2 ], [ %11, %B3 ]\n%11 = phi <8 x double> [ zeroinitializer, %B2 ], [ %12, %B3 ]\n%12 = phi <8 x double> [ zeroinitializer, %B2 ], [ %13, %B3 ]\n%13 = add nuw i64 %7, 8\n%14 = getelementptr inbounds double, ptr %0, i64 %7\n%15 = load <8 x double>, ptr %14, align 8\n%16 = getelementptr inbounds double, ptr %14, i64 8\n%17 = load <8 x double>, ptr %16, align 8\n%18 = getelementptr inbounds double, ptr %14, i64 16\n%19 = load <8 x double>, ptr %18, align 8\n%20 = getelementptr inbounds double, ptr %14, i64 24\n%21 = load <8 x double>, ptr %20, align 8\n%22 = fmul fast <8 x double> %15, %15\n%23 = fmul fast <8 x double> %17, %17\n%24 = fmul fast <8 x double> %19, %19\n%25 = fmul fast <8 x double> %21, %21\n%26 = fadd fast <8 x double> %22, %23\n%27 = fadd fast <8 x double> %26, %24\n%28 = fadd fast <8 x double> %27, %25\n%29 = fadd fast <8 x double> %28, <double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00>\n%30 = fadd fast <8 x double> %29, %9\n%31 = fadd fast <8 x double> %30, %10\n%32 = fadd fast <8 x double> %31, %11\n%33 = fadd fast <8 x double> %32, %12\n%34 = tail call fast double @llvm.sqrt.f64(double %23)\n%35 = tail call fast double @llvm.sqrt.f64(double %24)\n%36 = tail call fast double @llvm.sqrt.f64(double %25)\n%37 = tail call fast double @llvm.sqrt.f64(double %26)\n%38 = tail call fast double @llvm.sqrt.f64(double %27)\n%39 = tail call fast double @llvm.sqrt.f64(double %28)\n%40 = tail call fast double @llvm.sqrt.f64(double %29)\n%41 = tail call fast double @llvm.sqrt.f64(double %30)\n%42 = tail call fast double @llvm.sqrt.f64(double %31)\n%43 = tail call fast double @llvm.sqrt.f64(double %32)\n%44 = tail call fast double @llvm.sqrt.f64(double %33)\n%45 = tail call fast double @llvm.sqrt.f64(double %34)\n%46 = tail call fast double @llvm.sqrt.f64(double %35)\n%47 = tail call fast double @llvm.sqrt.f64(double %36)\n%48 = tail call fast double @llvm.sqrt.f64(double %37)\n%49 = tail call fast<eos>"}, "define dso_local void @test() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\nbr label %2\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = load i32, ptr @tester, align 4\n%5 = icmp slt i32 %3, %4\nbr i1 %5, label %6, label %12\n\n6:\n%7 = load i32, ptr %1, align 4\n%8 = call i32 @test_size(i32 noundef %7)\nbr label %9\n\n9:\n%10 = load i32, ptr %1, align 4\n%11 = add nsw i32 %10, 1\nstore i32 %11, ptr %1, align 4\nbr label %2\n\n12:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @test() {\nB:\n%0 = load i32, ptr @tester, align 4\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 0, %B ]\n%3 = tail call i32 @test_size(i32 noundef %2)\n%4 = add nuw nsw i32 %2, 1\n%5 = load i32, ptr @tester, align 4\n%6 = icmp slt i32 %4, %5\nbr i1 %6, label %B1, label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @test() {\nB:\n%0 = load i32, ptr @tester, align 4\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 0, %B ]\n%3 = tail call i32 @test_size(i32 noundef %2)\n%4 = add nuw nsw i32 %2, 1\n%5 = load i32, ptr @tester, align 4\n%6 = icmp slt i32 %4, %5\nbr i1 %6, label %B1, label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @test() {\nB:\n%0 = load i32, ptr @tester, align 4\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 0, %B ]\n%3 = tail call i32 @test_size(i32 noundef %2)\n%4 = add nuw nsw i32 %2, 1\n%5 = load i32, ptr @tester, align 4\n%6 = icmp slt i32 %4, %5\nbr i1 %6, label %B1, label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @MethodParamsIsValid(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %6, label %7\n\n6:\nstore i32 0, ptr %2, align 4\nbr label %42\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\n%11 = icmp slt i32 %10, 1\nbr i1 %11, label %12, label %13\n\n12:\nstore i32 0, ptr %2, align 4\nbr label %42\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.TYPE_3__, ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 4\n%17 = srem i32 %16, 2\n%18 = icmp ne i32 %17, 0\nbr i1 %18, label %19, label %20\n\n19:\nstore i32 0, ptr %2, align 4\nbr label %42\n\n20:\n%21 = load ptr, ptr %3, align 8\n%22 = getelementptr inbounds %struct.TYPE_3__, ptr %21, i32 0, i32 3\n%23 = load i32, ptr %22, align 4\n%24 = call i32 @SelectionParamsIsValid(i32 noundef %23)\n%25 = icmp ne i32 %24, 0\nbr i1 %25, label %27, label %26\n\n26:\nstore i32 0, ptr %2, align 4\nbr label %42\n\n27:\n%28 = load ptr, ptr %3, align 8\n%29 = getelementptr inbounds %struct.TYPE_3__, ptr %28, i32 0, i32 2\n%30 = load i32, ptr %29, align 4\n%31 = call i32 @CrossOverParamsIsValid(i32 noundef %30)\n%32 = icmp ne i32 %31, 0\nbr i1 %32, label %34, label %33\n\n33:\nstore i32 0, ptr %2, align 4\nbr label %42\n\n34:\n%35 = load ptr, ptr %3, align 8\n%36 = getelementptr inbounds %struct.TYPE_3__, ptr %35, i32 0, i32 1\n%37 = load i32, ptr %36, align 4\n%38 = call i32 @ProblemParamsIsValid(i32 noundef %37)\n%39 = icmp ne i32 %38, 0\nbr i1 %39, label %41, label %40\n\n40:\nstore i32 0, ptr %2, align 4\nbr label %42\n\n41:\nstore i32 1, ptr %2, align 4\nbr label %42\n\n42:\n%43 = load i32, ptr %2, align 4\nret i32 %43\n}": {"base_truth": "define dso_local i32 @MethodParamsIsValid(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B5, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = icmp sgt i32 %2, 0\n%4 = and i32 %2, 1\n%5 = icmp eq i32 %4, 0\n%6 = and i1 %3, %5\nbr i1 %6, label %B2, label %B5\n\nB2:\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%8 = load i32, ptr %7, align 4\n%9 = tail call i32 @SelectionParamsIsValid(i32 noundef %8)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B5, label %B3\n\nB3:\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @CrossOverParamsIsValid(i32 noundef %12)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B5, label %B4\n\nB4:\n%15 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = tail call i32 @ProblemParamsIsValid(i32 noundef %16)\n%18 = icmp ne i32 %17, 0\n%19 = zext i1 %18 to i32\nbr label %B5\n\nB5:\n%20 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ 0, %B3 ], [ %19, %B4 ]\nret i32 %20\n}", "codellama": "define dso_local i32 @MethodParamsIsValid(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B5, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B5, label %B2\n\nB2:\n%4 = and i32 %2, 1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B3, label %B5\n\nB3:\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @SelectionParamsIsValid(i32 noundef %7)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B5, label %B4\n\nB4:\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @CrossOverParamsIsValid(i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B5, label %B5\n\nB5:\n%14 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ 0, %B3 ], [ 0, %B4 ], [ 1, %B4 ]\nret i32 %14\n}", "codegemma": "define dso_local i32 @MethodParamsIsValid(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B6, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B6, label %B2\n\nB2:\n%4 = and i32 %2, 1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B3, label %B6\n\nB3:\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @SelectionParamsIsValid(i32 noundef %7)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B6, label %B4\n\nB4:\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @CrossOverParamsIsValid(i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B6, label %B5\n\nB5:\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%15 = load i32, ptr %14, align 4\n%16 = tail call i32 @ProblemParamsIsValid(i32 noundef %15)\n%17 = icmp ne i32 %16, 0\n%18 = zext i1 %17 to i32\nbr label %B6\n\nB6:\n%19 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ 0, %B3 ], [ 0, %B4 ], [ %18, %B5 ]\nret i32 %19\n}"}, "define dso_local i32 @xfrm_count_auth_supported() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 0, ptr %1, align 4\nstore i32 0, ptr %2, align 4\nbr label %3\n\n3:\n%4 = load i32, ptr %1, align 4\n%5 = call i32 (...) @aalg_entries()\n%6 = icmp slt i32 %4, %5\nbr i1 %6, label %7, label %22\n\n7:\n%8 = load ptr, ptr @aalg_list, align 8\n%9 = load i32, ptr %1, align 4\n%10 = sext i32 %9 to i64\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i64 %10\n%12 = getelementptr inbounds %struct.TYPE_2__, ptr %11, i32 0, i32 0\n%13 = load i64, ptr %12, align 8\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %18\n\n15:\n%16 = load i32, ptr %2, align 4\n%17 = add nsw i32 %16, 1\nstore i32 %17, ptr %2, align 4\nbr label %18\n\n18:\nbr label %19\n\n19:\n%20 = load i32, ptr %1, align 4\n%21 = add nsw i32 %20, 1\nstore i32 %21, ptr %1, align 4\nbr label %3\n\n22:\n%23 = load i32, ptr %2, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %23\n}": {"base_truth": "define dso_local i32 @xfrm_count_auth_supported() {\nB:\n%0 = tail call i32 (...) @aalg_entries()\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i64 [ %10, %B1 ], [ 0, %B ]\n%3 = phi i32 [ %9, %B1 ], [ 0, %B ]\n%4 = load ptr, ptr @aalg_list, align 8\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %4, i64 %2\n%6 = load i64, ptr %5, align 8\n%7 = icmp ne i64 %6, 0\n%8 = zext i1 %7 to i32\n%9 = add nuw nsw i32 %3, %8\n%10 = add nuw nsw i64 %2, 1\n%11 = tail call i32 (...) @aalg_entries()\n%12 = sext i32 %11 to i64\n%13 = icmp slt i64 %10, %12\nbr i1 %13, label %B1, label %B2\n\nB2:\n%14 = phi i32 [ 0, %B ], [ %9, %B1 ]\nret i32 %14\n}", "codellama": "define dso_local i32 @xfrm_count_auth_supported() {\nB:\n%0 = tail call i32 (...) @aalg_entries()\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B7\n\nB1:\n%2 = load ptr, ptr @aalg_list, align 8\n%3 = zext i32 %0 to i64\n%4 = icmp ult i32 %0, 32\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = and i64 %3, 4294967264\nbr label %B3\n\nB3:\n%6 = phi i64 [ 0, %B2 ], [ %27, %B3 ]\n%7 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %23, %B3 ]\n%8 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %24, %B3 ]\n%9 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %25, %B3 ]\n%10 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %26, %B3 ]\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %2, i64 %6\n%12 = load <8 x i64>, ptr %11, align 8\n%13 = getelementptr inbounds i64, ptr %11, i64 8\n%14 = load <8 x i64>, ptr %13, align 8\n%15 = getelementptr inbounds i64, ptr %11, i64 16\n%16 = load <8 x i64>, ptr %15, align 8\n%17 = getelementptr inbounds i64, ptr %11, i64 24\n%18 = load <8 x i64>, ptr %17, align 8\n%19 = icmp ne <8 x i64> %12, zeroinitializer\n%20 = icmp ne <8 x i64> %14, zeroinitializer\n%21 = icmp ne <8 x i64> %16, zeroinitializer\n%22 = icmp ne <8 x i64> %18, zeroinitializer\n%23 = select <8 x i1> %19, <8 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, <8 x i32> zeroinitializer\n%24 = select <8 x i1> %20, <8 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, <8 x i32> zeroinitializer\n%25 = select <8 x i1> %21, <8 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, <8 x i32> zeroinitializer\n%26 = select <8 x i1> %22, <8 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, <8 x i32> zeroinitializer\n%27 = add nuw nsw i64 %6, 32\n%28 = icmp eq i64 %27, %5\nbr i1 %28, label %B4, label %B3\n\nB4:\n%29 = add <8 x i32> %24, %23\n%30 = add <8 x i32> %25, %29\n%31 = add <8 x i32> %26, %30\n%32 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %31)\n%33 = icmp eq i64 %5, %3\nbr i1 %33, label %B7, label %B5\n\nB5:\n%34 = phi i64 [ 0, %B1 ], [ %5, %B4 ]\n%35 = phi i32 [ 0, %B1 ], [ %32, %B4 ]\nbr label %B6\n\nB6:\n%36 = phi i64 [ %42, %B6 ], [ %34, %B5 ]\n%37 = phi i32 [ %41, %B6 ], [ %35, %B5 ]\n%38 = getelementptr inbounds %struct.TYPE_2__, ptr %2, i64 %36\n%39 = load i64, ptr %38, align 8\n%40 = icmp ne i64 %39, 0\n%41 = add nuw nsw i32 %37, %40\n%42 = add nuw nsw i64 %36, 1\n%43 = icmp eq i64 %42, %3\nbr i1 %43, label %B7, label %B6\n\nB7:\n%44 = phi i32 [ 0, %B ], [ %32, %B4 ], [ %41, %B6 ]\nret i32 %44\n}", "codegemma": "define dso_local i32 @xfrm_count_auth_supported() {\nB:\n%0 = tail call i32 (...) @aalg_entries()\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i64 [ %10, %B1 ], [ 0, %B ]\n%3 = phi i32 [ %9, %B1 ], [ 0, %B ]\n%4 = load ptr, ptr @aalg_list, align 8\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %4, i64 %2\n%6 = load i64, ptr %5, align 8\n%7 = icmp ne i64 %6, 0\n%8 = zext i1 %7 to i32\n%9 = add nuw nsw i32 %3, %8\n%10 = add nuw nsw i64 %2, 1\n%11 = icmp eq i64 %10, %0\nbr i1 %11, label %B2, label %B1\n\nB2:\n%12 = phi i32 [ 0, %B ], [ %9, %B1 ]\nret i32 %12\n}"}, "define internal i32 @mwl_map2regioncode(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.ieee80211_regdomain ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nswitch i32 %6, label %41 [\ni32 131, label %7\ni32 130, label %7\ni32 135, label %9\ni32 134, label %11\ni32 133, label %11\ni32 132, label %11\ni32 129, label %35\ni32 128, label %37\ni32 138, label %39\ni32 137, label %39\ni32 136, label %39\n]\n\n7:\n%8 = load i32, ptr @DOMAIN_CODE_FCC, align 4\nstore i32 %8, ptr %2, align 4\nbr label %43\n\n9:\n%10 = load i32, ptr @DOMAIN_CODE_IC, align 4\nstore i32 %10, ptr %2, align 4\nbr label %43\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.ieee80211_regdomain ptr %12, i32 0, i32 1\n%14 = load i32, ptr %13, align 4\n%15 = load i32, ptr @CTRY_SPAIN, align 4\n%16 = icmp eq i32 %14, %15\nbr i1 %16, label %17, label %19\n\n17:\n%18 = load i32, ptr @DOMAIN_CODE_SPAIN, align 4\nstore i32 %18, ptr %2, align 4\nbr label %43\n\n19:\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.ieee80211_regdomain ptr %20, i32 0, i32 1\n%22 = load i32, ptr %21, align 4\n%23 = load i32, ptr @CTRY_FRANCE, align 4\n%24 = icmp eq i32 %22, %23\nbr i1 %24, label %31, label %25\n\n25:\n%26 = load ptr, ptr %3, align 8\n%27 = getelementptr inbounds %struct.ieee80211_regdomain ptr %26, i32 0, i32 1\n%28 = load i32, ptr %27, align 4\n%29 = load i32, ptr @CTRY_FRANCE2, align 4\n%30 = icmp eq i32 %28, %29\nbr i1 %30, label %31, label %33\n\n31:\n%32 = load i32, ptr @DOMAIN_CODE_FRANCE, align 4\nstore i32 %32, ptr %2, align 4\nbr label %43\n\n33:\n%34 = load i32, ptr @DOMAIN_CODE_ETSI_131, align 4\nstore i32 %34, ptr %2, align 4\nbr label %43\n\n35:\n%36 = load i32, ptr @DOMAIN_CODE_MKK, align 4\nstore i32 %36, ptr %2, align 4\nbr label %43\n\n37:\n%38 = load i32, ptr @DOMAIN_CODE_DGT, align 4\nstore i32 %38, ptr %2, align 4\nbr label %43\n\n39:\n%40 = load i32, ptr @DOMAIN_CODE_AUS, align 4\nstore i32 %40, ptr %2, align 4\nbr label %43\n\n41:\n%42 = load i32, ptr @DOMAIN_CODE_FCC, align 4\nstore i32 %42, ptr %2, align 4\nbr label %43\n\n43:\n%44 = load i32, ptr %2, align 4\nret i32 %44\n}": {"base_truth": "define internal i32 @mwl_map2regioncode(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B7 [\ni32 136, label %B6\ni32 137, label %B6\ni32 135, label %B1\ni32 134, label %B2\ni32 133, label %B2\ni32 132, label %B2\ni32 129, label %B4\ni32 128, label %B5\ni32 138, label %B6\n]\n\nB1:\nbr label %B7\n\nB2:\n%2 = getelementptr inbounds %struct.ieee80211_regdomain, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @CTRY_SPAIN, align 4\n%5 = icmp eq i32 %3, %4\nbr i1 %5, label %B7, label %B3\n\nB3:\n%6 = load i32, ptr @CTRY_FRANCE, align 4\n%7 = icmp eq i32 %3, %6\n%8 = load i32, ptr @CTRY_FRANCE2, align 4\n%9 = icmp eq i32 %3, %8\n%10 = select i1 %7, i1 true, i1 %9\n%11 = select i1 %10, ptr @DOMAIN_CODE_FRANCE, ptr @DOMAIN_CODE_ETSI_131\nbr label %B7\n\nB4:\nbr label %B7\n\nB5:\nbr label %B7\n\nB6:\nbr label %B7\n\nB7:\n%12 = phi ptr [ @DOMAIN_CODE_AUS, %B6 ], [ @DOMAIN_CODE_DGT, %B5 ], [ @DOMAIN_CODE_MKK, %B4 ], [ @DOMAIN_CODE_IC, %B1 ], [ @DOMAIN_CODE_SPAIN, %B2 ], [ @DOMAIN_CODE_FCC, %B ], [ %11, %B3 ]\n%13 = load i32, ptr %12, align 4\nret i32 %13\n}", "codellama": "define internal i32 @mwl_map2regioncode(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B10 [\ni32 131, label %B11\ni32 130, label %B11\ni32 135, label %B2\ni32 134, label %B3\ni32 133, label %B3\ni32 132, label %B3\ni32 129, label %B4\ni32 128, label %B5\ni32 138, label %B6\ni32 137, label %B6\ni32 136, label %B6\n]\n\nB1:\nbr label %B10\n\nB2:\nbr label %B11\n\nB3:\n%2 = getelementptr inbounds %struct.ieee80211_regdomain, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @CTRY_SPAIN, align 4\n%5 = icmp eq i32 %3, %4\nbr i1 %5, label %B11, label %B4\n\nB4:\n%6 = load i32, ptr @CTRY_FRANCE, align 4\n%7 = icmp eq i32 %3, %6\n%8 = load i32, ptr @CTRY_FRANCE2, align 4\n%9 = icmp eq i32 %3, %8\n%10 = select i1 %7, i1 true, i1 %9\n%11 = select i1 %10, ptr @DOMAIN_CODE_FRANCE, ptr @DOMAIN_CODE_ETSI_131\nbr label %B11\n\nB5:\nbr label %B11\n\nB6:\nbr label %B11\n\nB7:\nbr label %B10\n\nB8:\nbr label %B10\n\nB9:\nbr label %B10\n\nB10:\n%12 = phi ptr [ @DOMAIN_CODE_FCC, %B ], [ @DOMAIN_CODE_AUS, %B6 ], [ @DOMAIN_CODE_DGT, %B5 ], [ @DOMAIN_CODE_MKK, %B4 ], [ @DOMAIN_CODE_FCC, %B7 ], [ @DOMAIN_CODE_FCC, %B8 ], [ @DOMAIN_CODE_FCC, %B9 ]\n%13 = load i32, ptr %12, align 4\nbr label %B11\n\nB11:\n%14 = phi i32 [ 131, %B ], [ 130, %B ], [ 135, %B2 ], [ 134, %B3 ], [ 133, %B3 ], [ 132, %B3 ], [ 129, %B5 ], [ 128, %B5 ], [ 138, %B6 ], [ 137, %B6 ], [ 136, %B6 ], [ %13, %B10 ], [ %13, %B9 ], [ %13, %B8 ], [ %13, %B7 ], [ %13, %B4 ], [ %13, %B3 ], [ %13, %B2 ], [ %13, %B ]\nret i32 %14\n}", "codegemma": "define internal i32 @mwl_map2regioncode(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B10 [\ni32 131, label %B1\ni32 130, label %B1\ni32 135, label %B2\ni32 134, label %B3\ni32 133, label %B3\ni32 132, label %B3\ni32 129, label %B7\ni32 128, label %B8\ni32 138, label %B9\ni32 137, label %B9\ni32 136, label %B9\n]\n\nB1:\n%2 = load i32, ptr @DOMAIN_CODE_FCC, align 4\nbr label %B11\n\nB2:\n%3 = load i32, ptr @DOMAIN_CODE_IC, align 4\nbr label %B11\n\nB3:\n%4 = getelementptr inbounds %struct.ieee80211_regdomain, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr @CTRY_SPAIN, align 4\n%7 = icmp eq i32 %5, %6\nbr i1 %7, label %B4, label %B5\n\nB4:\n%8 = load i32, ptr @DOMAIN_CODE_SPAIN, align 4\nbr label %B11\n\nB5:\n%9 = load i32, ptr @CTRY_FRANCE, align 4\n%10 = icmp eq i32 %5, %9\n%11 = load i32, ptr @CTRY_FRANCE2, align 4\n%12 = icmp eq i32 %5, %11\n%13 = select i1 %10, i1 true, i1 %12\nbr i1 %13, label %B6, label %B7\n\nB6:\n%14 = load i32, ptr @DOMAIN_CODE_FRANCE, align 4\nbr label %B11\n\nB7:\n%15 = load i32, ptr @DOMAIN_CODE_MKK, align 4\nbr label %B11\n\nB8:\n%16 = load i32, ptr @DOMAIN_CODE_DGT, align 4\nbr label %B11\n\nB9:\n%17 = load i32, ptr @DOMAIN_CODE_AUS, align 4\nbr label %B11\n\nB10:\n%18 = load i32, ptr @DOMAIN_CODE_FCC, align 4\nbr label %B11\n\nB11:\n%19 = phi i32 [ %18, %B10 ], [ %17, %B9 ], [ %16, %B8 ], [ %14, %B6 ], [ %8, %B4 ], [ %3, %B2 ], [ %2, %B1 ]\nret i32 %19\n}"}, "define dso_local void @kvm_set_way_flush(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @vcpu_hcr(ptr noundef %4)\n%6 = load i64, ptr %5, align 8\nstore i64 %6, ptr %3, align 8\n%7 = load i64, ptr %3, align 8\n%8 = load i64, ptr @HCR_TVM, align 8\n%9 = and i64 %7, %8\n%10 = icmp ne i64 %9, 0\nbr i1 %10, label %27, label %11\n\n11:\n%12 = load ptr, ptr %2, align 8\n%13 = call ptr @vcpu_pc(ptr noundef %12)\n%14 = load i32, ptr %13, align 4\n%15 = load ptr, ptr %2, align 8\n%16 = call i32 @vcpu_has_cache_enabled(ptr noundef %15)\n%17 = call i32 @trace_kvm_set_way_flush(i32 noundef %14, i32 noundef %16)\n%18 = load ptr, ptr %2, align 8\n%19 = getelementptr inbounds %struct.kvm_vcpu, ptr %18, i32 0, i32 0\n%20 = load i32, ptr %19, align 4\n%21 = call i32 @stage2_flush_vm(i32 noundef %20)\n%22 = load i64, ptr %3, align 8\n%23 = load i64, ptr @HCR_TVM, align 8\n%24 = or i64 %22, %23\n%25 = load ptr, ptr %2, align 8\n%26 = call ptr @vcpu_hcr(ptr noundef %25)\nstore i64 %24, ptr %26, align 8\nbr label %27\n\n27:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @kvm_set_way_flush(ptr noundef %0) {\nB:\n%1 = tail call ptr @vcpu_hcr(ptr noundef %0)\n%2 = load i64, ptr %1, align 8\n%3 = load i64, ptr @HCR_TVM, align 8\n%4 = and i64 %3, %2\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call ptr @vcpu_pc(ptr noundef %0)\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @vcpu_has_cache_enabled(ptr noundef %0)\n%9 = tail call i32 @trace_kvm_set_way_flush(i32 noundef %7, i32 noundef %8)\n%10 = load i32, ptr %0, align 4\n%11 = tail call i32 @stage2_flush_vm(i32 noundef %10)\n%12 = load i64, ptr @HCR_TVM, align 8\n%13 = or i64 %12, %2\n%14 = tail call ptr @vcpu_hcr(ptr noundef nonnull %0)\nstore i64 %13, ptr %14, align 8\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @kvm_set_way_flush(ptr noundef %0) {\nB:\n%1 = tail call ptr @vcpu_hcr(ptr noundef %0)\n%2 = load i64, ptr %1, align 8\n%3 = load i64, ptr @HCR_TVM, align 8\n%4 = and i64 %3, %2\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call ptr @vcpu_pc(ptr noundef %0)\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @vcpu_has_cache_enabled(ptr noundef %0)\n%9 = tail call i32 @trace_kvm_set_way_flush(i32 noundef %7, i32 noundef %8)\n%10 = load i32, ptr %0, align 4\n%11 = tail call i32 @stage2_flush_vm(i32 noundef %10)\n%12 = load i64, ptr @HCR_TVM, align 8\n%13 = or i64 %12, %2\n%14 = tail call ptr @vcpu_hcr(ptr noundef nonnull %0)\nstore i64 %13, ptr %14, align 8\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @kvm_set_way_flush(ptr noundef %0) {\nB:\n%1 = tail call ptr @vcpu_hcr(ptr noundef %0)\n%2 = load i64, ptr %1, align 8\n%3 = load i64, ptr @HCR_TVM, align 8\n%4 = and i64 %3, %2\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call ptr @vcpu_pc(ptr noundef %0)\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @vcpu_has_cache_enabled(ptr noundef %0)\n%9 = tail call i32 @trace_kvm_set_way_flush(i32 noundef %7, i32 noundef %8)\n%10 = load i32, ptr %0, align 4\n%11 = tail call i32 @stage2_flush_vm(i32 noundef %10)\n%12 = load i64, ptr @HCR_TVM, align 8\n%13 = or i64 %12, %2\n%14 = tail call ptr @vcpu_hcr(ptr noundef nonnull %0)\nstore i64 %13, ptr %14, align 8\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i32 @goodix_ts_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @i2c_get_clientdata(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.goodix_ts_data ptr %6, i32 0, i32 2\n%8 = load i64, ptr %7, align 8\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %19\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.goodix_ts_data ptr %11, i32 0, i32 1\n%13 = load i64, ptr %12, align 8\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %19\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = getelementptr inbounds %struct.goodix_ts_data ptr %16, i32 0, i32 0\n%18 = call i32 @wait_for_completion(ptr noundef %17)\nbr label %19\n\n19:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @goodix_ts_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @i2c_get_clientdata(ptr noundef %0)\n%2 = getelementptr inbounds %struct.goodix_ts_data, ptr %1, i64 0, i32 2\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.goodix_ts_data, ptr %1, i64 0, i32 1\n%6 = load i64, ptr %5, align 8\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = tail call i32 @wait_for_completion(ptr noundef nonnull %1)\nbr label %B3\n\nB3:\nret i32 0\n}", "codellama": "define internal i32 @goodix_ts_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @i2c_get_clientdata(ptr noundef %0)\n%2 = getelementptr inbounds %struct.goodix_ts_data, ptr %1, i64 0, i32 2\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.goodix_ts_data, ptr %1, i64 0, i32 1\n%6 = load i64, ptr %5, align 8\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = tail call i32 @wait_for_completion(ptr noundef nonnull %1)\nbr label %B3\n\nB3:\nret i32 0\n}", "codegemma": "define internal i32 @goodix_ts_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @i2c_get_clientdata(ptr noundef %0)\n%2 = getelementptr inbounds %struct.goodix_ts_data, ptr %1, i64 0, i32 2\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.goodix_ts_data, ptr %1, i64 0, i32 1\n%6 = load i64, ptr %5, align 8\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = tail call i32 @wait_for_completion(ptr noundef nonnull %1)\nbr label %B3\n\nB3:\nret i32 0\n}"}, "define dso_local i32 @param_read_string_array(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca %struct.TYPE_5__, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%9 = load i32, ptr @gs_param_type_string_array, align 4\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %7, i32 0, i32 1\nstore i32 %9, ptr %10, align 4\n%11 = load ptr, ptr %4, align 8\n%12 = load i32, ptr %5, align 4\n%13 = call i32 @param_read_requested_typed(ptr noundef %11, i32 noundef %12, ptr noundef %7)\nstore i32 %13, ptr %8, align 4\n%14 = load i32, ptr %8, align 4\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %16, label %21\n\n16:\n%17 = getelementptr inbounds %struct.TYPE_5__, ptr %7, i32 0, i32 0\n%18 = getelementptr inbounds %struct.TYPE_4__, ptr %17, i32 0, i32 0\n%19 = load i32, ptr %18, align 4\n%20 = load ptr, ptr %6, align 8\nstore i32 %19, ptr %20, align 4\nbr label %21\n\n21:\n%22 = load i32, ptr %8, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret i32 %22\n}": {"base_truth": "define dso_local i32 @param_read_string_array(ptr noundef %0, i32 noundef %1, ptr nocapture noundef writeonly %2) {\nB:\n%3 = alloca %struct.TYPE_5__, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\n%4 = load i32, ptr @gs_param_type_string_array, align 4\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %3, i64 0, i32 1\nstore i32 %4, ptr %5, align 4\n%6 = call i32 @param_read_requested_typed(ptr noundef %0, i32 noundef %1, ptr noundef nonnull %3)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr %3, align 4\nstore i32 %8, ptr %2, align 4\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %6\n}", "codellama": "define dso_local i32 @param_read_string_array(ptr noundef %0, i32 noundef %1, ptr nocapture noundef writeonly %2) {\nB:\n%3 = alloca %struct.TYPE_5__, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\n%4 = load i32, ptr @gs_param_type_string_array, align 4\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %3, i64 0, i32 1\nstore i32 %4, ptr %5, align 4\n%6 = call i32 @param_read_requested_typed(ptr noundef %0, i32 noundef %1, ptr noundef nonnull %3)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr %3, align 4\nstore i32 %8, ptr %2, align 4\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %6\n}", "codegemma": "define dso_local i32 @param_read_string_array(ptr noundef %0, i32 noundef %1, ptr nocapture noundef writeonly %2) {\nB:\n%3 = alloca %struct.TYPE_5__, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\n%4 = load i32, ptr @gs_param_type_string_array, align 4\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %3, i64 0, i32 1\nstore i32 %4, ptr %5, align 4\n%6 = call i32 @param_read_requested_typed(ptr noundef %0, i32 noundef %1, ptr noundef nonnull %3)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr %3, align 4\nstore i32 %8, ptr %2, align 4\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %6\n}"}, "define dso_local i32 @tetris_get_keypress() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = load i32, ptr @tetris_keypress, align 4\nstore i32 %2, ptr %1, align 4\nstore i32 0, ptr @tetris_keypress, align 4\n%3 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %3\n}": {"base_truth": "define dso_local i32 @tetris_get_keypress() {\nB:\n%0 = load i32, ptr @tetris_keypress, align 4\nstore i32 0, ptr @tetris_keypress, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @tetris_get_keypress() {\nB:\n%0 = load i32, ptr @tetris_keypress, align 4\nstore i32 0, ptr @tetris_keypress, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @tetris_get_keypress() {\nB:\n%0 = load i32, ptr @tetris_keypress, align 4\nstore i32 0, ptr @tetris_keypress, align 4\nret i32 %0\n}"}, "define dso_local i32 @intel_guc_submission_init(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.intel_guc ptr %6, i32 0, i32 0\n%8 = load i64, ptr %7, align 8\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %11\n\n10:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %42\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = call i32 @guc_stage_desc_pool_create(ptr noundef %12)\nstore i32 %13, ptr %4, align 4\n%14 = load i32, ptr %4, align 4\n%15 = icmp ne i32 %14, 0\nbr i1 %15, label %16, label %18\n\n16:\n%17 = load i32, ptr %4, align 4\nstore i32 %17, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %42\n\n18:\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.intel_guc ptr %19, i32 0, i32 0\n%21 = load i64, ptr %20, align 8\n%22 = icmp ne i64 %21, 0\n%23 = xor i1 %22, true\n%24 = zext i1 %23 to i32\n%25 = call i32 @GEM_BUG_ON(i32 noundef %24)\n%26 = load ptr, ptr %3, align 8\n%27 = call i32 @guc_verify_doorbells(ptr noundef %26)\n%28 = icmp ne i32 %27, 0\n%29 = xor i1 %28, true\n%30 = zext i1 %29 to i32\n%31 = call i32 @WARN_ON(i32 noundef %30)\n%32 = load ptr, ptr %3, align 8\n%33 = call i32 @guc_clients_create(ptr noundef %32)\nstore i32 %33, ptr %4, align 4\n%34 = load i32, ptr %4, align 4\n%35 = icmp ne i32 %34, 0\nbr i1 %35, label %36, label %37\n\n36:\nbr label %38\n\n37:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %42\n\n38:\n%39 = load ptr, ptr %3, align 8\n%40 = call i32 @guc_stage_desc_pool_destroy(ptr noundef %39)\n%41 = load i32, ptr %4, align 4\nstore i32 %41, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %42\n\n42:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%43 = load i32, ptr %2, align 4\nret i32 %43\n}": {"base_truth": "define dso_local i32 @intel_guc_submission_init(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = tail call i32 @guc_stage_desc_pool_create(ptr noundef nonnull %0)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B4\n\nB2:\n%5 = load i64, ptr %0, align 8\n%6 = icmp eq i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @GEM_BUG_ON(i32 noundef %7)\n%9 = tail call i32 @guc_verify_doorbells(ptr noundef nonnull %0)\n%10 = icmp eq i32 %9, 0\n%11 = zext i1 %10 to i32\n%12 = tail call i32 @WARN_ON(i32 noundef %11)\n%13 = tail call i32 @guc_clients_create(ptr noundef nonnull %0)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = tail call i32 @guc_stage_desc_pool_destroy(ptr noundef nonnull %0)\nbr label %B4\n\nB4:\n%16 = phi i32 [ %13, %B3 ], [ 0, %B ], [ %3, %B1 ], [ 0, %B2 ]\nret i32 %16\n}", "codellama": "define dso_local i32 @intel_guc_submission_init(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = tail call i32 @guc_stage_desc_pool_create(ptr noundef nonnull %0)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B4\n\nB2:\n%5 = load i64, ptr %0, align 8\n%6 = icmp eq i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @GEM_BUG_ON(i32 noundef %7)\n%9 = tail call i32 @guc_verify_doorbells(ptr noundef nonnull %0)\n%10 = icmp eq i32 %9, 0\n%11 = zext i1 %10 to i32\n%12 = tail call i32 @WARN_ON(i32 noundef %11)\n%13 = tail call i32 @guc_clients_create(ptr noundef nonnull %0)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = tail call i32 @guc_stage_desc_pool_destroy(ptr noundef nonnull %0)\nbr label %B4\n\nB4:\n%16 = phi i32 [ %13, %B3 ], [ 0, %B ], [ %3, %B1 ], [ 0, %B2 ]\nret i32 %16\n}", "codegemma": "define dso_local i32 @intel_guc_submission_init(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = tail call i32 @guc_stage_desc_pool_create(ptr noundef nonnull %0)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B4\n\nB2:\n%5 = load i64, ptr %0, align 8\n%6 = icmp eq i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @GEM_BUG_ON(i32 noundef %7)\n%9 = tail call i32 @guc_verify_doorbells(ptr noundef nonnull %0)\n%10 = icmp eq i32 %9, 0\n%11 = zext i1 %10 to i32\n%12 = tail call i32 @WARN_ON(i32 noundef %11)\n%13 = tail call i32 @guc_clients_create(ptr noundef nonnull %0)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = tail call i32 @guc_stage_desc_pool_destroy(ptr noundef nonnull %0)\nbr label %B4\n\nB4:\n%16 = phi i32 [ %3, %B1 ], [ %13, %B3 ], [ 0, %B ], [ 0, %B2 ]\nret i32 %16\n}"}, "define dso_local void @testSelectionSort() {\n%1 = alloca [9 x i32], align 16\n%2 = alloca i32, align 4\n%3 = alloca [18 x i32], align 16\n%4 = alloca i32, align 4\n%5 = call i32 @printf(ptr noundef @.str)\ncall void @llvm.lifetime.start.p0(i64 36, ptr %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 16 %1, ptr align 16 @__const.testSelectionSort.data, i64 36, i1 false)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 9, ptr %2, align 4\n%6 = getelementptr inbounds [9 x i32], ptr %1, i64 0, i64 0\n%7 = load i32, ptr %2, align 4\n%8 = call i32 @selectionSort(ptr noundef %6, i32 noundef %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 36, ptr %1)\n%9 = call i32 @printf(ptr noundef @.str.1)\ncall void @llvm.lifetime.start.p0(i64 72, ptr %3)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 16 %3, ptr align 16 @__const.testSelectionSort.data.2, i64 72, i1 false)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 18, ptr %4, align 4\n%10 = getelementptr inbounds [18 x i32], ptr %3, i64 0, i64 0\n%11 = load i32, ptr %4, align 4\n%12 = call i32 @selectionSort(ptr noundef %10, i32 noundef %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 72, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @testSelectionSort() {\nB:\n%0 = alloca [9 x i32], align 16\n%1 = alloca [18 x i32], align 16\n%2 = tail call i32 @printf(ptr noundef nonnull @.str)\ncall void @llvm.lifetime.start.p0(i64 36, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(36) %0, ptr noundef nonnull align 16 dereferenceable(36) @__const.testSelectionSort.data, i64 36, i1 false)\n%3 = call i32 @selectionSort(ptr noundef nonnull %0, i32 noundef 9)\ncall void @llvm.lifetime.end.p0(i64 36, ptr nonnull %0)\n%4 = call i32 @printf(ptr noundef nonnull @.str.1)\ncall void @llvm.lifetime.start.p0(i64 72, ptr nonnull %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %1, ptr noundef nonnull align 16 dereferenceable(72) @__const.testSelectionSort.data.2, i64 72, i1 false)\n%5 = call i32 @selectionSort(ptr noundef nonnull %1, i32 noundef 18)\ncall void @llvm.lifetime.end.p0(i64 72, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @testSelectionSort() {\nB:\n%0 = alloca [9 x i32], align 16\n%1 = alloca [18 x i32], align 16\n%2 = tail call i32 @printf(ptr noundef nonnull @.str)\ncall void @llvm.lifetime.start.p0(i64 36, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(36) %0, ptr noundef nonnull align 16 dereferenceable(36) @__const.testSelectionSort.data, i64 36, i1 false)\n%3 = call i32 @selectionSort(ptr noundef nonnull %0, i32 noundef 9)\ncall void @llvm.lifetime.end.p0(i64 36, ptr nonnull %0)\n%4 = call i32 @printf(ptr noundef nonnull @.str.1)\ncall void @llvm.lifetime.start.p0(i64 72, ptr nonnull %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %1, ptr noundef nonnull align 16 dereferenceable(72) @__const.testSelectionSort.data.2, i64 72, i1 false)\n%5 = call i32 @selectionSort(ptr noundef nonnull %1, i32 noundef 18)\ncall void @llvm.lifetime.end.p0(i64 72, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @testSelectionSort() {\nB:\n%0 = alloca [9 x i32], align 16\n%1 = alloca [18 x i32], align 16\n%2 = tail call i32 @printf(ptr noundef nonnull @.str)\ncall void @llvm.lifetime.start.p0(i64 36, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(36) %0, ptr noundef nonnull align 16 dereferenceable(36) @__const.testSelectionSort.data, i64 36, i1 false)\n%3 = call i32 @selectionSort(ptr noundef nonnull %0, i32 noundef 9)\ncall void @llvm.lifetime.end.p0(i64 36, ptr nonnull %0)\n%4 = call i32 @printf(ptr noundef nonnull @.str.1)\ncall void @llvm.lifetime.start.p0(i64 72, ptr nonnull %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %1, ptr noundef nonnull align 16 dereferenceable(72) @__const.testSelectionSort.data.2, i64 72, i1 false)\n%5 = call i32 @selectionSort(ptr noundef nonnull %1, i32 noundef 18)\ncall void @llvm.lifetime.end.p0(i64 72, ptr nonnull %1)\nret void\n}"}, "define internal void @cadillac_rx_hook(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @GET_BUS(ptr noundef %7)\nstore i32 %8, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%9 = load ptr, ptr %2, align 8\n%10 = call i32 @GET_ADDR(ptr noundef %9)\nstore i32 %10, ptr %4, align 4\n%11 = load i32, ptr %4, align 4\n%12 = icmp eq i32 %11, 356\nbr i1 %12, label %13, label %25\n\n13:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%14 = load ptr, ptr %2, align 8\n%15 = call i32 @GET_BYTE(ptr noundef %14, i32 noundef 0)\n%16 = and i32 %15, 7\n%17 = shl i32 %16, 8\n%18 = load ptr, ptr %2, align 8\n%19 = call i32 @GET_BYTE(ptr noundef %18, i32 noundef 1)\n%20 = or i32 %17, %19\nstore i32 %20, ptr %5, align 4\n%21 = load i32, ptr %5, align 4\n%22 = call i32 @to_signed(i32 noundef %21, i32 noundef 11)\nstore i32 %22, ptr %5, align 4\n%23 = load i32, ptr %5, align 4\n%24 = call i32 @update_sample(ptr noundef @cadillac_torque_driver, i32 noundef %23)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nbr label %25\n\n25:\n%26 = load i32, ptr %4, align 4\n%27 = icmp eq i32 %26, 880\nbr i1 %27, label %28, label %47\n\n28:\n%29 = load i32, ptr %3, align 4\n%30 = icmp eq i32 %29, 0\nbr i1 %30, label %31, label %47\n\n31:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%32 = load ptr, ptr %2, align 8\n%33 = call i32 @GET_BYTE(ptr noundef %32, i32 noundef 2)\n%34 = and i32 %33, 128\nstore i32 %34, ptr %6, align 4\n%35 = load i32, ptr %6, align 4\n%36 = icmp ne i32 %35, 0\nbr i1 %36, label %37, label %41\n\n37:\n%38 = load i32, ptr @cadillac_cruise_engaged_last, align 4\n%39 = icmp ne i32 %38, 0\nbr i1 %39, label %41, label %40\n\n40:\nstore i32 1, ptr @controls_allowed, align 4\nbr label %41\n\n41:\n%42 = load i32, ptr %6, align 4\n%43 = icmp ne i32 %42, 0\nbr i1 %43, label %45, label %44\n\n44:\nstore i32 0, ptr @controls_allowed, align 4\nbr label %45\n\n45:\n%46 = load i32, ptr %6, align 4\nstore i32 %46, ptr @cadillac_cruise_engaged_last, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\nbr label %47\n\n47:\n%48 = load i32, ptr %4, align 4\n%49 = icmp eq i32 %48, 338\nbr i1 %49, label %53, label %50\n\n50:\n%51 = load i32, ptr %4, align 4\n%52 = icmp eq i32 %51, 340\nbr i1 %52, label %53, label %59\n\n53:\n%54 = load ptr, ptr %2, align 8\n%55 = call i32 @GET_BYTE(ptr noundef %54, i32 noundef 4)\n%56 = and i32 %55, 16\n%57 = icmp ne i32 %56, 0\n%58 = zext i1 %57 to i32\nstore i32 %58, ptr @cadillac_supercruise_on, align 4\nbr label %59\n\n59:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define internal void @cadillac_rx_hook(ptr noundef %0) {\nB:\n%1 = tail call i32 @GET_BUS(ptr noundef %0)\n%2 = tail call i32 @GET_ADDR(ptr noundef %0)\n%3 = icmp eq i32 %2, 356\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 0)\n%5 = shl i32 %4, 8\n%6 = and i32 %5, 1792\n%7 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 1)\n%8 = or i32 %6, %7\n%9 = tail call i32 @to_signed(i32 noundef %8, i32 noundef 11)\n%10 = tail call i32 @update_sample(ptr noundef nonnull @cadillac_torque_driver, i32 noundef %9)\nbr label %B8\n\nB2:\n%11 = icmp eq i32 %2, 880\n%12 = icmp eq i32 %1, 0\n%13 = select i1 %11, i1 %12, i1 false\nbr i1 %13, label %B3, label %B6\n\nB3:\n%14 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 2)\n%15 = and i32 %14, 128\n%16 = icmp eq i32 %15, 0\n%17 = load i32, ptr @cadillac_cruise_engaged_last, align 4\n%18 = icmp eq i32 %17, 0\n%19 = xor i1 %16, true\n%20 = select i1 %19, i1 %18, i1 false\n%21 = or i1 %16, %20\nbr i1 %21, label %B4, label %B5\n\nB4:\n%22 = zext i1 %19 to i32\nstore i32 %22, ptr @controls_allowed, align 4\nbr label %B5\n\nB5:\nstore i32 %15, ptr @cadillac_cruise_engaged_last, align 4\nbr label %B8\n\nB6:\nswitch i32 %2, label %B8 [\ni32 340, label %B7\ni32 338, label %B7\n]\n\nB7:\n%23 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 4)\n%24 = lshr i32 %23, 4\n%25 = and i32 %24, 1\nstore i32 %25, ptr @cadillac_supercruise_on, align 4\nbr label %B8\n\nB8:\nret void\n}", "codellama": "define internal void @cadillac_rx_hook(ptr noundef %0) {\nB:\n%1 = tail call i32 @GET_BUS(ptr noundef %0)\n%2 = tail call i32 @GET_ADDR(ptr noundef %0)\nswitch i32 %2, label %B6 [\ni32 356, label %B1\ni32 880, label %B2\n]\n\nB1:\n%3 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 0)\n%4 = shl i32 %3, 8\n%5 = and i32 %4, 192\n%6 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 1)\n%7 = or i32 %5, %6\n%8 = tail call i32 @to_signed(i32 noundef %7, i32 noundef 11)\n%9 = tail call i32 @update_sample(ptr noundef nonnull @cadillac_torque_driver, i32 noundef %8)\nbr label %B2\n\nB2:\n%10 = icmp eq i32 %2, 880\n%11 = icmp eq i32 %1, 0\n%12 = select i1 %10, i1 %11, i1 false\nbr i1 %12, label %B3, label %B5\n\nB3:\n%13 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 2)\n%14 = and i32 %13, 128\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B5, label %B4\n\nB4:\n%16 = load i32, ptr @cadillac_cruise_engaged_last, align 4\n%17 = icmp eq i32 %16, 0\n%18 = select i1 %17, i32 1, i32 0\nstore i32 %18, ptr @controls_allowed, align 4\nstore i32 %14, ptr @cadillac_cruise_engaged_last, align 4\nbr label %B5\n\nB5:\n%19 = phi i32 [ %14, %B4 ], [ 0, %B3 ], [ 0, %B2 ]\nstore i32 %19, ptr @cadillac_cruise_engaged_last, align 4\nbr label %B6\n\nB6:\n%20 = icmp eq i32 %2, 338\n%21 = icmp eq i32 %2, 340\n%22 = or i1 %20, %21\nbr i1 %22, label %B7, label %B8\n\nB7:\n%23 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 4)\n%24 = lshr i32 %23, 4\n%25 = and i32 %24, 1\nstore i32 %25, ptr @cadillac_supercruise_on, align 4\nbr label %B8\n\nB8:\nret void\n}", "codegemma": "define internal void @cadillac_rx_hook(ptr noundef %0) {\nB:\n%1 = tail call i32 @GET_BUS(ptr noundef %0)\n%2 = tail call i32 @GET_ADDR(ptr noundef %0)\nswitch i32 %2, label %B3 [\ni32 356, label %B1\ni32 880, label %B2\ni32 338, label %B4\ni32 340, label %B4\n]\n\nB1:\n%3 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 0)\n%4 = shl i32 %3, 8\n%5 = and i32 %4, 56\n%6 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 1)\n%7 = or i32 %5, %6\n%8 = tail call i32 @to_signed(i32 noundef %7, i32 noundef 11)\n%9 = tail call i32 @update_sample(ptr noundef nonnull @cadillac_torque_driver, i32 noundef %8)\nbr label %B3\n\nB2:\n%10 = icmp eq i32 %1, 0\nbr i1 %10, label %B3, label %B4\n\nB3:\n%11 = tail call i32 @GET_BYTE(ptr noundef %0, i32 noundef 2)\n%12 = and i32 %11, 128\n%13 = icmp ne i32 %12, 0\n%14 = load i32, ptr @cadillac_cruise_engaged_last, align 4\n%15 = icmp ne i32 %14, 0\n%16 = select i1 %13, i1 %15, i1 false\n%17 = zext i1 %16 to i32\nstore i32 %17, ptr @controls_allowed, align 4\nbr label %B4\n\nB4:\n%18 = phi i32 [ %12, %B3 ], [ 0, %B2 ], [ 1, %B1 ], [ 0, %B1 ], [ 1, %B1 ]\nstore i32 %18, ptr @cadillac_cruise_engaged_last, align 4\nret void\n}"}, "define dso_local void @OP_19(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_19 ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = and i32 %5, 2047\nswitch i32 %6, label %52 [\ni32 0, label %7\ni32 32, label %10\ni32 33, label %13\ni32 66, label %16\ni32 100, label %19\ni32 258, label %22\ni32 300, label %25\ni32 386, label %28\ni32 450, label %31\ni32 514, label %34\ni32 578, label %37\ni32 834, label %40\ni32 898, label %43\ni32 1056, label %46\ni32 1057, label %49\n]\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @OP_19_SUB_0000(ptr noundef %8)\nbr label %55\n\n10:\n%11 = load ptr, ptr %2, align 8\n%12 = call i32 @OP_19_SUB_0032(ptr noundef %11)\nbr label %55\n\n13:\n%14 = load ptr, ptr %2, align 8\n%15 = call i32 @OP_19_SUB_0033(ptr noundef %14)\nbr label %55\n\n16:\n%17 = load ptr, ptr %2, align 8\n%18 = call i32 @OP_19_SUB_0066(ptr noundef %17)\nbr label %55\n\n19:\n%20 = load ptr, ptr %2, align 8\n%21 = call i32 @OP_19_SUB_0100(ptr noundef %20)\nbr label %55\n\n22:\n%23 = load ptr, ptr %2, align 8\n%24 = call i32 @OP_19_SUB_0258(ptr noundef %23)\nbr label %55\n\n25:\n%26 = load ptr, ptr %2, align 8\n%27 = call i32 @OP_19_SUB_0300(ptr noundef %26)\nbr label %55\n\n28:\n%29 = load ptr, ptr %2, align 8\n%30 = call i32 @OP_19_SUB_0386(ptr noundef %29)\nbr label %55\n\n31:\n%32 = load ptr, ptr %2, align 8\n%33 = call i32 @OP_19_SUB_0450(ptr noundef %32)\nbr label %55\n\n34:\n%35 = load ptr, ptr %2, align 8\n%36 = call i32 @OP_19_SUB_0514(ptr noundef %35)\nbr label %55\n\n37:\n%38 = load ptr, ptr %2, align 8\n%39 = call i32 @OP_19_SUB_0578(ptr noundef %38)\nbr label %55\n\n40:\n%41 = load ptr, ptr %2, align 8\n%42 = call i32 @OP_19_SUB_0834(ptr noundef %41)\nbr label %55\n\n43:\n%44 = load ptr, ptr %2, align 8\n%45 = call i32 @OP_19_SUB_0898(ptr noundef %44)\nbr label %55\n\n46:\n%47 = load ptr, ptr %2, align 8\n%48 = call i32 @OP_19_SUB_1056(ptr noundef %47)\nbr label %55\n\n49:\n%50 = load ptr, ptr %2, align 8\n%51 = call i32 @OP_19_SUB_1057(ptr noundef %50)\nbr label %55\n\n52:\n%53 = load ptr, ptr %2, align 8\n%54 = call i32 @OP_DC(ptr noundef %53)\nbr label %55\n\n55:\nret void\n}": {"base_truth": "define dso_local void @OP_19(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = and i32 %1, 2047\nswitch i32 %2, label %B16 [\ni32 0, label %B1\ni32 32, label %B2\ni32 33, label %B3\ni32 66, label %B4\ni32 100, label %B5\ni32 258, label %B6\ni32 300, label %B7\ni32 386, label %B8\ni32 450, label %B9\ni32 514, label %B10\ni32 578, label %B11\ni32 834, label %B12\ni32 898, label %B13\ni32 1056, label %B14\ni32 1057, label %B15\n]\n\nB1:\n%3 = tail call i32 @OP_19_SUB_0000(ptr noundef nonnull %0)\nbr label %B17\n\nB2:\n%4 = tail call i32 @OP_19_SUB_0032(ptr noundef nonnull %0)\nbr label %B17\n\nB3:\n%5 = tail call i32 @OP_19_SUB_0033(ptr noundef nonnull %0)\nbr label %B17\n\nB4:\n%6 = tail call i32 @OP_19_SUB_0066(ptr noundef nonnull %0)\nbr label %B17\n\nB5:\n%7 = tail call i32 @OP_19_SUB_0100(ptr noundef nonnull %0)\nbr label %B17\n\nB6:\n%8 = tail call i32 @OP_19_SUB_0258(ptr noundef nonnull %0)\nbr label %B17\n\nB7:\n%9 = tail call i32 @OP_19_SUB_0300(ptr noundef nonnull %0)\nbr label %B17\n\nB8:\n%10 = tail call i32 @OP_19_SUB_0386(ptr noundef nonnull %0)\nbr label %B17\n\nB9:\n%11 = tail call i32 @OP_19_SUB_0450(ptr noundef nonnull %0)\nbr label %B17\n\nB10:\n%12 = tail call i32 @OP_19_SUB_0514(ptr noundef nonnull %0)\nbr label %B17\n\nB11:\n%13 = tail call i32 @OP_19_SUB_0578(ptr noundef nonnull %0)\nbr label %B17\n\nB12:\n%14 = tail call i32 @OP_19_SUB_0834(ptr noundef nonnull %0)\nbr label %B17\n\nB13:\n%15 = tail call i32 @OP_19_SUB_0898(ptr noundef nonnull %0)\nbr label %B17\n\nB14:\n%16 = tail call i32 @OP_19_SUB_1056(ptr noundef nonnull %0)\nbr label %B17\n\nB15:\n%17 = tail call i32 @OP_19_SUB_1057(ptr noundef nonnull %0)\nbr label %B17\n\nB16:\n%18 = tail call i32 @OP_DC(ptr noundef nonnull %0)\nbr label %B17\n\nB17:\nret void\n}", "codellama": "define dso_local void @OP_19(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = and i32 %1, 2047\nswitch i32 %2, label %B19 [\ni32 0, label %B1\ni32 32, label %B2\ni32 33, label %B3\ni32 66, label %B4\ni32 100, label %B5\ni32 258, label %B6\ni32 300, label %B7\ni32 386, label %B8\ni32 450, label %B9\ni32 514, label %B10\ni32 578, label %B11\ni32 834, label %B12\ni32 898, label %B13\ni32 1056, label %B14\ni32 1057, label %B15\n]\n\nB1:\n%3 = tail call i32 @OP_19_SUB_0000(ptr noundef nonnull %0)\nbr label %B20\n\nB2:\n%4 = tail call i32 @OP_19_SUB_0032(ptr noundef nonnull %0)\nbr label %B20\n\nB3:\n%5 = tail call i32 @OP_19_SUB_0033(ptr noundef nonnull %0)\nbr label %B20\n\nB4:\n%6 = tail call i32 @OP_19_SUB_0066(ptr noundef nonnull %0)\nbr label %B20\n\nB5:\n%7 = tail call i32 @OP_19_SUB_0100(ptr noundef nonnull %0)\nbr label %B20\n\nB6:\n%8 = tail call i32 @OP_19_SUB_0258(ptr noundef nonnull %0)\nbr label %B20\n\nB7:\n%9 = tail call i32 @OP_19_SUB_0300(ptr noundef nonnull %0)\nbr label %B20\n\nB8:\n%10 = tail call i32 @OP_19_SUB_0386(ptr noundef nonnull %0)\nbr label %B20\n\nB9:\n%11 = tail call i32 @OP_19_SUB_0450(ptr noundef nonnull %0)\nbr label %B20\n\nB10:\n%12 = tail call i32 @OP_19_SUB_0514(ptr noundef nonnull %0)\nbr label %B20\n\nB11:\n%13 = tail call i32 @OP_19_SUB_0578(ptr noundef nonnull %0)\nbr label %B20\n\nB12:\n%14 = tail call i32 @OP_19_SUB_0834(ptr noundef nonnull %0)\nbr label %B20\n\nB13:\n%15 = tail call i32 @OP_19_SUB_0898(ptr noundef nonnull %0)\nbr label %B20\n\nB14:\n%16 = tail call i32 @OP_19_SUB_1056(ptr noundef nonnull %0)\nbr label %B20\n\nB15:\n%17 = tail call i32 @OP_19_SUB_1057(ptr noundef nonnull %0)\nbr label %B20\n\nB16:\n%18 = tail call i32 @OP_DC(ptr noundef nonnull %0)\nbr label %B20\n\nB17:\n%19 = tail call i32 @OP_DC(ptr noundef nonnull %0)\nbr label %B20\n\nB18:\n%20 = tail call i32 @OP_DC(ptr noundef nonnull %0)\nbr label %B20\n\nB19:\n%21 = tail call i32 @OP_DC(ptr noundef nonnull %0)\nbr label %B20\n\nB20:\nret void\n}", "codegemma": "define dso_local void @OP_19(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = and i32 %1, 2047\nswitch i32 %2, label %B12 [\ni32 0, label %B1\ni32 32, label %B2\ni32 33, label %B3\ni32 66, label %B4\ni32 100, label %B5\ni32 258, label %B6\ni32 300, label %B7\ni32 386, label %B8\ni32 450, label %B9\ni32 514, label %B10\ni32 578, label %B11\ni32 834, label %B13\ni32 898, label %B14\ni32 1056, label %B15\ni32 1057, label %B16\n]\n\nB1:\n%3 = tail call i32 @OP_19_SUB_0000(ptr noundef nonnull %0)\nbr label %B17\n\nB2:\n%4 = tail call i32 @OP_19_SUB_0032(ptr noundef nonnull %0)\nbr label %B17\n\nB3:\n%5 = tail call i32 @OP_19_SUB_0033(ptr noundef nonnull %0)\nbr label %B17\n\nB4:\n%6 = tail call i32 @OP_19_SUB_0066(ptr noundef nonnull %0)\nbr label %B17\n\nB5:\n%7 = tail call i32 @OP_19_SUB_0100(ptr noundef nonnull %0)\nbr label %B17\n\nB6:\n%8 = tail call i32 @OP_19_SUB_0258(ptr noundef nonnull %0)\nbr label %B17\n\nB7:\n%9 = tail call i32 @OP_19_SUB_0300(ptr noundef nonnull %0)\nbr label %B17\n\nB8:\n%10 = tail call i32 @OP_19_SUB_0386(ptr noundef nonnull %0)\nbr label %B17\n\nB9:\n%11 = tail call i32 @OP_19_SUB_0450(ptr noundef nonnull %0)\nbr label %B17\n\nB10:\n%12 = tail call i32 @OP_19_SUB_0514(ptr noundef nonnull %0)\nbr label %B17\n\nB11:\n%13 = tail call i32 @OP_19_SUB_0578(ptr noundef nonnull %0)\nbr label %B17\n\nB12:\n%14 = tail call i32 @OP_DC(ptr noundef nonnull %0)\nbr label %B17\n\nB13:\n%15 = tail call i32 @OP_19_SUB_0834(ptr noundef nonnull %0)\nbr label %B17\n\nB14:\n%16 = tail call i32 @OP_19_SUB_0898(ptr noundef nonnull %0)\nbr label %B17\n\nB15:\n%17 = tail call i32 @OP_19_SUB_1056(ptr noundef nonnull %0)\nbr label %B17\n\nB16:\n%18 = tail call i32 @OP_19_SUB_1057(ptr noundef nonnull %0)\nbr label %B17\n\nB17:\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca float, align 4\n%5 = alloca float, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore float 0.000000e+00, ptr %5, align 4\n%6 = call i32 @scanf(ptr noundef @.str, ptr noundef %2)\nbr label %7\n\n7:\n%8 = load i32, ptr %2, align 4\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %10, label %20\n\n10:\n%11 = load float, ptr %5, align 4\n%12 = load i32, ptr %2, align 4\n%13 = srem i32 %12, 10\n%14 = sitofp i32 %13 to float\n%15 = fadd fast float %11, %14\nstore float %15, ptr %5, align 4\n%16 = load i32, ptr %2, align 4\n%17 = sdiv i32 %16, 10\nstore i32 %17, ptr %2, align 4\n%18 = load i32, ptr %3, align 4\n%19 = add nsw i32 %18, 1\nstore i32 %19, ptr %3, align 4\nbr label %7\n\n20:\n%21 = load float, ptr %5, align 4\n%22 = load i32, ptr %3, align 4\n%23 = sitofp i32 %22 to float\n%24 = fdiv fast float %21, %23\nstore float %24, ptr %4, align 4\n%25 = load float, ptr %4, align 4\n%26 = fcmp fast ole float %25, 7.000000e+00\nbr i1 %26, label %27, label %29\n\n27:\n%28 = call i32 @printf(ptr noundef @.str.1)\nbr label %31\n\n29:\n%30 = call i32 @printf(ptr noundef @.str.2)\nbr label %31\n\n31:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%32 = load i32, ptr %1, align 4\nret i32 %32\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = phi float [ %9, %B1 ], [ 0.000000e+00, %B ]\n%5 = phi i32 [ %11, %B1 ], [ 0, %B ]\n%6 = phi i32 [ %10, %B1 ], [ %2, %B ]\n%7 = srem i32 %6, 10\n%8 = sitofp i32 %7 to float\n%9 = fadd fast float %4, %8\n%10 = sdiv i32 %6, 10\n%11 = add nuw nsw i32 %5, 1\n%12 = add i32 %6, 9\n%13 = icmp ult i32 %12, 19\nbr i1 %13, label %B2, label %B1\n\nB2:\nstore i32 %10, ptr %0, align 4\n%14 = sitofp i32 %11 to float\n%15 = fdiv fast float %9, %14\n%16 = fcmp fast ugt float %15, 7.000000e+00\nbr i1 %16, label %B3, label %B4\n\nB3:\nbr label %B4\n\nB4:\n%17 = phi ptr [ @.str.2, %B3 ], [ @.str.1, %B2 ]\n%18 = call i32 @printf(ptr noundef nonnull %17)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = phi i32 [ %11, %B1 ], [ 0, %B ]\n%5 = phi float [ %9, %B1 ], [ 0.000000e+00, %B ]\n%6 = phi i32 [ %10, %B1 ], [ %2, %B ]\n%7 = srem i32 %6, 10\n%8 = sitofp i32 %7 to float\n%9 = fadd fast float %5, %8\n%10 = sdiv i32 %6, 10\n%11 = add nuw nsw i32 %4, 1\n%12 = add i32 %6, 9\n%13 = icmp ult i32 %12, 19\nbr i1 %13, label %B2, label %B1\n\nB2:\nstore i32 %10, ptr %0, align 4\n%14 = sitofp i32 %11 to float\n%15 = fdiv fast float %9, %14\n%16 = fcmp fast ugt float %15, 7.000000e+00\n%17 = select i1 %16, ptr @.str.2, ptr @.str.1\nbr label %B3\n\nB3:\n%18 = phi ptr [ @.str.1, %B ], [ %17, %B2 ]\n%19 = call i32 @printf(ptr noundef nonnull %18)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = phi i32 [ %10, %B1 ], [ 0, %B ]\n%5 = phi float [ %9, %B1 ], [ 0.000000e+00, %B ]\n%6 = phi i32 [ %11, %B1 ], [ %2, %B ]\n%7 = srem i32 %6, 10\n%8 = sitofp i32 %7 to float\n%9 = fadd fast float %5, %8\n%10 = add nuw nsw i32 %4, 1\n%11 = sdiv i32 %6, 10\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B2, label %B1\n\nB2:\n%13 = phi float [ 0.000000e+00, %B ], [ %9, %B1 ]\n%14 = phi i32 [ 0, %B ], [ %10, %B1 ]\n%15 = sitofp i32 %14 to float\n%16 = fdiv fast float %13, %15\n%17 = fcmp fast ult float %16, 7.000000e+00\n%18 = select i1 %17, ptr @.str.2, ptr @.str.1\n%19 = call i32 @printf(ptr noundef nonnull %18)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local void @tcp_unregister_congestion_control(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 @spin_lock(ptr noundef @tcp_cong_list_lock)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.tcp_congestion_ops ptr %4, i32 0, i32 0\n%6 = call i32 @list_del_rcu(ptr noundef %5)\n%7 = call i32 @spin_unlock(ptr noundef @tcp_cong_list_lock)\nret void\n}": {"base_truth": "define dso_local void @tcp_unregister_congestion_control(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock(ptr noundef nonnull @tcp_cong_list_lock)\n%2 = tail call i32 @list_del_rcu(ptr noundef %0)\n%3 = tail call i32 @spin_unlock(ptr noundef nonnull @tcp_cong_list_lock)\nret void\n}", "codellama": "define dso_local void @tcp_unregister_congestion_control(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock(ptr noundef nonnull @tcp_cong_list_lock)\n%2 = tail call i32 @list_del_rcu(ptr noundef %0)\n%3 = tail call i32 @spin_unlock(ptr noundef nonnull @tcp_cong_list_lock)\nret void\n}", "codegemma": "define dso_local void @tcp_unregister_congestion_control(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock(ptr noundef nonnull @tcp_cong_list_lock)\n%2 = tail call i32 @list_del_rcu(ptr noundef %0)\n%3 = tail call i32 @spin_unlock(ptr noundef nonnull @tcp_cong_list_lock)\nret void\n}"}, "define internal i32 @z_erofs_put_stagingpage(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %5, align 8\n%7 = call i32 @z_erofs_page_is_staging(ptr noundef %6)\n%8 = icmp ne i32 %7, 0\nbr i1 %8, label %10, label %9\n\n9:\nstore i32 0, ptr %3, align 4\nbr label %23\n\n10:\n%11 = load ptr, ptr %5, align 8\n%12 = call i32 @page_ref_count(ptr noundef %11)\n%13 = icmp sgt i32 %12, 1\nbr i1 %13, label %14, label %17\n\n14:\n%15 = load ptr, ptr %5, align 8\n%16 = call i32 @put_page(ptr noundef %15)\nbr label %22\n\n17:\n%18 = load ptr, ptr %5, align 8\n%19 = getelementptr inbounds %struct.page ptr %18, i32 0, i32 0\n%20 = load ptr, ptr %4, align 8\n%21 = call i32 @list_add(ptr noundef %19, ptr noundef %20)\nbr label %22\n\n22:\nstore i32 1, ptr %3, align 4\nbr label %23\n\n23:\n%24 = load i32, ptr %3, align 4\nret i32 %24\n}": {"base_truth": "define internal i32 @z_erofs_put_stagingpage(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @z_erofs_page_is_staging(ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i32 @page_ref_count(ptr noundef %1)\n%5 = icmp sgt i32 %4, 1\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @put_page(ptr noundef %1)\nbr label %B4\n\nB3:\n%7 = tail call i32 @list_add(ptr noundef %1, ptr noundef %0)\nbr label %B4\n\nB4:\n%8 = phi i32 [ 0, %B ], [ 1, %B3 ], [ 1, %B2 ]\nret i32 %8\n}", "codellama": "define internal i32 @z_erofs_put_stagingpage(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @z_erofs_page_is_staging(ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i32 @page_ref_count(ptr noundef %1)\n%5 = icmp sgt i32 %4, 1\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @put_page(ptr noundef %1)\nbr label %B4\n\nB3:\n%7 = tail call i32 @list_add(ptr noundef %1, ptr noundef %0)\nbr label %B4\n\nB4:\n%8 = phi i32 [ 0, %B ], [ 1, %B3 ], [ 1, %B2 ]\nret i32 %8\n}", "codegemma": "define internal i32 @z_erofs_put_stagingpage(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @z_erofs_page_is_staging(ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i32 @page_ref_count(ptr noundef %1)\n%5 = icmp sgt i32 %4, 1\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @put_page(ptr noundef %1)\nbr label %B4\n\nB3:\n%7 = tail call i32 @list_add(ptr noundef %1, ptr noundef %0)\nbr label %B4\n\nB4:\n%8 = phi i32 [ 0, %B ], [ 1, %B3 ], [ 1, %B2 ]\nret i32 %8\n}"}, "define dso_local i32 @PLATFORM_TRIG(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %6, label %12\n\n6:\n%7 = call i32 (...) @PadButtons()\n%8 = load i32, ptr @PAD_CROSS, align 4\n%9 = and i32 %7, %8\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %11, label %12\n\n11:\nstore i32 0, ptr %2, align 4\nbr label %13\n\n12:\nstore i32 1, ptr %2, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %2, align 4\nret i32 %14\n}": {"base_truth": "define dso_local i32 @PLATFORM_TRIG(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 (...) @PadButtons()\n%3 = load i32, ptr @PAD_CROSS, align 4\n%4 = and i32 %3, %2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\nbr label %B3\n\nB3:\n%6 = phi i32 [ 1, %B2 ], [ 0, %B1 ]\nret i32 %6\n}", "codellama": "define dso_local i32 @PLATFORM_TRIG(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 (...) @PadButtons()\n%3 = load i32, ptr @PAD_CROSS, align 4\n%4 = and i32 %3, %2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\nbr label %B3\n\nB3:\n%6 = phi i32 [ 1, %B2 ], [ 0, %B1 ]\nret i32 %6\n}", "codegemma": "define dso_local i32 @PLATFORM_TRIG(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 (...) @PadButtons()\n%3 = load i32, ptr @PAD_CROSS, align 4\n%4 = and i32 %3, %2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\nbr label %B3\n\nB3:\n%6 = phi i32 [ 1, %B2 ], [ 0, %B1 ]\nret i32 %6\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%3 = call i32 @printf(ptr noundef @.str)\n%4 = call i32 (...) @fork()\nstore i32 %4, ptr %2, align 4\n%5 = load i32, ptr %2, align 4\nswitch i32 %5, label %15 [\ni32 -1, label %6\ni32 0, label %9\n]\n\n6:\n%7 = call i32 @perror(ptr noundef @.str.1)\n%8 = call i32 @exit(i32 noundef 1)\nunreachable\n\n9:\n%10 = call i32 @sleep(i32 noundef 5)\n%11 = call i32 (...) @getppid()\n%12 = load i32, ptr @SIGALRM, align 4\n%13 = call i32 @kill(i32 noundef %11, i32 noundef %12)\n%14 = call i32 @exit(i32 noundef 0)\nunreachable\n\n15:\n%16 = call i32 @printf(ptr noundef @.str.2)\n%17 = load i32, ptr @SIGALRM, align 4\n%18 = load i32, ptr @ding, align 4\n%19 = call i32 @signal(i32 noundef %17, i32 noundef %18)\n%20 = call i32 (...) @pause()\n%21 = load i64, ptr @alarm_fired, align 8\n%22 = icmp ne i64 %21, 0\nbr i1 %22, label %23, label %25\n\n23:\n%24 = call i32 @printf(ptr noundef @.str.3)\nbr label %25\n\n25:\n%26 = call i32 @printf(ptr noundef @.str.4)\n%27 = call i32 @exit(i32 noundef 0)\nunreachable\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 (...) @fork()\nswitch i32 %1, label %B3 [\ni32 -1, label %B1\ni32 0, label %B2\n]\n\nB1:\n%2 = tail call i32 @perror(ptr noundef nonnull @.str.1)\n%3 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%4 = tail call i32 @sleep(i32 noundef 5)\n%5 = tail call i32 (...) @getppid()\n%6 = load i32, ptr @SIGALRM, align 4\n%7 = tail call i32 @kill(i32 noundef %5, i32 noundef %6)\n%8 = tail call i32 @exit(i32 noundef 0)\nunreachable\n\nB3:\n%9 = tail call i32 @printf(ptr noundef nonnull @.str.2)\n%10 = load i32, ptr @SIGALRM, align 4\n%11 = load i32, ptr @ding, align 4\n%12 = tail call i32 @signal(i32 noundef %10, i32 noundef %11)\n%13 = tail call i32 (...) @pause()\n%14 = load i64, ptr @alarm_fired, align 8\n%15 = icmp eq i64 %14, 0\nbr i1 %15, label %B5, label %B4\n\nB4:\n%16 = tail call i32 @printf(ptr noundef nonnull @.str.3)\nbr label %B5\n\nB5:\n%17 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%18 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 (...) @fork()\nswitch i32 %1, label %B3 [\ni32 -1, label %B1\ni32 0, label %B2\n]\n\nB1:\n%2 = tail call i32 @perror(ptr noundef nonnull @.str.1)\n%3 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%4 = tail call i32 @sleep(i32 noundef 5)\n%5 = tail call i32 (...) @getppid()\n%6 = load i32, ptr @SIGALRM, align 4\n%7 = tail call i32 @kill(i32 noundef %5, i32 noundef %6)\n%8 = tail call i32 @exit(i32 noundef 0)\nunreachable\n\nB3:\n%9 = tail call i32 @printf(ptr noundef nonnull @.str.2)\n%10 = load i32, ptr @SIGALRM, align 4\n%11 = load i32, ptr @ding, align 4\n%12 = tail call i32 @signal(i32 noundef %10, i32 noundef %11)\n%13 = tail call i32 (...) @pause()\n%14 = load i64, ptr @alarm_fired, align 8\n%15 = icmp eq i64 %14, 0\nbr i1 %15, label %B5, label %B4\n\nB4:\n%16 = tail call i32 @printf(ptr noundef nonnull @.str.3)\nbr label %B5\n\nB5:\n%17 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%18 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 (...) @fork()\nswitch i32 %1, label %B3 [\ni32 -1, label %B1\ni32 0, label %B2\n]\n\nB1:\n%2 = tail call i32 @perror(ptr noundef nonnull @.str.1)\n%3 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%4 = tail call i32 @sleep(i32 noundef 5)\n%5 = tail call i32 (...) @getppid()\n%6 = load i32, ptr @SIGALRM, align 4\n%7 = tail call i32 @kill(i32 noundef %5, i32 noundef %6)\n%8 = tail call i32 @exit(i32 noundef 0)\nunreachable\n\nB3:\n%9 = tail call i32 @printf(ptr noundef nonnull @.str.2)\n%10 = load i32, ptr @SIGALRM, align 4\n%11 = load i32, ptr @ding, align 4\n%12 = tail call i32 @signal(i32 noundef %10, i32 noundef %11)\n%13 = tail call i32 (...) @pause()\n%14 = load i64, ptr @alarm_fired, align 8\n%15 = icmp eq i64 %14, 0\nbr i1 %15, label %B5, label %B4\n\nB4:\n%16 = tail call i32 @printf(ptr noundef nonnull @.str.3)\nbr label %B5\n\nB5:\n%17 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%18 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}"}, "define dso_local void @maprequest(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %4, i32 0, i32 0\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @getclient(i32 noundef %8)\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %16, label %11\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.TYPE_4__, ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 4\n%15 = call i32 @manage(i32 noundef %14)\nbr label %16\n\n16:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @maprequest(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @getclient(i32 noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @manage(i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @maprequest(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @getclient(i32 noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @manage(i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @maprequest(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @getclient(i32 noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @manage(i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal void @vf610_nfc_ecc_mode(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr @NFC_FLASH_CONFIG, align 4\n%7 = load i32, ptr @CONFIG_ECC_MODE_MASK, align 4\n%8 = load i32, ptr @CONFIG_ECC_MODE_SHIFT, align 4\n%9 = load i32, ptr %4, align 4\n%10 = call i32 @vf610_nfc_set_field(ptr noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)\nret void\n}": {"base_truth": "define internal void @vf610_nfc_ecc_mode(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @NFC_FLASH_CONFIG, align 4\n%3 = load i32, ptr @CONFIG_ECC_MODE_MASK, align 4\n%4 = load i32, ptr @CONFIG_ECC_MODE_SHIFT, align 4\n%5 = tail call i32 @vf610_nfc_set_field(ptr noundef %0, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %1)\nret void\n}", "codellama": "define internal void @vf610_nfc_ecc_mode(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @NFC_FLASH_CONFIG, align 4\n%3 = load i32, ptr @CONFIG_ECC_MODE_MASK, align 4\n%4 = load i32, ptr @CONFIG_ECC_MODE_SHIFT, align 4\n%5 = tail call i32 @vf610_nfc_set_field(ptr noundef %0, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %1)\nret void\n}", "codegemma": "define internal void @vf610_nfc_ecc_mode(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @NFC_FLASH_CONFIG, align 4\n%3 = load i32, ptr @CONFIG_ECC_MODE_MASK, align 4\n%4 = load i32, ptr @CONFIG_ECC_MODE_SHIFT, align 4\n%5 = tail call i32 @vf610_nfc_set_field(ptr noundef %0, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %1)\nret void\n}"}, "define dso_local i32 @AcpiUtValidNameChar(i8 noundef signext %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i8, align 1\n%5 = alloca i32, align 4\nstore i8 %0, ptr %4, align 1\nstore i32 %1, ptr %5, align 4\n%6 = load i8, ptr %4, align 1\n%7 = sext i8 %6 to i32\n%8 = icmp sge i32 %7, 65\nbr i1 %8, label %9, label %13\n\n9:\n%10 = load i8, ptr %4, align 1\n%11 = sext i8 %10 to i32\n%12 = icmp sle i32 %11, 90\nbr i1 %12, label %36, label %13\n\n13:\n%14 = load i8, ptr %4, align 1\n%15 = sext i8 %14 to i32\n%16 = icmp sge i32 %15, 48\nbr i1 %16, label %17, label %21\n\n17:\n%18 = load i8, ptr %4, align 1\n%19 = sext i8 %18 to i32\n%20 = icmp sle i32 %19, 57\nbr i1 %20, label %36, label %21\n\n21:\n%22 = load i8, ptr %4, align 1\n%23 = sext i8 %22 to i32\n%24 = icmp eq i32 %23, 95\nbr i1 %24, label %36, label %25\n\n25:\n%26 = load i8, ptr %4, align 1\n%27 = sext i8 %26 to i32\n%28 = icmp eq i32 %27, 33\nbr i1 %28, label %29, label %34\n\n29:\n%30 = load i32, ptr %5, align 4\n%31 = icmp eq i32 %30, 3\nbr i1 %31, label %32, label %34\n\n32:\n%33 = load i32, ptr @TRUE, align 4\nstore i32 %33, ptr %3, align 4\nbr label %38\n\n34:\n%35 = load i32, ptr @FALSE, align 4\nstore i32 %35, ptr %3, align 4\nbr label %38\n\n36:\n%37 = load i32, ptr @TRUE, align 4\nstore i32 %37, ptr %3, align 4\nbr label %38\n\n38:\n%39 = load i32, ptr %3, align 4\nret i32 %39\n}": {"base_truth": "define dso_local i32 @AcpiUtValidNameChar(i8 noundef signext %0, i32 noundef %1) {\nB:\n%2 = add i8 %0, -65\n%3 = icmp ult i8 %2, 26\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = add i8 %0, -48\n%5 = icmp ult i8 %4, 10\n%6 = icmp eq i8 %0, 95\n%7 = or i1 %6, %5\n%8 = icmp eq i8 %0, 33\n%9 = icmp eq i32 %1, 3\n%10 = and i1 %8, %9\n%11 = or i1 %7, %10\n%12 = select i1 %11, ptr @TRUE, ptr @FALSE\nbr label %B2\n\nB2:\n%13 = phi ptr [ @TRUE, %B ], [ %12, %B1 ]\n%14 = load i32, ptr %13, align 4\nret i32 %14\n}", "codellama": "define dso_local i32 @AcpiUtValidNameChar(i8 noundef signext %0, i32 noundef %1) {\nB:\n%2 = add i8 %0, -65\n%3 = icmp ult i8 %2, 26\n%4 = add i8 %0, -48\n%5 = icmp ult i8 %4, 10\n%6 = icmp eq i8 %0, 95\n%7 = icmp eq i8 %0, 33\n%8 = icmp eq i32 %1, 3\n%9 = and i1 %8, %7\n%10 = select i1 %9, ptr @TRUE, ptr @FALSE\n%11 = select i1 %6, ptr @TRUE, ptr %10\n%12 = select i1 %5, ptr @TRUE, ptr %11\n%13 = select i1 %3, ptr @TRUE, ptr %12\nret i32 %13\n}", "codegemma": "define dso_local i32 @AcpiUtValidNameChar(i8 noundef signext %0, i32 noundef %1) {\nB:\n%2 = add i8 %0, -65\n%3 = icmp ult i8 %2, 26\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = add i8 %0, -48\n%5 = icmp ult i8 %4, 10\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = icmp eq i8 %0, 95\n%7 = icmp eq i32 %1, 3\n%8 = and i1 %6, %7\nbr i1 %8, label %B3, label %B4\n\nB3:\nbr label %B4\n\nB4:\n%9 = phi ptr [ @TRUE, %B3 ], [ @FALSE, %B2 ]\n%10 = load i32, ptr %9, align 4\nret i32 %10\n}"}, "define dso_local void @media_print_topology(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = icmp ne i32 %5, 0\nbr i1 %6, label %7, label %10\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @media_print_topology_dot(ptr noundef %8)\nbr label %13\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = call i32 @media_print_topology_text(ptr noundef %11)\nbr label %13\n\n13:\nret void\n}": {"base_truth": "define dso_local void @media_print_topology(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @media_print_topology_dot(ptr noundef %0)\nbr label %B3\n\nB2:\n%4 = tail call i32 @media_print_topology_text(ptr noundef %0)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @media_print_topology(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @media_print_topology_dot(ptr noundef %0)\nbr label %B3\n\nB2:\n%4 = tail call i32 @media_print_topology_text(ptr noundef %0)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @media_print_topology(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @media_print_topology_dot(ptr noundef %0)\nbr label %B3\n\nB2:\n%4 = tail call i32 @media_print_topology_text(ptr noundef %0)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local void @select_down() {\n%1 = alloca i64, align 8\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%3 = load i32, ptr @VI_current_page, align 4\n%4 = icmp ne i32 %3, 2\nbr i1 %4, label %5, label %6\n\n5:\nstore i32 1, ptr %2, align 4\nbr label %24\n\n6:\n%7 = load i32, ptr @select_active, align 4\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %9, label %10\n\n9:\nstore i32 1, ptr %2, align 4\nbr label %24\n\n10:\nstore i64 1, ptr %1, align 8\nbr label %11\n\n11:\n%12 = load i32, ptr @select_active, align 4\n%13 = sext i32 %12 to i64\n%14 = load i64, ptr %1, align 8\n%15 = add nsw i64 %13, %14\n%16 = trunc i64 %15 to i32\n%17 = call i32 @select_set_active(i32 noundef %16)\n%18 = icmp eq i32 %17, -2\nbr i1 %18, label %19, label %23\n\n19:\nbr label %20\n\n20:\n%21 = load i64, ptr %1, align 8\n%22 = add nsw i64 %21, 1\nstore i64 %22, ptr %1, align 8\nbr label %11\n\n23:\nstore i32 0, ptr %2, align 4\nbr label %24\n\n24:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\n%25 = load i32, ptr %2, align 4\nswitch i32 %25, label %27 [\ni32 0, label %26\ni32 1, label %26\n]\n\n26:\nret void\n\n27:\nunreachable\n}": {"base_truth": "define dso_local void @select_down() {\nB:\n%0 = load i32, ptr @VI_current_page, align 4\n%1 = icmp ne i32 %0, 2\n%2 = load i32, ptr @select_active, align 4\n%3 = icmp eq i32 %2, -1\n%4 = select i1 %1, i1 true, i1 %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = phi i32 [ %10, %B1 ], [ 1, %B ]\n%6 = load i32, ptr @select_active, align 4\n%7 = add i32 %6, %5\n%8 = tail call i32 @select_set_active(i32 noundef %7)\n%9 = icmp eq i32 %8, -2\n%10 = add i32 %5, 1\nbr i1 %9, label %B1, label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @select_down() {\nB:\n%0 = load i32, ptr @VI_current_page, align 4\n%1 = icmp ne i32 %0, 2\n%2 = load i32, ptr @select_active, align 4\n%3 = icmp eq i32 %2, -1\n%4 = select i1 %1, i1 true, i1 %3\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = phi i64 [ %9, %B2 ], [ 1, %B ]\n%6 = trunc i64 %5 to i32\n%7 = tail call i32 @select_set_active(i32 noundef %6)\n%8 = icmp eq i32 %7, -2\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = add nuw nsw i64 %5, 1\n%10 = load i32, ptr @select_active, align 4\n%11 = sext i32 %10 to i64\n%12 = add nsw i64 %11, %5\n%13 = icmp sgt i64 %12, 2147483647\nbr i1 %13, label %B3, label %B1\n\nB3:\nret void\n}", "codegemma": "define dso_local void @select_down() {\nB:\n%0 = load i32, ptr @VI_current_page, align 4\n%1 = icmp eq i32 %0, 2\nbr i1 %1, label %B1, label %B3\n\nB1:\n%2 = load i32, ptr @select_active, align 4\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = phi i64 [ %6, %B2 ], [ 1, %B1 ]\n%5 = tail call i32 @select_set_active(i32 noundef %2)\n%6 = add nuw nsw i64 %4, 1\n%7 = icmp eq i32 %5, -2\nbr i1 %7, label %B2, label %B3\n\nB3:\nret void\n}"}, "define dso_local i32 @rtl8370_setAsicUnknownMulticastTrapPriority(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %4, 7\nbr i1 %5, label %6, label %8\n\n6:\n%7 = load i32, ptr @RT_ERR_QOS_INT_PRIORITY, align 4\nstore i32 %7, ptr %2, align 4\nbr label %11\n\n8:\n%9 = load i32, ptr %3, align 4\n%10 = call i32 @rtl8370_setAsicRegBits(i32 noundef 2177, i32 noundef 28672, i32 noundef %9)\nstore i32 %10, ptr %2, align 4\nbr label %11\n\n11:\n%12 = load i32, ptr %2, align 4\nret i32 %12\n}": {"base_truth": "define dso_local i32 @rtl8370_setAsicUnknownMulticastTrapPriority(i32 noundef %0) {\nB:\n%1 = icmp sgt i32 %0, 7\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i32, ptr @RT_ERR_QOS_INT_PRIORITY, align 4\nbr label %B3\n\nB2:\n%3 = tail call i32 @rtl8370_setAsicRegBits(i32 noundef 2177, i32 noundef 28672, i32 noundef %0)\nbr label %B3\n\nB3:\n%4 = phi i32 [ %2, %B1 ], [ %3, %B2 ]\nret i32 %4\n}", "codellama": "define dso_local i32 @rtl8370_setAsicUnknownMulticastTrapPriority(i32 noundef %0) {\nB:\n%1 = icmp sgt i32 %0, 7\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i32, ptr @RT_ERR_QOS_INT_PRIORITY, align 4\nbr label %B3\n\nB2:\n%3 = tail call i32 @rtl8370_setAsicRegBits(i32 noundef 2177, i32 noundef 28672, i32 noundef %0)\nbr label %B3\n\nB3:\n%4 = phi i32 [ %2, %B1 ], [ %3, %B2 ]\nret i32 %4\n}", "codegemma": "define dso_local i32 @rtl8370_setAsicUnknownMulticastTrapPriority(i32 noundef %0) {\nB:\n%1 = icmp sgt i32 %0, 7\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i32, ptr @RT_ERR_QOS_INT_PRIORITY, align 4\nbr label %B3\n\nB2:\n%3 = tail call i32 @rtl8370_setAsicRegBits(i32 noundef 2177, i32 noundef 28672, i32 noundef %0)\nbr label %B3\n\nB3:\n%4 = phi i32 [ %2, %B1 ], [ %3, %B2 ]\nret i32 %4\n}"}, "define dso_local i32 @re_get_changes_when_casemapped(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%7 = load i32, ptr %2, align 4\n%8 = ashr i32 %7, 15\nstore i32 %8, ptr %4, align 4\n%9 = load i32, ptr %2, align 4\n%10 = load i32, ptr %4, align 4\n%11 = shl i32 %10, 15\n%12 = xor i32 %9, %11\nstore i32 %12, ptr %3, align 4\n%13 = load ptr, ptr @re_changes_when_casemapped_stage_1, align 8\n%14 = load i32, ptr %4, align 4\n%15 = sext i32 %14 to i64\n%16 = getelementptr inbounds i64, ptr %13, i64 %15\n%17 = load i64, ptr %16, align 8\n%18 = trunc i64 %17 to i32\n%19 = shl i32 %18, 4\nstore i32 %19, ptr %5, align 4\n%20 = load i32, ptr %3, align 4\n%21 = ashr i32 %20, 11\nstore i32 %21, ptr %4, align 4\n%22 = load i32, ptr %4, align 4\n%23 = shl i32 %22, 11\n%24 = load i32, ptr %3, align 4\n%25 = xor i32 %24, %23\nstore i32 %25, ptr %3, align 4\n%26 = load ptr, ptr @re_changes_when_casemapped_stage_2, align 8\n%27 = load i32, ptr %5, align 4\n%28 = load i32, ptr %4, align 4\n%29 = add nsw i32 %27, %28\n%30 = sext i32 %29 to i64\n%31 = getelementptr inbounds i64, ptr %26, i64 %30\n%32 = load i64, ptr %31, align 8\n%33 = trunc i64 %32 to i32\n%34 = shl i32 %33, 3\nstore i32 %34, ptr %5, align 4\n%35 = load i32, ptr %3, align 4\n%36 = ashr i32 %35, 8\nstore i32 %36, ptr %4, align 4\n%37 = load i32, ptr %4, align 4\n%38 = shl i32 %37, 8\n%39 = load i32, ptr %3, align 4\n%40 = xor i32 %39, %38\nstore i32 %40, ptr %3, align 4\n%41 = load ptr, ptr @re_changes_when_casemapped_stage_3, align 8\n%42 = load i32, ptr %5, align 4\n%43 = load i32, ptr %4, align 4\n%44 = add nsw i32 %42, %43\n%45 = sext i32 %44 to i64\n%46 = getelementptr inbounds i64, ptr %41, i64 %45\n%47 = load i64, ptr %46, align 8\n%48 = trunc i64 %47 to i32\n%49 = shl i32 %48, 3\nstore i32 %49, ptr %5, align 4\n%50 = load i32, ptr %3, align 4\n%51 = ashr i32 %50, 5\nstore i32 %51, ptr %4, align 4\n%52 = load i32, ptr %4, align 4\n%53 = shl i32 %52, 5\n%54 = load i32, ptr %3, align 4\n%55 = xor i32 %54, %53\nstore i32 %55, ptr %3, align 4\n%56 = load ptr, ptr @re_changes_when_casemapped_stage_4, align 8\n%57 = load i32, ptr %5, align 4\n%58 = load i32, ptr %4, align 4\n%59 = add nsw i32 %57, %58\n%60 = sext i32 %59 to i64\n%61 = getelementptr inbounds i64, ptr %56, i64 %60\n%62 = load i64, ptr %61, align 8\n%63 = trunc i64 %62 to i32\n%64 = shl i32 %63, 5\nstore i32 %64, ptr %5, align 4\n%65 = load i32, ptr %3, align 4\n%66 = load i32, ptr %5, align 4\n%67 = add nsw i32 %66, %65\nstore i32 %67, ptr %5, align 4\n%68 = load ptr, ptr @re_changes_when_casemapped_stage_5, align 8\n%69 = load i32, ptr %5, align 4\n%70 = ashr i32 %69, 3\n%71 = sext i32 %70 to i64\n%72 = getelementptr inbounds i32, ptr %68, i64 %71\n%73 = load i32, ptr %72, align 4\n%74 = load i32, ptr %5, align 4\n%75 = and i32 %74, 7\n%76 = ashr i32 %73, %75\n%77 = and i32 %76, 1\nstore i32 %77, ptr %6, align 4\n%78 = load i32, ptr %6, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %78\n}": {"base_truth": "define dso_local i32 @re_get_changes_when_casemapped(i32 noundef %0) {\nB:\n%1 = ashr i32 %0, 15\n%2 = load ptr, ptr @re_changes_when_casemapped_stage_1, align 8\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds i64, ptr %2, i64 %3\n%5 = load i64, ptr %4, align 8\n%6 = trunc i64 %5 to i32\n%7 = shl i32 %6, 4\n%8 = lshr i32 %0, 11\n%9 = and i32 %8, 15\n%10 = load ptr, ptr @re_changes_when_casemapped_stage_2, align 8\n%11 = or i32 %7, %9\n%12 = sext i32 %11 to i64\n%13 = getelementptr inbounds i64, ptr %10, i64 %12\n%14 = load i64, ptr %13, align 8\n%15 = trunc i64 %14 to i32\n%16 = shl i32 %15, 3\n%17 = lshr i32 %0, 8\n%18 = and i32 %17, 7\n%19 = load ptr, ptr @re_changes_when_casemapped_stage_3, align 8\n%20 = or i32 %16, %18\n%21 = sext i32 %20 to i64\n%22 = getelementptr inbounds i64, ptr %19, i64 %21\n%23 = load i64, ptr %22, align 8\n%24 = trunc i64 %23 to i32\n%25 = shl i32 %24, 3\n%26 = lshr i32 %0, 5\n%27 = and i32 %26, 7\n%28 = and i32 %0, 24\n%29 = load ptr, ptr @re_changes_when_casemapped_stage_4, align 8\n%30 = or i32 %25, %27\n%31 = sext i32 %30 to i64\n%32 = getelementptr inbounds i64, ptr %29, i64 %31\n%33 = load i64, ptr %32, align 8\n%34 = trunc i64 %33 to i32\n%35 = shl i32 %34, 5\n%36 = or i32 %35, %28\n%37 = load ptr, ptr @re_changes_when_casemapped_stage_5, align 8\n%38 = ashr exact i32 %36, 3\n%39 = sext i32 %38 to i64\n%40 = getelementptr inbounds i32, ptr %37, i64 %39\n%41 = load i32, ptr %40, align 4\n%42 = and i32 %0, 7\n%43 = lshr i32 %41, %42\n%44 = and i32 %43, 1\nret i32 %44\n}", "codellama": "define dso_local i32 @re_get_changes_when_casemapped(i32 noundef %0) {\nB:\n%1 = ashr i32 %0, 15\n%2 = shl i32 %1, 15\n%3 = xor i32 %2, %0\n%4 = load ptr, ptr @re_changes_when_casemapped_stage_1, align 8\n%5 = sext i32 %1 to i64\n%6 = getelementptr inbounds i64, ptr %4, i64 %5\n%7 = load i64, ptr %6, align 8\n%8 = trunc i64 %7 to i32\n%9 = shl i32 %8, 4\n%10 = lshr i32 %3, 11\n%11 = and i32 %10, 15\n%12 = load ptr, ptr @re_changes_when_casemapped_stage_2, align 8\n%13 = or i32 %9, %11\n%14 = sext i32 %13 to i64\n%15 = getelementptr inbounds i64, ptr %12, i64 %14\n%16 = load i64, ptr %15, align 8\n%17 = trunc i64 %16 to i32\n%18 = shl i32 %17, 3\n%19 = lshr i32 %3, 8\n%20 = and i32 %19, 7\n%21 = load ptr, ptr @re_changes_when_casemapped_stage_3, align 8\n%22 = or i32 %18, %20\n%23 = sext i32 %22 to i64\n%24 = getelementptr inbounds i64, ptr %21, i64 %23\n%25 = load i64, ptr %24, align 8\n%26 = trunc i64 %25 to i32\n%27 = shl i32 %26, 3\n%28 = lshr i32 %3, 5\n%29 = and i32 %28, 7\n%30 = and i32 %3, 24\n%31 = load ptr, ptr @re_changes_when_casemapped_stage_4, align 8\n%32 = or i32 %27, %29\n%3</s>", "codegemma": "define dso_local i32 @re_get_changes_when_casemapped(i32 noundef %0) {\nB:\n%1 = ashr i32 %0, 15\n%2 = shl i32 %1, 15\n%3 = xor i32 %2, %0\n%4 = load ptr, ptr @re_changes_when_casemapped_stage_1, align 8\n%5 = sext i32 %1 to i64\n%6 = getelementptr inbounds i64, ptr %4, i64 %5\n%7 = load i64, ptr %6, align 8\n%8 = trunc i64 %7 to i32\n%9 = shl i32 %8, 4\n%10 = ashr i32 %3, 11\n%11 = shl i32 %10, 11\n%12 = xor i32 %11, %3\n%13 = load ptr, ptr @re_changes_when_casemapped_stage_2, align 8\n%14 = add nsw i32 %9, %10\n%15 = sext i32 %14 to i64\n%16 = getelementptr inbounds i64, ptr %13, i64 %15\n%17 = load i64, ptr %16, align 8\n%18 = trunc i64 %17 to i32\n%19 = shl i32 %18, 3\n%20 = ashr i32 %12, 8\n%21 = shl i32 %20, 8\n%22 = xor i32 %21, %12\n%23 = load ptr, ptr @re_changes_when_casemapped_stage_3, align 8\n%24 = add nsw i32 %19, %20\n%25 = sext i32 %24 to i64\n%26 = getelementptr inbounds i64, ptr %23, i64 %25\n%27 = load i64, ptr %26, align 8\n%28 = trunc i64 %27 to i32\n%29 = shl i32 %28, 3\n%30 = ashr i32 %22, 5\n%31 = shl i32 %30, 5\n%32 = xor i32 %31, %22\n%33 = load ptr, ptr @re_changes_when_casemapped_stage_4, align 8\n%34 = add nsw i32 %29, %30\n%35 = sext i32 %34 to i64<eos>"}, "define dso_local i64 @mkunary(i32 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca i64, align 8\nstore i32 %0, ptr %4, align 4\nstore i64 %1, ptr %5, align 8\n%8 = load ptr, ptr @SMVs, align 8\n%9 = load i64, ptr %5, align 8\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %8, i64 %9\n%11 = getelementptr inbounds %struct.TYPE_6__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 8\n%13 = icmp eq i32 %12, 1\nbr i1 %13, label %14, label %41\n\n14:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%15 = load ptr, ptr @SMVs, align 8\n%16 = load i64, ptr %5, align 8\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %15, i64 %16\n%18 = getelementptr inbounds %struct.TYPE_6__, ptr %17, i32 0, i32 2\n%19 = getelementptr inbounds %struct.TYPE_5__, ptr %18, i32 0, i32 0\n%20 = load i32, ptr %19, align 8\nstore i32 %20, ptr %6, align 4\n%21 = load i32, ptr %4, align 4\nswitch i32 %21, label %33 [\ni32 13, label %22\ni32 14, label %25\ni32 15, label %28\n]\n\n22:\n%23 = load i32, ptr %6, align 4\n%24 = sub nsw i32 0, %23\nstore i32 %24, ptr %6, align 4\nbr label %33\n\n25:\n%26 = load i32, ptr %6, align 4\n%27 = xor i32 %26, -1\nstore i32 %27, ptr %6, align 4\nbr label %33\n\n28:\n%29 = load i32, ptr %6, align 4\n%30 = icmp ne i32 %29, 0\n%31 = xor i1 %30, true\n%32 = zext i1 %31 to i32\nstore i32 %32, ptr %6, align 4\nbr label %33\n\n33:\n%34 = load i32, ptr %6, align 4\n%35 = load ptr, ptr @SMVs, align 8\n%36 = load i64, ptr %5, align 8\n%37 = getelementptr inbounds %struct.TYPE_6__, ptr %35, i64 %36\n%38 = getelementptr inbounds %struct.TYPE_6__, ptr %37, i32 0, i32 2\n%39 = getelementptr inbounds %struct.TYPE_5__, ptr %38, i32 0, i32 0\nstore i32 %34, ptr %39, align 8\n%40 = load i64, ptr %5, align 8\nstore i64 %40, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\nbr label %55\n\n41:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%42 = call i64 (...) @allocSMV()\nstore i64 %42, ptr %7, align 8\n%43 = load i32, ptr %4, align 4\n%44 = load ptr, ptr @SMVs, align 8\n%45 = load i64, ptr %7, align 8\n%46 = getelementptr inbounds %struct.TYPE_6__, ptr %44, i64 %45\n%47 = getelementptr inbounds %struct.TYPE_6__, ptr %46, i32 0, i32 0\nstore i32 %43, ptr %47, align 8\n%48 = load i64, ptr %5, align 8\n%49 = load ptr, ptr @SMVs, align 8\n%50 = load i64, ptr %7, align 8\n%51 = getelementptr inbounds %struct.TYPE_6__, ptr %49, i64 %50\n%52 = getelementptr inbounds %struct.TYPE_6__, ptr %51, i32 0, i32 1\n%53 = getelementptr inbounds %struct.TYPE_4__, ptr %52, i32 0, i32 0\nstore i64 %48, ptr %53, align 8\n%54 = load i64, ptr %7, align 8\nstore i64 %54, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nbr label %55\n\n55:\n%56 = load i64, ptr %3, align 8\nret i64 %56\n}": {"base_truth": "define dso_local i64 @mkunary(i32 noundef %0, i64 noundef %1) {\nB:\n%2 = load ptr, ptr @SMVs, align 8\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 %1\n%4 = load i32, ptr %3, align 8\n%5 = icmp eq i32 %4, 1\nbr i1 %5, label %B1, label %B6\n\nB1:\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 %1, i32 2\n%7 = load i32, ptr %6, align 8\nswitch i32 %0, label %B5 [\ni32 13, label %B2\ni32 14, label %B3\ni32 15, label %B4\n]\n\nB2:\n%8 = sub nsw i32 0, %7\nbr label %B5\n\nB3:\n%9 = xor i32 %7, -1\nbr label %B5\n\nB4:\n%10 = icmp eq i32 %7, 0\n%11 = zext i1 %10 to i32\nbr label %B5\n\nB5:\n%12 = phi i32 [ %7, %B1 ], [ %11, %B4 ], [ %9, %B3 ], [ %8, %B2 ]\nstore i32 %12, ptr %6, align 8\nbr label %B7\n\nB6:\n%13 = tail call i64 (...) @allocSMV()\n%14 = load ptr, ptr @SMVs, align 8\n%15 = getelementptr inbounds %struct.TYPE_6__, ptr %14, i64 %13\nstore i32 %0, ptr %15, align 8\n%16 = getelementptr inbounds %struct.TYPE_6__, ptr %14, i64 %13, i32 1\nstore i64 %1, ptr %16, align 8\nbr label %B7\n\nB7:\n%17 = phi i64 [ %1, %B5 ], [ %13, %B6 ]\nret i64 %17\n}", "codellama": "define dso_local i64 @mkunary(i32 noundef %0, i64 noundef %1) {\nB:\n%2 = load ptr, ptr @SMVs, align 8\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 %1\n%4 = load i32, ptr %3, align 8\n%5 = icmp eq i32 %4, 1\nbr i1 %5, label %B1, label %B4\n\nB1:\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 %1, i32 2\n%7 = load i32, ptr %6, align 8\nswitch i32 %0, label %B3 [\ni32 13, label %B2\ni32 14, label %B2\ni32 15, label %B2\n]\n\nB2:\n%8 = phi i32 [ 0, %B1 ], [ -1, %B1 ], [ -1, %B1 ], [ %7, %B1 ]\n%9 = xor i32 %8, -1\n%10 = icmp eq i32 %8, 0\n%11 = zext i1 %10 to i32\nbr label %B3\n\nB3:\n%12 = phi i32 [ %7, %B1 ], [ %11, %B2 ], [ %7, %B1 ]\nstore i32 %12, ptr %6, align 8\nbr label %B5\n\nB4:\n%13 = tail call i64 (...) @allocSMV()\n%14 = load ptr, ptr @SMVs, align 8\n%15 = getelementptr inbounds %struct.TYPE_6__, ptr %14, i64 %1\nstore i32 %0, ptr %15, align 8\n%16 = getelementptr inbounds %struct.TYPE_6__, ptr %14, i64 %1, i32 1\nstore i64 %1, ptr %16, align 8\nbr label %B5\n\nB5:\n%17 = phi i64 [ %1, %B3 ], [ %13, %B4 ]\nret i64 %17\n}", "codegemma": "define dso_local i64 @mkunary(i32 noundef %0, i64 noundef %1) {\nB:\n%2 = load ptr, ptr @SMVs, align 8\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 %1\n%4 = load i32, ptr %3, align 8\n%5 = icmp eq i32 %4, 1\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 %1, i32 2\n%7 = load i32, ptr %6, align 8\n%8 = icmp eq i32 %7, 1\n%9 = sub nsw i32 0, %7\n%10 = xor i32 %9, -1\n%11 = icmp eq i32 %7, 0\n%12 = zext i1 %11 to i32\n%13 = select i1 %8, i32 %10, i32 %12\nstore i32 %13, ptr %6, align 8\nbr label %B3\n\nB2:\n%14 = tail call i64 (...) @allocSMV()\n%15 = load ptr, ptr @SMVs, align 8\n%16 = getelementptr inbounds %struct.TYPE_6__, ptr %15, i64 %14\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %15, i64 %14, i32 1\nstore i32 %0, ptr %16, align 8\n%18 = getelementptr inbounds %struct.TYPE_6__, ptr %15, i64 %14, i32 1, i32 0\nstore i64 %1, ptr %18, align 8\nbr label %B3\n\nB3:\n%19 = phi i64 [ %14, %B2 ], [ %1, %B1 ]\nret i64 %19\n}"}, "define internal i32 @actionTag(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call i64 @Panel_getSelected(i32 noundef %8)\n%10 = inttoptr i64 %9 to ptr\nstore ptr %10, ptr %4, align 8\n%11 = load ptr, ptr %4, align 8\n%12 = icmp ne ptr %11, null\nbr i1 %12, label %15, label %13\n\n13:\n%14 = load i32, ptr @HTOP_OK, align 4\nstore i32 %14, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n15:\n%16 = load ptr, ptr %4, align 8\n%17 = call i32 @Process_toggleTag(ptr noundef %16)\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.TYPE_3__, ptr %18, i32 0, i32 0\n%20 = load i32, ptr %19, align 4\n%21 = load i32, ptr @KEY_DOWN, align 4\n%22 = call i32 @Panel_onKey(i32 noundef %20, i32 noundef %21)\n%23 = load i32, ptr @HTOP_OK, align 4\nstore i32 %23, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n24:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%25 = load i32, ptr %2, align 4\nret i32 %25\n}": {"base_truth": "define internal i32 @actionTag(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i64 @Panel_getSelected(i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = inttoptr i64 %2 to ptr\n%5 = tail call i32 @Process_toggleTag(ptr noundef nonnull %4)\n%6 = load i32, ptr %0, align 4\n%7 = load i32, ptr @KEY_DOWN, align 4\n%8 = tail call i32 @Panel_onKey(i32 noundef %6, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = load i32, ptr @HTOP_OK, align 4\nret i32 %9\n}", "codellama": "define internal i32 @actionTag(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i64 @Panel_getSelected(i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = inttoptr i64 %2 to ptr\n%5 = tail call i32 @Process_toggleTag(ptr noundef nonnull %4)\n%6 = load i32, ptr %0, align 4\n%7 = load i32, ptr @KEY_DOWN, align 4\n%8 = tail call i32 @Panel_onKey(i32 noundef %6, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = load i32, ptr @HTOP_OK, align 4\nret i32 %9\n}", "codegemma": "define internal i32 @actionTag(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i64 @Panel_getSelected(i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = inttoptr i64 %2 to ptr\n%5 = tail call i32 @Process_toggleTag(ptr noundef nonnull %4)\n%6 = load i32, ptr %0, align 4\n%7 = load i32, ptr @KEY_DOWN, align 4\n%8 = tail call i32 @Panel_onKey(i32 noundef %6, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = load i32, ptr @HTOP_OK, align 4\nret i32 %9\n}"}, "define dso_local i32 @zfcp_sysfs_port_is_removing(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 @lockdep_assert_held(ptr noundef @zfcp_sysfs_port_units_mutex)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.zfcp_port ptr %4, i32 0, i32 0\n%6 = call i32 @atomic_read(ptr noundef %5)\n%7 = icmp eq i32 %6, -1\n%8 = zext i1 %7 to i32\nret i32 %8\n}": {"base_truth": "define dso_local i32 @zfcp_sysfs_port_is_removing(ptr noundef %0) {\nB:\n%1 = tail call i32 @lockdep_assert_held(ptr noundef nonnull @zfcp_sysfs_port_units_mutex)\n%2 = tail call i32 @atomic_read(ptr noundef %0)\n%3 = icmp eq i32 %2, -1\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codellama": "define dso_local i32 @zfcp_sysfs_port_is_removing(ptr noundef %0) {\nB:\n%1 = tail call i32 @lockdep_assert_held(ptr noundef nonnull @zfcp_sysfs_port_units_mutex)\n%2 = tail call i32 @atomic_read(ptr noundef %0)\n%3 = icmp eq i32 %2, -1\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codegemma": "define dso_local i32 @zfcp_sysfs_port_is_removing(ptr noundef %0) {\nB:\n%1 = tail call i32 @lockdep_assert_held(ptr noundef nonnull @zfcp_sysfs_port_units_mutex)\n%2 = tail call i32 @atomic_read(ptr noundef %0)\n%3 = icmp eq i32 %2, -1\n%4 = zext i1 %3 to i32\nret i32 %4\n}"}, "define internal void @handle_channel(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore ptr %3, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\n%12 = load ptr, ptr %5, align 8\n%13 = load i32, ptr %6, align 4\n%14 = load i32, ptr %7, align 4\n%15 = call i32 @determine_mtr(ptr noundef %12, i32 noundef %13, i32 noundef %14)\nstore i32 %15, ptr %9, align 4\n%16 = load i32, ptr %9, align 4\n%17 = call i64 @MTR_DIMMS_PRESENT(i32 noundef %16)\n%18 = icmp ne i64 %17, 0\nbr i1 %18, label %19, label %60\n\n19:\n%20 = load ptr, ptr %5, align 8\n%21 = load i32, ptr %7, align 4\n%22 = call i32 @determine_amb_present_reg(ptr noundef %20, i32 noundef %21)\nstore i32 %22, ptr %10, align 4\n%23 = load i32, ptr %10, align 4\n%24 = load i32, ptr %6, align 4\n%25 = shl i32 1, %24\n%26 = and i32 %23, %25\n%27 = icmp ne i32 %26, 0\nbr i1 %27, label %28, label %59\n\n28:\n%29 = load i32, ptr %9, align 4\n%30 = call i32 @MTR_DRAM_BANKS_ADDR_BITS(i32 noundef %29)\nstore i32 %30, ptr %11, align 4\n%31 = load i32, ptr %9, align 4\n%32 = call i64 @MTR_DIMM_ROWS_ADDR_BITS(i32 noundef %31)\n%33 = load i32, ptr %11, align 4\n%34 = sext i32 %33 to i64\n%35 = add nsw i64 %34, %32\n%36 = trunc i64 %35 to i32\nstore i32 %36, ptr %11, align 4\n%37 = load i32, ptr %9, align 4\n%38 = call i64 @MTR_DIMM_COLS_ADDR_BITS(i32 noundef %37)\n%39 = load i32, ptr %11, align 4\n%40 = sext i32 %39 to i64\n%41 = add nsw i64 %40, %38\n%42 = trunc i64 %41 to i32\nstore i32 %42, ptr %11, align 4\n%43 = load i32, ptr %9, align 4\n%44 = call i64 @MTR_DIMM_RANK(i32 noundef %43)\n%45 = load i32, ptr %11, align 4\n%46 = sext i32 %45 to i64\n%47 = add nsw i64 %46, %44\n%48 = trunc i64 %47 to i32\nstore i32 %48, ptr %11, align 4\n%49 = load i32, ptr %11, align 4\n%50 = add nsw i32 %49, 6\nstore i32 %50, ptr %11, align 4\n%51 = load i32, ptr %11, align 4\n%52 = sub nsw i32 %51, 20\nstore i32 %52, ptr %11, align 4\n%53 = load i32, ptr %11, align 4\n%54 = sub nsw i32 %53, 3\nstore i32 %54, ptr %11, align 4\n%55 = load i32, ptr %11, align 4\n%56 = shl i32 1, %55\n%57 = load ptr, ptr %8, align 8\n%58 = getelementptr inbounds %struct.i5400_dimm_info ptr %57, i32 0, i32 0\nstore i32 %56, ptr %58, align 4\nbr label %59\n\n59:\nbr label %60\n\n60:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\nret void\n}": {"base_truth": "define internal void @handle_channel(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef writeonly %3) {\nB:\n%4 = tail call i32 @determine_mtr(ptr noundef %0, i32 noundef %1, i32 noundef %2)\n%5 = tail call i64 @MTR_DIMMS_PRESENT(i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = tail call i32 @determine_amb_present_reg(ptr noundef %0, i32 noundef %2)\n%8 = shl nuw i32 1, %1\n%9 = and i32 %7, %8\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = tail call i32 @MTR_DRAM_BANKS_ADDR_BITS(i32 noundef %4)\n%12 = tail call i64 @MTR_DIMM_ROWS_ADDR_BITS(i32 noundef %4)\n%13 = trunc i64 %12 to i32\n%14 = tail call i64 @MTR_DIMM_COLS_ADDR_BITS(i32 noundef %4)\n%15 = trunc i64 %14 to i32\n%16 = tail call i64 @MTR_DIMM_RANK(i32 noundef %4)\n%17 = trunc i64 %16 to i32\n%18 = add i32 %11, -17\n%19 = add i32 %18, %13\n%20 = add i32 %19, %15\n%21 = add i32 %20, %17\n%22 = shl nuw i32 1, %21\nstore i32 %22, ptr %3, align 4\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @handle_channel(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef writeonly %3) {\nB:\n%4 = tail call i32 @determine_mtr(ptr noundef %0, i32 noundef %1, i32 noundef %2)\n%5 = tail call i64 @MTR_DIMMS_PRESENT(i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = tail call i32 @determine_amb_present_reg(ptr noundef %0, i32 noundef %2)\n%8 = shl nuw i32 1, %1\n%9 = and i32 %7, %8\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = tail call i32 @MTR_DRAM_BANKS_ADDR_BITS(i32 noundef %4)\n%12 = tail call i64 @MTR_DIMM_ROWS_ADDR_BITS(i32 noundef %4)\n%13 = tail call i64 @MTR_DIMM_COLS_ADDR_BITS(i32 noundef %4)\n%14 = tail call i64 @MTR_DIMM_RANK(i32 noundef %4)\n%15 = add i32 %11, 18\n%16 = add i32 %15, %12\n%17 = add i32 %16, %13\n%18 = add i32 %17, %14\n%19 = shl nuw i32 1, %18\nstore i32 %19, ptr %3, align 4\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @handle_channel(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef writeonly %3) {\nB:\n%4 = tail call i32 @determine_mtr(ptr noundef %0, i32 noundef %1, i32 noundef %2)\n%5 = tail call i64 @MTR_DIMMS_PRESENT(i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = tail call i32 @determine_amb_present_reg(ptr noundef %0, i32 noundef %2)\n%8 = shl nuw i32 1, %1\n%9 = and i32 %8, %7\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = tail call i32 @MTR_DRAM_BANKS_ADDR_BITS(i32 noundef %4)\n%12 = tail call i64 @MTR_DIMM_ROWS_ADDR_BITS(i32 noundef %4)\n%13 = trunc i64 %12 to i32\n%14 = add i32 %13, %11\n%15 = tail call i64 @MTR_DIMM_COLS_ADDR_BITS(i32 noundef %4)\n%16 = trunc i64 %15 to i32\n%17 = add i32 %14, %16\n%18 = tail call i64 @MTR_DIMM_RANK(i32 noundef %4)\n%19 = trunc i64 %18 to i32\n%20 = add i32 %17, %19\n%21 = add i32 %20, 6\n%22 = add i32 %21, -20\n%23 = add i32 %22, -3\n%24 = shl nuw i32 1, %23\nstore i32 %24, ptr %3, align 4\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local i32 @hasAnyFactorMatching(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\n%8 = load i32, ptr %4, align 4\n%9 = srem i32 %8, 2\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %11, label %17\n\n11:\n%12 = load ptr, ptr %5, align 8\n%13 = getelementptr inbounds i32, ptr %12, i64 2\n%14 = load i32, ptr %13, align 4\n%15 = icmp ne i32 %14, 0\nbr i1 %15, label %16, label %17\n\n16:\nstore i32 1, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %60\n\n17:\n%18 = load i32, ptr %4, align 4\n%19 = srem i32 %18, 3\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %21, label %27\n\n21:\n%22 = load ptr, ptr %5, align 8\n%23 = getelementptr inbounds i32, ptr %22, i64 3\n%24 = load i32, ptr %23, align 4\n%25 = icmp ne i32 %24, 0\nbr i1 %25, label %26, label %27\n\n26:\nstore i32 1, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %60\n\n27:\nstore i32 2, ptr %6, align 4\nbr label %28\n\n28:\n%29 = load i32, ptr %6, align 4\n%30 = load i32, ptr %6, align 4\n%31 = mul nsw i32 %29, %30\n%32 = load i32, ptr %4, align 4\n%33 = icmp sle i32 %31, %32\nbr i1 %33, label %34, label %51\n\n34:\n%35 = load i32, ptr %4, align 4\n%36 = load i32, ptr %6, align 4\n%37 = srem i32 %35, %36\n%38 = icmp eq i32 %37, 0\nbr i1 %38, label %39, label %47\n\n39:\n%40 = load ptr, ptr %5, align 8\n%41 = load i32, ptr %6, align 4\n%42 = sext i32 %41 to i64\n%43 = getelementptr inbounds i32, ptr %40, i64 %42\n%44 = load i32, ptr %43, align 4\n%45 = icmp ne i32 %44, 0\nbr i1 %45, label %46, label %47\n\n46:\nstore i32 1, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %60\n\n47:\nbr label %48\n\n48:\n%49 = load i32, ptr %6, align 4\n%50 = add nsw i32 %49, 2\nstore i32 %50, ptr %6, align 4\nbr label %28\n\n51:\n%52 = load ptr, ptr %5, align 8\n%53 = load i32, ptr %4, align 4\n%54 = sext i32 %53 to i64\n%55 = getelementptr inbounds i32, ptr %52, i64 %54\n%56 = load i32, ptr %55, align 4\n%57 = icmp ne i32 %56, 0\nbr i1 %57, label %58, label %59\n\n58:\nstore i32 1, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %60\n\n59:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %60\n\n60:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%61 = load i32, ptr %3, align 4\nret i32 %61\n}": {"base_truth": "define dso_local i32 @hasAnyFactorMatching(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = and i32 %0, 1\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = getelementptr inbounds i32, ptr %1, i64 2\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B9\n\nB2:\n%7 = srem i32 %0, 3\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B4\n\nB3:\n%9 = getelementptr inbounds i32, ptr %1, i64 3\n%10 = load i32, ptr %9, align 4\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B4, label %B9\n\nB4:\n%12 = icmp slt i32 %0, 4\nbr i1 %12, label %B8, label %B5\n\nB5:\n%13 = phi i64 [ %20, %B7 ], [ 2, %B4 ]\n%14 = trunc i64 %13 to i32\n%15 = srem i32 %0, %14\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B6, label %B7\n\nB6:\n%17 = getelementptr inbounds i32, ptr %1, i64 %13\n%18 = load i32, ptr %17, align 4\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B7, label %B9\n\nB7:\n%20 = add nuw i64 %13, 2\n%21 = trunc i64 %20 to i32\n%22 = mul nsw i32 %21, %21\n%23 = icmp sgt i32 %22, %0\nbr i1 %23, label %B8, label %B5\n\nB8:\n%24 = sext i32 %0 to i64\n%25 = getelementptr inbounds i32, ptr %1, i64 %24\n%26 = load i32, ptr %25, align 4\n%27 = icmp ne i32 %26, 0\n%28 = zext i1 %27 to i32\nbr label %B9\n\nB9:\n%29 = phi i32 [ 1, %B1 ], [ 1, %B3 ], [ %28, %B8 ], [ 1, %B6 ]\nret i32 %29\n}", "codellama": "define dso_local i32 @hasAnyFactorMatching(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = and i32 %0, 1\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = getelementptr inbounds i32, ptr %1, i64 2\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B10\n\nB2:\n%7 = srem i32 %0, 3\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B5\n\nB3:\n%9 = getelementptr inbounds i32, ptr %1, i64 3\n%10 = load i32, ptr %9, align 4\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B5, label %B10\n\nB4:\n%12 = getelementptr inbounds i32, ptr %1, i64 %0\n%13 = load i32, ptr %12, align 4\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B5, label %B10\n\nB5:\n%15 = phi i32 [ 2, %B2 ], [ 2, %B3 ], [ 2, %B4 ]\n%16 = phi i32 [ 0, %B2 ], [ 0, %B3 ], [ %0, %B4 ]\nbr label %B6\n\nB6:\n%17 = phi i32 [ %21, %B8 ], [ %15, %B5 ]\n%18 = phi i32 [ %20, %B8 ], [ %16, %B5 ]\n%19 = srem i32 %18, %17\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B7, label %B8\n\nB7:\n%21 = add nuw nsw i32 %17, 2\n%22 = mul nsw i32 %21, %21\n%23 = icmp sgt i32 %22, %0\nbr i1 %23, label %B9, label %B6\n\nB8:\n%24 = add nuw nsw i32 %17, 1\n%25 = mul nsw i32 %24, %24\n%26 = icmp sgt i32 %25, %0\nbr i1 %26, label %B9, label %B6\n\nB9:\n%27 = sext i32 %18 to i64\n%28 = getelementptr inbounds i32, ptr %1, i64 %27\n%29 = load i32, ptr %28, align 4\n%30 = icmp eq i32 %29, 0\n%31 = select i1 %30, i32 0, i32 1\nbr label %B10\n\nB10:\n%32 = phi i32 [ 1, %B1 ], [ 1, %B3 ], [ %31, %B9 ], [ 0, %B4 ]\nret i32 %32\n}", "codegemma": "define dso_local i32 @hasAnyFactorMatching(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = and i32 %0, 1\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = getelementptr inbounds i32, ptr %1, i64 2\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B10\n\nB2:\n%7 = srem i32 %0, 3\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B4\n\nB3:\n%9 = getelementptr inbounds i32, ptr %1, i64 3\n%10 = load i32, ptr %9, align 4\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B4, label %B10\n\nB4:\n%12 = icmp slt i32 %0, 4\nbr i1 %12, label %B10, label %B5\n\nB5:\n%13 = phi i64 [ %18, %B7 ], [ 2, %B4 ]\n%14 = srem i32 %0, %13\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B6, label %B7\n\nB6:\n%16 = getelementptr inbounds i32, ptr %1, i64 %13\n%17 = load i32, ptr %16, align 4\n%18 = add nuw nsw i64 %13, 2\n%19 = icmp eq i32 %17, 0\nbr i1 %19, label %B5, label %B10\n\nB7:\n%20 = getelementptr inbounds i32, ptr %1, i64 %13\n%21 = load i32, ptr %20, align 4\n%22 = icmp eq i32 %21, 0\nbr i1 %22, label %B8, label %B10\n\nB8:\n%23 = icmp slt i32 %0, 10\nbr i1 %23, label %B10, label %B9\n\nB9:\n%24 = getelementptr inbounds i32, ptr %1, i64 %13\n%25 = load i32, ptr %24, align 4\n%26 = icmp eq i32 %25, 0\nbr i1 %26, label %B10, label %B10\n\nB10:\n%27 = phi i32 [ 1, %B1 ], [ 1, %B3 ], [ 1, %B6 ], [ 1, %B9 ], [ 0, %B8 ], [ 1, %B7 ]\nret i32 %27\n}"}, "define dso_local void @drawHead() {\n%1 = load i64, ptr @WIRED, align 8\n%2 = icmp ne i64 %1, 0\nbr i1 %2, label %3, label %10\n\n3:\n%4 = load double, ptr @SCALE, align 8\n%5 = fdiv fast double 2.000000e-01, %4\n%6 = fdiv fast double %5, 2.000000e+00\n%7 = load double, ptr @SCALE, align 8\n%8 = fdiv fast double 3.000000e-01, %7\n%9 = call i32 @glutWireCylinder(double noundef nofpclass(nan inf) %6, double noundef nofpclass(nan inf) %8, i32 noundef 16, i32 noundef 16)\nbr label %17\n\n10:\n%11 = load double, ptr @SCALE, align 8\n%12 = fdiv fast double 2.000000e-01, %11\n%13 = fdiv fast double %12, 2.000000e+00\n%14 = load double, ptr @SCALE, align 8\n%15 = fdiv fast double 3.000000e-01, %14\n%16 = call i32 @glutSolidCylinder(double noundef nofpclass(nan inf) %13, double noundef nofpclass(nan inf) %15, i32 noundef 16, i32 noundef 16)\nbr label %17\n\n17:\nret void\n}": {"base_truth": "define dso_local void @drawHead() {\nB:\n%0 = load i64, ptr @WIRED, align 8\n%1 = icmp eq i64 %0, 0\n%2 = load double, ptr @SCALE, align 8\n%3 = fdiv fast double 1.000000e-01, %2\n%4 = fdiv fast double 3.000000e-01, %2\nbr i1 %1, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @glutWireCylinder(double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, i32 noundef 16, i32 noundef 16)\nbr label %B3\n\nB2:\n%6 = tail call i32 @glutSolidCylinder(double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, i32 noundef 16, i32 noundef 16)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @drawHead() {\nB:\n%0 = load i64, ptr @WIRED, align 8\n%1 = icmp eq i64 %0, 0\n%2 = load double, ptr @SCALE, align 8\n%3 = fdiv fast double 1.000000e-01, %2\n%4 = fdiv fast double 3.000000e-01, %2\nbr i1 %1, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @glutWireCylinder(double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, i32 noundef 16, i32 noundef 16)\nbr label %B3\n\nB2:\n%6 = tail call i32 @glutSolidCylinder(double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, i32 noundef 16, i32 noundef 16)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @drawHead() {\nB:\n%0 = load i64, ptr @WIRED, align 8\n%1 = icmp eq i64 %0, 0\n%2 = load double, ptr @SCALE, align 8\n%3 = fdiv fast double 5.000000e-02, %2\n%4 = fdiv fast double 3.000000e-01, %2\nbr i1 %1, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @glutWireCylinder(double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, i32 noundef 16, i32 noundef 16)\nbr label %B3\n\nB2:\n%6 = tail call i32 @glutSolidCylinder(double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, i32 noundef 16, i32 noundef 16)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local void @glCompDrawBegin() {\n%1 = alloca [4 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 16, ptr %1)\n%2 = load i32, ptr @GL_VIEWPORT, align 4\n%3 = getelementptr inbounds [4 x i32], ptr %1, i64 0, i64 0\n%4 = call i32 @glGetIntegerv(i32 noundef %2, ptr noundef %3)\n%5 = load i32, ptr @GL_PROJECTION, align 4\n%6 = call i32 @glMatrixMode(i32 noundef %5)\n%7 = call i32 (...) @glPushMatrix()\n%8 = call i32 (...) @glLoadIdentity()\n%9 = getelementptr inbounds [4 x i32], ptr %1, i64 0, i64 2\n%10 = load i32, ptr %9, align 8\n%11 = getelementptr inbounds [4 x i32], ptr %1, i64 0, i64 3\n%12 = load i32, ptr %11, align 4\n%13 = call i32 @glOrtho(i32 noundef 0, i32 noundef %10, i32 noundef 0, i32 noundef %12, i32 noundef -1, i32 noundef 1)\n%14 = load i32, ptr @GL_MODELVIEW, align 4\n%15 = call i32 @glMatrixMode(i32 noundef %14)\n%16 = load i32, ptr @GL_BLEND, align 4\n%17 = call i32 @glEnable(i32 noundef %16)\n%18 = call i32 (...) @glPushMatrix()\n%19 = call i32 (...) @glLoadIdentity()\n%20 = load i32, ptr @GL_DEPTH_TEST, align 4\n%21 = call i32 @glDisable(i32 noundef %20)\ncall void @llvm.lifetime.end.p0(i64 16, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @glCompDrawBegin() {\nB:\n%0 = alloca [4 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %0)\n%1 = load i32, ptr @GL_VIEWPORT, align 4\n%2 = call i32 @glGetIntegerv(i32 noundef %1, ptr noundef nonnull %0)\n%3 = load i32, ptr @GL_PROJECTION, align 4\n%4 = call i32 @glMatrixMode(i32 noundef %3)\n%5 = call i32 (...) @glPushMatrix()\n%6 = call i32 (...) @glLoadIdentity()\n%7 = getelementptr inbounds [4 x i32], ptr %0, i64 0, i64 2\n%8 = load i32, ptr %7, align 8\n%9 = getelementptr inbounds [4 x i32], ptr %0, i64 0, i64 3\n%10 = load i32, ptr %9, align 4\n%11 = call i32 @glOrtho(i32 noundef 0, i32 noundef %8, i32 noundef 0, i32 noundef %10, i32 noundef -1, i32 noundef 1)\n%12 = load i32, ptr @GL_MODELVIEW, align 4\n%13 = call i32 @glMatrixMode(i32 noundef %12)\n%14 = load i32, ptr @GL_BLEND, align 4\n%15 = call i32 @glEnable(i32 noundef %14)\n%16 = call i32 (...) @glPushMatrix()\n%17 = call i32 (...) @glLoadIdentity()\n%18 = load i32, ptr @GL_DEPTH_TEST, align 4\n%19 = call i32 @glDisable(i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @glCompDrawBegin() {\nB:\n%0 = alloca [4 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %0)\n%1 = load i32, ptr @GL_VIEWPORT, align 4\n%2 = call i32 @glGetIntegerv(i32 noundef %1, ptr noundef nonnull %0)\n%3 = load i32, ptr @GL_PROJECTION, align 4\n%4 = call i32 @glMatrixMode(i32 noundef %3)\n%5 = call i32 (...) @glPushMatrix()\n%6 = call i32 (...) @glLoadIdentity()\n%7 = getelementptr inbounds [4 x i32], ptr %0, i64 0, i64 2\n%8 = load i32, ptr %7, align 8\n%9 = getelementptr inbounds [4 x i32], ptr %0, i64 0, i64 3\n%10 = load i32, ptr %9, align 4\n%11 = call i32 @glOrtho(i32 noundef 0, i32 noundef %8, i32 noundef 0, i32 noundef %10, i32 noundef -1, i32 noundef 1)\n%12 = load i32, ptr @GL_MODELVIEW, align 4\n%13 = call i32 @glMatrixMode(i32 noundef %12)\n%14 = load i32, ptr @GL_BLEND, align 4\n%15 = call i32 @glEnable(i32 noundef %14)\n%16 = call i32 (...) @glPushMatrix()\n%17 = call i32 (...) @glLoadIdentity()\n%18 = load i32, ptr @GL_DEPTH_TEST, align 4\n%19 = call i32 @glDisable(i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @glCompDrawBegin() {\nB:\n%0 = alloca [4 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %0)\n%1 = load i32, ptr @GL_VIEWPORT, align 4\n%2 = call i32 @glGetIntegerv(i32 noundef %1, ptr noundef nonnull %0)\n%3 = load i32, ptr @GL_PROJECTION, align 4\n%4 = call i32 @glMatrixMode(i32 noundef %3)\n%5 = call i32 (...) @glPushMatrix()\n%6 = call i32 (...) @glLoadIdentity()\n%7 = getelementptr inbounds [4 x i32], ptr %0, i64 0, i64 2\n%8 = load i32, ptr %7, align 8\n%9 = getelementptr inbounds [4 x i32], ptr %0, i64 0, i64 3\n%10 = load i32, ptr %9, align 4\n%11 = call i32 @glOrtho(i32 noundef 0, i32 noundef %8, i32 noundef 0, i32 noundef %10, i32 noundef -1, i32 noundef 1)\n%12 = load i32, ptr @GL_MODELVIEW, align 4\n%13 = call i32 @glMatrixMode(i32 noundef %12)\n%14 = load i32, ptr @GL_BLEND, align 4\n%15 = call i32 @glEnable(i32 noundef %14)\n%16 = call i32 (...) @glPushMatrix()\n%17 = call i32 (...) @glLoadIdentity()\n%18 = load i32, ptr @GL_DEPTH_TEST, align 4\n%19 = call i32 @glDisable(i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %0)\nret void\n}"}, "define dso_local i32 @type_is_array(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.type ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = load i64, ptr @TYPE_ARRAY, align 8\n%7 = icmp eq i64 %5, %6\n%8 = zext i1 %7 to i32\nret i32 %8\n}": {"base_truth": "define dso_local i32 @type_is_array(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @TYPE_ARRAY, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codellama": "define dso_local i32 @type_is_array(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @TYPE_ARRAY, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codegemma": "define dso_local i32 @type_is_array(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @TYPE_ARRAY, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\nret i32 %4\n}"}, "define dso_local i64 @fl_equal(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\n%5 = alloca i64, align 8\nstore i64 %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\n%6 = load i64, ptr %4, align 8\n%7 = load i64, ptr %5, align 8\n%8 = call i64 @eq_comparable(i64 noundef %6, i64 noundef %7)\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %20\n\n10:\n%11 = load i64, ptr %4, align 8\n%12 = load i64, ptr %5, align 8\n%13 = icmp eq i64 %11, %12\nbr i1 %13, label %14, label %16\n\n14:\n%15 = load i64, ptr @FL_T, align 8\nbr label %18\n\n16:\n%17 = load i64, ptr @FL_F, align 8\nbr label %18\n\n18:\n%19 = phi i64 [ %15, %14 ], [ %17, %16 ]\nstore i64 %19, ptr %3, align 8\nbr label %32\n\n20:\n%21 = load i64, ptr %4, align 8\n%22 = load i64, ptr %5, align 8\n%23 = call i32 @compare_(i64 noundef %21, i64 noundef %22, i32 noundef 1)\n%24 = call i64 @numval(i32 noundef %23)\n%25 = icmp eq i64 %24, 0\nbr i1 %25, label %26, label %28\n\n26:\n%27 = load i64, ptr @FL_T, align 8\nbr label %30\n\n28:\n%29 = load i64, ptr @FL_F, align 8\nbr label %30\n\n30:\n%31 = phi i64 [ %27, %26 ], [ %29, %28 ]\nstore i64 %31, ptr %3, align 8\nbr label %32\n\n32:\n%33 = load i64, ptr %3, align 8\nret i64 %33\n}": {"base_truth": "define dso_local i64 @fl_equal(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @eq_comparable(i64 noundef %0, i64 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = icmp eq i64 %0, %1\nbr label %B3\n\nB2:\n%5 = tail call i32 @compare_(i64 noundef %0, i64 noundef %1, i32 noundef 1)\n%6 = tail call i64 @numval(i32 noundef %5)\n%7 = icmp eq i64 %6, 0\nbr label %B3\n\nB3:\n%8 = phi i1 [ %7, %B2 ], [ %4, %B1 ]\n%9 = load i64, ptr @FL_T, align 8\n%10 = load i64, ptr @FL_F, align 8\n%11 = select i1 %8, i64 %9, i64 %10\nret i64 %11\n}", "codellama": "define dso_local i64 @fl_equal(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @eq_comparable(i64 noundef %0, i64 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = icmp eq i64 %0, %1\n%5 = load i64, ptr @FL_T, align 8\n%6 = load i64, ptr @FL_F, align 8\n%7 = select i1 %4, i64 %5, i64 %6\nbr label %B3\n\nB2:\n%8 = tail call i32 @compare_(i64 noundef %0, i64 noundef %1, i32 noundef 1)\n%9 = tail call i64 @numval(i32 noundef %8)\n%10 = icmp eq i64 %9, 0\n%11 = load i64, ptr @FL_T, align 8\n%12 = load i64, ptr @FL_F, align 8\n%13 = select i1 %10, i64 %11, i64 %12\nbr label %B3\n\nB3:\n%14 = phi i64 [ %7, %B1 ], [ %13, %B2 ]\nret i64 %14\n}", "codegemma": "define dso_local i64 @fl_equal(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @eq_comparable(i64 noundef %0, i64 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = icmp eq i64 %0, %1\n%5 = load i64, ptr @FL_T, align 8\n%6 = load i64, ptr @FL_F, align 8\n%7 = select i1 %4, i64 %5, i64 %6\nbr label %B3\n\nB2:\n%8 = tail call i32 @compare_(i64 noundef %0, i64 noundef %1, i32 noundef 1)\n%9 = tail call i64 @numval(i32 noundef %8)\n%10 = icmp eq i64 %9, 0\n%11 = load i64, ptr @FL_T, align 8\n%12 = load i64, ptr @FL_F, align 8\n%13 = select i1 %10, i64 %11, i64 %12\nbr label %B3\n\nB3:\n%14 = phi i64 [ %7, %B1 ], [ %13, %B2 ]\nret i64 %14\n}"}, "define dso_local i32 @server_socket(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca %struct.sockaddr_in, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%6 = load i32, ptr @AF_INET, align 4\n%7 = load i32, ptr @SOCK_STREAM, align 4\n%8 = call i32 @socket(i32 noundef %6, i32 noundef %7, i32 noundef 0)\nstore i32 %8, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr %5)\n%9 = load i32, ptr %3, align 4\n%10 = icmp slt i32 %9, 0\nbr i1 %10, label %11, label %14\n\n11:\n%12 = call i32 @perror(ptr noundef @.str)\n%13 = call i32 @exit(i32 noundef 1)\nunreachable\n\n14:\n%15 = load i32, ptr @AF_INET, align 4\n%16 = getelementptr inbounds %struct.sockaddr_in, ptr %5, i32 0, i32 2\nstore i32 %15, ptr %16, align 4\n%17 = load i32, ptr @INADDR_ANY, align 4\n%18 = getelementptr inbounds %struct.sockaddr_in, ptr %5, i32 0, i32 1\n%19 = getelementptr inbounds %struct.TYPE_2__, ptr %18, i32 0, i32 0\nstore i32 %17, ptr %19, align 4\n%20 = load i32, ptr %2, align 4\n%21 = call i32 @htons(i32 noundef %20)\n%22 = getelementptr inbounds %struct.sockaddr_in, ptr %5, i32 0, i32 0\nstore i32 %21, ptr %22, align 4\n%23 = load i32, ptr %3, align 4\n%24 = load i32, ptr @SOL_SOCKET, align 4\n%25 = load i32, ptr @SO_REUSEADDR, align 4\n%26 = call i32 @setsockopt(i32 noundef %23, i32 noundef %24, i32 noundef %25, ptr noundef %4, i32 noundef 4)\n%27 = icmp eq i32 %26, -1\nbr i1 %27, label %28, label %30\n\n28:\n%29 = call i32 @perror(ptr noundef @.str.1)\nbr label %30\n\n30:\n%31 = load i32, ptr %3, align 4\n%32 = call i64 @bind(i32 noundef %31, ptr noundef %5, i32 noundef 12)\n%33 = icmp slt i64 %32, 0\nbr i1 %33, label %34, label %37\n\n34:\n%35 = call i32 @perror(ptr noundef @.str.2)\n%36 = call i32 @exit(i32 noundef 1)\nunreachable\n\n37:\n%38 = load i32, ptr %3, align 4\n%39 = call i32 @listen(i32 noundef %38, i32 noundef 1)\n%40 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 12, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %40\n}": {"base_truth": "define dso_local i32 @server_socket(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca %struct.sockaddr_in, align 4\n%3 = load i32, ptr @AF_INET, align 4\n%4 = load i32, ptr @SOCK_STREAM, align 4\n%5 = tail call i32 @socket(i32 noundef %3, i32 noundef %4, i32 noundef 0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 1, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %2)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = tail call i32 @perror(ptr noundef nonnull @.str)\n%8 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%9 = load i32, ptr @AF_INET, align 4\n%10 = getelementptr inbounds %struct.sockaddr_in, ptr %2, i64 0, i32 2\nstore i32 %9, ptr %10, align 4\n%11 = load i32, ptr @INADDR_ANY, align 4\n%12 = getelementptr inbounds %struct.sockaddr_in, ptr %2, i64 0, i32 1\nstore i32 %11, ptr %12, align 4\n%13 = tail call i32 @htons(i32 noundef %0)\nstore i32 %13, ptr %2, align 4\n%14 = load i32, ptr @SOL_SOCKET, align 4\n%15 = load i32, ptr @SO_REUSEADDR, align 4\n%16 = call i32 @setsockopt(i32 noundef %5, i32 noundef %14, i32 noundef %15, ptr noundef nonnull %1, i32 noundef 4)\n%17 = icmp eq i32 %16, -1\nbr i1 %17, label %B3, label %B4\n\nB3:\n%18 = call i32 @perror(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%19 = call i64 @bind(i32 noundef %5, ptr noundef nonnull %2, i32 noundef 12)\n%20 = icmp slt i64 %19, 0\nbr i1 %20, label %B5, label %B6\n\nB5:\n%21 = call i32 @perror(ptr noundef nonnull @.str.2)\n%22 = call i32 @exit(i32 noundef 1)\nunreachable\n\nB6:\n%23 = call i32 @listen(i32 noundef %5, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %5\n}", "codellama": "define dso_local i32 @server_socket(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca %struct.sockaddr_in, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 1, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %2)\n%3 = load i32, ptr @AF_INET, align 4\n%4 = load i32, ptr @SOCK_STREAM, align 4\n%5 = tail call i32 @socket(i32 noundef %3, i32 noundef %4, i32 noundef 0)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = tail call i32 @perror(ptr noundef nonnull @.str)\n%8 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%9 = load i32, ptr @AF_INET, align 4\n%10 = getelementptr inbounds %struct.sockaddr_in, ptr %2, i64 0, i32 2\nstore i32 %9, ptr %10, align 4\n%11 = load i32, ptr @INADDR_ANY, align 4\n%12 = getelementptr inbounds %struct.sockaddr_in, ptr %2, i64 0, i32 1\nstore i32 %11, ptr %12, align 4\n%13 = tail call i32 @htons(i32 noundef %0)\nstore i32 %13, ptr %2, align 4\n%14 = load i32, ptr @SOL_SOCKET, align 4\n%15 = load i32, ptr @SO_REUSEADDR, align 4\n%16 = call i32 @setsockopt(i32 noundef %5, i32 noundef %14, i32 noundef %15, ptr noundef nonnull %1, i32 noundef 4)\n%17 = icmp eq i32 %16, -1\nbr i1 %17, label %B3, label %B4\n\nB3:\n%18 = call i32 @perror(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%19 = call i64 @bind(i32 noundef %5, ptr noundef nonnull %2, i32 noundef 12)\n%20 = icmp slt i64 %19, 0\nbr i1 %20, label %B5, label %B6\n\nB5:\n%21 = call i32 @perror(ptr noundef nonnull @.str.2)\n%22 = call i32 @exit(i32 noundef 1)\nunreachable\n\nB6:\n%23 = call i32 @listen(i32 noundef %5, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %5\n}", "codegemma": "define dso_local i32 @server_socket(i32 noundef %0) {\nB:\n%1 = alloca %struct.sockaddr_in, align 4\n%2 = alloca i32, align 4\n%3 = load i32, ptr @AF_INET, align 4\n%4 = load i32, ptr @SOCK_STREAM, align 4\n%5 = tail call i32 @socket(i32 noundef %3, i32 noundef %4, i32 noundef 0)\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %1)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = tail call i32 @perror(ptr noundef nonnull @.str)\n%8 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%9 = load i32, ptr @AF_INET, align 4\n%10 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 2\nstore i32 %9, ptr %10, align 4\n%11 = load i32, ptr @INADDR_ANY, align 4\n%12 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 1\nstore i32 %11, ptr %12, align 4\n%13 = tail call i32 @htons(i32 noundef %0)\nstore i32 %13, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\nstore i32 1, ptr %2, align 4\n%14 = load i32, ptr @SOL_SOCKET, align 4\n%15 = load i32, ptr @SO_REUSEADDR, align 4\n%16 = call i32 @setsockopt(i32 noundef %5, i32 noundef %14, i32 noundef %15, ptr noundef nonnull %2, i32 noundef 4)\n%17 = icmp eq i32 %16, -1\nbr i1 %17, label %B3, label %B4\n\nB3:\n%18 = call i32 @perror(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%19 = call i64 @bind(i32 noundef %5, ptr noundef nonnull %1, i32 noundef 12)\n%20 = icmp slt i64 %19, 0\nbr i1 %20, label %B5, label %B6\n\nB5:\n%21 = call i32 @perror(ptr noundef nonnull @.str.2)\n%22 = call i32 @exit(i32 noundef 1)\nunreachable\n\nB6:\n%23 = call i32 @listen(i32 noundef %5, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %1)\nret i32 %5\n}"}, "define dso_local void @read_into_matrix(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\nstore i32 0, ptr %7, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %7, align 4\n%12 = load i32, ptr %5, align 4\n%13 = sub nsw i32 %12, 1\n%14 = icmp sle i32 %11, %13\nbr i1 %14, label %16, label %15\n\n15:\nstore i32 2, ptr %8, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nbr label %39\n\n16:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\nstore i32 0, ptr %9, align 4\nbr label %17\n\n17:\n%18 = load i32, ptr %9, align 4\n%19 = load i32, ptr %6, align 4\n%20 = sub nsw i32 %19, 1\n%21 = icmp sle i32 %18, %20\nbr i1 %21, label %23, label %22\n\n22:\nstore i32 5, ptr %8, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\nbr label %35\n\n23:\n%24 = load ptr, ptr %4, align 8\n%25 = load i32, ptr %7, align 4\n%26 = sext i32 %25 to i64\n%27 = getelementptr inbounds [10 x i32], ptr %24, i64 %26\n%28 = load i32, ptr %9, align 4\n%29 = sext i32 %28 to i64\n%30 = getelementptr inbounds [10 x i32], ptr %27, i64 0, i64 %29\n%31 = call i32 @scanf(ptr noundef @.str, ptr noundef %30)\nbr label %32\n\n32:\n%33 = load i32, ptr %9, align 4\n%34 = add nsw i32 %33, 1\nstore i32 %34, ptr %9, align 4\nbr label %17\n\n35:\nbr label %36\n\n36:\n%37 = load i32, ptr %7, align 4\n%38 = add nsw i32 %37, 1\nstore i32 %38, ptr %7, align 4\nbr label %10\n\n39:\nret void\n}": {"base_truth": "define dso_local void @read_into_matrix(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %1, 0\n%4 = icmp sgt i32 %2, 0\n%5 = and i1 %3, %4\nbr i1 %5, label %B1, label %B5\n\nB1:\n%6 = zext i32 %1 to i64\n%7 = zext i32 %2 to i64\nbr label %B2\n\nB2:\n%8 = phi i64 [ 0, %B1 ], [ %14, %B4 ]\nbr label %B3\n\nB3:\n%9 = phi i64 [ 0, %B2 ], [ %12, %B3 ]\n%10 = getelementptr inbounds [10 x i32], ptr %0, i64 %8, i64 %9\n%11 = tail call i32 @scanf(ptr noundef nonnull @.str, ptr noundef %10)\n%12 = add nuw nsw i64 %9, 1\n%13 = icmp eq i64 %12, %7\nbr i1 %13, label %B4, label %B3\n\nB4:\n%14 = add nuw nsw i64 %8, 1\n%15 = icmp eq i64 %14, %6\nbr i1 %15, label %B5, label %B2\n\nB5:\nret void\n}", "codellama": "define dso_local void @read_into_matrix(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %1, 1\n%4 = icmp slt i32 %2, 1\n%5 = or i1 %3, %4\nbr i1 %5, label %B1, label %B2\n\nB1:\nret void\n\nB2:\n%6 = add nsw i32 %1, -1\n%7 = add nsw i32 %2, -1\n%8 = zext i32 %6 to i64\n%9 = zext i32 %7 to i64\nbr label %B4\n\nB3:\n%10 = add nuw nsw i64 %12, 1\n%11 = icmp eq i64 %10, %8\nbr i1 %11, label %B1, label %B4\n\nB4:\n%12 = phi i64 [ 0, %B2 ], [ %10, %B3 ]\n%13 = phi i64 [ 0, %B2 ], [ %14, %B3 ]\n%14 = add nuw nsw i64 %13, 1\n%15 = icmp eq i64 %14, %9\nbr i1 %15, label %B1, label %B3\n\n}", "codegemma": "define dso_local void @read_into_matrix(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %1, 0\n%4 = icmp sgt i32 %2, 0\n%5 = and i1 %3, %4\nbr i1 %5, label %B1, label %B4\n\nB1:\n%6 = add nsw i32 %1, -1\nbr label %B3\n\nB2:\n%7 = add nuw nsw i32 %10, 1\n%8 = icmp eq i32 %7, %6\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = phi i64 [ 0, %B1 ], [ %10, %B2 ]\n%10 = add nuw nsw i64 %9, 1\n%11 = getelementptr inbounds [10 x i32], ptr %0, i64 %10\n%12 = tail call i32 @scanf(ptr noundef nonnull @.str, ptr noundef %11)\n%13 = icmp eq i64 %10, %2\nbr i1 %13, label %B2, label %B1\n\nB4:\nret void\n}"}, "define dso_local i32 @solcon_append_dobldobl_solution_string(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca [2 x i32], align 4\n%8 = alloca ptr, align 8\n%9 = alloca i64, align 8\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\n%12 = alloca ptr, align 8\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%13 = load i32, ptr %5, align 4\n%14 = zext i32 %13 to i64\n%15 = call ptr @llvm.stacksave()\nstore ptr %15, ptr %8, align 8\n%16 = alloca i32, i64 %14, align 16\nstore i64 %14, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %12)\n%17 = load i32, ptr %4, align 4\n%18 = getelementptr inbounds [2 x i32], ptr %7, i64 0, i64 0\nstore i32 %17, ptr %18, align 4\n%19 = load i32, ptr %5, align 4\n%20 = getelementptr inbounds [2 x i32], ptr %7, i64 0, i64 1\nstore i32 %19, ptr %20, align 4\nstore i32 0, ptr %11, align 4\nbr label %21\n\n21:\n%22 = load i32, ptr %11, align 4\n%23 = load i32, ptr %5, align 4\n%24 = icmp slt i32 %22, %23\nbr i1 %24, label %25, label %38\n\n25:\n%26 = load ptr, ptr %6, align 8\n%27 = load i32, ptr %11, align 4\n%28 = sext i32 %27 to i64\n%29 = getelementptr inbounds i8, ptr %26, i64 %28\n%30 = load i8, ptr %29, align 1\n%31 = sext i8 %30 to i32\n%32 = load i32, ptr %11, align 4\n%33 = sext i32 %32 to i64\n%34 = getelementptr inbounds i32, ptr %16, i64 %33\nstore i32 %31, ptr %34, align 4\nbr label %35\n\n35:\n%36 = load i32, ptr %11, align 4\n%37 = add nsw i32 %36, 1\nstore i32 %37, ptr %11, align 4\nbr label %21\n\n38:\n%39 = getelementptr inbounds [2 x i32], ptr %7, i64 0, i64 0\n%40 = load ptr, ptr %12, align 8\n%41 = call i32 @_ada_use_c2phc(i32 noundef 378, ptr noundef %39, ptr noundef %16, ptr noundef %40)\nstore i32 %41, ptr %10, align 4\n%42 = load i32, ptr %10, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %12)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\n%43 = load ptr, ptr %8, align 8\ncall void @llvm.stackrestore(ptr %43)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret i32 %42\n}": {"base_truth": "define dso_local i32 @solcon_append_dobldobl_solution_string(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = alloca [2 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\n%4 = zext i32 %1 to i64\n%5 = tail call ptr @llvm.stacksave()\n%6 = alloca i32, i64 %4, align 16\nstore i32 %0, ptr %3, align 4\n%7 = getelementptr inbounds [2 x i32], ptr %3, i64 0, i64 1\nstore i32 %1, ptr %7, align 4\n%8 = icmp sgt i32 %1, 0\nbr i1 %8, label %B1, label %B7\n\nB1:\n%9 = icmp ult i32 %1, 32\nbr i1 %9, label %B5, label %B2\n\nB2:\n%10 = and i64 %4, 4294967264\nbr label %B3\n\nB3:\n%11 = phi i64 [ 0, %B2 ], [ %28, %B3 ]\n%12 = getelementptr inbounds i8, ptr %2, i64 %11\n%13 = load <8 x i8>, ptr %12, align 1\n%14 = getelementptr inbounds i8, ptr %12, i64 8\n%15 = load <8 x i8>, ptr %14, align 1\n%16 = getelementptr inbounds i8, ptr %12, i64 16\n%17 = load <8 x i8>, ptr %16, align 1\n%18 = getelementptr inbounds i8, ptr %12, i64 24\n%19 = load <8 x i8>, ptr %18, align 1\n%20 = sext <8 x i8> %13 to <8 x i32>\n%21 = sext <8 x i8> %15 to <8 x i32>\n%22 = sext <8 x i8> %17 to <8 x i32>\n%23 = sext <8 x i8> %19 to <8 x i32>\n%24 = getelementptr inbounds i32, ptr %6, i64 %11\nstore <8 x i32> %20, ptr %24, align 16\n%25 = getelementptr inbounds i32, ptr %24, i64 8\nstore <8 x i32> %21, ptr %25, align 16\n%26 = getelementptr inbounds i32, ptr %24, i64 16\nstore <8 x i32> %22, ptr %26, align 16\n%27 = getelementptr inbounds i32, ptr %24, i64 24\nstore <8 x i32> %23, ptr %27, align 16\n%28 = add nuw i64 %11, 32\n%29 = icmp eq i64 %28, %10\nbr i1 %29, label %B4, label %B3\n\nB4:\n%30 = icmp eq i64 %10, %4\nbr i1 %30, label %B7, label %B5\n\nB5:\n%31 = phi i64 [ 0, %B1 ], [ %10, %B4 ]\nbr label %B6\n\nB6:\n%32 = phi i64 [ %37, %B6 ], [ %31, %B5 ]\n%33 = getelementptr inbounds i8, ptr %2, i64 %32\n%34 = load i8, ptr %33, align 1\n%35 = sext i8 %34 to i32\n%36 = getelementptr inbounds i32, ptr %6, i64 %32\nstore i32 %35, ptr %36, align 4\n%37 = add nuw nsw i64 %32, 1\n%38 = icmp eq i64 %37, %4\nbr i1 %38, label %B7, label %B6\n\nB7:\n%39 = call i32 @_ada_use_c2phc(i32 noundef 378, ptr noundef nonnull %3, ptr noundef nonnull %6, ptr noundef undef)\ncall void @llvm.stackrestore(ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %39\n}", "codellama": "define dso_local i32 @solcon_append_dobldobl_solution_string(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = alloca [2 x i32], align 4\n%4 = zext i32 %1 to i64\n%5 = tail call ptr @llvm.stacksave()\n%6 = alloca i32, i64 %4, align 16\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\nstore i32 %0, ptr %3, align 4\n%7 = getelementptr inbounds [2 x i32], ptr %3, i64 0, i64 1\nstore i32 %1, ptr %7, align 4\n%8 = icmp sgt i32 %1, 0\nbr i1 %8, label %B1, label %B7\n\nB1:\n%9 = icmp ult i32 %1, 32\nbr i1 %9, label %B5, label %B2\n\nB2:\n%10 = and i64 %4, 4294967264\nbr label %B3\n\nB3:\n%11 = phi i64 [ 0, %B2 ], [ %27, %B3 ]\n%12 = getelementptr inbounds i8, ptr %2, i64 %11\n%13 = load <8 x i8>, ptr %12, align 1\n%14 = getelementptr inbounds i8, ptr %12, i64 8\n%15 = load <8 x i8>, ptr %14, align 1\n%16 = getelementptr inbounds i8, ptr %12, i64 16\n%17 = load <8 x i8>, ptr %16, align 1\n%18 = getelementptr inbounds i8, ptr %12, i64 24\n%19 = load <8 x i8>, ptr %18, align 1\n%20 = sext <8 x i8> %13 to <8 x i32>\n%21 = sext <8 x i8> %15 to <8 x i32>\n%22 = sext <8 x i8> %17 to <8 x i32>\n%23 = sext <8 x i8> %19 to <8 x i32>\n%24 = getelementptr inbounds i32, ptr %6, i64 %11\nstore <8 x i32> %20, ptr %24, align 16\n%25 = getelementptr inbounds i32, ptr %24, i64 8\nstore <8 x i32> %21, ptr %25, align 16\n%26 = getelementptr inbounds i32, ptr %24, i64 16\nstore <8 x i32> %22, ptr %26, align 16\n%27 = add nuw i64 %11, 32\n%28 = icmp eq i64 %27, %10\nbr i1 %28, label %B4, label %B3\n\nB4:\n%29 = icmp eq i64 %10, %4\nbr i1 %29, label %B7, label %B5\n\nB5:\n%30 = phi i64 [ 0, %B1 ], [ %10, %B4 ]\nbr label %B6\n\nB6:\n%31 = phi i64 [ %37, %B6 ], [ %30, %B5 ]\n%32 = getelementptr inbounds i8, ptr %2, i64 %31\n%33 = load i8, ptr %32, align 1\n%34 = sext i8 %33 to i32\n%35 = getelementptr inbounds i32, ptr %6, i64 %31\nstore i32 %34, ptr %35, align 4\n%36 = add nuw nsw i64 %31, 1\n%37 = icmp eq i64 %36, %4\nbr i1 %37, label %B7, label %B6\n\nB7:\n%38 = call i32 @_ada_use_c2phc(i32 noundef 378, ptr noundef nonnull %3, ptr noundef nonnull %6, ptr noundef undef)\ncall void @llvm.stackrestore(ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret i32 %38\n}", "codegemma": "define dso_local i32 @solcon_append_dobldobl_solution_string(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = alloca [2 x i32], align 4\n%4 = zext i32 %1 to i64\n%5 = alloca i32, i64 %4, align 16\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\nstore i32 %0, ptr %3, align 4\n%6 = getelementptr inbounds [2 x i32], ptr %3, i64 0, i64 1\nstore i32 %1, ptr %6, align 4\n%7 = icmp sgt i32 %1, 0\nbr i1 %7, label %B1, label %B3\n\nB1:\n%8 = phi i64 [ %12, %B1 ], [ 0, %B ]\n%9 = getelementptr inbounds i8, ptr %2, i64 %8\n%10 = load i8, ptr %9, align 1\n%11 = sext i8 %10 to i32\n%12 = add nuw nsw i64 %8, 1\n%13 = getelementptr inbounds i32, ptr %5, i64 %8\nstore i32 %11, ptr %13, align 4\n%14 = icmp eq i64 %12, %4\nbr i1 %14, label %B2, label %B1\n\nB2:\n%15 = call i32 @_ada_use_c2phc(i32 noundef 378, ptr noundef nonnull %3, ptr noundef nonnull %5, ptr noundef null)\nbr label %B3\n\nB3:\n%16 = phi i32 [ %15, %B2 ], [ 0, %B ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %16\n}"}, "define dso_local void @test_app_init() {\n%1 = load i32, ptr @OGS_LOG_ERROR, align 4\n%2 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_sctp_domain, ptr noundef @.str, i32 noundef %1)\n%3 = load i32, ptr @OGS_LOG_ERROR, align 4\n%4 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_s1ap_domain, ptr noundef @.str.1, i32 noundef %3)\n%5 = load i32, ptr @OGS_LOG_ERROR, align 4\n%6 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_ngap_domain, ptr noundef @.str.2, i32 noundef %5)\n%7 = load i32, ptr @OGS_LOG_ERROR, align 4\n%8 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_diam_domain, ptr noundef @.str.3, i32 noundef %7)\n%9 = load i32, ptr @OGS_LOG_ERROR, align 4\n%10 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_dbi_domain, ptr noundef @.str.4, i32 noundef %9)\n%11 = load i32, ptr @OGS_LOG_ERROR, align 4\n%12 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_nas_domain, ptr noundef @.str.5, i32 noundef %11)\n%13 = load i32, ptr @OGS_LOG_ERROR, align 4\n%14 = call i32 @ogs_log_install_domain(ptr noundef @__ogs_gtp_domain, ptr noundef @.str.6, i32 noundef %13)\n%15 = call ptr (...) @ogs_app()\n%16 = getelementptr inbounds %struct.TYPE_4__, ptr %15, i32 0, i32 1\n%17 = getelementptr inbounds %struct.TYPE_3__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = call i32 @ogs_sctp_init(i32 noundef %18)\n%20 = call ptr (...) @ogs_app()\n%21 = getelementptr inbounds %struct.TYPE_4__, ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = call i64 @ogs_dbi_init(i32 noundef %22)\n%24 = load i64, ptr @OGS_OK, align 8\n%25 = icmp eq i64 %23, %24\n%26 = zext i1 %25 to i32\n%27 = call i32 @ogs_assert(i32 noundef %26)\nret void\n}": {"base_truth": "define dso_local void @test_app_init() {\nB:\n%0 = load i32, ptr @OGS_LOG_ERROR, align 4\n%1 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_sctp_domain, ptr noundef nonnull @.str, i32 noundef %0)\n%2 = load i32, ptr @OGS_LOG_ERROR, align 4\n%3 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_s1ap_domain, ptr noundef nonnull @.str.1, i32 noundef %2)\n%4 = load i32, ptr @OGS_LOG_ERROR, align 4\n%5 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_ngap_domain, ptr noundef nonnull @.str.2, i32 noundef %4)\n%6 = load i32, ptr @OGS_LOG_ERROR, align 4\n%7 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_diam_domain, ptr noundef nonnull @.str.3, i32 noundef %6)\n%8 = load i32, ptr @OGS_LOG_ERROR, align 4\n%9 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_dbi_domain, ptr noundef nonnull @.str.4, i32 noundef %8)\n%10 = load i32, ptr @OGS_LOG_ERROR, align 4\n%11 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_nas_domain, ptr noundef nonnull @.str.5, i32 noundef %10)\n%12 = load i32, ptr @OGS_LOG_ERROR, align 4\n%13 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_gtp_domain, ptr noundef nonnull @.str.6, i32 noundef %12)\n%14 = tail call ptr (...) @ogs_app()\n%15 = getelementptr inbounds %struct.TYPE_4__, ptr %14, i64 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = tail call i32 @ogs_sctp_init(i32 noundef %16)\n%18 = tail call ptr (...) @ogs_app()\n%19 = load i32, ptr %18, align 4\n%20 = tail call i64 @ogs_dbi_init(i32 noundef %19)\n%21 = load i64, ptr @OGS_OK, align 8\n%22 = icmp eq i64 %20, %21\n%23 = zext i1 %22 to i32\n%24 = tail call i32 @ogs_assert(i32 noundef %23)\nret void\n}", "codellama": "define dso_local void @test_app_init() {\nB:\n%0 = load i32, ptr @OGS_LOG_ERROR, align 4\n%1 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_sctp_domain, ptr noundef nonnull @.str, i32 noundef %0)\n%2 = load i32, ptr @OGS_LOG_ERROR, align 4\n%3 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_s1ap_domain, ptr noundef nonnull @.str.1, i32 noundef %2)\n%4 = load i32, ptr @OGS_LOG_ERROR, align 4\n%5 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_ngap_domain, ptr noundef nonnull @.str.2, i32 noundef %4)\n%6 = load i32, ptr @OGS_LOG_ERROR, align 4\n%7 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_diam_domain, ptr noundef nonnull @.str.3, i32 noundef %6)\n%8 = load i32, ptr @OGS_LOG_ERROR, align 4\n%9 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_dbi_domain, ptr noundef nonnull @.str.4, i32 noundef %8)\n%10 = load i32, ptr @OGS_LOG_ERROR, align 4\n%11 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_nas_domain, ptr noundef nonnull @.str.5, i32 noundef %10)\n%12 = load i32, ptr @OGS_LOG_ERROR, align 4\n%13 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_gtp_domain, ptr noundef nonnull @.str.6, i32 noundef %12)\n%14 = tail call ptr (...) @ogs_app()\n%15 = getelementptr inbounds %struct.TYPE_4__, ptr %14, i64 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = tail call i32 @ogs_sctp_init(i32 noundef %16)\n%18 = tail call ptr (...) @ogs_app()\n%19 = load i32, ptr %18, align 4\n%20 = tail call i64 @ogs_dbi_init(i32 noundef %19)\n%21 = load i64, ptr @OGS_OK, align 8\n%22 = icmp eq i64 %20, %21\n%23 = zext i1 %22 to i32\n%24 = tail call i32 @ogs_assert(i32 noundef %23)\nret void\n}", "codegemma": "define dso_local void @test_app_init() {\nB:\n%0 = load i32, ptr @OGS_LOG_ERROR, align 4\n%1 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_sctp_domain, ptr noundef nonnull @.str, i32 noundef %0)\n%2 = load i32, ptr @OGS_LOG_ERROR, align 4\n%3 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_s1ap_domain, ptr noundef nonnull @.str.1, i32 noundef %2)\n%4 = load i32, ptr @OGS_LOG_ERROR, align 4\n%5 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_ngap_domain, ptr noundef nonnull @.str.2, i32 noundef %4)\n%6 = load i32, ptr @OGS_LOG_ERROR, align 4\n%7 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_diam_domain, ptr noundef nonnull @.str.3, i32 noundef %6)\n%8 = load i32, ptr @OGS_LOG_ERROR, align 4\n%9 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_dbi_domain, ptr noundef nonnull @.str.4, i32 noundef %8)\n%10 = load i32, ptr @OGS_LOG_ERROR, align 4\n%11 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_nas_domain, ptr noundef nonnull @.str.5, i32 noundef %10)\n%12 = load i32, ptr @OGS_LOG_ERROR, align 4\n%13 = tail call i32 @ogs_log_install_domain(ptr noundef nonnull @__ogs_gtp_domain, ptr noundef nonnull @.str.6, i32 noundef %12)\n%14 = tail call ptr (...) @ogs_app()\n%15 = getelementptr inbounds %struct.TYPE_4__, ptr %14, i64 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = tail call i32 @ogs_sctp_init(i32 noundef %16)\n%18 = tail call ptr (...) @ogs_app()\n%19 = load i32, ptr %18, align 4\n%20 = tail call i64 @ogs_dbi_init(i32 noundef %19)\n%21 = load i64, ptr @OGS_OK, align 8\n%22 = icmp eq i64 %20, %21\n%23 = zext i1 %22 to i32\n%24 = tail call i32 @ogs_assert(i32 noundef %23)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca %struct.sigaction, align 8\n%3 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 24, ptr %2)\n%4 = load i32, ptr @handler, align 4\n%5 = getelementptr inbounds %struct.sigaction, ptr %2, i32 0, i32 2\nstore i32 %4, ptr %5, align 8\n%6 = getelementptr inbounds %struct.sigaction, ptr %2, i32 0, i32 1\nstore i64 0, ptr %6, align 8\n%7 = getelementptr inbounds %struct.sigaction, ptr %2, i32 0, i32 0\n%8 = call i32 @sigemptyset(ptr noundef %7)\n%9 = getelementptr inbounds %struct.sigaction, ptr %2, i32 0, i32 0\n%10 = load i32, ptr @SIGSTOP, align 4\n%11 = call i32 @sigaddset(ptr noundef %9, i32 noundef %10)\n%12 = load i32, ptr @SIGHUP, align 4\n%13 = call i32 @sigaction(i32 noundef %12, ptr noundef %2, i32 noundef 0)\n%14 = icmp eq i32 %13, -1\nbr i1 %14, label %15, label %17\n\n15:\n%16 = call i32 @printf(ptr noundef @.str)\nstore i32 1, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %19\n\n17:\n%18 = call i32 @printf(ptr noundef @.str.1)\nstore i32 0, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %19\n\n19:\ncall void @llvm.lifetime.end.p0(i64 24, ptr %2)\n%20 = load i32, ptr %1, align 4\nret i32 %20\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca %struct.sigaction, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %0)\n%1 = load i32, ptr @handler, align 4\n%2 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 2\nstore i32 %1, ptr %2, align 8\n%3 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 1\nstore i64 0, ptr %3, align 8\n%4 = call i32 @sigemptyset(ptr noundef nonnull %0)\n%5 = load i32, ptr @SIGSTOP, align 4\n%6 = call i32 @sigaddset(ptr noundef nonnull %0, i32 noundef %5)\n%7 = load i32, ptr @SIGHUP, align 4\n%8 = call i32 @sigaction(i32 noundef %7, ptr noundef nonnull %0, i32 noundef 0)\n%9 = icmp eq i32 %8, -1\n%10 = select i1 %9, ptr @.str, ptr @.str.1\n%11 = zext i1 %9 to i32\n%12 = call i32 @printf(ptr noundef nonnull %10)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %0)\nret i32 %11\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca %struct.sigaction, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %0)\n%1 = load i32, ptr @handler, align 4\n%2 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 2\nstore i32 %1, ptr %2, align 8\n%3 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 1\nstore i64 0, ptr %3, align 8\n%4 = call i32 @sigemptyset(ptr noundef nonnull %0)\n%5 = load i32, ptr @SIGSTOP, align 4\n%6 = call i32 @sigaddset(ptr noundef nonnull %0, i32 noundef %5)\n%7 = load i32, ptr @SIGHUP, align 4\n%8 = call i32 @sigaction(i32 noundef %7, ptr noundef nonnull %0, i32 noundef 0)\n%9 = icmp eq i32 %8, -1\n%10 = select i1 %9, ptr @.str, ptr @.str.1\n%11 = zext i1 %9 to i32\n%12 = call i32 @printf(ptr noundef nonnull %10)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %0)\nret i32 %11\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca %struct.sigaction, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %0)\n%1 = load i32, ptr @handler, align 4\n%2 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 2\nstore i32 %1, ptr %2, align 8\n%3 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 1\nstore i64 0, ptr %3, align 8\n%4 = call i32 @sigemptyset(ptr noundef nonnull %0)\n%5 = load i32, ptr @SIGSTOP, align 4\n%6 = call i32 @sigaddset(ptr noundef nonnull %0, i32 noundef %5)\n%7 = load i32, ptr @SIGHUP, align 4\n%8 = call i32 @sigaction(i32 noundef %7, ptr noundef nonnull %0, i32 noundef 0)\n%9 = icmp eq i32 %8, -1\n%10 = select i1 %9, ptr @.str, ptr @.str.1\n%11 = call i32 @printf(ptr noundef nonnull %10)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %0)\nret i32 1\n}"}, "define dso_local i64 @get_attavgwidth(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i64, align 8\n%8 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\nbr i1 true, label %9, label %18\n\n9:\n%10 = load i32, ptr %4, align 4\n%11 = load i32, ptr %5, align 4\n%12 = call i64 @get_attavgwidth_hook(i32 noundef %10, i32 noundef %11)\nstore i64 %12, ptr %7, align 8\n%13 = load i64, ptr %7, align 8\n%14 = icmp sgt i64 %13, 0\nbr i1 %14, label %15, label %17\n\n15:\n%16 = load i64, ptr %7, align 8\nstore i64 %16, ptr %3, align 8\nstore i32 1, ptr %8, align 4\nbr label %43\n\n17:\nbr label %18\n\n18:\n%19 = load i32, ptr @STATRELATTINH, align 4\n%20 = load i32, ptr %4, align 4\n%21 = call i32 @ObjectIdGetDatum(i32 noundef %20)\n%22 = load i32, ptr %5, align 4\n%23 = call i32 @Int16GetDatum(i32 noundef %22)\n%24 = call i32 @BoolGetDatum(i32 noundef 0)\n%25 = call i32 @SearchSysCache3(i32 noundef %19, i32 noundef %21, i32 noundef %23, i32 noundef %24)\nstore i32 %25, ptr %6, align 4\n%26 = load i32, ptr %6, align 4\n%27 = call i64 @HeapTupleIsValid(i32 noundef %26)\n%28 = icmp ne i64 %27, 0\nbr i1 %28, label %29, label %42\n\n29:\n%30 = load i32, ptr %6, align 4\n%31 = call i64 @GETSTRUCT(i32 noundef %30)\n%32 = inttoptr i64 %31 to ptr\n%33 = getelementptr inbounds %struct.TYPE_2__, ptr %32, i32 0, i32 0\n%34 = load i64, ptr %33, align 8\nstore i64 %34, ptr %7, align 8\n%35 = load i32, ptr %6, align 4\n%36 = call i32 @ReleaseSysCache(i32 noundef %35)\n%37 = load i64, ptr %7, align 8\n%38 = icmp sgt i64 %37, 0\nbr i1 %38, label %39, label %41\n\n39:\n%40 = load i64, ptr %7, align 8\nstore i64 %40, ptr %3, align 8\nstore i32 1, ptr %8, align 4\nbr label %43\n\n41:\nbr label %42\n\n42:\nstore i64 0, ptr %3, align 8\nstore i32 1, ptr %8, align 4\nbr label %43\n\n43:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%44 = load i64, ptr %3, align 8\nret i64 %44\n}": {"base_truth": "define dso_local i64 @get_attavgwidth(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i64 @get_attavgwidth_hook(i32 noundef %0, i32 noundef %1)\n%3 = icmp sgt i64 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = load i32, ptr @STATRELATTINH, align 4\n%5 = tail call i32 @ObjectIdGetDatum(i32 noundef %0)\n%6 = tail call i32 @Int16GetDatum(i32 noundef %1)\n%7 = tail call i32 @BoolGetDatum(i32 noundef 0)\n%8 = tail call i32 @SearchSysCache3(i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)\n%9 = tail call i64 @HeapTupleIsValid(i32 noundef %8)\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = tail call i64 @GETSTRUCT(i32 noundef %8)\n%12 = inttoptr i64 %11 to ptr\n%13 = load i64, ptr %12, align 8\n%14 = tail call i32 @ReleaseSysCache(i32 noundef %8)\n%15 = icmp sgt i64 %13, 0\nbr i1 %15, label %B4, label %B3\n\nB3:\nbr label %B4\n\nB4:\n%16 = phi i64 [ 0, %B3 ], [ %2, %B ], [ %13, %B2 ]\nret i64 %16\n}", "codellama": "define dso_local i64 @get_attavgwidth(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i64 @get_attavgwidth_hook(i32 noundef %0, i32 noundef %1)\n%3 = icmp sgt i64 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = load i32, ptr @STATRELATTINH, align 4\n%5 = tail call i32 @ObjectIdGetDatum(i32 noundef %0)\n%6 = tail call i32 @Int16GetDatum(i32 noundef %1)\n%7 = tail call i32 @BoolGetDatum(i32 noundef 0)\n%8 = tail call i32 @SearchSysCache3(i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)\n%9 = tail call i64 @HeapTupleIsValid(i32 noundef %8)\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = tail call i64 @GETSTRUCT(i32 noundef %8)\n%12 = inttoptr i64 %11 to ptr\n%13 = load i64, ptr %12, align 8\n%14 = tail call i32 @ReleaseSysCache(i32 noundef %8)\n%15 = icmp sgt i64 %13, 0\nbr i1 %15, label %B3, label %B3\n\nB3:\n%16 = phi i64 [ %2, %B ], [ 0, %B1 ], [ %13, %B2 ]\nret i64 %16\n}", "codegemma": "define dso_local i64 @get_attavgwidth(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i64 @get_attavgwidth_hook(i32 noundef %0, i32 noundef %1)\n%3 = icmp sgt i64 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = load i32, ptr @STATRELATTINH, align 4\n%5 = tail call i32 @ObjectIdGetDatum(i32 noundef %0)\n%6 = tail call i32 @Int16GetDatum(i32 noundef %1)\n%7 = tail call i32 @BoolGetDatum(i32 noundef 0)\n%8 = tail call i32 @SearchSysCache3(i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)\n%9 = tail call i64 @HeapTupleIsValid(i32 noundef %8)\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = tail call i64 @GETSTRUCT(i32 noundef %8)\n%12 = inttoptr i64 %11 to ptr\n%13 = load i64, ptr %12, align 8\n%14 = tail call i32 @ReleaseSysCache(i32 noundef %8)\n%15 = icmp sgt i64 %13, 0\nbr i1 %15, label %B3, label %B4\n\nB3:\n%16 = phi i64 [ %2, %B ], [ %13, %B2 ], [ 0, %B1 ]\nret i64 %16\n\nB4:\nbr label %B3\n}"}, "define dso_local i32 @putact_(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @putact_0_(i32 noundef 0, ptr noundef %3)\nret i32 %4\n}": {"base_truth": "define dso_local i32 @putact_(ptr noundef %0) {\nB:\n%1 = tail call i32 @putact_0_(i32 noundef 0, ptr noundef %0)\nret i32 %1\n}", "codellama": "define dso_local i32 @putact_(ptr noundef %0) {\nB:\n%1 = tail call i32 @putact_0_(i32 noundef 0, ptr noundef %0)\nret i32 %1\n}", "codegemma": "define dso_local i32 @putact_(ptr noundef %0) {\nB:\n%1 = tail call i32 @putact_0_(i32 noundef 0, ptr noundef %0)\nret i32 %1\n}"}, "define dso_local void @rdp_send_client_window_status(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%5 = load i32, ptr @rdp_send_client_window_status.current_status, align 4\n%6 = load i32, ptr %2, align 4\n%7 = icmp eq i32 %5, %6\nbr i1 %7, label %8, label %9\n\n8:\nstore i32 1, ptr %4, align 4\nbr label %31\n\n9:\n%10 = call i32 @rdp_init_data(i32 noundef 12)\nstore i32 %10, ptr %3, align 4\n%11 = load i32, ptr %3, align 4\n%12 = load i32, ptr %2, align 4\n%13 = call i32 @out_uint32_le(i32 noundef %11, i32 noundef %12)\n%14 = load i32, ptr %2, align 4\nswitch i32 %14, label %24 [\ni32 0, label %24\ni32 1, label %15\n]\n\n15:\n%16 = load i32, ptr %3, align 4\n%17 = call i32 @out_uint32_le(i32 noundef %16, i32 noundef 0)\n%18 = load i32, ptr %3, align 4\n%19 = load i32, ptr @g_width, align 4\n%20 = call i32 @out_uint16_le(i32 noundef %18, i32 noundef %19)\n%21 = load i32, ptr %3, align 4\n%22 = load i32, ptr @g_height, align 4\n%23 = call i32 @out_uint16_le(i32 noundef %21, i32 noundef %22)\nbr label %24\n\n24:\n%25 = load i32, ptr %3, align 4\n%26 = call i32 @s_mark_end(i32 noundef %25)\n%27 = load i32, ptr %3, align 4\n%28 = load i32, ptr @RDP_DATA_PDU_CLIENT_WINDOW_STATUS, align 4\n%29 = call i32 @rdp_send_data(i32 noundef %27, i32 noundef %28)\n%30 = load i32, ptr %2, align 4\nstore i32 %30, ptr @rdp_send_client_window_status.current_status, align 4\nstore i32 0, ptr %4, align 4\nbr label %31\n\n31:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\n%32 = load i32, ptr %4, align 4\nswitch i32 %32, label %34 [\ni32 0, label %33\ni32 1, label %33\n]\n\n33:\nret void\n\n34:\nunreachable\n}": {"base_truth": "define dso_local void @rdp_send_client_window_status(i32 noundef %0) {\nB:\n%1 = load i32, ptr @rdp_send_client_window_status.current_status, align 4\n%2 = icmp eq i32 %1, %0\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = tail call i32 @rdp_init_data(i32 noundef 12)\n%4 = tail call i32 @out_uint32_le(i32 noundef %3, i32 noundef %0)\n%5 = icmp eq i32 %0, 1\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @out_uint32_le(i32 noundef %3, i32 noundef 0)\n%7 = load i32, ptr @g_width, align 4\n%8 = tail call i32 @out_uint16_le(i32 noundef %3, i32 noundef %7)\n%9 = load i32, ptr @g_height, align 4\n%10 = tail call i32 @out_uint16_le(i32 noundef %3, i32 noundef %9)\nbr label %B3\n\nB3:\n%11 = tail call i32 @s_mark_end(i32 noundef %3)\n%12 = load i32, ptr @RDP_DATA_PDU_CLIENT_WINDOW_STATUS, align 4\n%13 = tail call i32 @rdp_send_data(i32 noundef %3, i32 noundef %12)\nstore i32 %0, ptr @rdp_send_client_window_status.current_status, align 4\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @rdp_send_client_window_status(i32 noundef %0) {\nB:\n%1 = load i32, ptr @rdp_send_client_window_status.current_status, align 4\n%2 = icmp eq i32 %1, %0\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = tail call i32 @rdp_init_data(i32 noundef 12)\n%4 = tail call i32 @out_uint32_le(i32 noundef %3, i32 noundef %0)\nswitch i32 %0, label %B3 [\ni32 1, label %B2\n]\n\nB2:\n%5 = tail call i32 @out_uint32_le(i32 noundef %3, i32 noundef 0)\n%6 = load i32, ptr @g_width, align 4\n%7 = tail call i32 @out_uint16_le(i32 noundef %3, i32 noundef %6)\n%8 = load i32, ptr @g_height, align 4\n%9 = tail call i32 @out_uint16_le(i32 noundef %3, i32 noundef %8)\nbr label %B3\n\nB3:\n%10 = tail call i32 @s_mark_end(i32 noundef %3)\n%11 = load i32, ptr @RDP_DATA_PDU_CLIENT_WINDOW_STATUS, align 4\n%12 = tail call i32 @rdp_send_data(i32 noundef %3, i32 noundef %11)\nstore i32 %0, ptr @rdp_send_client_window_status.current_status, align 4\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @rdp_send_client_window_status(i32 noundef %0) {\nB:\n%1 = load i32, ptr @rdp_send_client_window_status.current_status, align 4\n%2 = icmp eq i32 %1, %0\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = tail call i32 @rdp_init_data(i32 noundef 12)\n%4 = tail call i32 @out_uint32_le(i32 noundef %3, i32 noundef %0)\n%5 = icmp eq i32 %0, 1\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @out_uint32_le(i32 noundef %3, i32 noundef 0)\n%7 = load i32, ptr @g_width, align 4\n%8 = tail call i32 @out_uint16_le(i32 noundef %3, i32 noundef %7)\n%9 = load i32, ptr @g_height, align 4\n%10 = tail call i32 @out_uint16_le(i32 noundef %3, i32 noundef %9)\nbr label %B3\n\nB3:\n%11 = tail call i32 @s_mark_end(i32 noundef %3)\n%12 = load i32, ptr @RDP_DATA_PDU_CLIENT_WINDOW_STATUS, align 4\n%13 = tail call i32 @rdp_send_data(i32 noundef %3, i32 noundef %12)\nstore i32 %0, ptr @rdp_send_client_window_status.current_status, align 4\nbr label %B4\n\nB4:\nret void\n}"}, "define internal i32 @read_cal_int_tables(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @read_pwr_cal_values(ptr noundef %6)\nstore i32 %7, ptr %4, align 4\n%8 = load i32, ptr %4, align 4\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %10, label %12\n\n10:\n%11 = load i32, ptr %4, align 4\nstore i32 %11, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %27\n\n12:\n%13 = load ptr, ptr %3, align 8\n%14 = call i32 @read_pwr_int_values(ptr noundef %13)\nstore i32 %14, ptr %4, align 4\n%15 = load i32, ptr %4, align 4\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %17, label %19\n\n17:\n%18 = load i32, ptr %4, align 4\nstore i32 %18, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %27\n\n19:\n%20 = load ptr, ptr %3, align 8\n%21 = call i32 @read_ofdm_cal_values(ptr noundef %20)\nstore i32 %21, ptr %4, align 4\n%22 = load i32, ptr %4, align 4\n%23 = icmp ne i32 %22, 0\nbr i1 %23, label %24, label %26\n\n24:\n%25 = load i32, ptr %4, align 4\nstore i32 %25, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %27\n\n26:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %27\n\n27:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%28 = load i32, ptr %2, align 4\nret i32 %28\n}": {"base_truth": "define internal i32 @read_cal_int_tables(ptr noundef %0) {\nB:\n%1 = tail call i32 @read_pwr_cal_values(ptr noundef %0)\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = tail call i32 @read_pwr_int_values(ptr noundef %0)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @read_ofdm_cal_values(ptr noundef %0)\nbr label %B3\n\nB3:\n%6 = phi i32 [ %1, %B ], [ %3, %B1 ], [ %5, %B2 ]\nret i32 %6\n}", "codellama": "define internal i32 @read_cal_int_tables(ptr noundef %0) {\nB:\n%1 = tail call i32 @read_pwr_cal_values(ptr noundef %0)\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = tail call i32 @read_pwr_int_values(ptr noundef %0)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @read_ofdm_cal_values(ptr noundef %0)\nbr label %B3\n\nB3:\n%6 = phi i32 [ %1, %B ], [ %3, %B1 ], [ %5, %B2 ]\nret i32 %6\n}", "codegemma": "define internal i32 @read_cal_int_tables(ptr noundef %0) {\nB:\n%1 = tail call i32 @read_pwr_cal_values(ptr noundef %0)\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = tail call i32 @read_pwr_int_values(ptr noundef %0)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @read_ofdm_cal_values(ptr noundef %0)\nbr label %B3\n\nB3:\n%6 = phi i32 [ %1, %B ], [ %3, %B1 ], [ %5, %B2 ]\nret i32 %6\n}"}, "define dso_local zeroext i8 @i2c_inbyte() {\n%1 = alloca i8, align 1\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 1, ptr %1)\nstore i8 0, ptr %1, align 1\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%3 = call i32 (...) @i2c_disable()\n%4 = call i32 (...) @i2c_dir_in()\n%5 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%6 = sdiv i32 %5, 2\n%7 = call i32 @i2c_delay(i32 noundef %6)\n%8 = call zeroext i8 (...) @i2c_getbit()\n%9 = zext i8 %8 to i32\n%10 = load i8, ptr %1, align 1\n%11 = zext i8 %10 to i32\n%12 = or i32 %11, %9\n%13 = trunc i32 %12 to i8\nstore i8 %13, ptr %1, align 1\n%14 = call i32 (...) @i2c_enable()\n%15 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%16 = sdiv i32 %15, 2\n%17 = call i32 @i2c_delay(i32 noundef %16)\nstore i32 1, ptr %2, align 4\nbr label %18\n\n18:\n%19 = load i32, ptr %2, align 4\n%20 = icmp slt i32 %19, 8\nbr i1 %20, label %21, label %52\n\n21:\n%22 = load i8, ptr %1, align 1\n%23 = zext i8 %22 to i32\n%24 = shl i32 %23, 1\n%25 = trunc i32 %24 to i8\nstore i8 %25, ptr %1, align 1\n%26 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%27 = call i32 @i2c_clk(i32 noundef %26)\n%28 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%29 = call i32 @i2c_delay(i32 noundef %28)\n%30 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%31 = call i32 @i2c_clk(i32 noundef %30)\n%32 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%33 = call i32 @i2c_delay(i32 noundef %32)\n%34 = call i32 (...) @i2c_disable()\n%35 = call i32 (...) @i2c_dir_in()\n%36 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%37 = sdiv i32 %36, 2\n%38 = call i32 @i2c_delay(i32 noundef %37)\n%39 = call zeroext i8 (...) @i2c_getbit()\n%40 = zext i8 %39 to i32\n%41 = load i8, ptr %1, align 1\n%42 = zext i8 %41 to i32\n%43 = or i32 %42, %40\n%44 = trunc i32 %43 to i8\nstore i8 %44, ptr %1, align 1\n%45 = call i32 (...) @i2c_enable()\n%46 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%47 = sdiv i32 %46, 2\n%48 = call i32 @i2c_delay(i32 noundef %47)\nbr label %49\n\n49:\n%50 = load i32, ptr %2, align 4\n%51 = add nsw i32 %50, 1\nstore i32 %51, ptr %2, align 4\nbr label %18\n\n52:\n%53 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%54 = call i32 @i2c_clk(i32 noundef %53)\n%55 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%56 = call i32 @i2c_delay(i32 noundef %55)\n%57 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%58 = call i32 @i2c_clk(i32 noundef %57)\n%59 = load i8, ptr %1, align 1\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 1, ptr %1)\nret i8 %59\n}": {"base_truth": "define dso_local zeroext i8 @i2c_inbyte() {\nB:\n%0 = tail call i32 (...) @i2c_disable()\n%1 = tail call i32 (...) @i2c_dir_in()\n%2 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%3 = sdiv i32 %2, 2\n%4 = tail call i32 @i2c_delay(i32 noundef %3)\n%5 = tail call zeroext i8 (...) @i2c_getbit()\n%6 = tail call i32 (...) @i2c_enable()\n%7 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%8 = sdiv i32 %7, 2\n%9 = tail call i32 @i2c_delay(i32 noundef %8)\n%10 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%11 = tail call i32 @i2c_clk(i32 noundef %10)\n%12 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%13 = tail call i32 @i2c_delay(i32 noundef %12)\n%14 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%15 = tail call i32 @i2c_clk(i32 noundef %14)\n%16 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%17 = tail call i32 @i2c_delay(i32 noundef %16)\n%18 = tail call i32 (...) @i2c_disable()\n%19 = tail call i32 (...) @i2c_dir_in()\n%20 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%21 = sdiv i32 %20, 2\n%22 = tail call i32 @i2c_delay(i32 noundef %21)\n%23 = tail call zeroext i8 (...) @i2c_getbit()\n%24 = tail call i32 (...) @i2c_enable()\n%25 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%26 = sdiv i32 %25, 2\n%27 = tail call i32 @i2c_delay(i32 noundef %26)\n%28 = shl i8 %5, 2\n%29 = shl i8 %23, 1\n%30 = or i8 %28, %29\n%31 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%32 = tail call i32 @i2c_clk(i32 noundef %31)\n%33 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%34 = tail call i32 @i2c_delay(i32 noundef %33)\n%35 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%36 = tail call i32 @i2c_clk(i32 noundef %35)\n%37 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%38 = tail call i32 @i2c_delay(i32 noundef %37)\n%39 = tail call i32 (...) @i2c_disable()\n%40 = tail call i32 (...) @i2c_dir_in()\n%41 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%42 = sdiv i32 %41, 2\n%43 = tail call i32 @i2c_delay(i32 noundef %42)\n%44 = tail call zeroext i8 (...) @i2c_getbit()\n%45 = or i8 %44, %30\n%46 = tail call i32 (...) @i2c_enable()\n%47 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%48 = sdiv i32 %47, 2\n%49 = tail call i32 @i2c_delay(i32 noundef %48)\n%50 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%51 = tail call i32 @i2c_clk(i32 noundef %50)\n%52 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%53 = tail call i32 @i2c_delay(i32 noundef %52)\n%54 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%55 = tail call i32 @i2c_clk(i32 noundef %54)\n%56 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%57 = tail call i32 @i2c_delay(i32 noundef %56)\n%58 = tail call i32 (...) @i2c_disable()\n%59 = tail call i32 (...) @i2c_dir_in()\n%60 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%61 = sdiv i32 %60, 2\n%62 = tail call i32 @i2c_delay(i32 noundef %61)\n%63 = tail call zeroext i8 (...) @i2c_getbit()\n%64 = tail call i32 (...) @i2c_enable()\n%65 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%66 = sdiv i32 %65, 2\n%67 = tail call i32 @i2c_delay(i32 noundef %66)\n%68 = shl i8 %45, 2\n%69 = shl i8 %63, 1\n%70 = or i8 %68, %69\n%71 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%72 = tail call i32 @i2c_clk(i32 noundef %71)\n%73 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%74 = tail call i32 @i2c_delay(i32 noundef %73)\n%75 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%76 = tail call i32 @i2c_clk(i32 noundef %75)\n%77 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%78 = tail call i32 @i2c_delay(i32 noundef %77)\n%79 = tail call i32 (...) @i2c_disable()\n%80 = tail call i32 (...) @i2c_dir_in()\n%81 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%82 = sdiv i32 %81, 2\n%83 = tail call i32 @i2c_delay(i32 noundef %82)\n%84 = tail call zeroext i8 (...) @i2c_getbit()\n%85 = or i8 %84, %70\n%86 = tail call i32 (...) @i2c_enable()\n%87 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%88 = sdiv i32 %87, 2\n%89 = tail call i32 @i2c_delay(i32 noundef %88)\n%90 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%91 = tail call i32 @i2c_clk(i32 noundef %90)\n%92 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%93 = tail call i32 @i2c_delay(i32 noundef %92)\n%94 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%95 = tail call i32 @i2c_clk(i32 noundef %94)\n%96 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%97 = tail call i32 @i2c_delay(i32 noundef %96)\n%98 = tail call i32 (...) @i2c_disable()\n%99 = tail call i32 (...) @i2c_dir_in()\n%100 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%101 = sdiv i32 %100, 2\n%102 = tail call i32 @i2c_delay(i32 noundef %101)\n%103 = tail call zeroext i8 (...) @i2c_getbit()\n%104 = tail call i32 (...) @i2c_enable()\n%105 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%106 = sdiv i32 %105, 2\n%107 = tail call i32 @i2c_delay(i32 noundef %106)\n%108 = shl i8 %85, 2\n%109 = shl i8 %103, 1\n%110 = or i8 %108, %109\n%111 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%112 = tail call i32 @i2c_clk(i32 noundef %111)\n%113 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%114 = tail call i32 @i2c_delay(i32 noundef %113)\n%115 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%116 = tail call i32 @i2c_clk(i32 noundef %115)\n%117 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%118 = tail call i32 @i2c_delay(i32 noundef %117)\n%119 = tail call i32 (...) @i2c_disable()\n%120 = tail call i32 (...) @i2c_dir_in()\n%121 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%122 = sdiv i32 %121, 2\n%123 = tail call i32 @i2c_delay(i32 noundef %122)\n%124 = tail call zeroext i8 (...) @i2c_getbit()\n%125 = or i8 %124, %110\n%126 = tail call i32 (...) @i2c_enable()\n%127 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%128 = sdiv i32 %127, 2\n%129 = tail call i32 @i2c_delay(i32 noundef %128)\n%130 = shl i8 %125, 1\n%131 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%132 = tail call i32 @i2c_clk(i32 noundef %131)\n%133 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%134 = tail call i32 @i2c_delay(i32 noundef %133)\n%135 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%136 = tail call i32 @i2c_clk(i32 noundef %135)\n%137 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%138 = tail call i32 @i2c_delay(i32 noundef %137)\n%139 = tail call i32 (...) @i2c_disable()\n%140 = tail call i32 (...) @i2c_dir_in()\n%141 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%142 = sdiv i32 %141, 2\n%143 = tail call i32 @i2c_delay(i32 noundef %142)\n%144 = tail call zeroext i8 (...) @i2c_getbit()\n%145 = or i8 %144, %130\n%146 = tail call i32 (...) @i2c_enable()\n%147 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%148 = sdiv i32 %147, 2\n%149 = tail call i32 @i2c_delay(i32 noundef %148)\n%150 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%151 = tail call i32 @i2c_clk(i32 noundef %150)\n%152 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%153 = tail call i32 @i2c_delay(i32 noundef %152)\n%154 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%155 = tail call i32 @i2c_clk(i32 noundef %154)\nret i8 %145\n}", "codellama": "define dso_local zeroext i8 @i2c_inbyte() {\nB:\n%0 = tail call i32 (...) @i2c_disable()\n%1 = tail call i32 (...) @i2c_dir_in()\n%2 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%3 = sdiv i32 %2, 2\n%4 = tail call i32 @i2c_delay(i32 noundef %3)\n%5 = tail call zeroext i8 (...) @i2c_getbit()\n%6 = tail call i32 (...) @i2c_enable()\n%7 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%8 = sdiv i32 %7, 2\n%9 = tail call i32 @i2c_delay(i32 noundef %8)\n%10 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%11 = tail call i32 @i2c_clk(i32 noundef %10)\n%12 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%13 = tail call i32 @i2c_delay(i32 noundef %12)\n%14 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%15 = tail call i32 @i2c_clk(i32 noundef %14)\n%16 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%17 = tail call i32 @i2c_delay(i32 noundef %16)\n%18 = tail call i32 (...) @i2c_disable()\n%19 = tail call i32 (...) @i2c_dir_in()\n%20 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%21 = sdiv i32 %20, 2\n%22 = tail call i32 @i2c_delay(i32 noundef %21)\n%23 = tail call zeroext i8 (...) @i2c_getbit()\n%24 = tail call i32 (...) @i2c_enable()\n%25 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%26 = sdiv i32 %25, 2\n%27 = tail call i32 @i2c_delay(i32 noundef %26)\n%28 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%29 = tail call i32 @i2c_clk(i32 noundef %28)\n%30 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%31 = tail call i32 @i2c_delay(i32 noundef %30)\n%32 = load i32, ptr @I2C_CLOCK_LOW, align 4\n%33 = tail call i32 @i2c_clk(i32 noundef %32)\n%34 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%35 = tail call i32 @i2c_delay(i32 noundef %34)\n%36 = tail call i32 (...) @i2c_disable()\n%37 = tail call i32 (...) @i2c_dir_in()\n%38 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%39 = sdiv i32 %38, 2\n%40 = tail call i32 @i2c_delay(i32 noundef %39)\n%41 = tail call zeroext i8 (...) @i2c_getbit()\n%42 = tail call i32 (...) @i2c_enable()\n%43 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%44 = sdiv i32 %43, 2\n%45 = tail call i32 @i2c_delay(i32 noundef %44)\n%46 = load i32, ptr @I2C_CLOCK_HIGH, align 4\n%47 = tail call i32 @i2c_clk(i32 noundef %46</s>", "codegemma": "define dso_local zeroext i8 @i2c_inbyte() {\nB:\n%0 = tail call i32 (...) @i2c_disable()\n%1 = tail call i32 (...) @i2c_dir_in()\n%2 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%3 = sdiv i32 %2, 2\n%4 = tail call i32 @i2c_delay(i32 noundef %3)\n%5 = tail call zeroext i8 (...) @i2c_getbit()\n%6 = tail call i32 (...) @i2c_enable()\n%7 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%8 = sdiv i32 %7, 2\n%9 = tail call i32 @i2c_delay(i32 noundef %8)\n%10 = tail call i32 @i2c_dir_in()\n%11 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%12 = sdiv i32 %11, 2\n%13 = tail call i32 @i2c_delay(i32 noundef %12)\n%14 = tail call zeroext i8 (...) @i2c_getbit()\n%15 = tail call i32 (...) @i2c_enable()\n%16 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%17 = sdiv i32 %16, 2\n%18 = tail call i32 @i2c_delay(i32 noundef %17)\n%19 = tail call i32 @i2c_dir_in()\n%20 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%21 = sdiv i32 %20, 2\n%22 = tail call i32 @i2c_delay(i32 noundef %21)\n%23 = tail call zeroext i8 (...) @i2c_getbit()\n%24 = tail call i32 (...) @i2c_enable()\n%25 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%26 = sdiv i32 %25, 2\n%27 = tail call i32 @i2c_delay(i32 noundef %26)\n%28 = tail call i32 @i2c_dir_in()\n%29 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%30 = sdiv i32 %29, 2\n%31 = tail call i32 @i2c_delay(i32 noundef %30)\n%32 = tail call zeroext i8 (...) @i2c_getbit()\n%33 = tail call i32 (...) @i2c_enable()\n%34 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%35 = sdiv i32 %34, 2\n%36 = tail call i32 @i2c_delay(i32 noundef %35)\n%37 = tail call i32 @i2c_dir_in()\n%38 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%39 = sdiv i32 %38, 2\n%40 = tail call i32 @i2c_delay(i32 noundef %39)\n%41 = tail call zeroext i8 (...) @i2c_getbit()\n%42 = tail call i32 (...) @i2c_enable()\n%43 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%44 = sdiv i32 %43, 2\n%45 = tail call i32 @i2c_delay(i32 noundef %44)\n%46 = tail call i32 @i2c_dir_in()\n%47 = load i32, ptr @CLOCK_HIGH_TIME, align 4\n%48 = sdiv i32 %47, 2\n%49 = tail call i32 @i2c_delay(i32 noundef %48)\n%50 = tail call zeroext i8 (...) @i2c_getbit()\n%51 = tail call i32 (...) @i2c_enable()\n%52 = load i32, ptr @CLOCK_LOW_TIME, align 4\n%53 = sdiv i32 %52, 2\n%54 = tail call i32 @i2c_delay(i32 noundef %53)\n%55 = tail call i32 @i2c_dir_in()\n%5<eos>"}, "define dso_local i32 @pdf_annot_ink_list_stroke_count(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\n%8 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%9 = load ptr, ptr %4, align 8\n%10 = load ptr, ptr %5, align 8\n%11 = load i32, ptr @InkList, align 4\n%12 = call i32 @PDF_NAME(i32 noundef %11)\n%13 = load i32, ptr @ink_list_subtypes, align 4\n%14 = call i32 @check_allowed_subtypes(ptr noundef %9, ptr noundef %10, i32 noundef %12, i32 noundef %13)\n%15 = load ptr, ptr %4, align 8\n%16 = load ptr, ptr %5, align 8\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = load i32, ptr @InkList, align 4\n%20 = call i32 @PDF_NAME(i32 noundef %19)\n%21 = call ptr @pdf_dict_get(ptr noundef %15, i32 noundef %18, i32 noundef %20)\nstore ptr %21, ptr %7, align 8\n%22 = load ptr, ptr %4, align 8\n%23 = load ptr, ptr %7, align 8\n%24 = load i32, ptr %6, align 4\n%25 = call ptr @pdf_array_get(ptr noundef %22, ptr noundef %23, i32 noundef %24)\nstore ptr %25, ptr %8, align 8\n%26 = load ptr, ptr %4, align 8\n%27 = load ptr, ptr %8, align 8\n%28 = call i32 @pdf_array_len(ptr noundef %26, ptr noundef %27)\n%29 = sdiv i32 %28, 2\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret i32 %29\n}": {"base_truth": "define dso_local i32 @pdf_annot_ink_list_stroke_count(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @InkList, align 4\n%4 = tail call i32 @PDF_NAME(i32 noundef %3)\n%5 = load i32, ptr @ink_list_subtypes, align 4\n%6 = tail call i32 @check_allowed_subtypes(ptr noundef %0, ptr noundef %1, i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %1, align 4\n%8 = load i32, ptr @InkList, align 4\n%9 = tail call i32 @PDF_NAME(i32 noundef %8)\n%10 = tail call ptr @pdf_dict_get(ptr noundef %0, i32 noundef %7, i32 noundef %9)\n%11 = tail call ptr @pdf_array_get(ptr noundef %0, ptr noundef %10, i32 noundef %2)\n%12 = tail call i32 @pdf_array_len(ptr noundef %0, ptr noundef %11)\n%13 = sdiv i32 %12, 2\nret i32 %13\n}", "codellama": "define dso_local i32 @pdf_annot_ink_list_stroke_count(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @InkList, align 4\n%4 = tail call i32 @PDF_NAME(i32 noundef %3)\n%5 = load i32, ptr @ink_list_subtypes, align 4\n%6 = tail call i32 @check_allowed_subtypes(ptr noundef %0, ptr noundef %1, i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %1, align 4\n%8 = load i32, ptr @InkList, align 4\n%9 = tail call i32 @PDF_NAME(i32 noundef %8)\n%10 = tail call ptr @pdf_dict_get(ptr noundef %0, i32 noundef %7, i32 noundef %9)\n%11 = tail call ptr @pdf_array_get(ptr noundef %0, ptr noundef %10, i32 noundef %2)\n%12 = tail call i32 @pdf_array_len(ptr noundef %0, ptr noundef %11)\n%13 = sdiv i32 %12, 2\nret i32 %13\n}", "codegemma": "define dso_local i32 @pdf_annot_ink_list_stroke_count(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @InkList, align 4\n%4 = tail call i32 @PDF_NAME(i32 noundef %3)\n%5 = load i32, ptr @ink_list_subtypes, align 4\n%6 = tail call i32 @check_allowed_subtypes(ptr noundef %0, ptr noundef %1, i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %1, align 4\n%8 = load i32, ptr @InkList, align 4\n%9 = tail call i32 @PDF_NAME(i32 noundef %8)\n%10 = tail call ptr @pdf_dict_get(ptr noundef %0, i32 noundef %7, i32 noundef %9)\n%11 = tail call ptr @pdf_array_get(ptr noundef %0, ptr noundef %10, i32 noundef %2)\n%12 = tail call i32 @pdf_array_len(ptr noundef %0, ptr noundef %11)\n%13 = sdiv i32 %12, 2\nret i32 %13\n}"}, "define dso_local i32 @processInstruction() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 1, ptr %1, align 4\n%2 = load i32, ptr @OPERATIONCODE, align 4\nswitch i32 %2, label %26 [\ni32 10, label %3\ni32 11, label %5\ni32 20, label %7\ni32 21, label %9\ni32 30, label %11\ni32 31, label %13\ni32 32, label %15\ni32 33, label %17\ni32 40, label %19\ni32 41, label %21\ni32 42, label %23\ni32 43, label %25\n]\n\n3:\n%4 = call i32 (...) @doRead()\nstore i32 %4, ptr %1, align 4\nbr label %30\n\n5:\n%6 = call i32 (...) @doWrite()\nstore i32 %6, ptr %1, align 4\nbr label %30\n\n7:\n%8 = call i32 (...) @doLoad()\nstore i32 %8, ptr %1, align 4\nbr label %30\n\n9:\n%10 = call i32 (...) @doStore()\nstore i32 %10, ptr %1, align 4\nbr label %30\n\n11:\n%12 = call i32 (...) @doAdd()\nstore i32 %12, ptr %1, align 4\nbr label %30\n\n13:\n%14 = call i32 (...) @doSubtract()\nstore i32 %14, ptr %1, align 4\nbr label %30\n\n15:\n%16 = call i32 (...) @doDivide()\nstore i32 %16, ptr %1, align 4\nbr label %30\n\n17:\n%18 = call i32 (...) @doMultiply()\nstore i32 %18, ptr %1, align 4\nbr label %30\n\n19:\n%20 = call i32 (...) @doBranch()\nstore i32 %20, ptr %1, align 4\nbr label %30\n\n21:\n%22 = call i32 (...) @doBranchNeg()\nstore i32 %22, ptr %1, align 4\nbr label %30\n\n23:\n%24 = call i32 (...) @doBranchZero()\nstore i32 %24, ptr %1, align 4\nbr label %30\n\n25:\nstore i32 0, ptr %1, align 4\nbr label %30\n\n26:\n%27 = load i32, ptr @INSTRUCTIONCOUNTER, align 4\n%28 = call i32 @printf(ptr noundef @.str, i32 noundef %27)\n%29 = call i32 @system(ptr noundef @.str.1)\nstore i32 -1, ptr %1, align 4\nbr label %30\n\n30:\n%31 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %31\n}": {"base_truth": "define dso_local i32 @processInstruction() {\nB:\n%0 = load i32, ptr @OPERATIONCODE, align 4\nswitch i32 %0, label %B12 [\ni32 10, label %B1\ni32 11, label %B2\ni32 20, label %B3\ni32 21, label %B4\ni32 30, label %B5\ni32 31, label %B6\ni32 32, label %B7\ni32 33, label %B8\ni32 40, label %B9\ni32 41, label %B10\ni32 42, label %B11\ni32 43, label %B13\n]\n\nB1:\n%1 = tail call i32 (...) @doRead()\nbr label %B13\n\nB2:\n%2 = tail call i32 (...) @doWrite()\nbr label %B13\n\nB3:\n%3 = tail call i32 (...) @doLoad()\nbr label %B13\n\nB4:\n%4 = tail call i32 (...) @doStore()\nbr label %B13\n\nB5:\n%5 = tail call i32 (...) @doAdd()\nbr label %B13\n\nB6:\n%6 = tail call i32 (...) @doSubtract()\nbr label %B13\n\nB7:\n%7 = tail call i32 (...) @doDivide()\nbr label %B13\n\nB8:\n%8 = tail call i32 (...) @doMultiply()\nbr label %B13\n\nB9:\n%9 = tail call i32 (...) @doBranch()\nbr label %B13\n\nB10:\n%10 = tail call i32 (...) @doBranchNeg()\nbr label %B13\n\nB11:\n%11 = tail call i32 (...) @doBranchZero()\nbr label %B13\n\nB12:\n%12 = load i32, ptr @INSTRUCTIONCOUNTER, align 4\n%13 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %12)\n%14 = tail call i32 @system(ptr noundef nonnull @.str.1)\nbr label %B13\n\nB13:\n%15 = phi i32 [ -1, %B12 ], [ %11, %B11 ], [ %10, %B10 ], [ %9, %B9 ], [ %8, %B8 ], [ %7, %B7 ], [ %6, %B6 ], [ %5, %B5 ], [ %4, %B4 ], [ %3, %B3 ], [ %2, %B2 ], [ %1, %B1 ], [ 0, %B ]\nret i32 %15\n}", "codellama": "define dso_local i32 @processInstruction() {\nB:\n%0 = load i32, ptr @OPERATIONCODE, align 4\nswitch i32 %0, label %B10 [\ni32 10, label %B1\ni32 11, label %B2\ni32 20, label %B3\ni32 21, label %B4\ni32 30, label %B5\ni32 31, label %B6\ni32 32, label %B7\ni32 33, label %B8\ni32 40, label %B9\ni32 41, label %B11\ni32 42, label %B12\ni32 43, label %B13\n]\n\nB1:\n%1 = tail call i32 (...) @doRead()\nbr label %B13\n\nB2:\n%2 = tail call i32 (...) @doWrite()\nbr label %B13\n\nB3:\n%3 = tail call i32 (...) @doLoad()\nbr label %B13\n\nB4:\n%4 = tail call i32 (...) @doStore()\nbr label %B13\n\nB5:\n%5 = tail call i32 (...) @doAdd()\nbr label %B13\n\nB6:\n%6 = tail call i32 (...) @doSubtract()\nbr label %B13\n\nB7:\n%7 = tail call i32 (...) @doDivide()\nbr label %B13\n\nB8:\n%8 = tail call i32 (...) @doMultiply()\nbr label %B13\n\nB9:\n%9 = tail call i32 (...) @doBranch()\nbr label %B13\n\nB10:\n%10 = load i32, ptr @INSTRUCTIONCOUNTER, align 4\n%11 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %10)\n%12 = tail call i32 @system(ptr noundef nonnull @.str.1)\nbr label %B13\n\nB11:\n%13 = tail call i32 (...) @doBranchNeg()\nbr label %B13\n\nB12:\n%14 = tail call i32 (...) @doBranchZero()\nbr label %B13\n\nB13:\n%15 = phi i32 [ -1, %B10 ], [ %14, %B12 ], [ %13, %B11 ], [ %9, %B9 ], [ %8, %B8 ], [ %7, %B7 ], [ %6, %B6 ], [ %5, %B5 ], [ %4, %B4 ], [ %3, %B3 ], [ %2, %B2 ], [ %1, %B1 ], [ 0, %B ]\nret i32 %15\n}", "codegemma": "define dso_local i32 @processInstruction() {\nB:\n%0 = load i32, ptr @OPERATIONCODE, align 4\nswitch i32 %0, label %B12 [\ni32 10, label %B1\ni32 11, label %B2\ni32 20, label %B3\ni32 21, label %B4\ni32 30, label %B5\ni32 31, label %B6\ni32 32, label %B7\ni32 33, label %B8\ni32 40, label %B9\ni32 41, label %B10\ni32 42, label %B11\ni32 43, label %B13\n]\n\nB1:\n%1 = tail call i32 (...) @doRead()\nbr label %B13\n\nB2:\n%2 = tail call i32 (...) @doWrite()\nbr label %B13\n\nB3:\n%3 = tail call i32 (...) @doLoad()\nbr label %B13\n\nB4:\n%4 = tail call i32 (...) @doStore()\nbr label %B13\n\nB5:\n%5 = tail call i32 (...) @doAdd()\nbr label %B13\n\nB6:\n%6 = tail call i32 (...) @doSubtract()\nbr label %B13\n\nB7:\n%7 = tail call i32 (...) @doDivide()\nbr label %B13\n\nB8:\n%8 = tail call i32 (...) @doMultiply()\nbr label %B13\n\nB9:\n%9 = tail call i32 (...) @doBranch()\nbr label %B13\n\nB10:\n%10 = tail call i32 (...) @doBranchNeg()\nbr label %B13\n\nB11:\n%11 = tail call i32 (...) @doBranchZero()\nbr label %B13\n\nB12:\n%12 = load i32, ptr @INSTRUCTIONCOUNTER, align 4\n%13 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %12)\n%14 = tail call i32 @system(ptr noundef nonnull @.str.1)\nbr label %B13\n\nB13:\n%15 = phi i32 [ -1, %B12 ], [ %11, %B11 ], [ %10, %B10 ], [ %9, %B9 ], [ %8, %B8 ], [ %7, %B7 ], [ %6, %B6 ], [ %5, %B5 ], [ %4, %B4 ], [ %3, %B3 ], [ %2, %B2 ], [ %1, %B1 ]\nret i32 %15\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 1, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%5 = call i32 @scanf(ptr noundef @.str, ptr noundef %2)\nstore i32 1, ptr %4, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %4, align 4\n%8 = load i32, ptr %2, align 4\n%9 = icmp sle i32 %7, %8\nbr i1 %9, label %10, label %17\n\n10:\n%11 = load i32, ptr %3, align 4\n%12 = load i32, ptr %4, align 4\n%13 = mul nsw i32 %11, %12\nstore i32 %13, ptr %3, align 4\nbr label %14\n\n14:\n%15 = load i32, ptr %4, align 4\n%16 = add nsw i32 %15, 1\nstore i32 %16, ptr %4, align 4\nbr label %6\n\n17:\n%18 = load i32, ptr %3, align 4\n%19 = call i32 @printf(ptr noundef @.str, i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B7, label %B1\n\nB1:\n%4 = icmp ult i32 %2, 32\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = and i32 %2, -32\n%6 = or i32 %5, 1\nbr label %B3\n\nB3:\n%7 = phi i32 [ 0, %B2 ], [ %20, %B3 ]\n%8 = phi <8 x i32> [ <i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8>, %B2 ], [ %21, %B3 ]\n%9 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %16, %B3 ]\n%10 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %17, %B3 ]\n%11 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %18, %B3 ]\n%12 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %19, %B3 ]\n%13 = add <8 x i32> %8, <i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8>\n%14 = add <8 x i32> %8, <i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16>\n%15 = add <8 x i32> %8, <i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24>\n%16 = mul <8 x i32> %8, %9\n%17 = mul <8 x i32> %13, %10\n%18 = mul <8 x i32> %14, %11\n%19 = mul <8 x i32> %15, %12\n%20 = add nuw i32 %7, 32\n%21 = add <8 x i32> %8, <i32 32, i32 32, i32 32, i32 32, i32 32, i32 32, i32 32, i32 32>\n%22 = icmp eq i32 %20, %5\nbr i1 %22, label %B4, label %B3\n\nB4:\n%23 = mul <8 x i32> %17, %16\n%24 = mul <8 x i32> %18, %23\n%25 = mul <8 x i32> %19, %24\n%26 = call i32 @llvm.vector.reduce.mul.v8i32(<8 x i32> %25)\n%27 = icmp eq i32 %2, %5\nbr i1 %27, label %B7, label %B5\n\nB5:\n%28 = phi i32 [ 1, %B1 ], [ %6, %B4 ]\n%29 = phi i32 [ 1, %B1 ], [ %26, %B4 ]\nbr label %B6\n\nB6:\n%30 = phi i32 [ %33, %B6 ], [ %28, %B5 ]\n%31 = phi i32 [ %32, %B6 ], [ %29, %B5 ]\n%32 = mul nsw i32 %30, %31\n%33 = add nuw i32 %30, 1\n%34 = icmp eq i32 %30, %2\nbr i1 %34, label %B7, label %B6\n\nB7:\n%35 = phi i32 [ 1, %B ], [ %26, %B4 ], [ %32, %B6 ]\n%36 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %35)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B7, label %B1\n\nB1:\n%4 = icmp ult i32 %2, 32\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = and i32 %2, -32\n%6 = and i32 %2, 3\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B3, label %B4\n\nB3:\n%8 = phi i32 [ %25, %B3 ], [ 1, %B2 ]\n%9 = phi i32 [ %24, %B3 ], [ 0, %B2 ]\n%10 = phi i32 [ %26, %B3 ], [ 0, %B2 ]\n%11 = mul nsw i32 %8, %9\n%12 = add nuw nsw i32 %10, 32\n%13 = mul nsw i32 %11, %12\n%14 = add nuw nsw i32 %10, 31\n%15 = mul nsw i32 %13, %14\n%16 = add nuw nsw i32 %10, 30\n%17 = mul nsw i32 %15, %16\n%18 = add nuw nsw i32 %10, 29\n%19 = mul nsw i32 %17, %18\n%20 = add nuw nsw i32 %10, 28\n%21 = mul nsw i32 %19, %20\n%22 = add nuw nsw i32 %10, 27\n%23 = mul nsw i32 %21, %22\n%24 = add nuw nsw i32 %9, 32\n%25 = add nuw nsw i32 %8, 32\n%26 = add i32 %10, 32\n%27 = icmp eq i32 %26, %5\nbr i1 %27, label %B4, label %B3\n\nB4:\n%28 = phi i32 [ undef, %B2 ], [ %23, %B3 ]\n%29 = phi i32 [ 1, %B2 ], [ %25, %B3 ]\n%30 = phi i32 [ 0, %B2 ], [ %24, %B3 ]\n%31 = phi i32 [ %11, %B2 ], [ %23, %B3 ]\n%32 = icmp eq i32 %2, %5\nbr i1 %32, label %B7, label %B5\n\nB5:\n%33 = phi i32 [ 1, %B1 ], [ %29, %B4 ]\n%34 = phi i32 [ 0, %B1 ], [ %30, %B4 ]\n%35 = phi i32 [ 1, %B1 ], [ %33, %B4 ]\nbr label %B6\n\nB6:\n%36 = phi i32 [ %39, %B6 ], [ %33, %B5 ]\n%37 = phi i32 [ %38, %B6 ], [ %34, %B5 ]\n%38 = phi i32 [ %35, %B6 ], [ %39, %B6 ]\n%39 = mul nsw i32 %36, %37\n%40 = add nuw nsw i32 %37, 1\n%41 = icmp eq i32 %37, %2\nbr i1 %41, label %B7, label %B6\n\nB7:\n%42 = phi i32 [ 1, %B ], [ %33, %B4 ], [ %39, %B6 ]\n%43 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %42)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp slt i32 %2, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = phi i32 [ %6, %B1 ], [ 1, %B ]\n%5 = phi i32 [ %7, %B1 ], [ 1, %B ]\n%6 = mul nsw i32 %4, %5\n%7 = add nuw i32 %5, 1\n%8 = icmp eq i32 %5, %2\nbr i1 %8, label %B2, label %B1\n\nB2:\n%9 = phi i32 [ 1, %B ], [ %6, %B1 ]\n%10 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local i32 @pow(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%7 = load i32, ptr %4, align 4\nstore i32 %7, ptr %6, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %6, align 4\n%10 = icmp ugt i32 %9, 0\nbr i1 %10, label %11, label %17\n\n11:\n%12 = load i32, ptr %3, align 4\n%13 = load i32, ptr %5, align 4\n%14 = mul i32 %13, %12\nstore i32 %14, ptr %5, align 4\n%15 = load i32, ptr %6, align 4\n%16 = add i32 %15, -1\nstore i32 %16, ptr %6, align 4\nbr label %8\n\n17:\n%18 = load i32, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %18\n}": {"base_truth": "define dso_local i32 @pow(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B7, label %B1\n\nB1:\n%3 = icmp ult i32 %1, 32\nbr i1 %3, label %B5, label %B2\n\nB2:\n%4 = and i32 %1, -32\n%5 = and i32 %1, 31\n%6 = insertelement <8 x i32> poison, i32 %0, i64 0\n%7 = shufflevector <8 x i32> %6, <8 x i32> poison, <8 x i32> zeroinitializer\n%8 = insertelement <8 x i32> poison, i32 %0, i64 0\n%9 = shufflevector <8 x i32> %8, <8 x i32> poison, <8 x i32> zeroinitializer\n%10 = insertelement <8 x i32> poison, i32 %0, i64 0\n%11 = shufflevector <8 x i32> %10, <8 x i32> poison, <8 x i32> zeroinitializer\n%12 = insertelement <8 x i32> poison, i32 %0, i64 0\n%13 = shufflevector <8 x i32> %12, <8 x i32> poison, <8 x i32> zeroinitializer\nbr label %B3\n\nB3:\n%14 = phi i32 [ 0, %B2 ], [ %23, %B3 ]\n%15 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %19, %B3 ]\n%16 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %20, %B3 ]\n%17 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %21, %B3 ]\n%18 = phi <8 x i32> [ <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>, %B2 ], [ %22, %B3 ]\n%19 = mul <8 x i32> %15, %7\n%20 = mul <8 x i32> %16, %9\n%21 = mul <8 x i32> %17, %11\n%22 = mul <8 x i32> %18, %13\n%23 = add nuw i32 %14, 32\n%24 = icmp eq i32 %23, %4\nbr i1 %24, label %B4, label %B3\n\nB4:\n%25 = mul <8 x i32> %20, %19\n%26 = mul <8 x i32> %21, %25\n%27 = mul <8 x i32> %22, %26\n%28 = tail call i32 @llvm.vector.reduce.mul.v8i32(<8 x i32> %27)\n%29 = icmp eq i32 %4, %1\nbr i1 %29, label %B7, label %B5\n\nB5:\n%30 = phi i32 [ %1, %B1 ], [ %5, %B4 ]\n%31 = phi i32 [ 1, %B1 ], [ %28, %B4 ]\nbr label %B6\n\nB6:\n%32 = phi i32 [ %35, %B6 ], [ %30, %B5 ]\n%33 = phi i32 [ %34, %B6 ], [ %31, %B5 ]\n%34 = mul i32 %33, %0\n%35 = add i32 %32, -1\n%36 = icmp eq i32 %35, 0\nbr i1 %36, label %B7, label %B6\n\nB7:\n%37 = phi i32 [ 1, %B ], [ %28, %B4 ], [ %34, %B6 ]\nret i32 %37\n}", "codellama": "define dso_local i32 @pow(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi i32 [ %6, %B1 ], [ 1, %B ]\n%4 = phi i32 [ %7, %B1 ], [ %1, %B ]\n%5 = mul i32 %3, %0\n%6 = add i32 %5, -1\n%7 = add i32 %4, -1\n%8 = icmp eq i32 %6, 0\nbr i1 %8, label %B2, label %B1\n\nB2:\n%9 = phi i32 [ 1, %B ], [ %5, %B1 ]\nret i32 %9\n}", "codegemma": "define dso_local i32 @pow(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi i32 [ %5, %B1 ], [ %1, %B ]\n%4 = phi i32 [ %7, %B1 ], [ 1, %B ]\n%5 = mul i32 %4, %0\n%6 = add i32 %3, -1\n%7 = tail call i32 @llvm.umin.i32(i32 %6, i32 0)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B1\n\nB2:\n%9 = phi i32 [ 1, %B ], [ %5, %B1 ]\nret i32 %9\n}"}, "define dso_local ptr @copy_parserec(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %8, label %9\n\n8:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %15\n\n9:\n%10 = call ptr @rmalloc(i32 noundef 4)\nstore ptr %10, ptr %4, align 8\n%11 = load ptr, ptr %4, align 8\n%12 = load ptr, ptr %3, align 8\n%13 = call i32 @memcpy(ptr noundef %11, ptr noundef %12, i32 noundef 4)\n%14 = load ptr, ptr %4, align 8\nstore ptr %14, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %15\n\n15:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%16 = load ptr, ptr %2, align 8\nret ptr %16\n}": {"base_truth": "define dso_local ptr @copy_parserec(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call ptr @rmalloc(i32 noundef 4)\n%3 = tail call i32 @memcpy(ptr noundef %2, ptr noundef nonnull %0, i32 noundef 4)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %2, %B1 ], [ null, %B ]\nret ptr %4\n}", "codellama": "define dso_local ptr @copy_parserec(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call ptr @rmalloc(i32 noundef 4)\n%3 = tail call i32 @memcpy(ptr noundef %2, ptr noundef nonnull %0, i32 noundef 4)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %2, %B1 ], [ null, %B ]\nret ptr %4\n}", "codegemma": "define dso_local ptr @copy_parserec(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call ptr @rmalloc(i32 noundef 4)\n%3 = tail call i32 @memcpy(ptr noundef %2, ptr noundef nonnull %0, i32 noundef 4)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %2, %B1 ], [ null, %B ]\nret ptr %4\n}"}, "define internal void @omap_set_vpp(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = call i64 (...) @cpu_class_is_omap1()\n%7 = icmp ne i64 %6, 0\nbr i1 %7, label %8, label %44\n\n8:\n%9 = load i32, ptr %4, align 4\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %11, label %25\n\n11:\n%12 = load i32, ptr @omap_set_vpp.count, align 4\n%13 = add nsw i32 %12, 1\nstore i32 %13, ptr @omap_set_vpp.count, align 4\n%14 = icmp eq i32 %12, 0\nbr i1 %14, label %15, label %24\n\n15:\n%16 = load i32, ptr @EMIFS_CONFIG, align 4\n%17 = call i32 @omap_readl(i32 noundef %16)\nstore i32 %17, ptr %5, align 4\n%18 = load i32, ptr @OMAP_EMIFS_CONFIG_WP, align 4\n%19 = load i32, ptr %5, align 4\n%20 = or i32 %19, %18\nstore i32 %20, ptr %5, align 4\n%21 = load i32, ptr %5, align 4\n%22 = load i32, ptr @EMIFS_CONFIG, align 4\n%23 = call i32 @omap_writel(i32 noundef %21, i32 noundef %22)\nbr label %24\n\n24:\nbr label %43\n\n25:\n%26 = load i32, ptr @omap_set_vpp.count, align 4\n%27 = icmp ne i32 %26, 0\nbr i1 %27, label %28, label %42\n\n28:\n%29 = load i32, ptr @omap_set_vpp.count, align 4\n%30 = add nsw i32 %29, -1\nstore i32 %30, ptr @omap_set_vpp.count, align 4\n%31 = icmp eq i32 %30, 0\nbr i1 %31, label %32, label %42\n\n32:\n%33 = load i32, ptr @EMIFS_CONFIG, align 4\n%34 = call i32 @omap_readl(i32 noundef %33)\nstore i32 %34, ptr %5, align 4\n%35 = load i32, ptr @OMAP_EMIFS_CONFIG_WP, align 4\n%36 = xor i32 %35, -1\n%37 = load i32, ptr %5, align 4\n%38 = and i32 %37, %36\nstore i32 %38, ptr %5, align 4\n%39 = load i32, ptr %5, align 4\n%40 = load i32, ptr @EMIFS_CONFIG, align 4\n%41 = call i32 @omap_writel(i32 noundef %39, i32 noundef %40)\nbr label %42\n\n42:\nbr label %43\n\n43:\nbr label %44\n\n44:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @omap_set_vpp(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = tail call i64 (...) @cpu_class_is_omap1()\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B8, label %B1\n\nB1:\n%4 = icmp eq i32 %1, 0\n%5 = load i32, ptr @omap_set_vpp.count, align 4\nbr i1 %4, label %B4, label %B2\n\nB2:\n%6 = add nsw i32 %5, 1\nstore i32 %6, ptr @omap_set_vpp.count, align 4\n%7 = icmp eq i32 %5, 0\nbr i1 %7, label %B3, label %B8\n\nB3:\n%8 = load i32, ptr @EMIFS_CONFIG, align 4\n%9 = tail call i32 @omap_readl(i32 noundef %8)\n%10 = load i32, ptr @OMAP_EMIFS_CONFIG_WP, align 4\n%11 = or i32 %10, %9\nbr label %B7\n\nB4:\n%12 = icmp eq i32 %5, 0\nbr i1 %12, label %B8, label %B5\n\nB5:\n%13 = add nsw i32 %5, -1\nstore i32 %13, ptr @omap_set_vpp.count, align 4\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B6, label %B8\n\nB6:\n%15 = load i32, ptr @EMIFS_CONFIG, align 4\n%16 = tail call i32 @omap_readl(i32 noundef %15)\n%17 = load i32, ptr @OMAP_EMIFS_CONFIG_WP, align 4\n%18 = xor i32 %17, -1\n%19 = and i32 %16, %18\nbr label %B7\n\nB7:\n%20 = phi i32 [ %11, %B3 ], [ %19, %B6 ]\n%21 = load i32, ptr @EMIFS_CONFIG, align 4\n%22 = tail call i32 @omap_writel(i32 noundef %20, i32 noundef %21)\nbr label %B8\n\nB8:\nret void\n}", "codellama": "define internal void @omap_set_vpp(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = tail call i64 (...) @cpu_class_is_omap1()\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B7, label %B1\n\nB1:\n%4 = icmp eq i32 %1, 0\n%5 = load i32, ptr @omap_set_vpp.count, align 4\nbr i1 %4, label %B3, label %B2\n\nB2:\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B6, label %B7\n\nB3:\n%7 = icmp eq i32 %5, 0\nbr i1 %7, label %B7, label %B4\n\nB4:\n%8 = add nsw i32 %5, -1\nstore i32 %8, ptr @omap_set_vpp.count, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B5, label %B7\n\nB5:\n%10 = load i32, ptr @EMIFS_CONFIG, align 4\n%11 = tail call i32 @omap_readl(i32 noundef %10)\n%12 = load i32, ptr @OMAP_EMIFS_CONFIG_WP, align 4\n%13 = or i32 %12, %11\n%14 = load i32, ptr @EMIFS_CONFIG, align 4\n%15 = tail call i32 @omap_writel(i32 noundef %13, i32 noundef %14)\nbr label %B7\n\nB6:\n%16 = load i32, ptr @EMIFS_CONFIG, align 4\n%17 = tail call i32 @omap_readl(i32 noundef %16)\n%18 = load i32, ptr @OMAP_EMIFS_CONFIG_WP, align 4\n%19 = xor i32 %18, -1\n%20 = and i32 %17, %19\n%21 = load i32, ptr @EMIFS_CONFIG, align 4\n%22 = tail call i32 @omap_writel(i32 noundef %20, i32 noundef %21)\nbr label %B7\n\nB7:\nret void\n}", "codegemma": "define internal void @omap_set_vpp(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = tail call i64 (...) @cpu_class_is_omap1()\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = icmp eq i32 %1, 0\n%5 = load i32, ptr @omap_set_vpp.count, align 4\nbr i1 %4, label %B3, label %B2\n\nB2:\n%6 = add nsw i32 %5, 1\nstore i32 %6, ptr @omap_set_vpp.count, align 4\n%7 = icmp eq i32 %5, 0\nbr i1 %7, label %B4, label %B5\n\nB3:\n%8 = icmp eq i32 %5, 0\nbr i1 %8, label %B5, label %B4\n\nB4:\n%9 = add nsw i32 %5, -1\nstore i32 %9, ptr @omap_set_vpp.count, align 4\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B5\n\nB5:\nret void\n}"}, "define dso_local void @ArenaPoke(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\nbr label %8\n\n8:\n%9 = load i32, ptr %4, align 4\n%10 = call i64 @ArenaCheck(i32 noundef %9)\n%11 = icmp ne i64 %10, 0\nbr i1 %11, label %12, label %16\n\n12:\nbr label %13\n\n13:\nbr label %14\n\n14:\nbr label %15\n\n15:\nbr label %18\n\n16:\n%17 = call i32 @mps_lib_assert_fail(ptr noundef @.str, i32 noundef 946, ptr noundef @.str.1)\nbr label %18\n\n18:\nbr label %19\n\n19:\nbr label %20\n\n20:\n%21 = load i32, ptr %4, align 4\n%22 = load ptr, ptr %5, align 8\n%23 = ptrtoint ptr %22 to i32\n%24 = call i64 @SegOfAddr(ptr noundef %7, i32 noundef %21, i32 noundef %23)\n%25 = icmp ne i64 %24, 0\nbr i1 %25, label %26, label %32\n\n26:\n%27 = load i32, ptr %4, align 4\n%28 = load i32, ptr %7, align 4\n%29 = load ptr, ptr %5, align 8\n%30 = load i32, ptr %6, align 4\n%31 = call i32 @ArenaPokeSeg(i32 noundef %27, i32 noundef %28, ptr noundef %29, i32 noundef %30)\nbr label %35\n\n32:\n%33 = load i32, ptr %6, align 4\n%34 = load ptr, ptr %5, align 8\nstore i32 %33, ptr %34, align 4\nbr label %35\n\n35:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret void\n}": {"base_truth": "define dso_local void @ArenaPoke(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = tail call i64 @ArenaCheck(i32 noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @mps_lib_assert_fail(ptr noundef nonnull @.str, i32 noundef 946, ptr noundef nonnull @.str.1)\nbr label %B2\n\nB2:\n%7 = ptrtoint ptr %1 to i64\n%8 = trunc i64 %7 to i32\n%9 = call i64 @SegOfAddr(ptr noundef nonnull %3, i32 noundef %0, i32 noundef %8)\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i32, ptr %3, align 4\n%12 = call i32 @ArenaPokeSeg(i32 noundef %0, i32 noundef %11, ptr noundef %1, i32 noundef %2)\nbr label %B5\n\nB4:\nstore i32 %2, ptr %1, align 4\nbr label %B5\n\nB5:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret void\n}", "codellama": "define dso_local void @ArenaPoke(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = tail call i64 @ArenaCheck(i32 noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @mps_lib_assert_fail(ptr noundef nonnull @.str, i32 noundef 946, ptr noundef nonnull @.str.1)\nbr label %B2\n\nB2:\n%7 = ptrtoint ptr %1 to i64\n%8 = trunc i64 %7 to i32\n%9 = call i64 @SegOfAddr(ptr noundef nonnull %3, i32 noundef %0, i32 noundef %8)\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i32, ptr %3, align 4\n%12 = call i32 @ArenaPokeSeg(i32 noundef %0, i32 noundef %11, ptr noundef %1, i32 noundef %2)\nbr label %B5\n\nB4:\nstore i32 %2, ptr %1, align 4\nbr label %B5\n\nB5:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret void\n}", "codegemma": "define dso_local void @ArenaPoke(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = tail call i64 @ArenaCheck(i32 noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @mps_lib_assert_fail(ptr noundef nonnull @.str, i32 noundef 946, ptr noundef nonnull @.str.1)\nbr label %B2\n\nB2:\n%7 = ptrtoint ptr %1 to i64\n%8 = call i64 @SegOfAddr(ptr noundef nonnull %3, i32 noundef %0, i64 noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = load i32, ptr %3, align 4\n%11 = call i32 @ArenaPokeSeg(i32 noundef %0, i32 noundef %10, ptr noundef %1, i32 noundef %2)\nbr label %B5\n\nB4:\nstore i32 %2, ptr %1, align 4\nbr label %B5\n\nB5:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret void\n}"}, "define internal i32 @dcp_sha_finup(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @dcp_sha_update_fx(ptr noundef %3, i32 noundef 1)\nret i32 %4\n}": {"base_truth": "define internal i32 @dcp_sha_finup(ptr noundef %0) {\nB:\n%1 = tail call i32 @dcp_sha_update_fx(ptr noundef %0, i32 noundef 1)\nret i32 %1\n}", "codellama": "define internal i32 @dcp_sha_finup(ptr noundef %0) {\nB:\n%1 = tail call i32 @dcp_sha_update_fx(ptr noundef %0, i32 noundef 1)\nret i32 %1\n}", "codegemma": "define internal i32 @dcp_sha_finup(ptr noundef %0) {\nB:\n%1 = tail call i32 @dcp_sha_update_fx(ptr noundef %0, i32 noundef 1)\nret i32 %1\n}"}, "define dso_local i32 @IsMacBroadcast(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %8, label %9\n\n8:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %26\n\n9:\nstore i32 0, ptr %4, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %4, align 4\n%12 = icmp slt i32 %11, 6\nbr i1 %12, label %13, label %25\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = load i32, ptr %4, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds i32, ptr %14, i64 %16\n%18 = load i32, ptr %17, align 4\n%19 = icmp ne i32 %18, 255\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %26\n\n21:\nbr label %22\n\n22:\n%23 = load i32, ptr %4, align 4\n%24 = add nsw i32 %23, 1\nstore i32 %24, ptr %4, align 4\nbr label %10\n\n25:\nstore i32 1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %26\n\n26:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%27 = load i32, ptr %2, align 4\nret i32 %27\n}": {"base_truth": "define dso_local i32 @IsMacBroadcast(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B7, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 255\nbr i1 %3, label %B2, label %B7\n\nB2:\n%4 = getelementptr inbounds i32, ptr %0, i64 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 255\nbr i1 %6, label %B3, label %B7\n\nB3:\n%7 = getelementptr inbounds i32, ptr %0, i64 2\n%8 = load i32, ptr %7, align 4\n%9 = icmp eq i32 %8, 255\nbr i1 %9, label %B4, label %B7\n\nB4:\n%10 = getelementptr inbounds i32, ptr %0, i64 3\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, 255\nbr i1 %12, label %B5, label %B7\n\nB5:\n%13 = getelementptr inbounds i32, ptr %0, i64 4\n%14 = load i32, ptr %13, align 4\n%15 = icmp eq i32 %14, 255\nbr i1 %15, label %B6, label %B7\n\nB6:\n%16 = getelementptr inbounds i32, ptr %0, i64 5\n%17 = load i32, ptr %16, align 4\n%18 = icmp eq i32 %17, 255\n%19 = zext i1 %18 to i32\nbr label %B7\n\nB7:\n%20 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ 0, %B3 ], [ 0, %B4 ], [ 0, %B5 ], [ %19, %B6 ]\nret i32 %20\n}", "codellama": "define dso_local i32 @IsMacBroadcast(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B4, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 255\nbr i1 %3, label %B2, label %B4\n\nB2:\n%4 = getelementptr inbounds i32, ptr %0, i64 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 255\nbr i1 %6, label %B3, label %B4\n\nB3:\n%7 = getelementptr inbounds i32, ptr %0, i64 2\n%8 = load i32, ptr %7, align 4\n%9 = icmp eq i32 %8, 255\n%10 = getelementptr inbounds i32, ptr %0, i64 3\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, 255\n%13 = select i1 %9, i1 %12, i1 false\n%14 = zext i1 %13 to i32\nbr label %B4\n\nB4:\n%15 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ %14, %B3 ]\nret i32 %15\n}", "codegemma": "define dso_local i32 @IsMacBroadcast(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B4, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 255\nbr i1 %3, label %B2, label %B4\n\nB2:\n%4 = getelementptr inbounds i32, ptr %0, i64 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 255\nbr i1 %6, label %B3, label %B4\n\nB3:\n%7 = getelementptr inbounds i32, ptr %0, i64 2\n%8 = load i32, ptr %7, align 4\n%9 = icmp eq i32 %8, 255\nbr i1 %9, label %B4, label %B4\n\nB4:\n%10 = phi i32 [ 0, %B ], [ 1, %B1 ], [ 0, %B2 ], [ 1, %B3 ]\nret i32 %10\n}"}, "define dso_local i32 @list_copy(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 1, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\nstore ptr null, ptr %7, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = icmp ne ptr %9, null\nbr i1 %10, label %11, label %14\n\n11:\n%12 = load ptr, ptr %5, align 8\n%13 = icmp ne ptr %12, null\nbr label %14\n\n14:\n%15 = phi i1 [ false, %2 ], [ %13, %11 ]\n%16 = zext i1 %15 to i32\n%17 = call i32 @assert(i32 noundef %16)\n%18 = load ptr, ptr %5, align 8\n%19 = getelementptr inbounds %struct.TYPE_10__, ptr %18, i32 0, i32 0\n%20 = load i32, ptr %19, align 4\n%21 = icmp eq i32 %20, 0\nbr i1 %21, label %22, label %23\n\n22:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %44\n\n23:\n%24 = load ptr, ptr %4, align 8\n%25 = call i32 @list_clear(ptr noundef %24)\nbr label %26\n\n26:\n%27 = load i32, ptr %6, align 4\n%28 = load ptr, ptr %5, align 8\n%29 = getelementptr inbounds %struct.TYPE_10__, ptr %28, i32 0, i32 0\n%30 = load i32, ptr %29, align 4\n%31 = icmp sle i32 %27, %30\nbr i1 %31, label %32, label %43\n\n32:\n%33 = load ptr, ptr %5, align 8\n%34 = load i32, ptr %6, align 4\n%35 = call ptr @list_get_num(ptr noundef %33, i32 noundef %34)\nstore ptr %35, ptr %7, align 8\n%36 = load ptr, ptr %4, align 8\n%37 = load ptr, ptr %7, align 8\n%38 = getelementptr inbounds %struct.TYPE_9__, ptr %37, i32 0, i32 0\n%39 = load i32, ptr %38, align 4\n%40 = call i32 @list_ins_tail_data(ptr noundef %36, i32 noundef %39)\n%41 = load i32, ptr %6, align 4\n%42 = add nsw i32 %41, 1\nstore i32 %42, ptr %6, align 4\nbr label %26\n\n43:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %44\n\n44:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%45 = load i32, ptr %3, align 4\nret i32 %45\n}": {"base_truth": "define dso_local i32 @list_copy(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\n%7 = load i32, ptr %1, align 4\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B1\n\nB1:\n%9 = tail call i32 @list_clear(ptr noundef %0)\n%10 = load i32, ptr %1, align 4\n%11 = icmp slt i32 %10, 1\nbr i1 %11, label %B3, label %B2\n\nB2:\n%12 = phi i32 [ %16, %B2 ], [ 1, %B1 ]\n%13 = tail call ptr @list_get_num(ptr noundef nonnull %1, i32 noundef %12)\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @list_ins_tail_data(ptr noundef %0, i32 noundef %14)\n%16 = add nuw nsw i32 %12, 1\n%17 = load i32, ptr %1, align 4\n%18 = icmp slt i32 %12, %17\nbr i1 %18, label %B2, label %B3\n\nB3:\nret i32 0\n}", "codellama": "define dso_local i32 @list_copy(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\n%7 = load i32, ptr %1, align 4\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B1\n\nB1:\n%9 = tail call i32 @list_clear(ptr noundef %0)\n%10 = load i32, ptr %1, align 4\n%11 = icmp slt i32 %10, 1\nbr i1 %11, label %B3, label %B2\n\nB2:\n%12 = phi i32 [ %17, %B2 ], [ 1, %B1 ]\n%13 = tail call ptr @list_get_num(ptr noundef nonnull %1, i32 noundef %12)\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @list_ins_tail_data(ptr noundef %0, i32 noundef %14)\n%16 = add nuw nsw i32 %12, 1\n%17 = icmp eq i32 %12, %10\nbr i1 %17, label %B3, label %B2\n\nB3:\n%18 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ]\nret i32 %18\n}", "codegemma": "define dso_local i32 @list_copy(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\n%7 = load i32, ptr %1, align 4\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B1\n\nB1:\n%9 = tail call i32 @list_clear(ptr noundef nonnull %0)\n%10 = load i32, ptr %1, align 4\n%11 = icmp slt i32 %10, 1\nbr i1 %11, label %B3, label %B2\n\nB2:\n%12 = phi i32 [ %16, %B2 ], [ 1, %B1 ]\n%13 = tail call ptr @list_get_num(ptr noundef nonnull %1, i32 noundef %12)\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @list_ins_tail_data(ptr noundef nonnull %0, i32 noundef %14)\n%16 = add nuw i32 %12, 1\n%17 = load i32, ptr %1, align 4\n%18 = icmp slt i32 %12, %17\nbr i1 %18, label %B2, label %B3\n\nB3:\nret i32 0\n}"}, "define internal i32 @i2400mu_resume(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.usb_interface, ptr %7, i32 0, i32 0\nstore ptr %8, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%9 = load ptr, ptr %2, align 8\n%10 = call ptr @usb_get_intfdata(ptr noundef %9)\nstore ptr %10, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%11 = load ptr, ptr %5, align 8\n%12 = getelementptr inbounds %struct.i2400mu ptr %11, i32 0, i32 0\nstore ptr %12, ptr %6, align 8\n%13 = load ptr, ptr %4, align 8\n%14 = load ptr, ptr %2, align 8\n%15 = call i32 @d_fnstart(i32 noundef 3, ptr noundef %13, ptr noundef @.str, ptr noundef %14)\n%16 = load ptr, ptr %6, align 8\n%17 = getelementptr inbounds %struct.i2400m ptr %16, i32 0, i32 0\n%18 = load i64, ptr %17, align 8\n%19 = icmp eq i64 %18, 0\nbr i1 %19, label %20, label %23\n\n20:\n%21 = load ptr, ptr %4, align 8\n%22 = call i32 @d_printf(i32 noundef 1, ptr noundef %21, ptr noundef @.str.1)\nbr label %28\n\n23:\n%24 = load ptr, ptr %4, align 8\n%25 = call i32 @d_printf(i32 noundef 1, ptr noundef %24, ptr noundef @.str.2)\n%26 = load ptr, ptr %5, align 8\n%27 = call i32 @i2400mu_notification_setup(ptr noundef %26)\nbr label %28\n\n28:\n%29 = load ptr, ptr %4, align 8\n%30 = load ptr, ptr %2, align 8\n%31 = load i32, ptr %3, align 4\n%32 = call i32 @d_fnend(i32 noundef 3, ptr noundef %29, ptr noundef @.str.3, ptr noundef %30, i32 noundef %31)\n%33 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %33\n}": {"base_truth": "define internal i32 @i2400mu_resume(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @d_fnstart(i32 noundef 3, ptr noundef %0, ptr noundef nonnull @.str, ptr noundef %0)\n%3 = load i64, ptr %1, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @d_printf(i32 noundef 1, ptr noundef %0, ptr noundef nonnull @.str.1)\nbr label %B3\n\nB2:\n%6 = tail call i32 @d_printf(i32 noundef 1, ptr noundef %0, ptr noundef nonnull @.str.2)\n%7 = tail call i32 @i2400mu_notification_setup(ptr noundef nonnull %1)\nbr label %B3\n\nB3:\n%8 = tail call i32 @d_fnend(i32 noundef 3, ptr noundef %0, ptr noundef nonnull @.str.3, ptr noundef %0, i32 noundef 0)\nret i32 0\n}", "codellama": "define internal i32 @i2400mu_resume(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @d_fnstart(i32 noundef 3, ptr noundef %0, ptr noundef nonnull @.str, ptr noundef %0)\n%3 = load i64, ptr %1, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @d_printf(i32 noundef 1, ptr noundef %0, ptr noundef nonnull @.str.1)\nbr label %B3\n\nB2:\n%6 = tail call i32 @d_printf(i32 noundef 1, ptr noundef %0, ptr noundef nonnull @.str.2)\n%7 = tail call i32 @i2400mu_notification_setup(ptr noundef nonnull %1)\nbr label %B3\n\nB3:\n%8 = tail call i32 @d_fnend(i32 noundef 3, ptr noundef %0, ptr noundef nonnull @.str.3, ptr noundef %0, i32 noundef 0)\nret i32 0\n}", "codegemma": "define internal i32 @i2400mu_resume(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @d_fnstart(i32 noundef 3, ptr noundef %0, ptr noundef nonnull @.str, ptr noundef %0)\n%3 = load i64, ptr %1, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @d_printf(i32 noundef 1, ptr noundef %0, ptr noundef nonnull @.str.1)\nbr label %B3\n\nB2:\n%6 = tail call i32 @d_printf(i32 noundef 1, ptr noundef %0, ptr noundef nonnull @.str.2)\n%7 = tail call i32 @i2400mu_notification_setup(ptr noundef nonnull %1)\nbr label %B3\n\nB3:\n%8 = tail call i32 @d_fnend(i32 noundef 3, ptr noundef %0, ptr noundef nonnull @.str.3, ptr noundef %0, i32 noundef 0)\nret i32 0\n}"}, "define internal void @test_dns_name_reverse() {\n%1 = call i32 @test_dns_name_reverse_one(ptr noundef @.str, ptr noundef @.str.1)\n%2 = call i32 @test_dns_name_reverse_one(ptr noundef @.str.2, ptr noundef @.str.3)\n%3 = call i32 @test_dns_name_reverse_one(ptr noundef @.str.4, ptr noundef @.str.5)\n%4 = call i32 @test_dns_name_reverse_one(ptr noundef @.str.6, ptr noundef @.str.7)\nret void\n}": {"base_truth": "define internal void @test_dns_name_reverse() {\nB:\n%0 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\n%1 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.3)\n%2 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.5)\n%3 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.6, ptr noundef nonnull @.str.7)\nret void\n}", "codellama": "define internal void @test_dns_name_reverse() {\nB:\n%0 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\n%1 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.3)\n%2 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.5)\n%3 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.6, ptr noundef nonnull @.str.7)\nret void\n}", "codegemma": "define internal void @test_dns_name_reverse() {\nB:\n%0 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\n%1 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.3)\n%2 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.5)\n%3 = tail call i32 @test_dns_name_reverse_one(ptr noundef nonnull @.str.6, ptr noundef nonnull @.str.7)\nret void\n}"}, "define dso_local i32 @buffer_close_(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore ptr null, ptr %3, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = icmp ne ptr %4, null\n%6 = zext i1 %5 to i32\n%7 = call i32 @assert(i32 noundef %6)\n%8 = load ptr, ptr %2, align 8\n%9 = call ptr @scew_reader_data(ptr noundef %8)\nstore ptr %9, ptr %3, align 8\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %13, i32 0, i32 1\nstore i32 %12, ptr %14, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 1\n}": {"base_truth": "define dso_local i32 @buffer_close_(ptr noundef %0) {\nB:\n%1 = icmp ne ptr %0, null\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @assert(i32 noundef %2)\n%4 = tail call ptr @scew_reader_data(ptr noundef %0)\n%5 = load i32, ptr %4, align 4\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i64 0, i32 1\nstore i32 %5, ptr %6, align 4\nret i32 1\n}", "codellama": "define dso_local i32 @buffer_close_(ptr noundef %0) {\nB:\n%1 = icmp ne ptr %0, null\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @assert(i32 noundef %2)\n%4 = tail call ptr @scew_reader_data(ptr noundef %0)\n%5 = load i32, ptr %4, align 4\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i64 0, i32 1\nstore i32 %5, ptr %6, align 4\nret i32 1\n}", "codegemma": "define dso_local i32 @buffer_close_(ptr noundef %0) {\nB:\n%1 = icmp ne ptr %0, null\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @assert(i32 noundef %2)\n%4 = tail call ptr @scew_reader_data(ptr noundef %0)\n%5 = load i32, ptr %4, align 4\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i64 0, i32 1\nstore i32 %5, ptr %6, align 4\nret i32 1\n}"}, "define dso_local ptr @luaH_getint(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca %struct.TYPE_7__, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load i32, ptr @LUA_T_NUMBER, align 4\n%7 = getelementptr inbounds %struct.TYPE_7__, ptr %5, i32 0, i32 1\nstore i32 %6, ptr %7, align 4\n%8 = load i32, ptr %4, align 4\n%9 = getelementptr inbounds %struct.TYPE_7__, ptr %5, i32 0, i32 0\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %9, i32 0, i32 0\nstore i32 %8, ptr %10, align 4\n%11 = load ptr, ptr %3, align 8\n%12 = call ptr @luaH_present(ptr noundef %11, ptr noundef %5)\n%13 = getelementptr inbounds %struct.TYPE_8__, ptr %12, i32 0, i32 0\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @luaH_getint(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_7__, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\n%3 = load i32, ptr @LUA_T_NUMBER, align 4\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %2, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\nstore i32 %1, ptr %2, align 4\n%5 = call ptr @luaH_present(ptr noundef %0, ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret ptr %5\n}", "codellama": "define dso_local ptr @luaH_getint(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_7__, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\n%3 = load i32, ptr @LUA_T_NUMBER, align 4\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %2, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\nstore i32 %1, ptr %2, align 4\n%5 = call ptr @luaH_present(ptr noundef %0, ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret ptr %5\n}", "codegemma": "define dso_local ptr @luaH_getint(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_7__, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\n%3 = load i32, ptr @LUA_T_NUMBER, align 4\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %2, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\nstore i32 %1, ptr %2, align 4\n%5 = call ptr @luaH_present(ptr noundef %0, ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret ptr %5\n}"}, "define internal void @log_exit(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.r5conf ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %7, label %10\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @r5l_exit_log(ptr noundef %8)\nbr label %18\n\n10:\n%11 = load ptr, ptr %2, align 8\n%12 = call i64 @raid5_has_ppl(ptr noundef %11)\n%13 = icmp ne i64 %12, 0\nbr i1 %13, label %14, label %17\n\n14:\n%15 = load ptr, ptr %2, align 8\n%16 = call i32 @ppl_exit_log(ptr noundef %15)\nbr label %17\n\n17:\nbr label %18\n\n18:\nret void\n}": {"base_truth": "define internal void @log_exit(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @r5l_exit_log(ptr noundef nonnull %0)\nbr label %B4\n\nB2:\n%4 = tail call i64 @raid5_has_ppl(ptr noundef nonnull %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B3\n\nB3:\n%6 = tail call i32 @ppl_exit_log(ptr noundef nonnull %0)\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define internal void @log_exit(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @r5l_exit_log(ptr noundef nonnull %0)\nbr label %B4\n\nB2:\n%4 = tail call i64 @raid5_has_ppl(ptr noundef nonnull %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B3\n\nB3:\n%6 = tail call i32 @ppl_exit_log(ptr noundef nonnull %0)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define internal void @log_exit(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @r5l_exit_log(ptr noundef nonnull %0)\nbr label %B4\n\nB2:\n%4 = tail call i64 @raid5_has_ppl(ptr noundef nonnull %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B3\n\nB3:\n%6 = tail call i32 @ppl_exit_log(ptr noundef nonnull %0)\nbr label %B4\n\nB4:\nret void\n}"}, "define internal void @ltq_cputemp_enable() {\n%1 = load i32, ptr @CGU_GPHY1_CR, align 4\n%2 = call i32 @ltq_cgu_r32(i32 noundef %1)\n%3 = load i32, ptr @CGU_TEMP_PD, align 4\n%4 = or i32 %2, %3\n%5 = load i32, ptr @CGU_GPHY1_CR, align 4\n%6 = call i32 @ltq_cgu_w32(i32 noundef %4, i32 noundef %5)\nret void\n}": {"base_truth": "define internal void @ltq_cputemp_enable() {\nB:\n%0 = load i32, ptr @CGU_GPHY1_CR, align 4\n%1 = tail call i32 @ltq_cgu_r32(i32 noundef %0)\n%2 = load i32, ptr @CGU_TEMP_PD, align 4\n%3 = or i32 %2, %1\n%4 = load i32, ptr @CGU_GPHY1_CR, align 4\n%5 = tail call i32 @ltq_cgu_w32(i32 noundef %3, i32 noundef %4)\nret void\n}", "codellama": "define internal void @ltq_cputemp_enable() {\nB:\n%0 = load i32, ptr @CGU_GPHY1_CR, align 4\n%1 = tail call i32 @ltq_cgu_r32(i32 noundef %0)\n%2 = load i32, ptr @CGU_TEMP_PD, align 4\n%3 = or i32 %2, %1\n%4 = load i32, ptr @CGU_GPHY1_CR, align 4\n%5 = tail call i32 @ltq_cgu_w32(i32 noundef %3, i32 noundef %4)\nret void\n}", "codegemma": "define internal void @ltq_cputemp_enable() {\nB:\n%0 = load i32, ptr @CGU_GPHY1_CR, align 4\n%1 = tail call i32 @ltq_cgu_r32(i32 noundef %0)\n%2 = load i32, ptr @CGU_TEMP_PD, align 4\n%3 = or i32 %2, %1\n%4 = load i32, ptr @CGU_GPHY1_CR, align 4\n%5 = tail call i32 @ltq_cgu_w32(i32 noundef %3, i32 noundef %4)\nret void\n}"}, "define dso_local void @_dl_parse_lazy_relocation_information(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca i64, align 8\n%7 = alloca i64, align 8\n%8 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i64 %1, ptr %6, align 8\nstore i64 %2, ptr %7, align 8\nstore i32 %3, ptr %8, align 4\n%9 = load i32, ptr %8, align 4\n%10 = load ptr, ptr %5, align 8\n%11 = load i64, ptr %6, align 8\n%12 = load i64, ptr %7, align 8\n%13 = load i32, ptr @_dl_do_lazy_reloc, align 4\n%14 = call i32 @_dl_parse(ptr noundef %10, ptr noundef null, i64 noundef %11, i64 noundef %12, i32 noundef %13)\nret void\n}": {"base_truth": "define dso_local void @_dl_parse_lazy_relocation_information(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr @_dl_do_lazy_reloc, align 4\n%5 = tail call i32 @_dl_parse(ptr noundef %0, ptr noundef null, i64 noundef %1, i64 noundef %2, i32 noundef %4)\nret void\n}", "codellama": "define dso_local void @_dl_parse_lazy_relocation_information(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr @_dl_do_lazy_reloc, align 4\n%5 = tail call i32 @_dl_parse(ptr noundef %0, ptr noundef null, i64 noundef %1, i64 noundef %2, i32 noundef %4)\nret void\n}", "codegemma": "define dso_local void @_dl_parse_lazy_relocation_information(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr @_dl_do_lazy_reloc, align 4\n%5 = tail call i32 @_dl_parse(ptr noundef %0, ptr noundef null, i64 noundef %1, i64 noundef %2, i32 noundef %4)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 31, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 3, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 2016, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 0, ptr %5, align 4\n%6 = load i32, ptr %4, align 4\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr %2, align 4\n%9 = call i32 @day_of_year(i32 noundef %6, i32 noundef %7, i32 noundef %8)\nstore i32 %9, ptr %5, align 4\n%10 = load i32, ptr %2, align 4\n%11 = load i32, ptr %3, align 4\n%12 = load i32, ptr %4, align 4\n%13 = load i32, ptr %5, align 4\n%14 = call i32 @printf(ptr noundef @.str, i32 noundef %10, i32 noundef %11, i32 noundef %12, i32 noundef %13)\n%15 = load i32, ptr %5, align 4\n%16 = add nsw i32 %15, 1\nstore i32 %16, ptr %5, align 4\n%17 = load i32, ptr %4, align 4\n%18 = load i32, ptr %5, align 4\n%19 = call i32 @month_day(i32 noundef %17, i32 noundef %18, ptr noundef %3, ptr noundef %2)\n%20 = load i32, ptr %2, align 4\n%21 = load i32, ptr %3, align 4\n%22 = load i32, ptr %4, align 4\n%23 = load i32, ptr %5, align 4\n%24 = call i32 @printf(ptr noundef @.str, i32 noundef %20, i32 noundef %21, i32 noundef %22, i32 noundef %23)\n%25 = call i32 (...) @getchar()\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 31, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 3, ptr %1, align 4\n%2 = tail call i32 @day_of_year(i32 noundef 2016, i32 noundef 3, i32 noundef 31)\n%3 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 31, i32 noundef 3, i32 noundef 2016, i32 noundef %2)\n%4 = add nsw i32 %2, 1\n%5 = call i32 @month_day(i32 noundef 2016, i32 noundef %4, ptr noundef nonnull %1, ptr noundef nonnull %0)\n%6 = load i32, ptr %0, align 4\n%7 = load i32, ptr %1, align 4\n%8 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6, i32 noundef %7, i32 noundef 2016, i32 noundef %4)\n%9 = call i32 (...) @getchar()\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 3, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 31, ptr %1, align 4\n%2 = tail call i32 @day_of_year(i32 noundef 2016, i32 noundef 3, i32 noundef 31)\n%3 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 31, i32 noundef 3, i32 noundef 2016, i32 noundef %2)\n%4 = add nsw i32 %2, 1\n%5 = call i32 @month_day(i32 noundef 2016, i32 noundef %4, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr %0, align 4\n%8 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6, i32 noundef %7, i32 noundef 2016, i32 noundef %4)\n%9 = call i32 (...) @getchar()\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 3, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 2016, ptr %1, align 4\n%2 = call i32 @day_of_year(i32 noundef 2016, i32 noundef 3, i32 noundef 31)\n%3 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef 31, i32 noundef 3, i32 noundef 2016, i32 noundef %2)\n%4 = add nsw i32 %2, 1\n%5 = call i32 @month_day(i32 noundef 2016, i32 noundef %4, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%6 = load i32, ptr %0, align 4\n%7 = load i32, ptr %1, align 4\n%8 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6, i32 noundef %7, i32 noundef 2016, i32 noundef %4)\n%9 = call i32 (...) @getchar()\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local void @startscrolldiagleft(i8 noundef zeroext %0, i8 noundef zeroext %1) {\n%3 = alloca i8, align 1\n%4 = alloca i8, align 1\nstore i8 %0, ptr %3, align 1\nstore i8 %1, ptr %4, align 1\n%5 = load i32, ptr @I2C_DEV_2, align 4\n%6 = call i32 @i2c_write_register(i32 noundef %5, i32 noundef 0, i32 noundef 163)\n%7 = icmp eq i32 %6, 2\nbr i1 %7, label %8, label %9\n\n8:\nbr label %11\n\n9:\n%10 = call i32 @exit(i32 noundef 1)\nunreachable\n\n11:\n%12 = load i32, ptr @I2C_DEV_2, align 4\n%13 = call i32 @i2c_write_register(i32 noundef %12, i32 noundef 0, i32 noundef 0)\n%14 = icmp eq i32 %13, 2\nbr i1 %14, label %15, label %16\n\n15:\nbr label %18\n\n16:\n%17 = call i32 @exit(i32 noundef 1)\nunreachable\n\n18:\n%19 = load i32, ptr @I2C_DEV_2, align 4\n%20 = call i32 @i2c_write_register(i32 noundef %19, i32 noundef 0, i32 noundef 32)\n%21 = icmp eq i32 %20, 2\nbr i1 %21, label %22, label %23\n\n22:\nbr label %25\n\n23:\n%24 = call i32 @exit(i32 noundef 1)\nunreachable\n\n25:\n%26 = load i32, ptr @I2C_DEV_2, align 4\n%27 = call i32 @i2c_write_register(i32 noundef %26, i32 noundef 0, i32 noundef 42)\n%28 = icmp eq i32 %27, 2\nbr i1 %28, label %29, label %30\n\n29:\nbr label %32\n\n30:\n%31 = call i32 @exit(i32 noundef 1)\nunreachable\n\n32:\n%33 = load i32, ptr @I2C_DEV_2, align 4\n%34 = call i32 @i2c_write_register(i32 noundef %33, i32 noundef 0, i32 noundef 0)\n%35 = icmp eq i32 %34, 2\nbr i1 %35, label %36, label %37\n\n36:\nbr label %39\n\n37:\n%38 = call i32 @exit(i32 noundef 1)\nunreachable\n\n39:\n%40 = load i32, ptr @I2C_DEV_2, align 4\n%41 = load i8, ptr %3, align 1\n%42 = zext i8 %41 to i32\n%43 = call i32 @i2c_write_register(i32 noundef %40, i32 noundef 0, i32 noundef %42)\n%44 = icmp eq i32 %43, 2\nbr i1 %44, label %45, label %46\n\n45:\nbr label %48\n\n46:\n%47 = call i32 @exit(i32 noundef 1)\nunreachable\n\n48:\n%49 = load i32, ptr @I2C_DEV_2, align 4\n%50 = call i32 @i2c_write_register(i32 noundef %49, i32 noundef 0, i32 noundef 0)\n%51 = icmp eq i32 %50, 2\nbr i1 %51, label %52, label %53\n\n52:\nbr label %55\n\n53:\n%54 = call i32 @exit(i32 noundef 1)\nunreachable\n\n55:\n%56 = load i32, ptr @I2C_DEV_2, align 4\n%57 = load i8, ptr %4, align 1\n%58 = zext i8 %57 to i32\n%59 = call i32 @i2c_write_register(i32 noundef %56, i32 noundef 0, i32 noundef %58)\n%60 = icmp eq i32 %59, 2\nbr i1 %60, label %61, label %62\n\n61:\nbr label %64\n\n62:\n%63 = call i32 @exit(i32 noundef 1)\nunreachable\n\n64:\n%65 = load i32, ptr @I2C_DEV_2, align 4\n%66 = call i32 @i2c_write_register(i32 noundef %65, i32 noundef 0, i32 noundef 1)\n%67 = icmp eq i32 %66, 2\nbr i1 %67, label %68, label %69\n\n68:\nbr label %71\n\n69:\n%70 = call i32 @exit(i32 noundef 1)\nunreachable\n\n71:\n%72 = load i32, ptr @I2C_DEV_2, align 4\n%73 = call i32 @i2c_write_register(i32 noundef %72, i32 noundef 0, i32 noundef 47)\n%74 = icmp eq i32 %73, 2\nbr i1 %74, label %75, label %76\n\n75:\nbr label %78\n\n76:\n%77 = call i32 @exit(i32 noundef 1)\nunreachable\n\n78:\nret void\n}": {"base_truth": "define dso_local void @startscrolldiagleft(i8 noundef zeroext %0, i8 noundef zeroext %1) {\nB:\n%2 = load i32, ptr @I2C_DEV_2, align 4\n%3 = tail call i32 @i2c_write_register(i32 noundef %2, i32 noundef 0, i32 noundef 163)\n%4 = icmp eq i32 %3, 2\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%6 = load i32, ptr @I2C_DEV_2, align 4\n%7 = tail call i32 @i2c_write_register(i32 noundef %6, i32 noundef 0, i32 noundef 0)\n%8 = icmp eq i32 %7, 2\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB4:\n%10 = load i32, ptr @I2C_DEV_2, align 4\n%11 = tail call i32 @i2c_write_register(i32 noundef %10, i32 noundef 0, i32 noundef 32)\n%12 = icmp eq i32 %11, 2\nbr i1 %12, label %B6, label %B5\n\nB5:\n%13 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB6:\n%14 = load i32, ptr @I2C_DEV_2, align 4\n%15 = tail call i32 @i2c_write_register(i32 noundef %14, i32 noundef 0, i32 noundef 42)\n%16 = icmp eq i32 %15, 2\nbr i1 %16, label %B8, label %B7\n\nB7:\n%17 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB8:\n%18 = load i32, ptr @I2C_DEV_2, align 4\n%19 = tail call i32 @i2c_write_register(i32 noundef %18, i32 noundef 0, i32 noundef 0)\n%20 = icmp eq i32 %19, 2\nbr i1 %20, label %B10, label %B9\n\nB9:\n%21 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB10:\n%22 = load i32, ptr @I2C_DEV_2, align 4\n%23 = zext i8 %0 to i32\n%24 = tail call i32 @i2c_write_register(i32 noundef %22, i32 noundef 0, i32 noundef %23)\n%25 = icmp eq i32 %24, 2\nbr i1 %25, label %B12, label %B11\n\nB11:\n%26 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB12:\n%27 = load i32, ptr @I2C_DEV_2, align 4\n%28 = tail call i32 @i2c_write_register(i32 noundef %27, i32 noundef 0, i32 noundef 0)\n%29 = icmp eq i32 %28, 2\nbr i1 %29, label %B14, label %B13\n\nB13:\n%30 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB14:\n%31 = load i32, ptr @I2C_DEV_2, align 4\n%32 = zext i8 %1 to i32\n%33 = tail call i32 @i2c_write_register(i32 noundef %31, i32 noundef 0, i32 noundef %32)\n%34 = icmp eq i32 %33, 2\nbr i1 %34, label %B16, label %B15\n\nB15:\n%35 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB16:\n%36 = load i32, ptr @I2C_DEV_2, align 4\n%37 = tail call i32 @i2c_write_register(i32 noundef %36, i32 noundef 0, i32 noundef 1)\n%38 = icmp eq i32 %37, 2\nbr i1 %38, label %B18, label %B17\n\nB17:\n%39 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB18:\n%40 = load i32, ptr @I2C_DEV_2, align 4\n%41 = tail call i32 @i2c_write_register(i32 noundef %40, i32 noundef 0, i32 noundef 47)\n%42 = icmp eq i32 %41, 2\nbr i1 %42, label %B20, label %B19\n\nB19:\n%43 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB20:\nret void\n}", "codellama": "define dso_local void @startscrolldiagleft(i8 noundef zeroext %0, i8 noundef zeroext %1) {\nB:\n%2 = load i32, ptr @I2C_DEV_2, align 4\n%3 = tail call i32 @i2c_write_register(i32 noundef %2, i32 noundef 0, i32 noundef 163)\n%4 = icmp eq i32 %3, 2\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%6 = load i32, ptr @I2C_DEV_2, align 4\n%7 = tail call i32 @i2c_write_register(i32 noundef %6, i32 noundef 0, i32 noundef 0)\n%8 = icmp eq i32 %7, 2\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB4:\n%10 = load i32, ptr @I2C_DEV_2, align 4\n%11 = tail call i32 @i2c_write_register(i32 noundef %10, i32 noundef 0, i32 noundef 32)\n%12 = icmp eq i32 %11, 2\nbr i1 %12, label %B6, label %B5\n\nB5:\n%13 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB6:\n%14 = load i32, ptr @I2C_DEV_2, align 4\n%15 = tail call i32 @i2c_write_register(i32 noundef %14, i32 noundef 0, i32 noundef 42)\n%16 = icmp eq i32 %15, 2\nbr i1 %16, label %B8, label %B7\n\nB7:\n%17 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB8:\n%18 = load i32, ptr @I2C_DEV_2, align 4\n%19 = tail call i32 @i2c_write_register(i32 noundef %18, i32 noundef 0, i32 noundef 0)\n%20 = icmp eq i32 %19, 2\nbr i1 %20, label %B9, label %B10\n\nB9:\n%21 = tail call i32 @i2c_write_register(i32 noundef %18, i32 noundef 0, i32 noundef %0)\n%22 = icmp eq i32 %21, 2\nbr i1 %22, label %B11, label %B10\n\nB10:\n%</s>", "codegemma": "define dso_local void @startscrolldiagleft(i8 noundef zeroext %0, i8 noundef zeroext %1) {\nB:\n%2 = load i32, ptr @I2C_DEV_2, align 4\n%3 = tail call i32 @i2c_write_register(i32 noundef %2, i32 noundef 0, i32 noundef 163)\n%4 = icmp eq i32 %3, 2\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\n%6 = load i32, ptr @I2C_DEV_2, align 4\n%7 = tail call i32 @i2c_write_register(i32 noundef %6, i32 noundef 0, i32 noundef 0)\n%8 = icmp eq i32 %7, 2\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB4:\n%10 = load i32, ptr @I2C_DEV_2, align 4\n%11 = tail call i32 @i2c_write_register(i32 noundef %10, i32 noundef 0, i32 noundef 32)\n%12 = icmp eq i32 %11, 2\nbr i1 %12, label %B6, label %B5\n\nB5:\n%13 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB6:\n%14 = load i32, ptr @I2C_DEV_2, align 4\n%15 = tail call i32 @i2c_write_register(i32 noundef %14, i32 noundef 0, i32 noundef 42)\n%16 = icmp eq i32 %15, 2\nbr i1 %16, label %B8, label %B7\n\nB7:\n%17 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB8:\n%18 = load i32, ptr @I2C_DEV_2, align 4\n%19 = tail call i32 @i2c_write_register(i32 noundef %18, i32 noundef 0, i32 noundef 0)\n%20 = icmp eq i32 %19, 2\nbr i1 %20, label %B10, label %B9\n\nB9:\n%21 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB10:\n%22 = zext i8 %0 to i32\n%23 = load i32, ptr @I2C_DEV_2, align 4\n%24 = tail call i32 @i2c_write_register(i32 noundef %23, i32 noundef 0, i32 noundef %22)\n%25 = icmp eq i32 %24, 2\nbr i1 %25, label %B12, label %B11\n\nB11:\n%26 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB12:\n%27 = load i32, ptr @I2<eos>"}, "define internal i32 @smk_open_cipso(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = call i32 @seq_open(ptr noundef %5, ptr noundef @cipso_seq_ops)\nret i32 %6\n}": {"base_truth": "define internal i32 @smk_open_cipso(ptr nocapture noundef readnone %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @seq_open(ptr noundef %1, ptr noundef nonnull @cipso_seq_ops)\nret i32 %2\n}", "codellama": "define internal i32 @smk_open_cipso(ptr nocapture noundef readnone %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @seq_open(ptr noundef %1, ptr noundef nonnull @cipso_seq_ops)\nret i32 %2\n}", "codegemma": "define internal i32 @smk_open_cipso(ptr nocapture noundef readnone %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @seq_open(ptr noundef %1, ptr noundef nonnull @cipso_seq_ops)\nret i32 %2\n}"}, "define dso_local void @tcb_write(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @lib3ds_io_write_word(ptr noundef %5, i32 noundef %8)\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = load i32, ptr @LIB3DS_KEY_USE_TENS, align 4\n%14 = and i32 %12, %13\n%15 = icmp ne i32 %14, 0\nbr i1 %15, label %16, label %22\n\n16:\n%17 = load ptr, ptr %4, align 8\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.TYPE_3__, ptr %18, i32 0, i32 5\n%20 = load i32, ptr %19, align 4\n%21 = call i32 @lib3ds_io_write_float(ptr noundef %17, i32 noundef %20)\nbr label %22\n\n22:\n%23 = load ptr, ptr %3, align 8\n%24 = getelementptr inbounds %struct.TYPE_3__, ptr %23, i32 0, i32 0\n%25 = load i32, ptr %24, align 4\n%26 = load i32, ptr @LIB3DS_KEY_USE_CONT, align 4\n%27 = and i32 %25, %26\n%28 = icmp ne i32 %27, 0\nbr i1 %28, label %29, label %35\n\n29:\n%30 = load ptr, ptr %4, align 8\n%31 = load ptr, ptr %3, align 8\n%32 = getelementptr inbounds %struct.TYPE_3__, ptr %31, i32 0, i32 4\n%33 = load i32, ptr %32, align 4\n%34 = call i32 @lib3ds_io_write_float(ptr noundef %30, i32 noundef %33)\nbr label %35\n\n35:\n%36 = load ptr, ptr %3, align 8\n%37 = getelementptr inbounds %struct.TYPE_3__, ptr %36, i32 0, i32 0\n%38 = load i32, ptr %37, align 4\n%39 = load i32, ptr @LIB3DS_KEY_USE_BIAS, align 4\n%40 = and i32 %38, %39\n%41 = icmp ne i32 %40, 0\nbr i1 %41, label %42, label %48\n\n42:\n%43 = load ptr, ptr %4, align 8\n%44 = load ptr, ptr %3, align 8\n%45 = getelementptr inbounds %struct.TYPE_3__, ptr %44, i32 0, i32 3\n%46 = load i32, ptr %45, align 4\n%47 = call i32 @lib3ds_io_write_float(ptr noundef %43, i32 noundef %46)\nbr label %48\n\n48:\n%49 = load ptr, ptr %3, align 8\n%50 = getelementptr inbounds %struct.TYPE_3__, ptr %49, i32 0, i32 0\n%51 = load i32, ptr %50, align 4\n%52 = load i32, ptr @LIB3DS_KEY_USE_EASE_TO, align 4\n%53 = and i32 %51, %52\n%54 = icmp ne i32 %53, 0\nbr i1 %54, label %55, label %61\n\n55:\n%56 = load ptr, ptr %4, align 8\n%57 = load ptr, ptr %3, align 8\n%58 = getelementptr inbounds %struct.TYPE_3__, ptr %57, i32 0, i32 2\n%59 = load i32, ptr %58, align 4\n%60 = call i32 @lib3ds_io_write_float(ptr noundef %56, i32 noundef %59)\nbr label %61\n\n61:\n%62 = load ptr, ptr %3, align 8\n%63 = getelementptr inbounds %struct.TYPE_3__, ptr %62, i32 0, i32 0\n%64 = load i32, ptr %63, align 4\n%65 = load i32, ptr @LIB3DS_KEY_USE_EASE_FROM, align 4\n%66 = and i32 %64, %65\n%67 = icmp ne i32 %66, 0\nbr i1 %67, label %68, label %74\n\n68:\n%69 = load ptr, ptr %4, align 8\n%70 = load ptr, ptr %3, align 8\n%71 = getelementptr inbounds %struct.TYPE_3__, ptr %70, i32 0, i32 1\n%72 = load i32, ptr %71, align 4\n%73 = call i32 @lib3ds_io_write_float(ptr noundef %69, i32 noundef %72)\nbr label %74\n\n74:\nret void\n}": {"base_truth": "define dso_local void @tcb_write(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @lib3ds_io_write_word(ptr noundef %1, i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @LIB3DS_KEY_USE_TENS, align 4\n%6 = and i32 %5, %4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 5\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %9)\n%11 = load i32, ptr %0, align 4\nbr label %B2\n\nB2:\n%12 = phi i32 [ %11, %B1 ], [ %4, %B ]\n%13 = load i32, ptr @LIB3DS_KEY_USE_CONT, align 4\n%14 = and i32 %13, %12\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B4, label %B3\n\nB3:\n%16 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 4\n%17 = load i32, ptr %16, align 4\n%18 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %17)\n%19 = load i32, ptr %0, align 4\nbr label %B4\n\nB4:\n%20 = phi i32 [ %19, %B3 ], [ %12, %B2 ]\n%21 = load i32, ptr @LIB3DS_KEY_USE_BIAS, align 4\n%22 = and i32 %21, %20\n%23 = icmp eq i32 %22, 0\nbr i1 %23, label %B6, label %B5\n\nB5:\n%24 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%25 = load i32, ptr %24, align 4\n%26 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %25)\n%27 = load i32, ptr %0, align 4\nbr label %B6\n\nB6:\n%28 = phi i32 [ %27, %B5 ], [ %20, %B4 ]\n%29 = load i32, ptr @LIB3DS_KEY_USE_EASE_TO, align 4\n%30 = and i32 %29, %28\n%31 = icmp eq i32 %30, 0\nbr i1 %31, label %B8, label %B7\n\nB7:\n%32 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%33 = load i32, ptr %32, align 4\n%34 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %33)\n%35 = load i32, ptr %0, align 4\nbr label %B8\n\nB8:\n%36 = phi i32 [ %35, %B7 ], [ %28, %B6 ]\n%37 = load i32, ptr @LIB3DS_KEY_USE_EASE_FROM, align 4\n%38 = and i32 %37, %36\n%39 = icmp eq i32 %38, 0\nbr i1 %39, label %B10, label %B9\n\nB9:\n%40 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%41 = load i32, ptr %40, align 4\n%42 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %41)\nbr label %B10\n\nB10:\nret void\n}", "codellama": "define dso_local void @tcb_write(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @lib3ds_io_write_word(ptr noundef %1, i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @LIB3DS_KEY_USE_TENS, align 4\n%6 = and i32 %5, %4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 5\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %9)\n%11 = load i32, ptr %0, align 4\nbr label %B2\n\nB2:\n%12 = phi i32 [ %11, %B1 ], [ %4, %B ]\n%13 = load i32, ptr @LIB3DS_KEY_USE_CONT, align 4\n%14 = and i32 %13, %12\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B4, label %B3\n\nB3:\n%16 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 4\n%17 = load i32, ptr %16, align 4\n%18 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %17)\n%19 = load i32, ptr %0, align 4\nbr label %B4\n\nB4:\n%20 = phi i32 [ %19, %B3 ], [ %12, %B2 ]\n%21 = load i32, ptr @LIB3DS_KEY_USE_BIAS, align 4\n%22 = and i32 %21, %20\n%23 = icmp eq i32 %22, 0\nbr i1 %23, label %B6, label %B5\n\nB5:\n%24 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%25 = load i32, ptr %24, align 4\n%26 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %25)\n%27 = load i32, ptr %0, align 4\nbr label %B6\n\nB6:\n%28 = phi i32 [ %27, %B5 ], [ %20, %B4 ]\n%29 = load i32, ptr @LIB3DS_KEY_USE_EASE_TO, align 4\n%30 = and i32 %29, %28\n%31 = icmp eq i32 %30, 0\nbr i1 %31, label %B8, label %B7\n\nB7:\n%32 = getelementptr inbounds %struct.</s>", "codegemma": "define dso_local void @tcb_write(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @lib3ds_io_write_word(ptr noundef %1, i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @LIB3DS_KEY_USE_TENS, align 4\n%6 = and i32 %5, %4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 5\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %9)\n%11 = load i32, ptr %0, align 4\nbr label %B2\n\nB2:\n%12 = phi i32 [ %11, %B1 ], [ %4, %B ]\n%13 = load i32, ptr @LIB3DS_KEY_USE_CONT, align 4\n%14 = and i32 %13, %12\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B4, label %B3\n\nB3:\n%16 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 4\n%17 = load i32, ptr %16, align 4\n%18 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %17)\n%19 = load i32, ptr %0, align 4\nbr label %B4\n\nB4:\n%20 = phi i32 [ %19, %B3 ], [ %12, %B2 ]\n%21 = load i32, ptr @LIB3DS_KEY_USE_BIAS, align 4\n%22 = and i32 %21, %20\n%23 = icmp eq i32 %22, 0\nbr i1 %23, label %B6, label %B5\n\nB5:\n%24 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%25 = load i32, ptr %24, align 4\n%26 = tail call i32 @lib3ds_io_write_float(ptr noundef %1, i32 noundef %25)\n%27 = load i32, ptr %0, align 4\nbr label %B6\n\nB6:\n%28 = phi i32 [ %27, %B5 ], [ %20, %B4 ]\n%29 = load i32, ptr @LIB3DS_KEY_USE_EASE_TO, align 4\n%30 = and i32 %29, %28\n%31 = icmp eq i32 %30, 0\nbr i1 %31, label %B8, label %B7\n\nB7:\n%32 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%33 = load i32, ptr %32, align 4\n%34 = tail call i32 @lib3ds<eos>"}, "define dso_local i32 @dot_product_nd(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\nstore i32 0, ptr %8, align 4\nstore i32 0, ptr %7, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %7, align 4\n%11 = load i32, ptr %6, align 4\n%12 = icmp slt i32 %10, %11\nbr i1 %12, label %13, label %30\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = load i32, ptr %7, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds i32, ptr %14, i64 %16\n%18 = load i32, ptr %17, align 4\n%19 = load ptr, ptr %5, align 8\n%20 = load i32, ptr %7, align 4\n%21 = sext i32 %20 to i64\n%22 = getelementptr inbounds i32, ptr %19, i64 %21\n%23 = load i32, ptr %22, align 4\n%24 = mul nsw i32 %18, %23\n%25 = load i32, ptr %8, align 4\n%26 = add nsw i32 %25, %24\nstore i32 %26, ptr %8, align 4\nbr label %27\n\n27:\n%28 = load i32, ptr %7, align 4\n%29 = add nsw i32 %28, 1\nstore i32 %29, ptr %7, align 4\nbr label %9\n\n30:\n%31 = load i32, ptr %8, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret i32 %31\n}": {"base_truth": "define dso_local i32 @dot_product_nd(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B7\n\nB1:\n%4 = zext i32 %2 to i64\n%5 = icmp ult i32 %2, 32\nbr i1 %5, label %B5, label %B2\n\nB2:\n%6 = and i64 %4, 4294967264\nbr label %B3\n\nB3:\n%7 = phi i64 [ 0, %B2 ], [ %36, %B3 ]\n%8 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %32, %B3 ]\n%9 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %33, %B3 ]\n%10 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %34, %B3 ]\n%11 = phi <8 x i32> [ zeroinitializer, %B2 ], [ %35, %B3 ]\n%12 = getelementptr inbounds i32, ptr %0, i64 %7\n%13 = load <8 x i32>, ptr %12, align 4\n%14 = getelementptr inbounds i32, ptr %12, i64 8\n%15 = load <8 x i32>, ptr %14, align 4\n%16 = getelementptr inbounds i32, ptr %12, i64 16\n%17 = load <8 x i32>, ptr %16, align 4\n%18 = getelementptr inbounds i32, ptr %12, i64 24\n%19 = load <8 x i32>, ptr %18, align 4\n%20 = getelementptr inbounds i32, ptr %1, i64 %7\n%21 = load <8 x i32>, ptr %20, align 4\n%22 = getelementptr inbounds i32, ptr %20, i64 8\n%23 = load <8 x i32>, ptr %22, align 4\n%24 = getelementptr inbounds i32, ptr %20, i64 16\n%25 = load <8 x i32>, ptr %24, align 4\n%26 = getelementptr inbounds i32, ptr %20, i64 24\n%27 = load <8 x i32>, ptr %26, align 4\n%28 = mul nsw <8 x i32> %21, %13\n%29 = mul nsw <8 x i32> %23, %15\n%30 = mul nsw <8 x i32> %25, %17\n%31 = mul nsw <8 x i32> %27, %19\n%32 = add <8 x i32> %28, %8\n%33 = add <8 x i32> %29, %9\n%34 = add <8 x i32> %30, %10\n%35 = add <8 x i32> %31, %11\n%36 = add nuw i64 %7, 32\n%37 = icmp eq i64 %36, %6\nbr i1 %37, label %B4, label %B3\n\nB4:\n%38 = add <8 x i32> %33, %32\n%39 = add <8 x i32> %34, %38\n%40 = add <8 x i32> %35, %39\n%41 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %40)\n%42 = icmp eq i64 %6, %4\nbr i1 %42, label %B7, label %B5\n\nB5:\n%43 = phi i64 [ 0, %B1 ], [ %6, %B4 ]\n%44 = phi i32 [ 0, %B1 ], [ %41, %B4 ]\nbr label %B6\n\nB6:\n%45 = phi i64 [ %53, %B6 ], [ %43, %B5 ]\n%46 = phi i32 [ %52, %B6 ], [ %44, %B5 ]\n%47 = getelementptr inbounds i32, ptr %0, i64 %45\n%48 = load i32, ptr %47, align 4\n%49 = getelementptr inbounds i32, ptr %1, i64 %45\n%50 = load i32, ptr %49, align 4\n%51 = mul nsw i32 %50, %48\n%52 = add nsw i32 %51, %46\n%53 = add nuw nsw i64 %45, 1\n%54 = icmp eq i64 %53, %4\nbr i1 %54, label %B7, label %B6\n\nB7:\n%55 = phi i32 [ 0, %B ], [ %41, %B4 ], [ %52, %B6 ]\nret i32 %55\n}", "codellama": "define dso_local i32 @dot_product_nd(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B7\n\nB1:\n%4 = zext i32 %2 to i64\n%5 = icmp ult i32 %2, 16\nbr i1 %5, label %B5, label %B2\n\nB2:\n%6 = and i64 %4, 4294967280\nbr label %B3\n\nB3:\n%7 = phi i64 [ 0, %B2 ], [ %33, %B3 ]\n%8 = phi <4 x i32> [ zeroinitializer, %B2 ], [ %29, %B3 ]\n%9 = phi <4 x i32> [ zeroinitializer, %B2 ], [ %30, %B3 ]\n%10 = phi <4 x i32> [ zeroinitializer, %B2 ], [ %31, %B3 ]\n%11 = phi <4 x i32> [ zeroinitializer, %B2 ], [ %32, %B3 ]\n%12 = getelementptr inbounds i32, ptr %0, i64 %7\n%13 = load <4 x i32>, ptr %12, align 4\n%14 = getelementptr inbounds i32, ptr %12, i64 4\n%15 = load <4 x i32>, ptr %14, align 4\n%16 = getelementptr inbounds i32, ptr %12, i64 8\n%17 = load <4 x i32>, ptr %16, align 4\n%18 = getelementptr inbounds i32, ptr %12, i64 12\n%19 = load <4 x i32>, ptr %18, align 4\n%20 = getelementptr inbounds i32, ptr %1, i64 %7\n%21 = load <4 x i32>, ptr %20, align 4\n%22 = getelementptr inbounds i32, ptr %20, i64 4\n%23 = load <4 x i32>, ptr %22, align 4\n%24 = getelementptr inbounds i32, ptr %20, i64 8\n%25 = load <4 x i32>, ptr %24, align 4\n%26 = getelementptr inbounds i32, ptr %20, i64 12\n%27 = load <4 x i32>, ptr %26, align 4\n%28 = mul nsw <4 x i32> %21, %13\n%29 = add nsw <4 x i32> %28, %8\n%30 = mul nsw <4 x i32> %23, %15\n%31 = add nsw <4 x i32> %30, %9\n%32 = mul nsw <4 x i32> %25, %17\n%33 = add nuw i64 %7, 16\n%34 = icmp eq i64 %33, %6\nbr i1 %34, label %B4, label %B3\n\nB4:\n%35 = add nsw <4 x i32> %31, %29\n%36 = add nsw <4 x i32> %32, %35\n%37 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %36)\n%38 = icmp eq i64 %6, %4\nbr i1 %38, label %B7, label %B5\n\nB5:\n%39 = phi i64 [ 0, %B1 ], [ %6, %B4 ]\n%40 = phi i32 [ 0, %B1 ], [ %37, %B4 ]\nbr label %B6\n\nB6:\n%41 = phi i64 [ %47, %B6 ], [ %39, %B5 ]\n%42 = phi i32 [ %46, %B6 ], [ %40, %B5 ]\n%43 = getelementptr inbounds i32, ptr %0, i64 %41\n%44 = load i32, ptr %43, align 4\n%45 = getelementptr inbounds i32, ptr %1, i64 %41\n%46 = add nsw i32 %44, %45\n%47 = add nuw nsw i64 %41, 1\n%48 = icmp eq i64 %47, %4\nbr i1 %48, label %B7, label %B6\n\nB7:\n%49 = phi i32 [ 0, %B ], [ %37, %B4 ], [ %46, %B6 ]\nret i32 %49\n}", "codegemma": "define dso_local i32 @dot_product_nd(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B5\n\nB1:\n%4 = zext i32 %2 to i64\nbr label %B2\n\nB2:\n%5 = phi i64 [ 0, %B1 ], [ %11, %B2 ]\n%6 = phi i32 [ 0, %B1 ], [ %10, %B2 ]\n%7 = getelementptr inbounds i32, ptr %0, i64 %5\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %1, i64 %5\n%10 = load i32, ptr %9, align 4\n%11 = add nuw nsw i64 %5, 1\n%12 = icmp eq i64 %11, %4\nbr i1 %12, label %B3, label %B2\n\nB3:\n%13 = mul nsw i32 %10, %8\n%14 = add nuw nsw i32 %13, %6\nbr label %B4\n\nB4:\n%15 = phi i32 [ %14, %B3 ], [ %21, %B4 ]\n%16 = icmp eq i64 %11, %4\nbr i1 %16, label %B5, label %B4\n\nB5:\n%17 = phi i32 [ 0, %B ], [ %15, %B4 ]\nret i32 %17\n}"}, "define dso_local void @CAM_read_entry(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 0, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\nstore i32 0, ptr %7, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\nstore i32 100, ptr %9, align 4\nstore i32 0, ptr %7, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %7, align 4\n%12 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%13 = icmp slt i32 %11, %12\nbr i1 %13, label %14, label %54\n\n14:\n%15 = load i32, ptr %7, align 4\n%16 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%17 = load i32, ptr %4, align 4\n%18 = mul nsw i32 %16, %17\n%19 = add nsw i32 %15, %18\nstore i32 %19, ptr %5, align 4\n%20 = load i32, ptr %5, align 4\n%21 = load i32, ptr @BIT31, align 4\n%22 = or i32 %20, %21\nstore i32 %22, ptr %5, align 4\nbr label %23\n\n23:\n%24 = load i32, ptr %9, align 4\n%25 = add nsw i32 %24, -1\nstore i32 %25, ptr %9, align 4\n%26 = icmp sge i32 %24, 0\nbr i1 %26, label %27, label %37\n\n27:\n%28 = load ptr, ptr %3, align 8\n%29 = load i32, ptr @RWCAM, align 4\n%30 = call i32 @read_nic_dword(ptr noundef %28, i32 noundef %29)\nstore i32 %30, ptr %8, align 4\n%31 = load i32, ptr %8, align 4\n%32 = load i32, ptr @BIT31, align 4\n%33 = and i32 %31, %32\n%34 = icmp ne i32 %33, 0\nbr i1 %34, label %35, label %36\n\n35:\nbr label %23\n\n36:\nbr label %37\n\n37:\n%38 = load ptr, ptr %3, align 8\n%39 = load i32, ptr @RWCAM, align 4\n%40 = load i32, ptr %5, align 4\n%41 = call i32 @write_nic_dword(ptr noundef %38, i32 noundef %39, i32 noundef %40)\n%42 = load i32, ptr @COMP_SEC, align 4\n%43 = load i32, ptr %5, align 4\n%44 = call i32 @RT_TRACE(i32 noundef %42, ptr noundef @.str, i32 noundef %43)\n%45 = load ptr, ptr %3, align 8\n%46 = load i32, ptr @RCAMO, align 4\n%47 = call i32 @read_nic_dword(ptr noundef %45, i32 noundef %46)\nstore i32 %47, ptr %6, align 4\n%48 = load i32, ptr @COMP_SEC, align 4\n%49 = load i32, ptr %6, align 4\n%50 = call i32 @RT_TRACE(i32 noundef %48, ptr noundef @.str.1, i32 noundef %49)\nbr label %51\n\n51:\n%52 = load i32, ptr %7, align 4\n%53 = add nsw i32 %52, 1\nstore i32 %53, ptr %7, align 4\nbr label %10\n\n54:\n%55 = call i32 @printk(ptr noundef @.str.2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @CAM_read_entry(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B5\n\nB1:\n%4 = phi i32 [ %31, %B4 ], [ %2, %B ]\n%5 = phi i32 [ %21, %B4 ], [ 100, %B ]\n%6 = phi i32 [ %30, %B4 ], [ 0, %B ]\n%7 = mul nsw i32 %4, %1\n%8 = add nsw i32 %7, %6\n%9 = load i32, ptr @BIT31, align 4\n%10 = or i32 %9, %8\n%11 = tail call i32 @llvm.smin.i32(i32 %5, i32 -1)\n%12 = add i32 %11, -1\nbr label %B2\n\nB2:\n%13 = phi i32 [ %5, %B1 ], [ %15, %B3 ]\n%14 = icmp sgt i32 %13, -1\nbr i1 %14, label %B3, label %B4\n\nB3:\n%15 = add nsw i32 %13, -1\n%16 = load i32, ptr @RWCAM, align 4\n%17 = tail call i32 @read_nic_dword(ptr noundef %0, i32 noundef %16)\n%18 = load i32, ptr @BIT31, align 4\n%19 = and i32 %18, %17\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B4, label %B2\n\nB4:\n%21 = phi i32 [ %15, %B3 ], [ %12, %B2 ]\n%22 = load i32, ptr @RWCAM, align 4\n%23 = tail call i32 @write_nic_dword(ptr noundef %0, i32 noundef %22, i32 noundef %10)\n%24 = load i32, ptr @COMP_SEC, align 4\n%25 = tail call i32 @RT_TRACE(i32 noundef %24, ptr noundef nonnull @.str, i32 noundef %10)\n%26 = load i32, ptr @RCAMO, align 4\n%27 = tail call i32 @read_nic_dword(ptr noundef %0, i32 noundef %26)\n%28 = load i32, ptr @COMP_SEC, align 4\n%29 = tail call i32 @RT_TRACE(i32 noundef %28, ptr noundef nonnull @.str.1, i32 noundef %27)\n%30 = add nuw nsw i32 %6, 1\n%31 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%32 = icmp slt i32 %30, %31\nbr i1 %32, label %B1, label %B5\n\nB5:\n%33 = tail call i32 @printk(ptr noundef nonnull @.str.2)\nret void\n}", "codellama": "define dso_local void @CAM_read_entry(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = phi i32 [ %21, %B3 ], [ 0, %B ]\n%5 = phi i32 [ %20, %B3 ], [ 0, %B ]\n%6 = mul nsw i32 %2, %1\n%7 = add nsw i32 %6, %4\n%8 = load i32, ptr @BIT31, align 4\n%9 = or i32 %8, %7\n%10 = phi i32 [ %11, %B3 ], [ 100, %B ]\n%11 = add nsw i32 %10, -1\n%12 = icmp sgt i32 %10, 0\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = phi i32 [ %17, %B2 ], [ %9, %B1 ]\n%14 = load i32, ptr @RWCAM, align 4\n%15 = tail call i32 @read_nic_dword(ptr noundef %0, i32 noundef %14)\n%16 = load i32, ptr @BIT31, align 4\n%17 = and i32 %16, %15\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B3, label %B2\n\nB3:\n%19 = phi i32 [ %9, %B1 ], [ %13, %B2 ]\n%20 = add nuw nsw i32 %5, 1\n%21 = add nsw i32 %10, -1\n%22 = icmp slt i32 %20, %2\nbr i1 %22, label %B1, label %B4\n\nB4:\n%23 = tail call i32 @printk(ptr noundef nonnull @.str.2)\nret void\n}", "codegemma": "define dso_local void @CAM_read_entry(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B5\n\nB1:\n%4 = phi i32 [ %13, %B4 ], [ %2, %B ]\n%5 = phi i32 [ %12, %B4 ], [ 0, %B ]\n%6 = phi i32 [ %11, %B4 ], [ 100, %B ]\n%7 = mul nsw i32 %4, %1\n%8 = add nsw i32 %7, %5\n%9 = load i32, ptr @BIT31, align 4\n%10 = or i32 %9, %8\n%11 = add nsw i32 %6, -1\n%12 = and i32 %11, %10\n%13 = icmp sgt i32 %6, 0\nbr i1 %13, label %B2, label %B4\n\nB2:\n%14 = load i32, ptr @RWCAM, align 4\n%15 = tail call i32 @read_nic_dword(ptr noundef %0, i32 noundef %14)\n%16 = load i32, ptr @BIT31, align 4\n%17 = and i32 %16, %15\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B4, label %B2\n\nB3:\n%19 = add nuw nsw i32 %21, 1\n%20 = icmp eq i32 %19, %2\nbr i1 %20, label %B5, label %B4\n\nB4:\n%21 = phi i32 [ %19, %B3 ], [ %5, %B1 ], [ %12, %B2 ]\n%22 = load i32, ptr @RWCAM, align 4\n%23 = tail call i32 @write_nic_dword(ptr noundef %0, i32 noundef %22, i32 noundef %10)\n%24 = load i32, ptr @COMP_SEC, align 4\n%25 = tail call i32 @RT_TRACE(i32 noundef %24, ptr noundef nonnull @.str, i32 noundef %10)\n%26 = load i32, ptr @RCAMO, align 4\n%27 = tail call i32 @read_nic_dword(ptr noundef %0, i32 noundef %26)\n%28 = load i32, ptr @COMP_SEC, align 4\n%29 = tail call i32 @RT_TRACE(i32 noundef %28, ptr noundef nonnull @.str.1, i32 noundef %27)\n%30 = load i32, ptr @CAM_CONTENT_COUNT, align 4\n%31 = icmp slt i32 %21, %30\nbr i1 %31, label %B3, label %B5\n\nB5:\n%32 = tail call i32 @printk(ptr noundef nonnull @.str.2)\nret void\n}"}, "define dso_local ptr @newJsonNumberLm(i64 noundef %0, ptr noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore i64 %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load i32, ptr @jsonNumber, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = call ptr @newJsonElementLm(i32 noundef %6, ptr noundef %7)\nstore ptr %8, ptr %5, align 8\n%9 = load i64, ptr %3, align 8\n%10 = load ptr, ptr %5, align 8\n%11 = getelementptr inbounds %struct.jsonElement ptr %10, i32 0, i32 0\n%12 = getelementptr inbounds %struct.TYPE_2__, ptr %11, i32 0, i32 0\nstore i64 %9, ptr %12, align 8\n%13 = load ptr, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @newJsonNumberLm(i64 noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @jsonNumber, align 4\n%3 = tail call ptr @newJsonElementLm(i32 noundef %2, ptr noundef %1)\nstore i64 %0, ptr %3, align 8\nret ptr %3\n}", "codellama": "define dso_local ptr @newJsonNumberLm(i64 noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @jsonNumber, align 4\n%3 = tail call ptr @newJsonElementLm(i32 noundef %2, ptr noundef %1)\nstore i64 %0, ptr %3, align 8\nret ptr %3\n}", "codegemma": "define dso_local ptr @newJsonNumberLm(i64 noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @jsonNumber, align 4\n%3 = tail call ptr @newJsonElementLm(i32 noundef %2, ptr noundef %1)\nstore i64 %0, ptr %3, align 8\nret ptr %3\n}"}, "define dso_local void @setStartStateUniform() {\n%1 = alloca i32, align 4\n%2 = alloca double, align 8\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%4 = load i64, ptr @gProblemType, align 8\n%5 = load i64, ptr @POMDP_problem_type, align 8\n%6 = icmp ne i64 %4, %5\nbr i1 %6, label %7, label %8\n\n7:\nstore i32 1, ptr %3, align 4\nbr label %26\n\n8:\n%9 = load double, ptr @gNumStates, align 8\n%10 = fdiv fast double 1.000000e+00, %9\nstore double %10, ptr %2, align 8\nstore i32 0, ptr %1, align 4\nbr label %11\n\n11:\n%12 = load i32, ptr %1, align 4\n%13 = sitofp i32 %12 to double\n%14 = load double, ptr @gNumStates, align 8\n%15 = fcmp fast olt double %13, %14\nbr i1 %15, label %16, label %25\n\n16:\n%17 = load double, ptr %2, align 8\n%18 = load ptr, ptr @gInitialBelief, align 8\n%19 = load i32, ptr %1, align 4\n%20 = sext i32 %19 to i64\n%21 = getelementptr inbounds double, ptr %18, i64 %20\nstore double %17, ptr %21, align 8\nbr label %22\n\n22:\n%23 = load i32, ptr %1, align 4\n%24 = add nsw i32 %23, 1\nstore i32 %24, ptr %1, align 4\nbr label %11\n\n25:\nstore i32 0, ptr %3, align 4\nbr label %26\n\n26:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\n%27 = load i32, ptr %3, align 4\nswitch i32 %27, label %29 [\ni32 0, label %28\ni32 1, label %28\n]\n\n28:\nret void\n\n29:\nunreachable\n}": {"base_truth": "define dso_local void @setStartStateUniform() {\nB:\n%0 = load i64, ptr @gProblemType, align 8\n%1 = load i64, ptr @POMDP_problem_type, align 8\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = load double, ptr @gNumStates, align 8\n%4 = fdiv fast double 1.000000e+00, %3\n%5 = fcmp fast ogt double %3, 0.000000e+00\nbr i1 %5, label %B2, label %B4\n\nB2:\n%6 = load ptr, ptr @gInitialBelief, align 8\nbr label %B3\n\nB3:\n%7 = phi i64 [ 0, %B2 ], [ %9, %B3 ]\n%8 = getelementptr inbounds double, ptr %6, i64 %7\nstore double %4, ptr %8, align 8\n%9 = add nuw i64 %7, 1\n%10 = trunc i64 %9 to i32\n%11 = sitofp i32 %10 to double\n%12 = load double, ptr @gNumStates, align 8\n%13 = fcmp fast ogt double %12, %11\nbr i1 %13, label %B3, label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @setStartStateUniform() {\nB:\n%0 = load i64, ptr @gProblemType, align 8\n%1 = load i64, ptr @POMDP_problem_type, align 8\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = load double, ptr @gNumStates, align 8\n%4 = fdiv fast double 1.000000e+00, %3\n%5 = fcmp fast ogt double %3, 0.000000e+00\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = phi i64 [ %10, %B2 ], [ 0, %B1 ]\n%7 = getelementptr inbounds double, ptr @gInitialBelief, i64 %6\nstore double %4, ptr %7, align 8\n%8 = load double, ptr @gNumStates, align 8\n%9 = fcmp fast ogt double %8, %6\n%10 = add nuw nsw i64 %6, 1\nbr i1 %9, label %B2, label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @setStartStateUniform() {\nB:\n%0 = load i64, ptr @gProblemType, align 8\n%1 = load i64, ptr @POMDP_problem_type, align 8\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = load double, ptr @gNumStates, align 8\n%4 = fdiv fast double 1.000000e+00, %3\n%5 = sitofp double %3 to double\n%6 = fcmp fast olt double %5, 0.000000e+00\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = phi double [ %11, %B2 ], [ %4, %B1 ]\n%8 = phi i64 [ %12, %B2 ], [ 0, %B1 ]\n%9 = load ptr, ptr @gInitialBelief, align 8\n%10 = getelementptr inbounds double, ptr %9, i64 %8\nstore double %7, ptr %10, align 8\n%11 = fdiv fast double %7, %3\n%12 = add nuw nsw i64 %8, 1\n%13 = icmp eq i64 %12, %3\nbr i1 %13, label %B3, label %B2\n\nB3:\nret void\n}"}, "define dso_local i32 @pila_esta_vacia(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = icmp ne ptr %4, null\nbr i1 %5, label %7, label %6\n\n6:\nstore i32 1, ptr %2, align 4\nbr label %13\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %8, i32 0, i32 0\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\n%12 = zext i1 %11 to i32\nstore i32 %12, ptr %2, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %2, align 4\nret i32 %14\n}": {"base_truth": "define dso_local i32 @pila_esta_vacia(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = icmp eq i64 %2, 0\n%4 = zext i1 %3 to i32\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ 1, %B ]\nret i32 %5\n}", "codellama": "define dso_local i32 @pila_esta_vacia(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = icmp eq i64 %2, 0\n%4 = zext i1 %3 to i32\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ 1, %B ]\nret i32 %5\n}", "codegemma": "define dso_local i32 @pila_esta_vacia(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = icmp eq i64 %2, 0\n%4 = zext i1 %3 to i32\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ 1, %B ]\nret i32 %5\n}"}, "define dso_local void @D4Np2_WriteRegisterByte(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %3, align 8\n%6 = load i64, ptr @MAX_WRITE_REGISTER_NUMBER, align 8\n%7 = icmp sgt i64 %5, %6\nbr i1 %7, label %8, label %11\n\n8:\n%9 = load i32, ptr @D4NP2_ERROR, align 4\n%10 = call i32 @d4np2ErrHandler(i32 noundef %9)\nbr label %11\n\n11:\n%12 = load i64, ptr %3, align 8\n%13 = load i64, ptr %4, align 8\n%14 = call i32 @d4np2Write(i64 noundef %12, i64 noundef %13)\n%15 = load i64, ptr %3, align 8\n%16 = load i64, ptr %4, align 8\n%17 = call i32 @D4Np2_UpdateRegisterMap(i32 noundef %14, i64 noundef %15, i64 noundef %16)\nret void\n}": {"base_truth": "define dso_local void @D4Np2_WriteRegisterByte(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr @MAX_WRITE_REGISTER_NUMBER, align 8\n%3 = icmp slt i64 %2, %0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @D4NP2_ERROR, align 4\n%5 = tail call i32 @d4np2ErrHandler(i32 noundef %4)\nbr label %B2\n\nB2:\n%6 = tail call i32 @d4np2Write(i64 noundef %0, i64 noundef %1)\n%7 = tail call i32 @D4Np2_UpdateRegisterMap(i32 noundef %6, i64 noundef %0, i64 noundef %1)\nret void\n}", "codellama": "define dso_local void @D4Np2_WriteRegisterByte(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr @MAX_WRITE_REGISTER_NUMBER, align 8\n%3 = icmp slt i64 %2, %0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @D4NP2_ERROR, align 4\n%5 = tail call i32 @d4np2ErrHandler(i32 noundef %4)\nbr label %B2\n\nB2:\n%6 = tail call i32 @d4np2Write(i64 noundef %0, i64 noundef %1)\n%7 = tail call i32 @D4Np2_UpdateRegisterMap(i32 noundef %6, i64 noundef %0, i64 noundef %1)\nret void\n}", "codegemma": "define dso_local void @D4Np2_WriteRegisterByte(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr @MAX_WRITE_REGISTER_NUMBER, align 8\n%3 = icmp slt i64 %2, %0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @D4NP2_ERROR, align 4\n%5 = tail call i32 @d4np2ErrHandler(i32 noundef %4)\nbr label %B2\n\nB2:\n%6 = tail call i32 @d4np2Write(i64 noundef %0, i64 noundef %1)\n%7 = tail call i32 @D4Np2_UpdateRegisterMap(i32 noundef %6, i64 noundef %0, i64 noundef %1)\nret void\n}"}, "define internal i32 @init_rttest() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%5 = call i32 @spin_lock_init(ptr noundef @rttest_lock)\nstore i32 0, ptr %3, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%9 = icmp slt i32 %7, %8\nbr i1 %9, label %10, label %19\n\n10:\n%11 = load ptr, ptr @mutexes, align 8\n%12 = load i32, ptr %3, align 4\n%13 = sext i32 %12 to i64\n%14 = getelementptr inbounds i32, ptr %11, i64 %13\n%15 = call i32 @rt_mutex_init(ptr noundef %14)\nbr label %16\n\n16:\n%17 = load i32, ptr %3, align 4\n%18 = add nsw i32 %17, 1\nstore i32 %18, ptr %3, align 4\nbr label %6\n\n19:\n%20 = call i32 @sysdev_class_register(ptr noundef @rttest_sysclass)\nstore i32 %20, ptr %2, align 4\n%21 = load i32, ptr %2, align 4\n%22 = icmp ne i32 %21, 0\nbr i1 %22, label %23, label %25\n\n23:\n%24 = load i32, ptr %2, align 4\nstore i32 %24, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %67\n\n25:\nstore i32 0, ptr %3, align 4\nbr label %26\n\n26:\n%27 = load i32, ptr %3, align 4\n%28 = load i32, ptr @MAX_RT_TEST_THREADS, align 4\n%29 = icmp slt i32 %27, %28\nbr i1 %29, label %30, label %60\n\n30:\n%31 = load i32, ptr %3, align 4\n%32 = call i32 @init_test_thread(i32 noundef %31)\nstore i32 %32, ptr %2, align 4\n%33 = load i32, ptr %2, align 4\n%34 = icmp ne i32 %33, 0\nbr i1 %34, label %35, label %36\n\n35:\nbr label %60\n\n36:\n%37 = load ptr, ptr @thread_data, align 8\n%38 = load i32, ptr %3, align 4\n%39 = sext i32 %38 to i64\n%40 = getelementptr inbounds %struct.TYPE_2__, ptr %37, i64 %39\n%41 = getelementptr inbounds %struct.TYPE_2__, ptr %40, i32 0, i32 0\n%42 = call i32 @sysdev_create_file(ptr noundef %41, ptr noundef @attr_status)\nstore i32 %42, ptr %2, align 4\n%43 = load i32, ptr %2, align 4\n%44 = icmp ne i32 %43, 0\nbr i1 %44, label %45, label %46\n\n45:\nbr label %60\n\n46:\n%47 = load ptr, ptr @thread_data, align 8\n%48 = load i32, ptr %3, align 4\n%49 = sext i32 %48 to i64\n%50 = getelementptr inbounds %struct.TYPE_2__, ptr %47, i64 %49\n%51 = getelementptr inbounds %struct.TYPE_2__, ptr %50, i32 0, i32 0\n%52 = call i32 @sysdev_create_file(ptr noundef %51, ptr noundef @attr_command)\nstore i32 %52, ptr %2, align 4\n%53 = load i32, ptr %2, align 4\n%54 = icmp ne i32 %53, 0\nbr i1 %54, label %55, label %56\n\n55:\nbr label %60\n\n56:\nbr label %57\n\n57:\n%58 = load i32, ptr %3, align 4\n%59 = add nsw i32 %58, 1\nstore i32 %59, ptr %3, align 4\nbr label %26\n\n60:\n%61 = load i32, ptr %2, align 4\n%62 = icmp ne i32 %61, 0\n%63 = zext i1 %62 to i64\n%64 = select i1 %62, ptr @.str.1, ptr @.str.2\n%65 = call i32 @printk(ptr noundef @.str, ptr noundef %64)\n%66 = load i32, ptr %2, align 4\nstore i32 %66, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %67\n\n67:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%68 = load i32, ptr %1, align 4\nret i32 %68\n}": {"base_truth": "define internal i32 @init_rttest() {\nB:\n%0 = tail call i32 @spin_lock_init(ptr noundef nonnull @rttest_lock)\n%1 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi i64 [ %7, %B1 ], [ 0, %B ]\n%4 = load ptr, ptr @mutexes, align 8\n%5 = getelementptr inbounds i32, ptr %4, i64 %3\n%6 = tail call i32 @rt_mutex_init(ptr noundef %5)\n%7 = add nuw nsw i64 %3, 1\n%8 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%9 = sext i32 %8 to i64\n%10 = icmp slt i64 %7, %9\nbr i1 %10, label %B1, label %B2\n\nB2:\n%11 = tail call i32 @sysdev_class_register(ptr noundef nonnull @rttest_sysclass)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B9\n\nB3:\n%13 = load i32, ptr @MAX_RT_TEST_THREADS, align 4\n%14 = icmp sgt i32 %13, 0\nbr i1 %14, label %B5, label %B8\n\nB4:\n%15 = add nuw nsw i64 %19, 1\n%16 = load i32, ptr @MAX_RT_TEST_THREADS, align 4\n%17 = sext i32 %16 to i64\n%18 = icmp slt i64 %15, %17\nbr i1 %18, label %B5, label %B8\n\nB5:\n%19 = phi i64 [ %15, %B4 ], [ 0, %B3 ]\n%20 = trunc i64 %19 to i32\n%21 = tail call i32 @init_test_thread(i32 noundef %20)\n%22 = icmp eq i32 %21, 0\nbr i1 %22, label %B6, label %B8\n\nB6:\n%23 = load ptr, ptr @thread_data, align 8\n%24 = getelementptr inbounds %struct.TYPE_2__, ptr %23, i64 %19\n%25 = tail call i32 @sysdev_create_file(ptr noundef %24, ptr noundef nonnull @attr_status)\n%26 = icmp eq i32 %25, 0\nbr i1 %26, label %B7, label %B8\n\nB7:\n%27 = load ptr, ptr @thread_data, align 8\n%28 = getelementptr inbounds %struct.TYPE_2__, ptr %27, i64 %19\n%29 = tail call i32 @sysdev_create_file(ptr noundef %28, ptr noundef nonnull @attr_command)\n%30 = icmp eq i32 %29, 0\nbr i1 %30, label %B4, label %B8\n\nB8:\n%31 = phi i32 [ 0, %B3 ], [ %21, %B5 ], [ %25, %B6 ], [ %29, %B7 ], [ 0, %B4 ]\n%32 = phi ptr [ @.str.2, %B3 ], [ @.str.1, %B5 ], [ @.str.1, %B6 ], [ @.str.1, %B7 ], [ @.str.2, %B4 ]\n%33 = tail call i32 @printk(ptr noundef nonnull @.str, ptr noundef nonnull %32)\nbr label %B9\n\nB9:\n%34 = phi i32 [ %31, %B8 ], [ %11, %B2 ]\nret i32 %34\n}", "codellama": "define internal i32 @init_rttest() {\nB:\n%0 = tail call i32 @spin_lock_init(ptr noundef nonnull @rttest_lock)\n%1 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi i64 [ %7, %B1 ], [ 0, %B ]\n%4 = load ptr, ptr @mutexes, align 8\n%5 = getelementptr inbounds i32, ptr %4, i64 %3\n%6 = tail call i32 @rt_mutex_init(ptr noundef %5)\n%7 = add nuw nsw i64 %3, 1\n%8 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%9 = sext i32 %8 to i64\n%10 = icmp slt i64 %7, %9\nbr i1 %10, label %B1, label %B2\n\nB2:\n%11 = tail call i32 @sysdev_class_register(ptr noundef nonnull @rttest_sysclass)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B7\n\nB3:\n%13 = load i32, ptr @MAX_RT_TEST_THREADS, align 4\n%14 = icmp sgt i32 %13, 0\nbr i1 %14, label %B4, label %B6\n\nB4:\n%15 = phi i64 [ %23, %B5 ], [ 0, %B3 ]\n%16 = trunc i64 %15 to i32\n%17 = tail call i32 @init_test_thread(i32 noundef %16)\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B5, label %B6\n\nB5:\n%19 = load ptr, ptr @thread_data, align 8\n%20 = getelementptr inbounds %struct.TYPE_2__, ptr %19, i64 %15\n%21 = tail call i32 @sysdev_create_file(ptr noundef %20, ptr noundef nonnull @attr_status)\n%22 = icmp eq i32 %21, 0\nbr i1 %22, label %B6, label %B6\n\nB6:\n%23 = phi i64 [ %15, %B4 ], [ %15, %B5 ], [ 0, %B3 ]\n%24 = phi i32 [ %17, %B4 ], [ %21, %B5 ], [ 0, %B3 ]\n%25 = load ptr, ptr @thread_data, align 8\n%26 = getelementptr inbounds %struct.TYPE_2__, ptr %25, i64 %23\n%27 = tail call i32 @sysdev_create_file(ptr noundef %26, ptr noundef nonnull @attr_command)\n%28 = icmp eq i32 %27, 0\nbr i1 %28, label %B7, label %B6\n\nB7:\n%29 = phi i32 [ %11, %B2 ], [ %27</s>", "codegemma": "define internal i32 @init_rttest() {\nB:\n%0 = tail call i32 @spin_lock_init(ptr noundef nonnull @rttest_lock)\n%1 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi i64 [ %6, %B1 ], [ 0, %B ]\n%4 = load ptr, ptr @mutexes, align 8\n%5 = getelementptr inbounds i32, ptr %4, i64 %3\n%6 = tail call i32 @rt_mutex_init(ptr noundef %5)\n%7 = load i32, ptr @MAX_RT_TEST_MUTEXES, align 4\n%8 = sext i32 %7 to i64\n%9 = icmp slt i64 %6, %8\nbr i1 %9, label %B1, label %B2\n\nB2:\n%10 = phi i32 [ 0, %B ], [ %6, %B1 ]\n%11 = load i32, ptr @MAX_RT_TEST_THREADS, align 4\n%12 = icmp sgt i32 %11, 0\nbr i1 %12, label %B3, label %B6\n\nB3:\n%13 = phi i64 [ %18, %B5 ], [ 0, %B2 ]\n%14 = tail call i32 @init_test_thread(i32 noundef %13)\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B4, label %B5\n\nB4:\n%16 = load ptr, ptr @thread_data, align 8\n%17 = getelementptr inbounds %struct.TYPE_2__, ptr %16, i64 %13\n%18 = tail call i32 @sysdev_create_file(ptr noundef %17, ptr noundef nonnull @attr_status)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B3, label %B5\n\nB5:\n%20 = load ptr, ptr @thread_data, align 8\n%21 = getelementptr inbounds %struct.TYPE_2__, ptr %20, i64 %13\n%22 = tail call i32 @sysdev_create_file(ptr noundef %21, ptr noundef nonnull @attr_command)\n%23 = icmp eq i32 %22, 0\nbr i1 %23, label %B6, label %B5\n\nB6:\n%24 = phi ptr [ @.str.2, %B2 ], [ @.str.1, %B5 ]\n%25 = tail call i32 @printk(ptr noundef nonnull @.str, ptr noundef nonnull %24)\nret i32 0\n}"}, "define dso_local i32 @new_socket() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%5 = load i32, ptr @AF_INET, align 4\n%6 = load i32, ptr @SOCK_STREAM, align 4\n%7 = call i32 @socket(i32 noundef %5, i32 noundef %6, i32 noundef 0)\nstore i32 %7, ptr %2, align 4\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %9, label %11\n\n9:\n%10 = call i32 @perror(ptr noundef @.str)\nstore i32 -1, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %30\n\n11:\n%12 = load i32, ptr %2, align 4\n%13 = load i32, ptr @F_GETFL, align 4\n%14 = call i32 @fcntl(i32 noundef %12, i32 noundef %13, i32 noundef 0)\nstore i32 %14, ptr %3, align 4\n%15 = icmp slt i32 %14, 0\nbr i1 %15, label %24, label %16\n\n16:\n%17 = load i32, ptr %2, align 4\n%18 = load i32, ptr @F_SETFL, align 4\n%19 = load i32, ptr %3, align 4\n%20 = load i32, ptr @O_NONBLOCK, align 4\n%21 = or i32 %19, %20\n%22 = call i32 @fcntl(i32 noundef %17, i32 noundef %18, i32 noundef %21)\n%23 = icmp slt i32 %22, 0\nbr i1 %23, label %24, label %28\n\n24:\n%25 = call i32 @perror(ptr noundef @.str.1)\n%26 = load i32, ptr %2, align 4\n%27 = call i32 @close(i32 noundef %26)\nstore i32 -1, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %30\n\n28:\n%29 = load i32, ptr %2, align 4\nstore i32 %29, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%31 = load i32, ptr %1, align 4\nret i32 %31\n}": {"base_truth": "define dso_local i32 @new_socket() {\nB:\n%0 = load i32, ptr @AF_INET, align 4\n%1 = load i32, ptr @SOCK_STREAM, align 4\n%2 = tail call i32 @socket(i32 noundef %0, i32 noundef %1, i32 noundef 0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @perror(ptr noundef nonnull @.str)\nbr label %B5\n\nB2:\n%5 = load i32, ptr @F_GETFL, align 4\n%6 = tail call i32 @fcntl(i32 noundef %2, i32 noundef %5, i32 noundef 0)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = load i32, ptr @F_SETFL, align 4\n%9 = load i32, ptr @O_NONBLOCK, align 4\n%10 = or i32 %9, %6\n%11 = tail call i32 @fcntl(i32 noundef %2, i32 noundef %8, i32 noundef %10)\n%12 = icmp slt i32 %11, 0\nbr i1 %12, label %B4, label %B5\n\nB4:\n%13 = tail call i32 @perror(ptr noundef nonnull @.str.1)\n%14 = tail call i32 @close(i32 noundef %2)\nbr label %B5\n\nB5:\n%15 = phi i32 [ -1, %B1 ], [ -1, %B4 ], [ %2, %B3 ]\nret i32 %15\n}", "codellama": "define dso_local i32 @new_socket() {\nB:\n%0 = load i32, ptr @AF_INET, align 4\n%1 = load i32, ptr @SOCK_STREAM, align 4\n%2 = tail call i32 @socket(i32 noundef %0, i32 noundef %1, i32 noundef 0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @perror(ptr noundef nonnull @.str)\nbr label %B5\n\nB2:\n%5 = load i32, ptr @F_GETFL, align 4\n%6 = tail call i32 @fcntl(i32 noundef %2, i32 noundef %5, i32 noundef 0)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = load i32, ptr @F_SETFL, align 4\n%9 = load i32, ptr @O_NONBLOCK, align 4\n%10 = or i32 %9, %6\n%11 = tail call i32 @fcntl(i32 noundef %2, i32 noundef %8, i32 noundef %10)\n%12 = icmp slt i32 %11, 0\nbr i1 %12, label %B4, label %B5\n\nB4:\n%13 = phi ptr [ @.str.1, %B2 ], [ @.str.1, %B3 ]\n%14 = tail call i32 @perror(ptr noundef nonnull %13)\n%15 = tail call i32 @close(i32 noundef %2)\nbr label %B5\n\nB5:\n%16 = phi i32 [ -1, %B1 ], [ -1, %B4 ], [ %2, %B3 ]\nret i32 %16\n}", "codegemma": "define dso_local i32 @new_socket() {\nB:\n%0 = load i32, ptr @AF_INET, align 4\n%1 = load i32, ptr @SOCK_STREAM, align 4\n%2 = tail call i32 @socket(i32 noundef %0, i32 noundef %1, i32 noundef 0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = load i32, ptr @F_GETFL, align 4\n%5 = tail call i32 @fcntl(i32 noundef %2, i32 noundef %4, i32 noundef 0)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr @F_SETFL, align 4\n%8 = load i32, ptr @O_NONBLOCK, align 4\n%9 = or i32 %8, %5\n%10 = tail call i32 @fcntl(i32 noundef %2, i32 noundef %7, i32 noundef %9)\n%11 = icmp slt i32 %10, 0\nbr i1 %11, label %B3, label %B4\n\nB3:\n%12 = phi ptr [ @.str, %B ], [ @.str.1, %B1 ], [ @.str.1, %B2 ]\n%13 = tail call i32 @perror(ptr noundef nonnull %12)\n%14 = tail call i32 @close(i32 noundef %2)\nbr label %B4\n\nB4:\n%15 = phi i32 [ %2, %B2 ], [ -1, %B3 ]\nret i32 %15\n}"}, "define internal void @umtxq_unbusy(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @umtxq_getchain(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.umtxq_chain ptr %6, i32 0, i32 2\n%8 = load i32, ptr @MA_OWNED, align 4\n%9 = call i32 @mtx_assert(ptr noundef %7, i32 noundef %8)\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.umtxq_chain ptr %10, i32 0, i32 0\n%12 = load i64, ptr %11, align 8\n%13 = icmp ne i64 %12, 0\n%14 = zext i1 %13 to i32\n%15 = call i32 @KASSERT(i32 noundef %14, ptr noundef @.str)\n%16 = load ptr, ptr %3, align 8\n%17 = getelementptr inbounds %struct.umtxq_chain ptr %16, i32 0, i32 0\nstore i64 0, ptr %17, align 8\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.umtxq_chain ptr %18, i32 0, i32 1\n%20 = load i64, ptr %19, align 8\n%21 = icmp ne i64 %20, 0\nbr i1 %21, label %22, label %25\n\n22:\n%23 = load ptr, ptr %3, align 8\n%24 = call i32 @wakeup_one(ptr noundef %23)\nbr label %25\n\n25:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @umtxq_unbusy(ptr noundef %0) {\nB:\n%1 = tail call ptr @umtxq_getchain(ptr noundef %0)\n%2 = getelementptr inbounds %struct.umtxq_chain, ptr %1, i64 0, i32 2\n%3 = load i32, ptr @MA_OWNED, align 4\n%4 = tail call i32 @mtx_assert(ptr noundef nonnull %2, i32 noundef %3)\n%5 = load i64, ptr %1, align 8\n%6 = icmp ne i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @KASSERT(i32 noundef %7, ptr noundef nonnull @.str)\nstore i64 0, ptr %1, align 8\n%9 = getelementptr inbounds %struct.umtxq_chain, ptr %1, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB1:\n%12 = tail call i32 @wakeup_one(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @umtxq_unbusy(ptr noundef %0) {\nB:\n%1 = tail call ptr @umtxq_getchain(ptr noundef %0)\n%2 = getelementptr inbounds %struct.umtxq_chain, ptr %1, i64 0, i32 2\n%3 = load i32, ptr @MA_OWNED, align 4\n%4 = tail call i32 @mtx_assert(ptr noundef nonnull %2, i32 noundef %3)\n%5 = load i64, ptr %1, align 8\n%6 = icmp ne i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @KASSERT(i32 noundef %7, ptr noundef nonnull @.str)\nstore i64 0, ptr %1, align 8\n%9 = getelementptr inbounds %struct.umtxq_chain, ptr %1, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB1:\n%12 = tail call i32 @wakeup_one(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @umtxq_unbusy(ptr noundef %0) {\nB:\n%1 = tail call ptr @umtxq_getchain(ptr noundef %0)\n%2 = getelementptr inbounds %struct.umtxq_chain, ptr %1, i64 0, i32 2\n%3 = load i32, ptr @MA_OWNED, align 4\n%4 = tail call i32 @mtx_assert(ptr noundef nonnull %2, i32 noundef %3)\n%5 = load i64, ptr %1, align 8\n%6 = icmp ne i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @KASSERT(i32 noundef %7, ptr noundef nonnull @.str)\nstore i64 0, ptr %1, align 8\n%9 = getelementptr inbounds %struct.umtxq_chain, ptr %1, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB1:\n%12 = tail call i32 @wakeup_one(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local nofpclass(nan inf) double @trace(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca double, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\nstore i32 %8, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\nstore double 0.000000e+00, ptr %5, align 8\nstore i32 0, ptr %3, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %3, align 4\n%11 = load i32, ptr %4, align 4\n%12 = icmp slt i32 %10, %11\nbr i1 %12, label %13, label %23\n\n13:\n%14 = load double, ptr %5, align 8\n%15 = load ptr, ptr %2, align 8\n%16 = load i32, ptr %3, align 4\n%17 = load i32, ptr %3, align 4\n%18 = call fast nofpclass(nan inf) double @getM(ptr noundef %15, i32 noundef %16, i32 noundef %17)\n%19 = fadd fast double %14, %18\nstore double %19, ptr %5, align 8\nbr label %20\n\n20:\n%21 = load i32, ptr %3, align 4\n%22 = add nsw i32 %21, 1\nstore i32 %22, ptr %3, align 4\nbr label %9\n\n23:\n%24 = load double, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret double %24\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @trace(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi double [ %6, %B1 ], [ 0.000000e+00, %B ]\n%4 = phi i32 [ %7, %B1 ], [ 0, %B ]\n%5 = tail call fast nofpclass(nan inf) double @getM(ptr noundef nonnull %0, i32 noundef %4, i32 noundef %4)\n%6 = fadd fast double %5, %3\n%7 = add nuw nsw i32 %4, 1\n%8 = icmp eq i32 %7, %1\nbr i1 %8, label %B2, label %B1\n\nB2:\n%9 = phi double [ 0.000000e+00, %B ], [ %6, %B1 ]\nret double %9\n}", "codellama": "define dso_local nofpclass(nan inf) double @trace(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi double [ %7, %B1 ], [ 0.000000e+00, %B ]\n%4 = phi i32 [ %8, %B1 ], [ 0, %B ]\n%5 = tail call fast nofpclass(nan inf) double @getM(ptr noundef nonnull %0, i32 noundef %4, i32 noundef %4)\n%6 = fadd fast double %5, %3\n%7 = fadd fast double %5, %3\n%8 = add nuw nsw i32 %4, 1\n%9 = icmp eq i32 %8, %1\nbr i1 %9, label %B2, label %B1\n\nB2:\n%10 = phi double [ 0.000000e+00, %B ], [ %7, %B1 ]\nret double %10\n}", "codegemma": "define dso_local nofpclass(nan inf) double @trace(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = zext i32 %1 to i64\nbr label %B2\n\nB2:\n%4 = phi i64 [ 0, %B1 ], [ %8, %B2 ]\n%5 = phi double [ 0.000000e+00, %B1 ], [ %7, %B2 ]\n%6 = tail call fast nofpclass(nan inf) double @getM(ptr noundef nonnull %0, i32 noundef %4, i32 noundef %4)\n%7 = fadd fast double %6, %5\n%8 = add nuw nsw i64 %4, 1\n%9 = icmp eq i64 %8, %3\nbr i1 %9, label %B3, label %B2\n\nB3:\n%10 = phi double [ 0.000000e+00, %B ], [ %7, %B2 ]\nret double %10\n}"}, "define dso_local void @pba_clk_mode(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%7 = load i64, ptr %5, align 8\n%8 = call i32 @spin_lock_irqsave(ptr noundef @pm_lock, i64 noundef %7)\n%9 = load i32, ptr @PBA_MASK, align 4\n%10 = call i32 @pm_readl(i32 noundef %9)\nstore i32 %10, ptr %6, align 4\n%11 = load i32, ptr %4, align 4\n%12 = icmp ne i32 %11, 0\nbr i1 %12, label %13, label %20\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.clk, ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 4\n%17 = shl i32 1, %16\n%18 = load i32, ptr %6, align 4\n%19 = or i32 %18, %17\nstore i32 %19, ptr %6, align 4\nbr label %28\n\n20:\n%21 = load ptr, ptr %3, align 8\n%22 = getelementptr inbounds %struct.clk, ptr %21, i32 0, i32 0\n%23 = load i32, ptr %22, align 4\n%24 = shl i32 1, %23\n%25 = xor i32 %24, -1\n%26 = load i32, ptr %6, align 4\n%27 = and i32 %26, %25\nstore i32 %27, ptr %6, align 4\nbr label %28\n\n28:\n%29 = load i32, ptr @PBA_MASK, align 4\n%30 = load i32, ptr %6, align 4\n%31 = call i32 @pm_writel(i32 noundef %29, i32 noundef %30)\n%32 = load i64, ptr %5, align 8\n%33 = call i32 @spin_unlock_irqrestore(ptr noundef @pm_lock, i64 noundef %32)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @pba_clk_mode(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull @pm_lock, i64 noundef undef)\n%3 = load i32, ptr @PBA_MASK, align 4\n%4 = tail call i32 @pm_readl(i32 noundef %3)\n%5 = icmp eq i32 %1, 0\n%6 = load i32, ptr %0, align 4\n%7 = shl nuw i32 1, %6\n%8 = or i32 %7, %4\n%9 = xor i32 %7, -1\n%10 = and i32 %4, %9\n%11 = select i1 %5, i32 %10, i32 %8\n%12 = load i32, ptr @PBA_MASK, align 4\n%13 = tail call i32 @pm_writel(i32 noundef %12, i32 noundef %11)\n%14 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull @pm_lock, i64 noundef undef)\nret void\n}", "codellama": "define dso_local void @pba_clk_mode(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull @pm_lock, i64 noundef undef)\n%3 = load i32, ptr @PBA_MASK, align 4\n%4 = tail call i32 @pm_readl(i32 noundef %3)\n%5 = icmp eq i32 %1, 0\n%6 = load i32, ptr %0, align 4\n%7 = shl nuw i32 1, %6\n%8 = or i32 %4, %7\n%9 = xor i32 %7, -1\n%10 = and i32 %4, %9\n%11 = select i1 %5, i32 %10, i32 %8\n%12 = load i32, ptr @PBA_MASK, align 4\n%13 = tail call i32 @pm_writel(i32 noundef %12, i32 noundef %11)\n%14 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull @pm_lock, i64 noundef undef)\nret void\n}", "codegemma": "define dso_local void @pba_clk_mode(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull @pm_lock, i64 noundef undef)\n%3 = load i32, ptr @PBA_MASK, align 4\n%4 = tail call i32 @pm_readl(i32 noundef %3)\n%5 = icmp eq i32 %1, 0\n%6 = load i32, ptr %0, align 4\n%7 = shl nuw i32 1, %6\n%8 = xor i32 %7, -1\n%9 = and i32 %4, %8\n%10 = or i32 %9, %7\n%11 = load i32, ptr @PBA_MASK, align 4\n%12 = tail call i32 @pm_writel(i32 noundef %11, i32 noundef %10)\n%13 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull @pm_lock, i64 noundef undef)\nret void\n}"}, "define internal void @set_rx_mode(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.net_device, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nstore i32 %6, ptr %3, align 4\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.net_device, ptr %7, i32 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = load i32, ptr @IFF_PROMISC, align 4\n%11 = and i32 %9, %10\n%12 = icmp ne i32 %11, 0\nbr i1 %12, label %13, label %28\n\n13:\n%14 = load i32, ptr @SetRxFilter, align 4\n%15 = load i32, ptr @RxStation, align 4\n%16 = or i32 %14, %15\n%17 = load i32, ptr @RxMulticast, align 4\n%18 = or i32 %16, %17\n%19 = load i32, ptr @RxBroadcast, align 4\n%20 = or i32 %18, %19\n%21 = load i32, ptr @RxProm, align 4\n%22 = or i32 %20, %21\n%23 = load i32, ptr %3, align 4\n%24 = zext i32 %23 to i64\n%25 = load i64, ptr @EL3_CMD, align 8\n%26 = add nsw i64 %24, %25\n%27 = call i32 @outw(i32 noundef %22, i64 noundef %26)\nbr label %64\n\n28:\n%29 = load ptr, ptr %2, align 8\n%30 = call i32 @netdev_mc_empty(ptr noundef %29)\n%31 = icmp ne i32 %30, 0\nbr i1 %31, label %32, label %39\n\n32:\n%33 = load ptr, ptr %2, align 8\n%34 = getelementptr inbounds %struct.net_device, ptr %33, i32 0, i32 1\n%35 = load i32, ptr %34, align 4\n%36 = load i32, ptr @IFF_ALLMULTI, align 4\n%37 = and i32 %35, %36\n%38 = icmp ne i32 %37, 0\nbr i1 %38, label %39, label %52\n\n39:\n%40 = load i32, ptr @SetRxFilter, align 4\n%41 = load i32, ptr @RxStation, align 4\n%42 = or i32 %40, %41\n%43 = load i32, ptr @RxMulticast, align 4\n%44 = or i32 %42, %43\n%45 = load i32, ptr @RxBroadcast, align 4\n%46 = or i32 %44, %45\n%47 = load i32, ptr %3, align 4\n%48 = zext i32 %47 to i64\n%49 = load i64, ptr @EL3_CMD, align 8\n%50 = add nsw i64 %48, %49\n%51 = call i32 @outw(i32 noundef %46, i64 noundef %50)\nbr label %63\n\n52:\n%53 = load i32, ptr @SetRxFilter, align 4\n%54 = load i32, ptr @RxStation, align 4\n%55 = or i32 %53, %54\n%56 = load i32, ptr @RxBroadcast, align 4\n%57 = or i32 %55, %56\n%58 = load i32, ptr %3, align 4\n%59 = zext i32 %58 to i64\n%60 = load i64, ptr @EL3_CMD, align 8\n%61 = add nsw i64 %59, %60\n%62 = call i32 @outw(i32 noundef %57, i64 noundef %61)\nbr label %63\n\n63:\nbr label %64\n\n64:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define internal void @set_rx_mode(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = getelementptr inbounds %struct.net_device, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @IFF_PROMISC, align 4\n%5 = and i32 %4, %3\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = load i32, ptr @SetRxFilter, align 4\n%8 = load i32, ptr @RxStation, align 4\n%9 = or i32 %8, %7\n%10 = load i32, ptr @RxMulticast, align 4\n%11 = or i32 %9, %10\nbr label %B6\n\nB2:\n%12 = tail call i32 @netdev_mc_empty(ptr noundef nonnull %0)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B4, label %B3\n\nB3:\n%14 = load i32, ptr %2, align 4\n%15 = load i32, ptr @IFF_ALLMULTI, align 4\n%16 = and i32 %15, %14\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B5, label %B4\n\nB4:\n%18 = load i32, ptr @SetRxFilter, align 4\n%19 = load i32, ptr @RxStation, align 4\n%20 = or i32 %19, %18\nbr label %B6\n\nB5:\n%21 = load i32, ptr @RxStation, align 4\nbr label %B6\n\nB6:\n%22 = phi ptr [ @RxMulticast, %B4 ], [ @SetRxFilter, %B5 ], [ @RxBroadcast, %B1 ]\n%23 = phi i32 [ %20, %B4 ], [ %21, %B5 ], [ %11, %B1 ]\n%24 = phi ptr [ @RxBroadcast, %B4 ], [ @RxBroadcast, %B5 ], [ @RxProm, %B1 ]\n%25 = load i32, ptr %22, align 4\n%26 = or i32 %23, %25\n%27 = load i32, ptr %24, align 4\n%28 = or i32 %26, %27\n%29 = zext i32 %1 to i64\n%30 = load i64, ptr @EL3_CMD, align 8\n%31 = add nsw i64 %30, %29\n%32 = tail call i32 @outw(i32 noundef %28, i64 noundef %31)\nret void\n}", "codellama": "define internal void @set_rx_mode(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = getelementptr inbounds %struct.net_device, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @IFF_PROMISC, align 4\n%5 = and i32 %4, %3\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = load i32, ptr @SetRxFilter, align 4\n%8 = load i32, ptr @RxStation, align 4\n%9 = or i32 %8, %7\n%10 = load i32, ptr @RxMulticast, align 4\n%11 = or i32 %9, %10\n%12 = load i32, ptr @RxBroadcast, align 4\n%13 = or i32 %11, %12\n%14 = load i32, ptr @RxProm, align 4\n%15 = or i32 %13, %14\n%16 = zext i32 %1 to i64\n%17 = load i64, ptr @EL3_CMD, align 8\n%18 = add nsw i64 %17, %16\n%19 = tail call i32 @outw(i32 noundef %15, i64 noundef %18)\nbr label %B6\n\nB2:\n%20 = tail call i32 @netdev_mc_empty(ptr noundef nonnull %0)\n%21 = icmp eq i32 %20, 0\nbr i1 %21, label %B4, label %B3\n\nB3:\n%22 = load i32, ptr %2, align 4\n%23 = load i32, ptr @IFF_ALLMULTI, align 4\n%24 = and i32 %23, %22\n%25 = icmp eq i32 %24, 0\nbr i1 %25, label %B5, label %B4\n\nB4:\n%26 = load i32, ptr @SetRxFilter, align 4\n%27 = load i32, ptr @RxStation, align 4\n%28 = or i32 %27, %26\n%29 = load i32, ptr @RxMulticast, align 4\n%30 = or i32 %28, %29\n%31 = load i32, ptr @RxBroadcast, align 4\n%32 = or i32 %30, %31\n%33 = zext i32 %1 to i64\n%34 = load i64, ptr @EL3_CMD, align 8\n%35 = add nsw i64 %34, %33\n%36 = tail call i32 @outw(i32 noundef %32, i64 noundef %35)\nbr label %B6\n\nB5:\n%37 = load i32, ptr @SetRxFilter, align 4\n%38 = load i32, ptr @RxStation, align 4\n%39 = or i32 %38, %37\n%40 = load i32, ptr @RxBroadcast, align 4\n%41 = or i32 %39, %40\n%42 = zext i32 %1 to i64\n%43 = load i64, ptr @EL3_CMD, align 8\n%44 = add nsw i64 %43, %42\n%45 = tail call i32 @outw(i32 noundef %41, i64 noundef %44)\nbr label %B6\n\nB6:\nret void\n}", "codegemma": "define internal void @set_rx_mode(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = getelementptr inbounds %struct.net_device, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @IFF_PROMISC, align 4\n%5 = and i32 %4, %3\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = load i32, ptr @SetRxFilter, align 4\n%8 = load i32, ptr @RxStation, align 4\n%9 = or i32 %8, %7\n%10 = load i32, ptr @RxMulticast, align 4\n%11 = or i32 %9, %10\n%12 = load i32, ptr @RxBroadcast, align 4\n%13 = or i32 %11, %12\n%14 = load i32, ptr @RxProm, align 4\n%15 = or i32 %13, %14\n%16 = zext i32 %1 to i64\n%17 = load i64, ptr @EL3_CMD, align 8\n%18 = add nsw i64 %17, %16\n%19 = tail call i32 @outw(i32 noundef %15, i64 noundef %18)\nbr label %B5\n\nB2:\n%20 = tail call i32 @netdev_mc_empty(ptr noundef nonnull %0)\n%21 = icmp eq i32 %20, 0\nbr i1 %21, label %B4, label %B3\n\nB3:\n%22 = load i32, ptr %2, align 4\n%23 = load i32, ptr @IFF_ALLMULTI, align 4\n%24 = and i32 %23, %22\n%25 = icmp eq i32 %24, 0\nbr i1 %25, label %B4, label %B5\n\nB4:\n%26 = load i32, ptr @SetRxFilter, align 4\n%27 = load i32, ptr @RxStation, align 4\n%28 = or i32 %27, %26\n%29 = load i32, ptr @RxBroadcast, align 4\n%30 = or i32 %28, %29\n%31 = zext i32 %1 to i64\n%32 = load i64, ptr @EL3_CMD, align 8\n%33 = add nsw i64 %32, %31\n%34 = tail call i32 @outw(i32 noundef %30, i64 noundef %33)\nbr label %B5\n\nB5:\nret void\n}"}, "define internal i32 @ixl_if_suspend(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\n%4 = call i32 @INIT_DEBUGOUT(ptr noundef @.str)\n%5 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %5\n}": {"base_truth": "define internal i32 @ixl_if_suspend(i32 noundef %0) {\nB:\n%1 = tail call i32 @INIT_DEBUGOUT(ptr noundef nonnull @.str)\nret i32 0\n}", "codellama": "define internal i32 @ixl_if_suspend(i32 noundef %0) {\nB:\n%1 = tail call i32 @INIT_DEBUGOUT(ptr noundef nonnull @.str)\nret i32 0\n}", "codegemma": "define internal i32 @ixl_if_suspend(i32 noundef %0) {\nB:\n%1 = tail call i32 @INIT_DEBUGOUT(ptr noundef nonnull @.str)\nret i32 0\n}"}, "define internal i32 @ilog(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = icmp slt i32 %4, 0\nbr i1 %5, label %6, label %7\n\n6:\nstore i32 0, ptr %2, align 4\nbr label %80\n\n7:\n%8 = load i32, ptr %3, align 4\n%9 = icmp slt i32 %8, 16384\nbr i1 %9, label %10, label %39\n\n10:\n%11 = load i32, ptr %3, align 4\n%12 = icmp slt i32 %11, 16\nbr i1 %12, label %13, label %20\n\n13:\n%14 = load i32, ptr %3, align 4\n%15 = sext i32 %14 to i64\n%16 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %15\n%17 = load i8, ptr %16, align 1\n%18 = sext i8 %17 to i32\n%19 = add nsw i32 0, %18\nstore i32 %19, ptr %2, align 4\nbr label %80\n\n20:\n%21 = load i32, ptr %3, align 4\n%22 = icmp slt i32 %21, 512\nbr i1 %22, label %23, label %31\n\n23:\n%24 = load i32, ptr %3, align 4\n%25 = ashr i32 %24, 5\n%26 = sext i32 %25 to i64\n%27 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %26\n%28 = load i8, ptr %27, align 1\n%29 = sext i8 %28 to i32\n%30 = add nsw i32 5, %29\nstore i32 %30, ptr %2, align 4\nbr label %80\n\n31:\n%32 = load i32, ptr %3, align 4\n%33 = ashr i32 %32, 10\n%34 = sext i32 %33 to i64\n%35 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %34\n%36 = load i8, ptr %35, align 1\n%37 = sext i8 %36 to i32\n%38 = add nsw i32 10, %37\nstore i32 %38, ptr %2, align 4\nbr label %80\n\n39:\n%40 = load i32, ptr %3, align 4\n%41 = icmp slt i32 %40, 16777216\nbr i1 %41, label %42, label %61\n\n42:\n%43 = load i32, ptr %3, align 4\n%44 = icmp slt i32 %43, 524288\nbr i1 %44, label %45, label %53\n\n45:\n%46 = load i32, ptr %3, align 4\n%47 = ashr i32 %46, 15\n%48 = sext i32 %47 to i64\n%49 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %48\n%50 = load i8, ptr %49, align 1\n%51 = sext i8 %50 to i32\n%52 = add nsw i32 15, %51\nstore i32 %52, ptr %2, align 4\nbr label %80\n\n53:\n%54 = load i32, ptr %3, align 4\n%55 = ashr i32 %54, 20\n%56 = sext i32 %55 to i64\n%57 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %56\n%58 = load i8, ptr %57, align 1\n%59 = sext i8 %58 to i32\n%60 = add nsw i32 20, %59\nstore i32 %60, ptr %2, align 4\nbr label %80\n\n61:\n%62 = load i32, ptr %3, align 4\n%63 = icmp slt i32 %62, 536870912\nbr i1 %63, label %64, label %72\n\n64:\n%65 = load i32, ptr %3, align 4\n%66 = ashr i32 %65, 25\n%67 = sext i32 %66 to i64\n%68 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %67\n%69 = load i8, ptr %68, align 1\n%70 = sext i8 %69 to i32\n%71 = add nsw i32 25, %70\nstore i32 %71, ptr %2, align 4\nbr label %80\n\n72:\n%73 = load i32, ptr %3, align 4\n%74 = ashr i32 %73, 30\n%75 = sext i32 %74 to i64\n%76 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %75\n%77 = load i8, ptr %76, align 1\n%78 = sext i8 %77 to i32\n%79 = add nsw i32 30, %78\nstore i32 %79, ptr %2, align 4\nbr label %80\n\n80:\n%81 = load i32, ptr %2, align 4\nret i32 %81\n}": {"base_truth": "define internal i32 @ilog(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 0\nbr i1 %1, label %B14, label %B1\n\nB1:\n%2 = icmp ult i32 %0, 16384\nbr i1 %2, label %B2, label %B7\n\nB2:\n%3 = icmp ult i32 %0, 16\nbr i1 %3, label %B3, label %B4\n\nB3:\n%4 = zext i32 %0 to i64\n%5 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %4\n%6 = load i8, ptr %5, align 1\n%7 = sext i8 %6 to i32\nbr label %B14\n\nB4:\n%8 = icmp ult i32 %0, 512\nbr i1 %8, label %B5, label %B6\n\nB5:\n%9 = lshr i32 %0, 5\n%10 = zext i32 %9 to i64\n%11 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %10\n%12 = load i8, ptr %11, align 1\n%13 = sext i8 %12 to i32\n%14 = add nsw i32 %13, 5\nbr label %B14\n\nB6:\n%15 = lshr i32 %0, 10\n%16 = zext i32 %15 to i64\n%17 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %16\n%18 = load i8, ptr %17, align 1\n%19 = sext i8 %18 to i32\n%20 = add nsw i32 %19, 10\nbr label %B14\n\nB7:\n%21 = icmp ult i32 %0, 16777216\nbr i1 %21, label %B8, label %B11\n\nB8:\n%22 = icmp ult i32 %0, 524288\nbr i1 %22, label %B9, label %B10\n\nB9:\n%23 = lshr i32 %0, 15\n%24 = zext i32 %23 to i64\n%25 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %24\n%26 = load i8, ptr %25, align 1\n%27 = sext i8 %26 to i32\n%28 = add nsw i32 %27, 15\nbr label %B14\n\nB10:\n%29 = lshr i32 %0, 20\n%30 = zext i32 %29 to i64\n%31 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %30\n%32 = load i8, ptr %31, align 1\n%33 = sext i8 %32 to i32\n%34 = add nsw i32 %33, 20\nbr label %B14\n\nB11:\n%35 = icmp ult i32 %0, 536870912\nbr i1 %35, label %B12, label %B13\n\nB12:\n%36 = lshr i32 %0, 25\n%37 = zext i32 %36 to i64\n%38 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %37\n%39 = load i8, ptr %38, align 1\n%40 = sext i8 %39 to i32\n%41 = add nsw i32 %40, 25\nbr label %B14\n\nB13:\n%42 = lshr i32 %0, 30\n%43 = zext i32 %42 to i64\n%44 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %43\n%45 = load i8, ptr %44, align 1\n%46 = sext i8 %45 to i32\n%47 = add nsw i32 %46, 30\nbr label %B14\n\nB14:\n%48 = phi i32 [ %7, %B3 ], [ %14, %B5 ], [ %20, %B6 ], [ %28, %B9 ], [ %34, %B10 ], [ %41, %B12 ], [ %47, %B13 ], [ 0, %B ]\nret i32 %48\n}", "codellama": "define internal i32 @ilog(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 0\nbr i1 %1, label %B10, label %B1\n\nB1:\n%2 = icmp ult i32 %0, 16384\nbr i1 %2, label %B2, label %B5\n\nB2:\n%3 = icmp ult i32 %0, 16\nbr i1 %3, label %B3, label %B4\n\nB3:\n%4 = zext i32 %0 to i64\n%5 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %4\n%6 = load i8, ptr %5, align 1\n%7 = zext i8 %6 to i32\nbr label %B10\n\nB4:\n%8 = icmp ult i32 %0, 512\n%9 = ashr i32 %0, 5\n%10 = sext i32 %9 to i64\n%11 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %10\n%12 = load i8, ptr %11, align 1\n%13 = sext i8 %12 to i32\n%14 = add nsw i32 %13, 5\n%15 = icmp ult i32 %0, 512\n%16 = ashr i32 %0, 10\n%17 = sext i32 %16 to i64\n%18 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %17\n%19 = load i8, ptr %18, align 1\n%20 = sext i8 %19 to i32\n%21 = add nsw i32 %20, 10\n%22 = select i1 %15, i32 %14, i32 %21\nbr label %B10\n\nB5:\n%23 = icmp ult i32 %0, 16777216\nbr i1 %23, label %B6, label %B9\n\nB6:\n%24 = icmp ult i32 %0, 524288\nbr i1 %24, label %B7, label %B8\n\nB7:\n%25 = ashr i32 %0, 15\n%26 = sext i32 %25 to i64\n%27 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %26\n%28 = load i8, ptr %27, align 1\n%29 = sext i8 %28 to i32\n%30 = add nsw i32 %29, 15\nbr label %B10\n\nB8:\n%31 = ashr i32 %0, 20\n%32 = sext i32</s>", "codegemma": "define internal i32 @ilog(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 0\nbr i1 %1, label %B10, label %B1\n\nB1:\n%2 = icmp slt i32 %0, 16384\nbr i1 %2, label %B2, label %B5\n\nB2:\n%3 = icmp slt i32 %0, 16\nbr i1 %3, label %B3, label %B4\n\nB3:\n%4 = sext i32 %0 to i64\n%5 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %4\n%6 = load i8, ptr %5, align 1\n%7 = sext i8 %6 to i32\nbr label %B10\n\nB4:\n%8 = icmp slt i32 %0, 512\nbr i1 %8, label %B5, label %B6\n\nB5:\n%9 = phi i32 [ 5, %B3 ], [ 10, %B4 ]\n%10 = ashr i32 %0, %9\n%11 = sext i32 %10 to i64\n%12 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %11\n%13 = load i8, ptr %12, align 1\n%14 = sext i8 %13 to i32\n%15 = add nsw i32 %14, %9\nbr label %B10\n\nB6:\n%16 = icmp slt i32 %0, 16777216\nbr i1 %16, label %B7, label %B9\n\nB7:\n%17 = icmp slt i32 %0, 524288\nbr i1 %17, label %B8, label %B9\n\nB8:\n%18 = ashr i32 %0, 15\n%19 = sext i32 %18 to i64\n%20 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %19\n%21 = load i8, ptr %20, align 1\n%22 = sext i8 %21 to i32\n%23 = add nsw i32 %22, 15\nbr label %B10\n\nB9:\n%24 = icmp slt i32 %0, 536870912\n%25 = ashr i32 %0, 25\n%26 = sext i32 %25 to i64\n%27 = getelementptr inbounds [16 x i8], ptr @ilog.log2_4, i64 0, i64 %26\n%28 = load i8, ptr %27, align 1\n%29 = sext i8 %28 to i32\n%30 = add nsw i32 %29, 25\nbr label %B10\n\nB10:\n%31 = phi i32 [ %7, %B3 ], [ %15, %B5 ], [ %23, %B8 ], [ %30, %B9 ],<eos>"}, "define dso_local ptr @IntegralTestsGetSuite() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call ptr (...) @CuSuiteNew()\nstore ptr %2, ptr %1, align 8\n%3 = load ptr, ptr %1, align 8\n%4 = load i32, ptr @TestComplexQuad2D, align 4\n%5 = call i32 @CuTestNew(ptr noundef @.str, i32 noundef %4)\n%6 = call i32 @CuSuiteAdd(ptr noundef %3, i32 noundef %5)\n%7 = load ptr, ptr %1, align 8\n%8 = load i32, ptr @TestComplexQuad3D, align 4\n%9 = call i32 @CuTestNew(ptr noundef @.str.1, i32 noundef %8)\n%10 = call i32 @CuSuiteAdd(ptr noundef %7, i32 noundef %9)\n%11 = load ptr, ptr %1, align 8\n%12 = load i32, ptr @TestSemiCircleIntegralRule01, align 4\n%13 = call i32 @CuTestNew(ptr noundef @.str.2, i32 noundef %12)\n%14 = call i32 @CuSuiteAdd(ptr noundef %11, i32 noundef %13)\n%15 = load ptr, ptr %1, align 8\n%16 = load i32, ptr @TestSemiCircleIntegralRule02, align 4\n%17 = call i32 @CuTestNew(ptr noundef @.str.3, i32 noundef %16)\n%18 = call i32 @CuSuiteAdd(ptr noundef %15, i32 noundef %17)\n%19 = load ptr, ptr %1, align 8\n%20 = load i32, ptr @TestSemiCircleLineIntegral01, align 4\n%21 = call i32 @CuTestNew(ptr noundef @.str.4, i32 noundef %20)\n%22 = call i32 @CuSuiteAdd(ptr noundef %19, i32 noundef %21)\n%23 = load ptr, ptr %1, align 8\n%24 = load i32, ptr @TestSemiCircleLineIntegral02, align 4\n%25 = call i32 @CuTestNew(ptr noundef @.str.5, i32 noundef %24)\n%26 = call i32 @CuSuiteAdd(ptr noundef %23, i32 noundef %25)\n%27 = load ptr, ptr %1, align 8\n%28 = load i32, ptr @TestSemiCircleLineIntegral03, align 4\n%29 = call i32 @CuTestNew(ptr noundef @.str.6, i32 noundef %28)\n%30 = call i32 @CuSuiteAdd(ptr noundef %27, i32 noundef %29)\n%31 = load ptr, ptr %1, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %31\n}": {"base_truth": "define dso_local ptr @IntegralTestsGetSuite() {\nB:\n%0 = tail call ptr (...) @CuSuiteNew()\n%1 = load i32, ptr @TestComplexQuad2D, align 4\n%2 = tail call i32 @CuTestNew(ptr noundef nonnull @.str, i32 noundef %1)\n%3 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %2)\n%4 = load i32, ptr @TestComplexQuad3D, align 4\n%5 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.1, i32 noundef %4)\n%6 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %5)\n%7 = load i32, ptr @TestSemiCircleIntegralRule01, align 4\n%8 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.2, i32 noundef %7)\n%9 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %8)\n%10 = load i32, ptr @TestSemiCircleIntegralRule02, align 4\n%11 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.3, i32 noundef %10)\n%12 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %11)\n%13 = load i32, ptr @TestSemiCircleLineIntegral01, align 4\n%14 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.4, i32 noundef %13)\n%15 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %14)\n%16 = load i32, ptr @TestSemiCircleLineIntegral02, align 4\n%17 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.5, i32 noundef %16)\n%18 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %17)\n%19 = load i32, ptr @TestSemiCircleLineIntegral03, align 4\n%20 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.6, i32 noundef %19)\n%21 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %20)\nret ptr %0\n}", "codellama": "define dso_local ptr @IntegralTestsGetSuite() {\nB:\n%0 = tail call ptr (...) @CuSuiteNew()\n%1 = load i32, ptr @TestComplexQuad2D, align 4\n%2 = tail call i32 @CuTestNew(ptr noundef nonnull @.str, i32 noundef %1)\n%3 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %2)\n%4 = load i32, ptr @TestComplexQuad3D, align 4\n%5 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.1, i32 noundef %4)\n%6 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %5)\n%7 = load i32, ptr @TestSemiCircleIntegralRule01, align 4\n%8 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.2, i32 noundef %7)\n%9 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %8)\n%10 = load i32, ptr @TestSemiCircleIntegralRule02, align 4\n%11 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.3, i32 noundef %10)\n%12 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %11)\n%13 = load i32, ptr @TestSemiCircleLineIntegral01, align 4\n%14 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.4, i32 noundef %13)\n%15 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %14)\n%16 = load i32, ptr @TestSemiCircleLineIntegral02, align 4\n%17 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.5, i32 noundef %16)\n%18 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %17)\n%19 = load i32, ptr @TestSemiCircleLineIntegral03, align 4\n%20 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.6, i32 noundef %19)\n%21 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %20)\nret ptr %0\n}", "codegemma": "define dso_local ptr @IntegralTestsGetSuite() {\nB:\n%0 = tail call ptr (...) @CuSuiteNew()\n%1 = load i32, ptr @TestComplexQuad2D, align 4\n%2 = tail call i32 @CuTestNew(ptr noundef nonnull @.str, i32 noundef %1)\n%3 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %2)\n%4 = load i32, ptr @TestComplexQuad3D, align 4\n%5 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.1, i32 noundef %4)\n%6 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %5)\n%7 = load i32, ptr @TestSemiCircleIntegralRule01, align 4\n%8 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.2, i32 noundef %7)\n%9 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %8)\n%10 = load i32, ptr @TestSemiCircleIntegralRule02, align 4\n%11 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.3, i32 noundef %10)\n%12 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %11)\n%13 = load i32, ptr @TestSemiCircleLineIntegral01, align 4\n%14 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.4, i32 noundef %13)\n%15 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %14)\n%16 = load i32, ptr @TestSemiCircleLineIntegral02, align 4\n%17 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.5, i32 noundef %16)\n%18 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %17)\n%19 = load i32, ptr @TestSemiCircleLineIntegral03, align 4\n%20 = tail call i32 @CuTestNew(ptr noundef nonnull @.str.6, i32 noundef %19)\n%21 = tail call i32 @CuSuiteAdd(ptr noundef %0, i32 noundef %20)\nret ptr %0\n}"}, "define dso_local void @pft(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\nbr label %5\n\n5:\n%6 = load ptr, ptr %3, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = icmp ule ptr %6, %7\nbr i1 %8, label %9, label %15\n\n9:\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds i8, ptr %10, i32 1\nstore ptr %11, ptr %3, align 8\n%12 = load i8, ptr %10, align 1\n%13 = sext i8 %12 to i32\n%14 = call i32 @printf(ptr noundef @.str, i32 noundef %13)\nbr label %5\n\n15:\nret void\n}": {"base_truth": "define dso_local void @pft(ptr noundef readonly %0, ptr noundef readnone %1) {\nB:\n%2 = icmp ugt ptr %0, %1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi ptr [ %4, %B1 ], [ %0, %B ]\n%4 = getelementptr inbounds i8, ptr %3, i64 1\n%5 = load i8, ptr %3, align 1\n%6 = sext i8 %5 to i32\n%7 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6)\n%8 = icmp ugt ptr %4, %1\nbr i1 %8, label %B2, label %B1\n\nB2:\nret void\n}", "codellama": "define dso_local void @pft(ptr noundef readonly %0, ptr noundef readnone %1) {\nB:\n%2 = icmp ugt ptr %0, %1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi ptr [ %7, %B1 ], [ %0, %B ]\n%4 = load i8, ptr %3, align 1\n%5 = sext i8 %4 to i32\n%6 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %5)\n%7 = getelementptr inbounds i8, ptr %3, i64 1\n%8 = icmp ugt ptr %7, %1\nbr i1 %8, label %B2, label %B1\n\nB2:\nret void\n}", "codegemma": "define dso_local void @pft(ptr noundef readonly %0, ptr noundef readnone %1) {\nB:\n%2 = icmp ugt ptr %0, %1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi ptr [ %5, %B1 ], [ %0, %B ]\n%4 = load i8, ptr %3, align 1\n%5 = getelementptr inbounds i8, ptr %3, i64 1\n%6 = sext i8 %4 to i32\n%7 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6)\n%8 = icmp ugt ptr %5, %1\nbr i1 %8, label %B2, label %B1\n\nB2:\nret void\n}"}, "define dso_local void @cgi_init_param() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = call ptr @cgi_get_data(ptr noundef %3)\nstore ptr %5, ptr %4, align 8\n%6 = load i32, ptr %3, align 4\n%7 = icmp ne i32 %6, 0\nbr i1 %7, label %8, label %52\n\n8:\nstore i32 0, ptr %1, align 4\nstore i32 0, ptr %2, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %2, align 4\n%11 = load i32, ptr %3, align 4\n%12 = icmp slt i32 %10, %11\nbr i1 %12, label %13, label %46\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = load i32, ptr %2, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds i8, ptr %14, i64 %16\n%18 = load i8, ptr %17, align 1\n%19 = sext i8 %18 to i32\n%20 = icmp eq i32 %19, 38\nbr i1 %20, label %21, label %29\n\n21:\n%22 = load ptr, ptr %4, align 8\n%23 = load i32, ptr %1, align 4\n%24 = load i32, ptr %2, align 4\n%25 = sub nsw i32 %24, 1\n%26 = call i32 @cgi_build_pair(ptr noundef %22, i32 noundef %23, i32 noundef %25)\n%27 = load i32, ptr %2, align 4\n%28 = add nsw i32 %27, 1\nstore i32 %28, ptr %1, align 4\nbr label %29\n\n29:\n%30 = load ptr, ptr %4, align 8\n%31 = load i32, ptr %2, align 4\n%32 = sext i32 %31 to i64\n%33 = getelementptr inbounds i8, ptr %30, i64 %32\n%34 = load i8, ptr %33, align 1\n%35 = sext i8 %34 to i32\n%36 = icmp eq i32 %35, 43\nbr i1 %36, label %37, label %42\n\n37:\n%38 = load ptr, ptr %4, align 8\n%39 = load i32, ptr %2, align 4\n%40 = sext i32 %39 to i64\n%41 = getelementptr inbounds i8, ptr %38, i64 %40\nstore i8 32, ptr %41, align 1\nbr label %42\n\n42:\nbr label %43\n\n43:\n%44 = load i32, ptr %2, align 4\n%45 = add nsw i32 %44, 1\nstore i32 %45, ptr %2, align 4\nbr label %9\n\n46:\n%47 = load ptr, ptr %4, align 8\n%48 = load i32, ptr %1, align 4\n%49 = load i32, ptr %2, align 4\n%50 = sub nsw i32 %49, 1\n%51 = call i32 @cgi_build_pair(ptr noundef %47, i32 noundef %48, i32 noundef %50)\nbr label %52\n\n52:\n%53 = load ptr, ptr %4, align 8\n%54 = call i32 @free(ptr noundef %53)\nstore ptr null, ptr %4, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @cgi_init_param() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call ptr @cgi_get_data(ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B9, label %B1\n\nB1:\n%4 = icmp sgt i32 %2, 0\nbr i1 %4, label %B2, label %B8\n\nB2:\n%5 = phi i64 [ %19, %B6 ], [ 0, %B1 ]\n%6 = phi i32 [ %17, %B6 ], [ 0, %B1 ]\n%7 = getelementptr inbounds i8, ptr %1, i64 %5\n%8 = load i8, ptr %7, align 1\n%9 = icmp eq i8 %8, 38\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = trunc i64 %5 to i32\n%11 = add i32 %10, -1\n%12 = call i32 @cgi_build_pair(ptr noundef nonnull %1, i32 noundef %6, i32 noundef %11)\n%13 = load i8, ptr %7, align 1\n%14 = trunc i64 %5 to i32\n%15 = add i32 %14, 1\nbr label %B4\n\nB4:\n%16 = phi i8 [ %13, %B3 ], [ %8, %B2 ]\n%17 = phi i32 [ %15, %B3 ], [ %6, %B2 ]\n%18 = icmp eq i8 %16, 43\nbr i1 %18, label %B5, label %B6\n\nB5:\nstore i8 32, ptr %7, align 1\nbr label %B6\n\nB6:\n%19 = add nuw nsw i64 %5, 1\n%20 = load i32, ptr %0, align 4\n%21 = sext i32 %20 to i64\n%22 = icmp slt i64 %19, %21\nbr i1 %22, label %B2, label %B7\n\nB7:\n%23 = trunc i64 %5 to i32\nbr label %B8\n\nB8:\n%24 = phi i32 [ 0, %B1 ], [ %17, %B7 ]\n%25 = phi i32 [ -1, %B1 ], [ %23, %B7 ]\n%26 = call i32 @cgi_build_pair(ptr noundef %1, i32 noundef %24, i32 noundef %25)\nbr label %B9\n\nB9:\n%27 = call i32 @free(ptr noundef %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @cgi_init_param() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call ptr @cgi_get_data(ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B7, label %B1\n\nB1:\n%4 = icmp sgt i32 %2, 0\nbr i1 %4, label %B2, label %B6\n\nB2:\n%5 = zext i32 %2 to i64\nbr label %B3\n\nB3:\n%6 = phi i64 [ 0, %B2 ], [ %17, %B5 ]\n%7 = phi i32 [ 0, %B2 ], [ %16, %B5 ]\n%8 = phi i32 [ 0, %B2 ], [ %18, %B5 ]\n%9 = getelementptr inbounds i8, ptr %1, i64 %6\n%10 = load i8, ptr %9, align 1\nswitch i8 %10, label %B5 [\ni8 38, label %B4\ni8 43, label %B8\n]\n\nB4:\n%11 = add nsw i64 %6, -1\n%12 = call i32 @cgi_build_pair(ptr noundef nonnull %1, i32 noundef %7, i32 noundef %11)\n%13 = add nuw nsw i64 %6, 1\n%14 = icmp eq i64 %13, %5\nbr i1 %14, label %B6, label %B5\n\nB5:\n%15 = phi i64 [ %6, %B3 ], [ %13, %B4 ]\n%16 = add nuw nsw i32 %7, 1\n%17 = add nuw nsw i64 %6, 1\n%18 = icmp eq i64 %17, %5\nbr i1 %18, label %B6, label %B3\n\nB6:\n%19 = phi i32 [ 0, %B1 ], [ %7, %B5 ], [ %7, %B4 ]\n%20 = phi i64 [ 0, %B1 ], [ %17, %B5 ], [ %11, %B4 ]\n%21 = call i32 @cgi_build_pair(ptr noundef nonnull %1, i32 noundef %19, i32 noundef %20)\nbr label %B7\n\nB7:\n%22 = call i32 @free(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n\nB8:\nstore i8 32, ptr %9, align 1\nbr label %B5\n}", "codegemma": "define dso_local void @cgi_init_param() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call ptr @cgi_get_data(ptr noundef nonnull %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B6\n\nB1:\n%4 = phi i64 [ %11, %B5 ], [ 0, %B ]\n%5 = phi i32 [ %12, %B5 ], [ %2, %B ]\n%6 = phi i32 [ %13, %B5 ], [ 0, %B ]\n%7 = getelementptr inbounds i8, ptr %1, i64 %4\n%8 = load i8, ptr %7, align 1\nswitch i8 %8, label %B5 [\ni8 38, label %B2\ni8 43, label %B3\n]\n\nB2:\n%9 = add nsw i32 %6, -1\n%10 = call i32 @cgi_build_pair(ptr noundef %1, i32 noundef %6, i32 noundef %9)\nbr label %B5\n\nB3:\nstore i8 32, ptr %7, align 1\nbr label %B5\n\nB4:\n%11 = add nuw nsw i64 %13, 1\n%12 = load i32, ptr %0, align 4\n%13 = add nsw i32 %12, -1\n%14 = sext i32 %13 to i64\n%15 = icmp slt i64 %11, %14\nbr i1 %15, label %B1, label %B6\n\nB5:\n%16 = add nsw i32 %6, -1\n%17 = call i32 @cgi_build_pair(ptr noundef %1, i32 noundef %6, i32 noundef %16)\nbr label %B6\n\nB6:\n%18 = phi i32 [ %5, %B ], [ %12, %B4 ], [ %12, %B5 ]\n%19 = phi i32 [ 0, %B ], [ %11, %B4 ], [ %13, %B5 ]\n%20 = call i32 @free(ptr noundef %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}"}, "define dso_local void @implement_button_loop() {\n%1 = load i64, ptr @BUTTON1_INVERTED, align 8\n%2 = icmp ne i64 %1, 0\nbr i1 %2, label %3, label %11\n\n3:\n%4 = load i32, ptr @BUTTON1, align 4\n%5 = call i64 @digitalRead(i32 noundef %4)\n%6 = load i64, ptr @LOW, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %8, label %9\n\n8:\nstore i32 1, ptr @button1pressed, align 4\nbr label %10\n\n9:\nstore i32 0, ptr @button1pressed, align 4\nbr label %10\n\n10:\nbr label %19\n\n11:\n%12 = load i32, ptr @BUTTON1, align 4\n%13 = call i64 @digitalRead(i32 noundef %12)\n%14 = load i64, ptr @HIGH, align 8\n%15 = icmp eq i64 %13, %14\nbr i1 %15, label %16, label %17\n\n16:\nstore i32 1, ptr @button1pressed, align 4\nbr label %18\n\n17:\nstore i32 0, ptr @button1pressed, align 4\nbr label %18\n\n18:\nbr label %19\n\n19:\n%20 = load i32, ptr @button1pressed, align 4\n%21 = icmp ne i32 %20, 0\nbr i1 %21, label %22, label %25\n\n22:\n%23 = load i32, ptr @RELAY1, align 4\n%24 = call i32 @toggle(i32 noundef %23, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button1pressed, align 4\nbr label %25\n\n25:\n%26 = load i64, ptr @BUTTON2_INVERTED, align 8\n%27 = icmp ne i64 %26, 0\nbr i1 %27, label %28, label %36\n\n28:\n%29 = load i32, ptr @BUTTON2, align 4\n%30 = call i64 @digitalRead(i32 noundef %29)\n%31 = load i64, ptr @LOW, align 8\n%32 = icmp eq i64 %30, %31\nbr i1 %32, label %33, label %34\n\n33:\nstore i32 1, ptr @button2pressed, align 4\nbr label %35\n\n34:\nstore i32 0, ptr @button2pressed, align 4\nbr label %35\n\n35:\nbr label %44\n\n36:\n%37 = load i32, ptr @BUTTON2, align 4\n%38 = call i64 @digitalRead(i32 noundef %37)\n%39 = load i64, ptr @HIGH, align 8\n%40 = icmp eq i64 %38, %39\nbr i1 %40, label %41, label %42\n\n41:\nstore i32 1, ptr @button2pressed, align 4\nbr label %43\n\n42:\nstore i32 0, ptr @button2pressed, align 4\nbr label %43\n\n43:\nbr label %44\n\n44:\n%45 = load i32, ptr @button2pressed, align 4\n%46 = icmp ne i32 %45, 0\nbr i1 %46, label %47, label %50\n\n47:\n%48 = load i32, ptr @RELAY2, align 4\n%49 = call i32 @toggle(i32 noundef %48, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button2pressed, align 4\nbr label %50\n\n50:\nret void\n}": {"base_truth": "define dso_local void @implement_button_loop() {\nB:\n%0 = load i64, ptr @BUTTON1_INVERTED, align 8\n%1 = icmp eq i64 %0, 0\n%2 = load i32, ptr @BUTTON1, align 4\n%3 = tail call i64 @digitalRead(i32 noundef %2)\nbr i1 %1, label %B2, label %B1\n\nB1:\n%4 = load i64, ptr @LOW, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B3, label %B4\n\nB2:\n%6 = load i64, ptr @HIGH, align 8\n%7 = icmp eq i64 %3, %6\nbr i1 %7, label %B3, label %B4\n\nB3:\nstore i32 1, ptr @button1pressed, align 4\n%8 = load i32, ptr @RELAY1, align 4\n%9 = tail call i32 @toggle(i32 noundef %8, i32 noundef 1, i32 noundef 500)\nbr label %B4\n\nB4:\nstore i32 0, ptr @button1pressed, align 4\n%10 = load i64, ptr @BUTTON2_INVERTED, align 8\n%11 = icmp eq i64 %10, 0\n%12 = load i32, ptr @BUTTON2, align 4\n%13 = tail call i64 @digitalRead(i32 noundef %12)\nbr i1 %11, label %B6, label %B5\n\nB5:\n%14 = load i64, ptr @LOW, align 8\n%15 = icmp eq i64 %13, %14\nbr i1 %15, label %B7, label %B8\n\nB6:\n%16 = load i64, ptr @HIGH, align 8\n%17 = icmp eq i64 %13, %16\nbr i1 %17, label %B7, label %B8\n\nB7:\nstore i32 1, ptr @button2pressed, align 4\n%18 = load i32, ptr @RELAY2, align 4\n%19 = tail call i32 @toggle(i32 noundef %18, i32 noundef 1, i32 noundef 500)\nbr label %B8\n\nB8:\nstore i32 0, ptr @button2pressed, align 4\nret void\n}", "codellama": "define dso_local void @implement_button_loop() {\nB:\n%0 = load i64, ptr @BUTTON1_INVERTED, align 8\n%1 = icmp eq i64 %0, 0\n%2 = load i32, ptr @BUTTON1, align 4\n%3 = tail call i64 @digitalRead(i32 noundef %2)\n%4 = load i64, ptr @LOW, align 8\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\nstore i32 %6, ptr @button1pressed, align 4\nbr i1 %1, label %B2, label %B1\n\nB1:\n%7 = load i32, ptr @BUTTON1, align 4\n%8 = tail call i64 @digitalRead(i32 noundef %7)\n%9 = load i64, ptr @HIGH, align 8\n%10 = icmp eq i64 %8, %9\n%11 = select i1 %10, i32 1, i32 0\nstore i32 %11, ptr @button1pressed, align 4\nbr label %B3\n\nB2:\n%12 = load i32, ptr @BUTTON1, align 4\n%13 = tail call i64 @digitalRead(i32 noundef %12)\n%14 = load i64, ptr @HIGH, align 8\n%15 = icmp eq i64 %13, %14\n%16 = select i1 %15, i32 1, i32 0\nstore i32 %16, ptr @button1pressed, align 4\nbr label %B3\n\nB3:\n%17 = load i32, ptr @RELAY1, align 4\n%18 = tail call i32 @toggle(i32 noundef %17, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button1pressed, align 4\n%19 = load i64, ptr @BUTTON2_INVERTED, align 8\n%20 = icmp eq i64 %19, 0\n%21 = load i32, ptr @BUTTON2, align 4\n%22 = tail call i64 @digitalRead(i32 noundef %21)\n%23 = load i64, ptr @LOW, align 8\n%24 = icmp eq i64 %22, %23\n%25 = zext i1 %24 to i32\nstore i32 %25, ptr @button2pressed, align 4\nbr i1 %20, label %B5, label %B4\n\nB4:\n%26 = load i32, ptr @RELAY2, align 4\n%27 = tail call i32 @toggle(i32 noundef %26, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button2pressed, align 4\nbr label %B7\n\nB5:\n%28 = load i32, ptr @BUTTON2, align 4\n%29 = tail call i64 @digitalRead(i32 noundef %28)\n%30 = load i64, ptr @HIGH, align 8\n%31 = icmp eq i64 %29, %30\n%32 = zext i1 %31 to i32\nstore i32 %32, ptr @button2pressed, align 4\nbr i1 %31, label %B6, label %B7\n\nB6:\n%33 = load i32, ptr @RELAY2, align 4\n%34 = tail call i32 @toggle(i32 noundef %33, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button2pressed, align 4\nbr label %B7\n\nB7:\nret void\n}", "codegemma": "define dso_local void @implement_button_loop() {\nB:\n%0 = load i64, ptr @BUTTON1_INVERTED, align 8\n%1 = icmp eq i64 %0, 0\n%2 = load i32, ptr @BUTTON1, align 4\n%3 = tail call i64 @digitalRead(i32 noundef %2)\n%4 = load i64, ptr @LOW, align 8\n%5 = icmp eq i64 %3, %4\n%6 = select i1 %5, i32 1, i32 0\nstore i32 %6, ptr @button1pressed, align 4\nbr i1 %1, label %B2, label %B1\n\nB1:\n%7 = load i64, ptr @HIGH, align 8\n%8 = icmp eq i64 %3, %7\n%9 = select i1 %8, i32 1, i32 0\nstore i32 %9, ptr @button1pressed, align 4\nbr label %B3\n\nB2:\n%10 = load i32, ptr @BUTTON2, align 4\n%11 = tail call i64 @digitalRead(i32 noundef %10)\n%12 = load i64, ptr @LOW, align 8\n%13 = icmp eq i64 %11, %12\n%14 = select i1 %13, i32 1, i32 0\nstore i32 %14, ptr @button2pressed, align 4\nbr label %B3\n\nB3:\n%15 = phi i32 [ %9, %B1 ], [ %14, %B2 ]\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B5, label %B4\n\nB4:\n%17 = load i32, ptr @RELAY1, align 4\n%18 = tail call i32 @toggle(i32 noundef %17, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button1pressed, align 4\nbr label %B5\n\nB5:\n%19 = load i64, ptr @BUTTON2_INVERTED, align 8\n%20 = icmp eq i64 %19, 0\nbr i1 %20, label %B7, label %B6\n\nB6:\n%21 = load i32, ptr @BUTTON2, align 4\n%22 = tail call i64 @digitalRead(i32 noundef %21)\n%23 = load i64, ptr @LOW, align 8\n%24 = icmp eq i64 %22, %23\n%25 = select i1 %24, i32 1, i32 0\nstore i32 %25, ptr @button2pressed, align 4\nbr label %B8\n\nB7:\n%26 = load i32, ptr @BUTTON2, align 4\n%27 = tail call i64 @digitalRead(i32 noundef %26)\n%28 = load i64, ptr @HIGH, align 8\n%29 = icmp eq i64 %27, %28\n%30 = select i1 %29, i32 1, i32 0\nstore i32 %30, ptr @button2pressed, align 4\nbr label %B8\n\nB8:\n%31 = phi i32 [ %25, %B6 ], [ %30, %B7 ]\n%32 = icmp eq i32 %31, 0\nbr i1 %32, label %B10, label %B9\n\nB9:\n%33 = load i32, ptr @RELAY2, align 4\n%34 = tail call i32 @toggle(i32 noundef %33, i32 noundef 1, i32 noundef 500)\nstore i32 0, ptr @button2pressed, align 4\nbr label %B10\n\nB10:\nret void\n}"}, "define internal i32 @get_ric(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = lshr i32 %3, 18\n%5 = and i32 %4, 3\nret i32 %5\n}": {"base_truth": "define internal i32 @get_ric(i32 noundef %0) {\nB:\n%1 = lshr i32 %0, 18\n%2 = and i32 %1, 3\nret i32 %2\n}", "codellama": "define internal i32 @get_ric(i32 noundef %0) {\nB:\n%1 = lshr i32 %0, 18\n%2 = and i32 %1, 3\nret i32 %2\n}", "codegemma": "define internal i32 @get_ric(i32 noundef %0) {\nB:\n%1 = lshr i32 %0, 18\n%2 = and i32 %1, 3\nret i32 %2\n}"}, "define internal void @p80211req_handlemsg(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.p80211msg ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\nswitch i32 %10, label %58 [\ni32 128, label %11\ni32 130, label %47\ni32 129, label %47\n]\n\n11:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%12 = load ptr, ptr %4, align 8\nstore ptr %12, ptr %5, align 8\n%13 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%14 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%15 = or i32 %13, %14\n%16 = xor i32 %15, -1\n%17 = load ptr, ptr %3, align 8\n%18 = getelementptr inbounds %struct.wlandevice ptr %17, i32 0, i32 0\n%19 = load i32, ptr %18, align 4\n%20 = and i32 %19, %16\nstore i32 %20, ptr %18, align 4\n%21 = load ptr, ptr %5, align 8\n%22 = getelementptr inbounds %struct.p80211msg_lnxreq_hostwep ptr %21, i32 0, i32 1\n%23 = getelementptr inbounds %struct.TYPE_4__, ptr %22, i32 0, i32 0\n%24 = load i32, ptr %23, align 4\n%25 = load i32, ptr @P80211ENUM_truth_true, align 4\n%26 = icmp eq i32 %24, %25\nbr i1 %26, label %27, label %33\n\n27:\n%28 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%29 = load ptr, ptr %3, align 8\n%30 = getelementptr inbounds %struct.wlandevice ptr %29, i32 0, i32 0\n%31 = load i32, ptr %30, align 4\n%32 = or i32 %31, %28\nstore i32 %32, ptr %30, align 4\nbr label %33\n\n33:\n%34 = load ptr, ptr %5, align 8\n%35 = getelementptr inbounds %struct.p80211msg_lnxreq_hostwep ptr %34, i32 0, i32 0\n%36 = getelementptr inbounds %struct.TYPE_3__, ptr %35, i32 0, i32 0\n%37 = load i32, ptr %36, align 4\n%38 = load i32, ptr @P80211ENUM_truth_true, align 4\n%39 = icmp eq i32 %37, %38\nbr i1 %39, label %40, label %46\n\n40:\n%41 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%42 = load ptr, ptr %3, align 8\n%43 = getelementptr inbounds %struct.wlandevice ptr %42, i32 0, i32 0\n%44 = load i32, ptr %43, align 4\n%45 = or i32 %44, %41\nstore i32 %45, ptr %43, align 4\nbr label %46\n\n46:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nbr label %58\n\n47:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%48 = load ptr, ptr %4, align 8\n%49 = getelementptr inbounds %struct.p80211msg ptr %48, i32 0, i32 0\n%50 = load i32, ptr %49, align 4\n%51 = icmp eq i32 %50, 130\n%52 = zext i1 %51 to i32\nstore i32 %52, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%53 = load ptr, ptr %4, align 8\nstore ptr %53, ptr %7, align 8\n%54 = load ptr, ptr %3, align 8\n%55 = load ptr, ptr %7, align 8\n%56 = load i32, ptr %6, align 4\n%57 = call i32 @p80211req_mibset_mibget(ptr noundef %54, ptr noundef %55, i32 noundef %56)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\nbr label %58\n\n58:\nret void\n}": {"base_truth": "define internal void @p80211req_handlemsg(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\nswitch i32 %2, label %B6 [\ni32 128, label %B1\ni32 130, label %B5\ni32 129, label %B5\n]\n\nB1:\n%3 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%4 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%5 = or i32 %4, %3\n%6 = xor i32 %5, -1\n%7 = load i32, ptr %0, align 4\n%8 = and i32 %7, %6\nstore i32 %8, ptr %0, align 4\n%9 = getelementptr inbounds %struct.p80211msg_lnxreq_hostwep, ptr %1, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr @P80211ENUM_truth_true, align 4\n%12 = icmp eq i32 %10, %11\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%14 = or i32 %13, %8\nstore i32 %14, ptr %0, align 4\n%15 = load i32, ptr @P80211ENUM_truth_true, align 4\nbr label %B3\n\nB3:\n%16 = phi i32 [ %14, %B2 ], [ %8, %B1 ]\n%17 = phi i32 [ %15, %B2 ], [ %11, %B1 ]\n%18 = icmp eq i32 %17, 128\nbr i1 %18, label %B4, label %B6\n\nB4:\n%19 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%20 = or i32 %16, %19\nstore i32 %20, ptr %0, align 4\nbr label %B6\n\nB5:\n%21 = icmp eq i32 %2, 130\n%22 = zext i1 %21 to i32\n%23 = tail call i32 @p80211req_mibset_mibget(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %22)\nbr label %B6\n\nB6:\nret void\n}", "codellama": "define internal void @p80211req_handlemsg(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\nswitch i32 %2, label %B5 [\ni32 128, label %B1\ni32 130, label %B4\ni32 129, label %B4\n]\n\nB1:\n%3 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%4 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%5 = or i32 %4, %3\n%6 = xor i32 %5, -1\n%7 = load i32, ptr %0, align 4\n%8 = and i32 %7, %6\nstore i32 %8, ptr %0, align 4\n%9 = getelementptr inbounds %struct.p80211msg_lnxreq_hostwep, ptr %1, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr @P80211ENUM_truth_true, align 4\n%12 = icmp eq i32 %10, %11\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%14 = or i32 %13, %8\nstore i32 %14, ptr %0, align 4\nbr label %B3\n\nB3:\n%15 = load i32, ptr %1, align 4\n%16 = icmp eq i32 %15, %11\n%17 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%18 = select i1 %16, i32 %17, i32 0\n%19 = or i32 %18, %8\nstore i32 %19, ptr %0, align 4\nbr label %B5\n\nB4:\n%20 = icmp eq i32 %2, 130\n%21 = zext i1 %20 to i32\n%22 = tail call i32 @p80211req_mibset_mibget(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %21)\nbr label %B5\n\nB5:\nret void\n}", "codegemma": "define internal void @p80211req_handlemsg(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\nswitch i32 %2, label %B6 [\ni32 128, label %B1\ni32 130, label %B4\ni32 129, label %B4\n]\n\nB1:\n%3 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%4 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%5 = or i32 %4, %3\n%6 = xor i32 %5, -1\n%7 = load i32, ptr %0, align 4\n%8 = and i32 %7, %6\nstore i32 %8, ptr %0, align 4\n%9 = getelementptr inbounds %struct.p80211msg_lnxreq_hostwep, ptr %1, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr @P80211ENUM_truth_true, align 4\n%12 = icmp eq i32 %10, %11\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = load i32, ptr @HOSTWEP_DECRYPT, align 4\n%14 = load i32, ptr %0, align 4\n%15 = or i32 %14, %13\nstore i32 %15, ptr %0, align 4\nbr label %B3\n\nB3:\n%16 = load i32, ptr %1, align 4\n%17 = load i32, ptr @P80211ENUM_truth_true, align 4\n%18 = icmp eq i32 %16, %17\nbr i1 %18, label %B5, label %B6\n\nB4:\n%19 = icmp eq i32 %2, 130\n%20 = zext i1 %19 to i32\n%21 = tail call i32 @p80211req_mibset_mibget(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %20)\nbr label %B6\n\nB5:\n%22 = load i32, ptr @HOSTWEP_ENCRYPT, align 4\n%23 = load i32, ptr %0, align 4\n%24 = or i32 %23, %22\nstore i32 %24, ptr %0, align 4\nbr label %B6\n\nB6:\nret void\n}"}, "define internal i32 @unk_lang_parser() {\nret i32 1\n}": {"base_truth": "define internal i32 @unk_lang_parser() {\nB:\nret i32 1\n}", "codellama": "define internal i32 @unk_lang_parser() {\nB:\nret i32 1\n}", "codegemma": "define internal i32 @unk_lang_parser() {\nB:\nret i32 1\n}"}, "define dso_local i32 @dns_resolvconfrewrite(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca %struct.taia align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = call i32 @taia_now(ptr noundef %4)\n%7 = call i64 @taia_less(ptr noundef @deadline, ptr noundef %4)\n%8 = icmp ne i64 %7, 0\nbr i1 %8, label %9, label %10\n\n9:\nstore i32 0, ptr @ok, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr @uses, align 4\n%12 = icmp ne i32 %11, 0\nbr i1 %12, label %14, label %13\n\n13:\nstore i32 0, ptr @ok, align 4\nbr label %14\n\n14:\n%15 = load i32, ptr @ok, align 4\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %24, label %17\n\n17:\n%18 = call i32 @init(ptr noundef @rules)\n%19 = icmp eq i32 %18, -1\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %32\n\n21:\n%22 = call i32 @taia_uint(ptr noundef @deadline, i32 noundef 600)\n%23 = call i32 @taia_add(ptr noundef @deadline, ptr noundef %4, ptr noundef @deadline)\nstore i32 10000, ptr @uses, align 4\nstore i32 1, ptr @ok, align 4\nbr label %24\n\n24:\n%25 = load i32, ptr @uses, align 4\n%26 = add nsw i32 %25, -1\nstore i32 %26, ptr @uses, align 4\n%27 = load ptr, ptr %3, align 8\n%28 = call i32 @stralloc_copy(ptr noundef %27, ptr noundef @rules)\n%29 = icmp ne i32 %28, 0\nbr i1 %29, label %31, label %30\n\n30:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %32\n\n31:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %32\n\n32:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%33 = load i32, ptr %2, align 4\nret i32 %33\n}": {"base_truth": "define dso_local i32 @dns_resolvconfrewrite(ptr noundef %0) {\nB:\n%1 = alloca %struct.taia, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @taia_now(ptr noundef nonnull %1)\n%3 = call i64 @taia_less(ptr noundef nonnull @deadline, ptr noundef nonnull %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\nstore i32 0, ptr @ok, align 4\nbr label %B2\n\nB2:\n%5 = load i32, ptr @uses, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B4\n\nB3:\nstore i32 0, ptr @ok, align 4\nbr label %B5\n\nB4:\n%7 = load i32, ptr @ok, align 4\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B5, label %B7\n\nB5:\n%9 = call i32 @init(ptr noundef nonnull @rules)\n%10 = icmp eq i32 %9, -1\nbr i1 %10, label %B8, label %B6\n\nB6:\n%11 = call i32 @taia_uint(ptr noundef nonnull @deadline, i32 noundef 600)\n%12 = call i32 @taia_add(ptr noundef nonnull @deadline, ptr noundef nonnull %1, ptr noundef nonnull @deadline)\nstore i32 1, ptr @ok, align 4\nbr label %B7\n\nB7:\n%13 = phi i32 [ 10000, %B6 ], [ %5, %B4 ]\n%14 = add nsw i32 %13, -1\nstore i32 %14, ptr @uses, align 4\n%15 = call i32 @stralloc_copy(ptr noundef %0, ptr noundef nonnull @rules)\n%16 = icmp eq i32 %15, 0\n%17 = sext i1 %16 to i32\nbr label %B8\n\nB8:\n%18 = phi i32 [ -1, %B5 ], [ %17, %B7 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %18\n}", "codellama": "define dso_local i32 @dns_resolvconfrewrite(ptr noundef %0) {\nB:\n%1 = alloca %struct.taia, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @taia_now(ptr noundef nonnull %1)\n%3 = call i64 @taia_less(ptr noundef nonnull @deadline, ptr noundef nonnull %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\nstore i32 0, ptr @ok, align 4\nbr label %B2\n\nB2:\n%5 = load i32, ptr @uses, align 4\n%6 = icmp eq i32 %5, 0\n%7 = select i1 %6, i1 true, i1 %4\nbr i1 %7, label %B3, label %B4\n\nB3:\n%8 = call i32 @init(ptr noundef nonnull @rules)\n%9 = icmp eq i32 %8, -1\nbr i1 %9, label %B6, label %B5\n\nB4:\n%10 = add nsw i32 %5, -1\nstore i32 %10, ptr @uses, align 4\nbr label %B5\n\nB5:\n%11 = phi i32 [ 10000, %B4 ], [ -1, %B3 ]\n%12 = call i32 @taia_uint(ptr noundef nonnull @deadline, i32 noundef 600)\n%13 = call i32 @taia_add(ptr noundef nonnull @deadline, ptr noundef nonnull %1, ptr noundef nonnull @deadline)\nstore i32 %11, ptr @uses, align 4\n%14 = call i32 @stralloc_copy(ptr noundef %0, ptr noundef nonnull @rules)\n%15 = icmp eq i32 %14, 0\n%16 = select i1 %15, i32 -1, i32 0\nbr label %B6\n\nB6:\n%17 = phi i32 [ -1, %B3 ], [ %16, %B5 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %17\n}", "codegemma": "define dso_local i32 @dns_resolvconfrewrite(ptr noundef %0) {\nB:\n%1 = alloca %struct.taia, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @taia_now(ptr noundef nonnull %1)\n%3 = call i64 @taia_less(ptr noundef nonnull @deadline, ptr noundef nonnull %1)\n%4 = icmp ne i64 %3, 0\n%5 = zext i1 %4 to i32\nstore i32 %5, ptr @ok, align 4\n%6 = load i32, ptr @uses, align 4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\nstore i32 0, ptr @ok, align 4\nbr label %B2\n\nB2:\n%8 = phi i32 [ 0, %B1 ], [ 1, %B ]\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = call i32 @init(ptr noundef nonnull @rules)\n%11 = icmp eq i32 %10, -1\nbr i1 %11, label %B6, label %B4\n\nB4:\n%12 = call i32 @taia_uint(ptr noundef nonnull @deadline, i32 noundef 600)\n%13 = call i32 @taia_add(ptr noundef nonnull @deadline, ptr noundef nonnull %1, ptr noundef nonnull @deadline)\n%14 = load i32, ptr @uses, align 4\n%15 = add nsw i32 %14, -1\nstore i32 %15, ptr @uses, align 4\n%16 = call i32 @stralloc_copy(ptr noundef %0, ptr noundef nonnull @rules)\n%17 = icmp eq i32 %16, 0\n%18 = sext i1 %17 to i32\nbr label %B6\n\nB5:\n%19 = load i32, ptr @uses, align 4\n%20 = add nsw i32 %19, -1\nstore i32 %20, ptr @uses, align 4\nbr label %B6\n\nB6:\n%21 = phi i32 [ -1, %B3 ], [ %18, %B4 ], [ -1, %B5 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %21\n}"}, "define dso_local void @BIT_4_C() {\n%1 = load i32, ptr @registers, align 4\n%2 = call i32 @bit(i32 noundef 4, i32 noundef %1)\nret void\n}": {"base_truth": "define dso_local void @BIT_4_C() {\nB:\n%0 = load i32, ptr @registers, align 4\n%1 = tail call i32 @bit(i32 noundef 4, i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @BIT_4_C() {\nB:\n%0 = load i32, ptr @registers, align 4\n%1 = tail call i32 @bit(i32 noundef 4, i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @BIT_4_C() {\nB:\n%0 = load i32, ptr @registers, align 4\n%1 = tail call i32 @bit(i32 noundef 4, i32 noundef %0)\nret void\n}"}, "define internal i32 @ov7x20_set_window(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%10 = load ptr, ptr %4, align 8\n%11 = load ptr, ptr %5, align 8\n%12 = call i32 @ov7x20_mode_init(ptr noundef %10, ptr noundef %11)\nstore i32 %12, ptr %6, align 4\n%13 = load i32, ptr %6, align 4\n%14 = icmp slt i32 %13, 0\nbr i1 %14, label %15, label %17\n\n15:\n%16 = load i32, ptr %6, align 4\nstore i32 %16, ptr %3, align 4\nstore i32 1, ptr %9, align 4\nbr label %73\n\n17:\n%18 = load ptr, ptr %5, align 8\n%19 = getelementptr inbounds %struct.ovcamchip_window ptr %18, i32 0, i32 4\n%20 = load i64, ptr %19, align 8\n%21 = icmp ne i64 %20, 0\nbr i1 %21, label %22, label %23\n\n22:\nstore i32 1, ptr %7, align 4\nstore i32 0, ptr %8, align 4\nbr label %24\n\n23:\nstore i32 2, ptr %7, align 4\nstore i32 1, ptr %8, align 4\nbr label %24\n\n24:\n%25 = load ptr, ptr %4, align 8\n%26 = load i64, ptr @HWSBASE, align 8\n%27 = load ptr, ptr %5, align 8\n%28 = getelementptr inbounds %struct.ovcamchip_window ptr %27, i32 0, i32 0\n%29 = load i32, ptr %28, align 8\n%30 = load i32, ptr %7, align 4\n%31 = ashr i32 %29, %30\n%32 = sext i32 %31 to i64\n%33 = add nsw i64 %26, %32\n%34 = call i32 @ov_write(ptr noundef %25, i32 noundef 23, i64 noundef %33)\n%35 = load ptr, ptr %4, align 8\n%36 = load i64, ptr @HWEBASE, align 8\n%37 = load ptr, ptr %5, align 8\n%38 = getelementptr inbounds %struct.ovcamchip_window ptr %37, i32 0, i32 0\n%39 = load i32, ptr %38, align 8\n%40 = load ptr, ptr %5, align 8\n%41 = getelementptr inbounds %struct.ovcamchip_window ptr %40, i32 0, i32 1\n%42 = load i32, ptr %41, align 4\n%43 = add nsw i32 %39, %42\n%44 = load i32, ptr %7, align 4\n%45 = ashr i32 %43, %44\n%46 = sext i32 %45 to i64\n%47 = add nsw i64 %36, %46\n%48 = call i32 @ov_write(ptr noundef %35, i32 noundef 24, i64 noundef %47)\n%49 = load ptr, ptr %4, align 8\n%50 = load i64, ptr @VWSBASE, align 8\n%51 = load ptr, ptr %5, align 8\n%52 = getelementptr inbounds %struct.ovcamchip_window ptr %51, i32 0, i32 2\n%53 = load i32, ptr %52, align 8\n%54 = load i32, ptr %8, align 4\n%55 = ashr i32 %53, %54\n%56 = sext i32 %55 to i64\n%57 = add nsw i64 %50, %56\n%58 = call i32 @ov_write(ptr noundef %49, i32 noundef 25, i64 noundef %57)\n%59 = load ptr, ptr %4, align 8\n%60 = load i64, ptr @VWEBASE, align 8\n%61 = load ptr, ptr %5, align 8\n%62 = getelementptr inbounds %struct.ovcamchip_window ptr %61, i32 0, i32 2\n%63 = load i32, ptr %62, align 8\n%64 = load ptr, ptr %5, align 8\n%65 = getelementptr inbounds %struct.ovcamchip_window ptr %64, i32 0, i32 3\n%66 = load i32, ptr %65, align 4\n%67 = add nsw i32 %63, %66\n%68 = load i32, ptr %8, align 4\n%69 = ashr i32 %67, %68\n%70 = sext i32 %69 to i64\n%71 = add nsw i64 %60, %70\n%72 = call i32 @ov_write(ptr noundef %59, i32 noundef 26, i64 noundef %71)\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %9, align 4\nbr label %73\n\n73:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%74 = load i32, ptr %3, align 4\nret i32 %74\n}": {"base_truth": "define internal i32 @ov7x20_set_window(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @ov7x20_mode_init(ptr noundef %0, ptr noundef %1)\n%3 = icmp slt i32 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 4\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\n%7 = select i1 %6, i32 2, i32 1\n%8 = zext i1 %6 to i32\n%9 = load i64, ptr @HWSBASE, align 8\n%10 = load i32, ptr %1, align 8\n%11 = ashr i32 %10, %7\n%12 = sext i32 %11 to i64\n%13 = add nsw i64 %9, %12\n%14 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 23, i64 noundef %13)\n%15 = load i64, ptr @HWEBASE, align 8\n%16 = load i32, ptr %1, align 8\n%17 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 1\n%18 = load i32, ptr %17, align 4\n%19 = add nsw i32 %18, %16\n%20 = ashr i32 %19, %7\n%21 = sext i32 %20 to i64\n%22 = add nsw i64 %15, %21\n%23 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 24, i64 noundef %22)\n%24 = load i64, ptr @VWSBASE, align 8\n%25 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 2\n%26 = load i32, ptr %25, align 8\n%27 = ashr i32 %26, %8\n%28 = sext i32 %27 to i64\n%29 = add nsw i64 %24, %28\n%30 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 25, i64 noundef %29)\n%31 = load i64, ptr @VWEBASE, align 8\n%32 = load i32, ptr %25, align 8\n%33 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 3\n%34 = load i32, ptr %33, align 4\n%35 = add nsw i32 %34, %32\n%36 = ashr i32 %35, %8\n%37 = sext i32 %36 to i64\n%38 = add nsw i64 %31, %37\n%39 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 26, i64 noundef %38)\nbr label %B2\n\nB2:\n%40 = phi i32 [ 0, %B1 ], [ %2, %B ]\nret i32 %40\n}", "codellama": "define internal i32 @ov7x20_set_window(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @ov7x20_mode_init(ptr noundef %0, ptr noundef %1)\n%3 = icmp slt i32 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 4\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\n%7 = select i1 %6, i32 2, i32 1\n%8 = select i1 %6, i32 1, i32 0\n%9 = load i64, ptr @HWSBASE, align 8\n%10 = load i32, ptr %1, align 8\n%11 = ashr i32 %10, %7\n%12 = sext i32 %11 to i64\n%13 = add nsw i64 %9, %12\n%14 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 23, i64 noundef %13)\n%15 = load i64, ptr @HWEBASE, align 8\n%16 = load i32, ptr %1, align 8\n%17 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 1\n%18 = load i32, ptr %17, align 4\n%19 = add nsw i32 %18, %16\n%20 = ashr i32 %19, %7\n%21 = sext i32 %20 to i64\n%22 = add nsw i64 %15, %21\n%23 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 24, i64 noundef %22)\n%24 = load i64, ptr @VWSBASE, align 8\n%25 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 2\n%26 = load i32, ptr %25, align 8\n%27 = ashr i32 %26, %8\n%28 = sext i32 %27 to i64\n%29 = add nsw i64 %24, %28\n%30 = tail call i32 @ov_write(ptr nound</s>", "codegemma": "define internal i32 @ov7x20_set_window(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @ov7x20_mode_init(ptr noundef %0, ptr noundef %1)\n%3 = icmp slt i32 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 4\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\n%7 = select i1 %6, i32 2, i32 1\n%8 = load i64, ptr @HWSBASE, align 8\n%9 = load i32, ptr %1, align 8\n%10 = ashr i32 %9, %7\n%11 = sext i32 %10 to i64\n%12 = add nsw i64 %8, %11\n%13 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 23, i64 noundef %12)\n%14 = load i64, ptr @HWEBASE, align 8\n%15 = load i32, ptr %1, align 8\n%16 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 1\n%17 = load i32, ptr %16, align 4\n%18 = add nsw i32 %17, %15\n%19 = ashr i32 %18, %7\n%20 = sext i32 %19 to i64\n%21 = add nsw i64 %14, %20\n%22 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 24, i64 noundef %21)\n%23 = load i64, ptr @VWSBASE, align 8\n%24 = getelementptr inbounds %struct.ovcamchip_window, ptr %1, i64 0, i32 2\n%25 = load i32, ptr %24, align 8\n%26 = ashr i32 %25, %7\n%27 = sext i32 %26 to i64\n%28 = add nsw i64 %23, %27\n%29 = tail call i32 @ov_write(ptr noundef %0, i32 noundef 25, i64 noundef %28)\n%30 = load i64, ptr @VWEBASE, align 8\n%31 = load i32, ptr %24, align 8\n%32 = getelementptr inbounds %struct.ovcamchip_<eos>"}, "define dso_local void @glGetProgramLocalParameterfvARB(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\n%7 = load i32, ptr @NFOSMESA_GLGETPROGRAMLOCALPARAMETERFVARB, align 4\n%8 = load i32, ptr @cur_context, align 4\n%9 = call i32 @HostCall_p(i32 noundef %7, i32 noundef %8, ptr noundef %4)\nret void\n}": {"base_truth": "define dso_local void @glGetProgramLocalParameterfvARB(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readnone %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr @NFOSMESA_GLGETPROGRAMLOCALPARAMETERFVARB, align 4\n%5 = load i32, ptr @cur_context, align 4\n%6 = call i32 @HostCall_p(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %3)\nret void\n}", "codellama": "define dso_local void @glGetProgramLocalParameterfvARB(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readnone %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr @NFOSMESA_GLGETPROGRAMLOCALPARAMETERFVARB, align 4\n%5 = load i32, ptr @cur_context, align 4\n%6 = call i32 @HostCall_p(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %3)\nret void\n}", "codegemma": "define dso_local void @glGetProgramLocalParameterfvARB(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readnone %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr @NFOSMESA_GLGETPROGRAMLOCALPARAMETERFVARB, align 4\n%5 = load i32, ptr @cur_context, align 4\n%6 = call i32 @HostCall_p(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %3)\nret void\n}"}, "define dso_local void @show() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\nbr label %2\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = icmp eq i32 %3, 256\nbr i1 %4, label %5, label %6\n\n5:\nbr label %51\n\n6:\n%7 = load ptr, ptr @array, align 8\n%8 = load i32, ptr %1, align 4\n%9 = sext i32 %8 to i64\n%10 = getelementptr inbounds i32, ptr %7, i64 %9\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %13, label %15\n\n13:\n%14 = call i32 @printf(ptr noundef @.str)\nbr label %15\n\n15:\n%16 = load ptr, ptr @array, align 8\n%17 = load i32, ptr %1, align 4\n%18 = sext i32 %17 to i64\n%19 = getelementptr inbounds i32, ptr %16, i64 %18\n%20 = load i32, ptr %19, align 4\n%21 = icmp eq i32 %20, 1\nbr i1 %21, label %22, label %24\n\n22:\n%23 = call i32 @printf(ptr noundef @.str.1)\nbr label %24\n\n24:\n%25 = load ptr, ptr @array, align 8\n%26 = load i32, ptr %1, align 4\n%27 = sext i32 %26 to i64\n%28 = getelementptr inbounds i32, ptr %25, i64 %27\n%29 = load i32, ptr %28, align 4\n%30 = icmp eq i32 %29, 2\nbr i1 %30, label %31, label %33\n\n31:\n%32 = call i32 @printf(ptr noundef @.str.2)\nbr label %33\n\n33:\n%34 = load ptr, ptr @array, align 8\n%35 = load i32, ptr %1, align 4\n%36 = sext i32 %35 to i64\n%37 = getelementptr inbounds i32, ptr %34, i64 %36\n%38 = load i32, ptr %37, align 4\n%39 = icmp eq i32 %38, 3\nbr i1 %39, label %40, label %42\n\n40:\n%41 = call i32 @printf(ptr noundef @.str.3)\nbr label %42\n\n42:\n%43 = load i32, ptr %1, align 4\n%44 = add nsw i32 %43, 1\nstore i32 %44, ptr %1, align 4\n%45 = load i32, ptr %1, align 4\n%46 = srem i32 %45, 64\n%47 = icmp eq i32 %46, 0\nbr i1 %47, label %48, label %50\n\n48:\n%49 = call i32 @printf(ptr noundef @.str.4)\nbr label %50\n\n50:\nbr label %2\n\n51:\n%52 = call i32 @printf(ptr noundef @.str.4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @show() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i64 [ 0, %B ], [ %24, %B11 ]\n%1 = load ptr, ptr @array, align 8\n%2 = getelementptr inbounds i32, ptr %1, i64 %0\n%3 = load i32, ptr %2, align 4\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @printf(ptr noundef nonnull @.str)\n%6 = load ptr, ptr @array, align 8\n%7 = getelementptr inbounds i32, ptr %6, i64 %0\n%8 = load i32, ptr %7, align 4\nbr label %B3\n\nB3:\n%9 = phi i32 [ %8, %B2 ], [ %3, %B1 ]\n%10 = icmp eq i32 %9, 1\nbr i1 %10, label %B4, label %B5\n\nB4:\n%11 = tail call i32 @printf(ptr noundef nonnull @.str.1)\n%12 = load ptr, ptr @array, align 8\n%13 = getelementptr inbounds i32, ptr %12, i64 %0\n%14 = load i32, ptr %13, align 4\nbr label %B5\n\nB5:\n%15 = phi i32 [ %14, %B4 ], [ %9, %B3 ]\n%16 = icmp eq i32 %15, 2\nbr i1 %16, label %B6, label %B7\n\nB6:\n%17 = tail call i32 @printf(ptr noundef nonnull @.str.2)\n%18 = load ptr, ptr @array, align 8\n%19 = getelementptr inbounds i32, ptr %18, i64 %0\n%20 = load i32, ptr %19, align 4\nbr label %B7\n\nB7:\n%21 = phi i32 [ %20, %B6 ], [ %15, %B5 ]\n%22 = icmp eq i32 %21, 3\nbr i1 %22, label %B8, label %B9\n\nB8:\n%23 = tail call i32 @printf(ptr noundef nonnull @.str.3)\nbr label %B9\n\nB9:\n%24 = add nuw nsw i64 %0, 1\n%25 = and i64 %24, 63\n%26 = icmp eq i64 %25, 0\nbr i1 %26, label %B10, label %B11\n\nB10:\n%27 = tail call i32 @printf(ptr noundef nonnull @.str.4)\nbr label %B11\n\nB11:\n%28 = icmp eq i64 %24, 256\nbr i1 %28, label %B12, label %B1\n\nB12:\n%29 = tail call i32 @printf(ptr noundef nonnull @.str.4)\nret void\n}", "codellama": "define dso_local void @show() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i64 [ 0, %B ], [ %16, %B1 ]\n%1 = load ptr, ptr @array, align 8\n%2 = getelementptr inbounds i32, ptr %1, i64 %0\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %B4 [\ni32 0, label %B2\ni32 1, label %B3\ni32 2, label %B5\ni32 3, label %B6\n]\n\nB2:\n%4 = tail call i32 @printf(ptr noundef nonnull @.str)\n%5 = load ptr, ptr @array, align 8\n%6 = getelementptr inbounds i32, ptr %5, i64 %0\n%7 = load i32, ptr %6, align 4\nbr label %B4\n\nB3:\n%8 = tail call i32 @printf(ptr noundef nonnull @.str.1)\n%9 = load ptr, ptr @array, align 8\n%10 = getelementptr inbounds i32, ptr %9, i64 %0\n%11 = load i32, ptr %10, align 4\nbr label %B4\n\nB4:\n%12 = phi i32 [ %3, %B1 ], [ %11, %B3 ], [ %7, %B2 ]\n%13 = icmp eq i32 %12, 3\nbr i1 %13, label %B5, label %B6\n\nB5:\n%14 = tail call i32 @printf(ptr noundef nonnull @.str.3)\n%15 = load ptr, ptr @array, align 8\n%16 = add nuw nsw i64 %0, 1\n%17 = and i64 %16, 63\n%18 = getelementptr inbounds i32, ptr %15, i64 %17\n%19 = load i32, ptr %18, align 4\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B1, label %B1\n\nB6:\n%21 = icmp eq i32 %12, 2\nbr i1 %21, label %B5, label %B7\n\nB7:\n%22 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%23 = load ptr, ptr @array, align 8\n%24 = add nuw nsw i64 %0, 1\n%25 = and i64 %24, 63\n%26 = getelementptr inbounds i32, ptr %23, i64 %25\n%27 = load i32, ptr %26, align 4\n%28 = icmp eq i32 %27, 0\nbr i1 %28, label %B8, label %B9\n\nB8:\n%29 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%30 = load ptr, ptr @array, align 8\n%31 = add nuw nsw i64 %0, 1\n%32 = and i64 %31, 63\n%33 = getelementptr inbounds i32, ptr %30, i64 %32\n%34 = load i32, ptr %33, align 4\n%35 = icmp eq i32 %34, 0\nbr i1 %35, label %B9, label %B10\n\nB9:\n%36 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%37 = load ptr, ptr @array, align 8\n%38 = add nuw nsw i64 %0, 1\n%39 = and i64 %38, 63\n%40 = getelementptr inbounds i32, ptr %37, i64 %39\n%41 = load i32, ptr %40, align 4\n%42 = icmp eq i32 %41, 0\nbr i1 %42, label %B10, label %B11\n\nB10:\n%43 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%44 = load ptr, ptr @array, align 8\n%45 = add nuw nsw i64 %0, 1\n%46 = and i64 %45, 63\n%47 = getelementptr inbounds i32, ptr %44, i64 %46\n%48 = load i32, ptr %47, align 4\n%49 = icmp eq i32 %48, 0\nbr i1 %49, label %B11, label %B12\n\nB11:\n%50 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%51 = load ptr, ptr @array, align 8\n%52 = add nuw nsw i64 %0, 1\n%53 = and i64 %52, 63\n%54 = getelementptr inbounds i32, ptr %51, i64 %53\n%55 = load i32, ptr %54, align 4\n%56 = icmp eq i32 %55, 0\nbr i1 %56, label %B12, label %B13\n\nB12:\n%57 = tail call i32 @printf(ptr noundef nonnull @.str.4)\n%58 = load ptr, ptr @array, align 8\n%59 = add nuw nsw i64 %0, 1\n%60 =</s>", "codegemma": "define dso_local void @show() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i64 [ 0, %B ], [ %11, %B10 ]\n%1 = load ptr, ptr @array, align 8\n%2 = getelementptr inbounds i32, ptr %1, i64 %0\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %B2 [\ni32 0, label %B3\ni32 1, label %B4\ni32 2, label %B5\ni32 3, label %B6\n]\n\nB2:\n%4 = tail call i32 @printf(ptr noundef nonnull @.str.4)\nbr label %B10\n\nB3:\n%5 = tail call i32 @printf(ptr noundef nonnull @.str)\nbr label %B10\n\nB4:\n%6 = tail call i32 @printf(ptr noundef nonnull @.str.1)\nbr label %B10\n\nB5:\n%7 = tail call i32 @printf(ptr noundef nonnull @.str.2)\nbr label %B10\n\nB6:\n%8 = tail call i32 @printf(ptr noundef nonnull @.str.3)\nbr label %B10\n\nB7:\n%9 = tail call i32 @printf(ptr noundef nonnull @.str.4)\nbr label %B10\n\nB8:\n%10 = tail call i32 @printf(ptr noundef nonnull @.str.4)\nbr label %B10\n\nB9:\n%11 = add nuw nsw i64 %0, 1\n%12 = and i64 %11, 63\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B7, label %B1\n\nB10:\n%14 = tail call i32 @printf(ptr noundef nonnull @.str.4)\nret void\n}"}, "define dso_local ptr @fetch_alloc_message_short() {\n%1 = alloca [1 x i32], align 4\n%2 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%3 = getelementptr inbounds [1 x i32], ptr %1, i64 0, i64 0\n%4 = call i32 @prefetch_data(ptr noundef %3, i32 noundef 4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%5 = getelementptr inbounds [1 x i32], ptr %1, i64 0, i64 0\n%6 = load i32, ptr %5, align 4\n%7 = call ptr @message_get(i32 noundef %6)\nstore ptr %7, ptr %2, align 8\n%8 = load ptr, ptr %2, align 8\n%9 = icmp ne ptr %8, null\nbr i1 %9, label %20, label %10\n\n10:\n%11 = call ptr @talloc0(i32 noundef 4)\nstore ptr %11, ptr %2, align 8\n%12 = getelementptr inbounds [1 x i32], ptr %1, i64 0, i64 0\n%13 = load i32, ptr %12, align 4\n%14 = load ptr, ptr %2, align 8\n%15 = getelementptr inbounds %struct.message ptr %14, i32 0, i32 0\nstore i32 %13, ptr %15, align 4\n%16 = load ptr, ptr %2, align 8\n%17 = call i32 @message_insert_tree(ptr noundef %16)\n%18 = load i32, ptr @messages_allocated, align 4\n%19 = add nsw i32 %18, 1\nstore i32 %19, ptr @messages_allocated, align 4\nbr label %20\n\n20:\n%21 = load ptr, ptr %2, align 8\n%22 = call i32 @fetch_message_short(ptr noundef %21)\n%23 = load ptr, ptr %2, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret ptr %23\n}": {"base_truth": "define dso_local ptr @fetch_alloc_message_short() {\nB:\n%0 = alloca [1 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @prefetch_data(ptr noundef nonnull %0, i32 noundef 4)\n%2 = load i32, ptr %0, align 4\n%3 = call ptr @message_get(i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = call ptr @talloc0(i32 noundef 4)\n%6 = load i32, ptr %0, align 4\nstore i32 %6, ptr %5, align 4\n%7 = call i32 @message_insert_tree(ptr noundef nonnull %5)\n%8 = load i32, ptr @messages_allocated, align 4\n%9 = add nsw i32 %8, 1\nstore i32 %9, ptr @messages_allocated, align 4\nbr label %B2\n\nB2:\n%10 = phi ptr [ %3, %B ], [ %5, %B1 ]\n%11 = call i32 @fetch_message_short(ptr noundef nonnull %10)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret ptr %10\n}", "codellama": "define dso_local ptr @fetch_alloc_message_short() {\nB:\n%0 = alloca [1 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @prefetch_data(ptr noundef nonnull %0, i32 noundef 4)\n%2 = load i32, ptr %0, align 4\n%3 = call ptr @message_get(i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = call ptr @talloc0(i32 noundef 4)\nstore i32 %2, ptr %5, align 4\n%6 = call i32 @message_insert_tree(ptr noundef nonnull %5)\n%7 = load i32, ptr @messages_allocated, align 4\n%8 = add nsw i32 %7, 1\nstore i32 %8, ptr @messages_allocated, align 4\nbr label %B2\n\nB2:\n%9 = phi ptr [ %5, %B1 ], [ %3, %B ]\n%10 = call i32 @fetch_message_short(ptr noundef %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret ptr %9\n}", "codegemma": "define dso_local ptr @fetch_alloc_message_short() {\nB:\n%0 = alloca [1 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @prefetch_data(ptr noundef nonnull %0, i32 noundef 4)\n%2 = load i32, ptr %0, align 4\n%3 = call ptr @message_get(i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = call ptr @talloc0(i32 noundef 4)\n%6 = load i32, ptr %0, align 4\nstore i32 %6, ptr %5, align 4\n%7 = call i32 @message_insert_tree(ptr noundef nonnull %5)\n%8 = load i32, ptr @messages_allocated, align 4\n%9 = add nsw i32 %8, 1\nstore i32 %9, ptr @messages_allocated, align 4\nbr label %B2\n\nB2:\n%10 = phi ptr [ %5, %B1 ], [ %3, %B ]\n%11 = call i32 @fetch_message_short(ptr noundef nonnull %10)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret ptr %10\n}"}, "define dso_local i32 @sum(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = icmp ne i32 %3, 0\nbr i1 %4, label %5, label %19\n\n5:\n%6 = load ptr, ptr @bi_tree, align 8\n%7 = load i32, ptr %2, align 4\n%8 = sext i32 %7 to i64\n%9 = getelementptr inbounds i32, ptr %6, i64 %8\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr %2, align 4\n%12 = load i32, ptr %2, align 4\n%13 = load i32, ptr %2, align 4\n%14 = sub nsw i32 0, %13\n%15 = and i32 %12, %14\n%16 = sub nsw i32 %11, %15\n%17 = call i32 @sum(i32 noundef %16)\n%18 = add nsw i32 %10, %17\nbr label %20\n\n19:\nbr label %20\n\n20:\n%21 = phi i32 [ %18, %5 ], [ 0, %19 ]\nret i32 %21\n}": {"base_truth": "define dso_local i32 @sum(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load ptr, ptr @bi_tree, align 8\nbr label %B2\n\nB2:\n%3 = phi i32 [ %0, %B1 ], [ %9, %B2 ]\n%4 = phi i32 [ 0, %B1 ], [ %10, %B2 ]\n%5 = sext i32 %3 to i64\n%6 = getelementptr inbounds i32, ptr %2, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = add i32 %3, -1\n%9 = and i32 %8, %3\n%10 = add nsw i32 %7, %4\n%11 = icmp eq i32 %9, 0\nbr i1 %11, label %B3, label %B2\n\nB3:\n%12 = phi i32 [ 0, %B ], [ %10, %B2 ]\nret i32 %12\n}", "codellama": "define dso_local i32 @sum(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = phi i32 [ %9, %B1 ], [ 0, %B ]\n%3 = phi i32 [ %10, %B1 ], [ %0, %B ]\n%4 = load ptr, ptr @bi_tree, align 8\n%5 = sext i32 %3 to i64\n%6 = getelementptr inbounds i32, ptr %4, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = add nsw i32 %3, -1\n%9 = add nsw i32 %2, %7\n%10 = and i32 %8, %3\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB2:\n%12 = phi i32 [ 0, %B ], [ %9, %B1 ]\nret i32 %12\n}", "codegemma": "define dso_local i32 @sum(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = phi i32 [ %5, %B1 ], [ %0, %B ]\n%3 = load ptr, ptr @bi_tree, align 8\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds i32, ptr %3, i64 %4\n%6 = load i32, ptr %5, align 4\n%7 = sub nsw i32 0, %2\n%8 = and i32 %7, %2\n%9 = sub nsw i32 %2, %8\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B2, label %B1\n\nB2:\n%11 = phi i32 [ 0, %B ], [ %6, %B1 ]\nret i32 %11\n}"}, "define dso_local zeroext i8 @IOIIC_Receive(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i8, align 1\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 1, ptr %4)\nstore i8 0, ptr %4, align 1\n%5 = call i32 (...) @IIC_SDAHigh()\nstore i32 0, ptr %3, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %3, align 4\n%8 = icmp slt i32 %7, 8\nbr i1 %8, label %9, label %31\n\n9:\n%10 = load i8, ptr %4, align 1\n%11 = zext i8 %10 to i32\n%12 = shl i32 %11, 1\n%13 = trunc i32 %12 to i8\nstore i8 %13, ptr %4, align 1\n%14 = call i32 (...) @IIC_SCLHigh()\n%15 = call i32 (...) @IIC_Wait2uSec()\n%16 = load i32, ptr @SW_SDA, align 4\n%17 = call i64 @IO_GetInput(i32 noundef %16)\n%18 = icmp ne i64 %17, 0\nbr i1 %18, label %19, label %24\n\n19:\n%20 = load i8, ptr %4, align 1\n%21 = zext i8 %20 to i32\n%22 = or i32 %21, 1\n%23 = trunc i32 %22 to i8\nstore i8 %23, ptr %4, align 1\nbr label %24\n\n24:\n%25 = call i32 (...) @IIC_Wait2uSec()\n%26 = call i32 (...) @IIC_SCLLow()\n%27 = call i32 (...) @IIC_Wait2uSec()\nbr label %28\n\n28:\n%29 = load i32, ptr %3, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %3, align 4\nbr label %6\n\n31:\n%32 = load i32, ptr %2, align 4\n%33 = icmp ne i32 %32, 0\nbr i1 %33, label %34, label %41\n\n34:\n%35 = call i32 (...) @IIC_SDALow()\n%36 = call i32 (...) @IIC_Wait2uSec()\n%37 = call i32 (...) @IIC_SCLHigh()\n%38 = call i32 (...) @IIC_Wait2uSec()\n%39 = call i32 (...) @IIC_SCLLow()\n%40 = call i32 (...) @IIC_Wait2uSec()\nbr label %41\n\n41:\n%42 = load i8, ptr %4, align 1\ncall void @llvm.lifetime.end.p0(i64 1, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i8 %42\n}": {"base_truth": "define dso_local zeroext i8 @IOIIC_Receive(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @IIC_SDAHigh()\n%2 = tail call i32 (...) @IIC_SCLHigh()\n%3 = tail call i32 (...) @IIC_Wait2uSec()\n%4 = load i32, ptr @SW_SDA, align 4\n%5 = tail call i64 @IO_GetInput(i32 noundef %4)\n%6 = tail call i32 (...) @IIC_Wait2uSec()\n%7 = tail call i32 (...) @IIC_SCLLow()\n%8 = tail call i32 (...) @IIC_Wait2uSec()\n%9 = tail call i32 (...) @IIC_SCLHigh()\n%10 = tail call i32 (...) @IIC_Wait2uSec()\n%11 = load i32, ptr @SW_SDA, align 4\n%12 = tail call i64 @IO_GetInput(i32 noundef %11)\n%13 = tail call i32 (...) @IIC_Wait2uSec()\n%14 = tail call i32 (...) @IIC_SCLLow()\n%15 = tail call i32 (...) @IIC_Wait2uSec()\n%16 = tail call i32 (...) @IIC_SCLHigh()\n%17 = tail call i32 (...) @IIC_Wait2uSec()\n%18 = load i32, ptr @SW_SDA, align 4\n%19 = tail call i64 @IO_GetInput(i32 noundef %18)\n%20 = tail call i32 (...) @IIC_Wait2uSec()\n%21 = tail call i32 (...) @IIC_SCLLow()\n%22 = tail call i32 (...) @IIC_Wait2uSec()\n%23 = tail call i32 (...) @IIC_SCLHigh()\n%24 = tail call i32 (...) @IIC_Wait2uSec()\n%25 = load i32, ptr @SW_SDA, align 4\n%26 = tail call i64 @IO_GetInput(i32 noundef %25)\n%27 = tail call i32 (...) @IIC_Wait2uSec()\n%28 = tail call i32 (...) @IIC_SCLLow()\n%29 = tail call i32 (...) @IIC_Wait2uSec()\n%30 = tail call i32 (...) @IIC_SCLHigh()\n%31 = tail call i32 (...) @IIC_Wait2uSec()\n%32 = load i32, ptr @SW_SDA, align 4\n%33 = tail call i64 @IO_GetInput(i32 noundef %32)\n%34 = tail call i32 (...) @IIC_Wait2uSec()\n%35 = tail call i32 (...) @IIC_SCLLow()\n%36 = tail call i32 (...) @IIC_Wait2uSec()\n%37 = tail call i32 (...) @IIC_SCLHigh()\n%38 = tail call i32 (...) @IIC_Wait2uSec()\n%39 = load i32, ptr @SW_SDA, align 4\n%40 = tail call i64 @IO_GetInput(i32 noundef %39)\n%41 = tail call i32 (...) @IIC_Wait2uSec()\n%42 = tail call i32 (...) @IIC_SCLLow()\n%43 = tail call i32 (...) @IIC_Wait2uSec()\n%44 = tail call i32 (...) @IIC_SCLHigh()\n%45 = tail call i32 (...) @IIC_Wait2uSec()\n%46 = load i32, ptr @SW_SDA, align 4\n%47 = tail call i64 @IO_GetInput(i32 noundef %46)\n%48 = tail call i32 (...) @IIC_Wait2uSec()\n%49 = tail call i32 (...) @IIC_SCLLow()\n%50 = tail call i32 (...) @IIC_Wait2uSec()\n%51 = tail call i32 (...) @IIC_SCLHigh()\n%52 = tail call i32 (...) @IIC_Wait2uSec()\n%53 = load i32, ptr @SW_SDA, align 4\n%54 = tail call i64 @IO_GetInput(i32 noundef %53)\n%55 = tail call i32 (...) @IIC_Wait2uSec()\n%56 = tail call i32 (...) @IIC_SCLLow()\n%57 = tail call i32 (...) @IIC_Wait2uSec()\n%58 = icmp eq i32 %0, 0\nbr i1 %58, label %B2, label %B1\n\nB1:\n%59 = tail call i32 (...) @IIC_SDALow()\n%60 = tail call i32 (...) @IIC_Wait2uSec()\n%61 = tail call i32 (...) @IIC_SCLHigh()\n%62 = tail call i32 (...) @IIC_Wait2uSec()\n%63 = tail call i32 (...) @IIC_SCLLow()\n%64 = tail call i32 (...) @IIC_Wait2uSec()\nbr label %B2\n\nB2:\n%65 = icmp eq i64 %5, 0\n%66 = select i1 %65, i8 0, i8 2\n%67 = icmp ne i64 %12, 0\n%68 = zext i1 %67 to i8\n%69 = or i8 %66, %68\n%70 = shl nuw nsw i8 %69, 2\n%71 = icmp eq i64 %19, 0\n%72 = select i1 %71, i8 0, i8 2\n%73 = or i8 %70, %72\n%74 = icmp ne i64 %26, 0\n%75 = zext i1 %74 to i8\n%76 = or i8 %73, %75\n%77 = shl nuw nsw i8 %76, 2\n%78 = icmp eq i64 %33, 0\n%79 = select i1 %78, i8 0, i8 2\n%80 = or i8 %77, %79\n%81 = icmp ne i64 %40, 0\n%82 = zext i1 %81 to i8\n%83 = or i8 %80, %82\n%84 = shl nuw i8 %83, 2\n%85 = icmp eq i64 %47, 0\n%86 = select i1 %85, i8 0, i8 2\n%87 = or i8 %84, %86\n%88 = icmp ne i64 %54, 0\n%89 = zext i1 %88 to i8\n%90 = or i8 %87, %89\nret i8 %90\n}", "codellama": "define dso_local zeroext i8 @IOIIC_Receive(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @IIC_SDAHigh()\n%2 = tail call i32 (...) @IIC_Wait2uSec()\n%3 = tail call i32 (...) @IIC_SCLHigh()\n%4 = tail call i32 (...) @IIC_Wait2uSec()\n%5 = load i32, ptr @SW_SDA, align 4\n%6 = tail call i64 @IO_GetInput(i32 noundef %5)\n%7 = icmp eq i64 %6, 0\n%8 = select i1 %7, i32 0, i32 2\n%9 = tail call i32 (...) @IIC_Wait2uSec()\n%10 = tail call i32 (...) @IIC_SCLLow()\n%11 = tail call i32 (...) @IIC_Wait2uSec()\n%12 = tail call i32 (...) @IIC_SCLHigh()\n%13 = tail call i32 (...) @IIC_Wait2uSec()\n%14 = tail call i32 (...) @IIC_SCLLow()\n%15 = tail call i32 (...) @IIC_Wait2uSec()\n%16 = tail call i32 (...) @IIC_SCLHigh()\n%17 = tail call i32 (...) @IIC_Wait2uSec()\n%18 = tail call i32 (...) @IIC_SCLLow()\n%19 = tail call i32 (...) @IIC_Wait2uSec()\n%20 = tail call i32 (...) @IIC_SCLHigh()\n%21 = tail call i32 (...) @IIC_Wait2uSec()\n%22 = tail call i32 (...) @IIC_SCLLow()\n%23 = tail call i32 (...) @IIC_Wait2uSec()\n%24 = tail call i32 (...) @IIC_SCLHigh()\n%25 = tail call i32 (...) @IIC_Wait2uSec()\n%26 = tail call i32 (...) @IIC_SCLLow()\n%27 = tail call i32 (...) @IIC_Wait2uSec()\n%28 = tail call i32 (...) @IIC_SCLHigh()\n%29 = tail call i32 (...) @IIC_Wait2uSec()\n%30 = tail call i32 (...) @IIC_SCLLow()\n%31 = tail call i32 (...) @IIC_Wait2uSec()\n%32 = tail call i32 (...) @IIC_SCLHigh()\n%33 = tail call i32 (...) @IIC_Wait2uSec()\n%34 = tail call i32 (...) @IIC_SCLLow()\n%35 = tail call i32 (...) @IIC_Wait2uSec()\n%36 = tail call i32 (...) @IIC_SCLHigh()\n%37 = tail call i32 (...) @IIC_Wait2uSec()\n%38 = tail call i32 (...) @IIC_SCLLow()\n%39 = tail call i32 (...) @IIC_Wait2uSec()\n%40 = tail call i32 (...) @IIC_SCLHigh()\n%41 = tail call i32 (...) @IIC_Wait2uSec()\n%42 = tail call i32 (...) @IIC_SCLLow()\n%43 = tail call i32 (...) @IIC_Wait2uSec()\n%44 = tail call i32 (...) @IIC_SCLHigh()\n%45 = tail call i32 (...) @IIC_Wait2uSec()\n%46 = tail call i32 (...) @IIC_SCLLow()\n%47 = tail call i32 (...) @IIC_Wait2uSec()\n%48 = tail call i32 (...) @IIC_SCLHigh()\n%49 = tail call i32 (...) @IIC_Wait2uSec()\n%50 = tail call i32 (...) @IIC_SCLLow()\n%51 = tail call i32 (...) @IIC_Wait2uSec()\n%52 = tail call i32 (...) @IIC_SCLHigh()\n%53 = tail call i32 (...) @IIC_Wait2uSec()\n%54 = tail call i32 (...) @IIC_SCLLow()\n%55 = tail call i32 (...) @IIC_Wait2uSec()\n%56 = tail call i32 (...) @IIC_SCLHigh()\n%57 = tail call i32 (...) @IIC_Wait2uSec()\n%58 = tail call i32 (...) @IIC_SCLLow()\n%59 = tail call i32 (...) @IIC_Wait2uSec()\n%60 = tail call i32 (...) @IIC_SCLHigh()\n%61 = tail call i32 (...) @IIC_Wait2uSec()\n%62 = tail call i32 (...) @IIC_SCLLow()\n%63 = tail call i32 (...) @IIC_Wait2uSec()\n%64 = tail call i32 (...) @IIC_SCLHigh()\n%65 = tail call i32 (...) @IIC_Wait2uSec()\n%66 = tail call i32 (...) @IIC_SCLLow()\n%67 = tail call i32 (...) @IIC_Wait2uSec()\n%68 = tail call i32 (...) @IIC_SCLHigh()\n%69 = tail call i32 (...) @IIC_Wait2uSec()\n%70 = tail call i32 (...) @IIC_SCLLow()\n%71 = tail call i32 (...) @IIC_Wait2uSec()\n%72 = tail call i32 (...) @IIC_SCLHigh()\n%73 = tail call i32 (...) @IIC_Wait2uSec()\n%74 = tail call i32 (...) @IIC_SCLLow()\n%75 = tail call</s>", "codegemma": "define dso_local zeroext i8 @IOIIC_Receive(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @IIC_SDAHigh()\n%2 = tail call i32 (...) @IIC_Wait2uSec()\n%3 = load i32, ptr @SW_SDA, align 4\n%4 = tail call i64 @IO_GetInput(i32 noundef %3)\n%5 = icmp ne i64 %4, 0\n%6 = zext i1 %5 to i8\n%7 = tail call i32 (...) @IIC_Wait2uSec()\n%8 = tail call i32 (...) @IIC_SCLLow()\n%9 = tail call i32 (...) @IIC_Wait2uSec()\n%10 = tail call i32 (...) @IIC_SDAHigh()\n%11 = tail call i32 (...) @IIC_Wait2uSec()\n%12 = tail call i32 (...) @IIC_SCLLow()\n%13 = tail call i32 (...) @IIC_Wait2uSec()\n%14 = tail call i32 (...) @IIC_SDAHigh()\n%15 = tail call i32 (...) @IIC_Wait2uSec()\n%16 = tail call i32 (...) @IIC_SCLLow()\n%17 = tail call i32 (...) @IIC_Wait2uSec()\n%18 = tail call i32 (...) @IIC_SDAHigh()\n%19 = tail call i32 (...) @IIC_Wait2uSec()\n%20 = tail call i32 (...) @IIC_SCLLow()\n%21 = tail call i32 (...) @IIC_Wait2uSec()\n%22 = tail call i32 (...) @IIC_SDAHigh()\n%23 = tail call i32 (...) @IIC_Wait2uSec()\n%24 = tail call i32 (...) @IIC_SCLLow()\n%25 = tail call i32 (...) @IIC_Wait2uSec()\n%26 = tail call i32 (...) @IIC_SDAHigh()\n%27 = tail call i32 (...) @IIC_Wait2uSec()\n%28 = tail call i32 (...) @IIC_SCLLow()\n%29 = tail call i32 (...) @IIC_Wait2uSec()\n%30 = tail call i32 (...) @IIC_SDAHigh()\n%31 = tail call i32 (...) @IIC_Wait2uSec()\n%32 = tail call i32 (...) @IIC_SCLLow()\n%33 = tail call i32 (...) @IIC_Wait2uSec()\n%34 = tail call i32 (...) @IIC_SDAHigh()\n%35 = tail call i32 (...) @IIC_Wait2uSec()\n%36 = tail call i32 (...) @IIC_SCLLow()\n%37 = tail call i32 (...) @IIC_Wait2uSec()\n%38 = tail call i32 (...) @IIC_SDAHigh()\n%39 = tail call i32 (...) @IIC_Wait2uSec()\n%40 = tail call i32 (...) @IIC_SCLLow()\n%41 = tail call i32 (...) @IIC_Wait2uSec()\n%42 = tail call i32 (...) @IIC_SDAHigh()\n%43 = tail call i32 (...) @IIC_Wait2uSec()\n%44 = tail call i32 (...) @IIC_SCLLow()\n%45 = tail call i32 (...) @IIC_Wait2uSec()\n%46 = tail call i32 (...) @IIC_SDAHigh()\n%47 = tail call i32 (...) @IIC_Wait2uSec()\n%48 = tail call i32 (...) @IIC_SCLLow()\n%49 = tail call i32 (...) @IIC_Wait2uSec()\n%50 = tail call i32 (...) @IIC_SDAHigh()\n%51 = tail call i32 (...) @IIC_Wait2uSec()\n%52 = tail call i32 (...) @IIC_SCLLow()\n%53 = tail call i32 (...) @IIC_Wait2uSec()\n%54 = tail call i32 (...) @IIC_SDAHigh()\n%55 = tail call i32 (...) @IIC_Wait2uSec()\n%56 = tail call i32 (...) @IIC_SCLLow()\n%57 = tail call i32 (...) @IIC_Wait2uSec()\n%58 = tail call i32 (...) @IIC_SDAHigh()\n%59 = tail call i32 (...) @IIC_Wait2uSec()\n%60 = tail call i32 (...) @IIC_SCLLow()\n%61 = tail call i32 (...) @IIC_Wait2uSec()\n%62 = tail call i32 (...) @IIC_SDAHigh()\n%63 = tail call i32 (...) @IIC_Wait2uSec()\n%64 = tail call i32 (...) @IIC_SCLLow()\n%65 = tail call i32 (...) @IIC_Wait2uSec()\n%66 = tail call i32 (...) @IIC_SDAHigh()\n%67 = tail call i32 (...) @IIC_Wait2uSec()\n%68 = tail call i32 (...) @IIC_SCLLow()\n%69 = tail call i32 (...) @IIC_Wait2uSec()\n%70 = tail call i32 (...) @IIC_SDAHigh()\n%71 = tail call i32 (...) @IIC_Wait2uSec()\n%72 = tail call i32 (...) @IIC_SCLLow()\n%73 = tail call i32 (...) @IIC_Wait2uSec()\n%74 = tail call i32 (...) @IIC_SDAHigh()\n%75 = tail call i32 (...) @IIC_Wait2uSec()\n%76 = tail call i32 (...) @IIC_SCLLow()\n%77 = tail call i32 (...) @IIC_Wait2uSec()\n%78 = tail call i32 (...) @IIC_SDAHigh()\n%79 = tail call i32 (...) @IIC_Wait2uSec()\n%80 = tail call i32 (...) @IIC_SCLLow()\n%81 = tail call i32 (...) @IIC_Wait2uSec()\n%82 = tail call i32 (...) @IIC_<eos>"}, "define internal i32 @nv50_crtc_mode_set_base(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca ptr, align 8\n%10 = alloca ptr, align 8\n%11 = alloca ptr, align 8\n%12 = alloca i32, align 4\n%13 = alloca i32, align 4\nstore ptr %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore ptr %3, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %10)\n%14 = load ptr, ptr %6, align 8\n%15 = getelementptr inbounds %struct.drm_crtc ptr %14, i32 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = call ptr @nouveau_drm(i32 noundef %16)\nstore ptr %17, ptr %10, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %11)\n%18 = load ptr, ptr %6, align 8\n%19 = call ptr @nouveau_crtc(ptr noundef %18)\nstore ptr %19, ptr %11, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %12)\n%20 = load ptr, ptr %6, align 8\n%21 = getelementptr inbounds %struct.drm_crtc ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = icmp ne i32 %22, 0\nbr i1 %23, label %27, label %24\n\n24:\n%25 = load ptr, ptr %10, align 8\n%26 = call i32 @NV_DEBUG(ptr noundef %25, ptr noundef @.str)\nstore i32 0, ptr %5, align 4\nstore i32 1, ptr %13, align 4\nbr label %50\n\n27:\n%28 = load ptr, ptr %6, align 8\n%29 = load ptr, ptr %9, align 8\n%30 = call i32 @nv50_crtc_swap_fbs(ptr noundef %28, ptr noundef %29)\nstore i32 %30, ptr %12, align 4\n%31 = load i32, ptr %12, align 4\n%32 = icmp ne i32 %31, 0\nbr i1 %32, label %33, label %35\n\n33:\n%34 = load i32, ptr %12, align 4\nstore i32 %34, ptr %5, align 4\nstore i32 1, ptr %13, align 4\nbr label %50\n\n35:\n%36 = load ptr, ptr %6, align 8\n%37 = call i32 @nv50_display_flip_stop(ptr noundef %36)\n%38 = load ptr, ptr %11, align 8\n%39 = load ptr, ptr %6, align 8\n%40 = getelementptr inbounds %struct.drm_crtc ptr %39, i32 0, i32 0\n%41 = load i32, ptr %40, align 4\n%42 = load i32, ptr %7, align 4\n%43 = load i32, ptr %8, align 4\n%44 = call i32 @nv50_crtc_set_image(ptr noundef %38, i32 noundef %41, i32 noundef %42, i32 noundef %43, i32 noundef 1)\n%45 = load ptr, ptr %6, align 8\n%46 = load ptr, ptr %6, align 8\n%47 = getelementptr inbounds %struct.drm_crtc ptr %46, i32 0, i32 0\n%48 = load i32, ptr %47, align 4\n%49 = call i32 @nv50_display_flip_next(ptr noundef %45, i32 noundef %48, ptr noundef null, i32 noundef 1)\nstore i32 0, ptr %5, align 4\nstore i32 1, ptr %13, align 4\nbr label %50\n\n50:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %12)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %10)\n%51 = load i32, ptr %5, align 4\nret i32 %51\n}": {"base_truth": "define internal i32 @nv50_crtc_mode_set_base(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) {\nB:\n%4 = getelementptr inbounds %struct.drm_crtc, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call ptr @nouveau_drm(i32 noundef %5)\n%7 = tail call ptr @nouveau_crtc(ptr noundef %0)\n%8 = load i32, ptr %0, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = tail call i32 @NV_DEBUG(ptr noundef %6, ptr noundef nonnull @.str)\nbr label %B4\n\nB2:\n%11 = tail call i32 @nv50_crtc_swap_fbs(ptr noundef nonnull %0, ptr noundef %3)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = tail call i32 @nv50_display_flip_stop(ptr noundef nonnull %0)\n%14 = load i32, ptr %0, align 4\n%15 = tail call i32 @nv50_crtc_set_image(ptr noundef %7, i32 noundef %14, i32 noundef %1, i32 noundef %2, i32 noundef 1)\n%16 = load i32, ptr %0, align 4\n%17 = tail call i32 @nv50_display_flip_next(ptr noundef nonnull %0, i32 noundef %16, ptr noundef null, i32 noundef 1)\nbr label %B4\n\nB4:\n%18 = phi i32 [ 0, %B3 ], [ 0, %B1 ], [ %11, %B2 ]\nret i32 %18\n}", "codellama": "define internal i32 @nv50_crtc_mode_set_base(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) {\nB:\n%4 = getelementptr inbounds %struct.drm_crtc, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call ptr @nouveau_drm(i32 noundef %5)\n%7 = tail call ptr @nouveau_crtc(ptr noundef %0)\n%8 = load i32, ptr %0, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = tail call i32 @NV_DEBUG(ptr noundef %6, ptr noundef nonnull @.str)\nbr label %B4\n\nB2:\n%11 = tail call i32 @nv50_crtc_swap_fbs(ptr noundef nonnull %0, ptr noundef %3)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = tail call i32 @nv50_display_flip_stop(ptr noundef nonnull %0)\n%14 = load i32, ptr %0, align 4\n%15 = tail call i32 @nv50_crtc_set_image(ptr noundef %7, i32 noundef %14, i32 noundef %1, i32 noundef %2, i32 noundef 1)\n%16 = load i32, ptr %0, align 4\n%17 = tail call i32 @nv50_display_flip_next(ptr noundef nonnull %0, i32 noundef %16, ptr noundef null, i32 noundef 1)\nbr label %B4\n\nB4:\n%18 = phi i32 [ 0, %B3 ], [ 0, %B1 ], [ %11, %B2 ]\nret i32 %18\n}", "codegemma": "define internal i32 @nv50_crtc_mode_set_base(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) {\nB:\n%4 = getelementptr inbounds %struct.drm_crtc, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call ptr @nouveau_drm(i32 noundef %5)\n%7 = tail call ptr @nouveau_crtc(ptr noundef %0)\n%8 = load i32, ptr %0, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = tail call i32 @NV_DEBUG(ptr noundef %6, ptr noundef nonnull @.str)\nbr label %B4\n\nB2:\n%11 = tail call i32 @nv50_crtc_swap_fbs(ptr noundef nonnull %0, ptr noundef %3)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = tail call i32 @nv50_display_flip_stop(ptr noundef nonnull %0)\n%14 = load i32, ptr %0, align 4\n%15 = tail call i32 @nv50_crtc_set_image(ptr noundef %7, i32 noundef %14, i32 noundef %1, i32 noundef %2, i32 noundef 1)\n%16 = load i32, ptr %0, align 4\n%17 = tail call i32 @nv50_display_flip_next(ptr noundef nonnull %0, i32 noundef %16, ptr noundef null, i32 noundef 1)\nbr label %B4\n\nB4:\n%18 = phi i32 [ 0, %B3 ], [ 0, %B1 ], [ %11, %B2 ]\nret i32 %18\n}"}, "define dso_local i32 @create_servsock(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca %struct.sockaddr_in, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%7 = load i32, ptr @AF_INET, align 4\n%8 = load i32, ptr @SOCK_STREAM, align 4\n%9 = call i32 @socket(i32 noundef %7, i32 noundef %8, i32 noundef 0)\nstore i32 %9, ptr %4, align 4\n%10 = load i32, ptr %4, align 4\n%11 = icmp eq i32 %10, -1\nbr i1 %11, label %12, label %13\n\n12:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %36\n\n13:\ncall void @llvm.lifetime.start.p0(i64 12, ptr %6)\n%14 = call i32 @memset(ptr noundef %6, i32 noundef 0, i32 noundef 12)\n%15 = load i32, ptr @AF_INET, align 4\n%16 = getelementptr inbounds %struct.sockaddr_in, ptr %6, i32 0, i32 2\nstore i32 %15, ptr %16, align 4\n%17 = load i32, ptr @INADDR_ANY, align 4\n%18 = call i32 @htonl(i32 noundef %17)\n%19 = getelementptr inbounds %struct.sockaddr_in, ptr %6, i32 0, i32 1\n%20 = getelementptr inbounds %struct.TYPE_2__, ptr %19, i32 0, i32 0\nstore i32 %18, ptr %20, align 4\n%21 = load i32, ptr %3, align 4\n%22 = call i32 @htons(i32 noundef %21)\n%23 = getelementptr inbounds %struct.sockaddr_in, ptr %6, i32 0, i32 0\nstore i32 %22, ptr %23, align 4\n%24 = load i32, ptr %4, align 4\n%25 = call i64 @bind(i32 noundef %24, ptr noundef %6, i32 noundef 12)\n%26 = icmp ne i64 %25, 0\nbr i1 %26, label %27, label %28\n\n27:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %35\n\n28:\n%29 = load i32, ptr %4, align 4\n%30 = call i64 @listen(i32 noundef %29, i32 noundef 0)\n%31 = icmp ne i64 %30, 0\nbr i1 %31, label %32, label %33\n\n32:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %35\n\n33:\n%34 = load i32, ptr %4, align 4\nstore i32 %34, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %35\n\n35:\ncall void @llvm.lifetime.end.p0(i64 12, ptr %6)\nbr label %36\n\n36:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%37 = load i32, ptr %2, align 4\nret i32 %37\n}": {"base_truth": "define dso_local i32 @create_servsock(i32 noundef %0) {\nB:\n%1 = alloca %struct.sockaddr_in, align 4\n%2 = load i32, ptr @AF_INET, align 4\n%3 = load i32, ptr @SOCK_STREAM, align 4\n%4 = tail call i32 @socket(i32 noundef %2, i32 noundef %3, i32 noundef 0)\n%5 = icmp eq i32 %4, -1\nbr i1 %5, label %B4, label %B1\n\nB1:\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %1)\n%6 = call i32 @memset(ptr noundef nonnull %1, i32 noundef 0, i32 noundef 12)\n%7 = load i32, ptr @AF_INET, align 4\n%8 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 2\nstore i32 %7, ptr %8, align 4\n%9 = load i32, ptr @INADDR_ANY, align 4\n%10 = call i32 @htonl(i32 noundef %9)\n%11 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 1\nstore i32 %10, ptr %11, align 4\n%12 = call i32 @htons(i32 noundef %0)\nstore i32 %12, ptr %1, align 4\n%13 = call i64 @bind(i32 noundef %4, ptr noundef nonnull %1, i32 noundef 12)\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %B2, label %B3\n\nB2:\n%15 = call i64 @listen(i32 noundef %4, i32 noundef 0)\n%16 = icmp eq i64 %15, 0\n%17 = select i1 %16, i32 %4, i32 -1\nbr label %B3\n\nB3:\n%18 = phi i32 [ -1, %B1 ], [ %17, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %1)\nbr label %B4\n\nB4:\n%19 = phi i32 [ %18, %B3 ], [ -1, %B ]\nret i32 %19\n}", "codellama": "define dso_local i32 @create_servsock(i32 noundef %0) {\nB:\n%1 = alloca %struct.sockaddr_in, align 4\n%2 = load i32, ptr @AF_INET, align 4\n%3 = load i32, ptr @SOCK_STREAM, align 4\n%4 = tail call i32 @socket(i32 noundef %2, i32 noundef %3, i32 noundef 0)\n%5 = icmp eq i32 %4, -1\nbr i1 %5, label %B3, label %B1\n\nB1:\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %1)\n%6 = call i32 @memset(ptr noundef nonnull %1, i32 noundef 0, i32 noundef 12)\n%7 = load i32, ptr @AF_INET, align 4\n%8 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 2\nstore i32 %7, ptr %8, align 4\n%9 = load i32, ptr @INADDR_ANY, align 4\n%10 = call i32 @htonl(i32 noundef %9)\n%11 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 1\nstore i32 %10, ptr %11, align 4\n%12 = call i32 @htons(i32 noundef %0)\nstore i32 %12, ptr %1, align 4\n%13 = call i64 @bind(i32 noundef %4, ptr noundef nonnull %1, i32 noundef 12)\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %B2, label %B3\n\nB2:\n%15 = call i64 @listen(i32 noundef %4, i32 noundef 0)\n%16 = icmp eq i64 %15, 0\n%17 = select i1 %16, i32 %4, i32 -1\nbr label %B3\n\nB3:\n%18 = phi i32 [ -1, %B ], [ -1, %B1 ], [ %17, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %1)\nret i32 %18\n}", "codegemma": "define dso_local i32 @create_servsock(i32 noundef %0) {\nB:\n%1 = alloca %struct.sockaddr_in, align 4\n%2 = load i32, ptr @AF_INET, align 4\n%3 = load i32, ptr @SOCK_STREAM, align 4\n%4 = tail call i32 @socket(i32 noundef %2, i32 noundef %3, i32 noundef 0)\n%5 = icmp eq i32 %4, -1\nbr i1 %5, label %B3, label %B1\n\nB1:\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %1)\n%6 = call i32 @memset(ptr noundef nonnull %1, i32 noundef 0, i32 noundef 12)\n%7 = load i32, ptr @AF_INET, align 4\n%8 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 2\nstore i32 %7, ptr %8, align 4\n%9 = load i32, ptr @INADDR_ANY, align 4\n%10 = call i32 @htonl(i32 noundef %9)\n%11 = getelementptr inbounds %struct.sockaddr_in, ptr %1, i64 0, i32 1\nstore i32 %10, ptr %11, align 4\n%12 = call i32 @htons(i32 noundef %0)\nstore i32 %12, ptr %1, align 4\n%13 = call i64 @bind(i32 noundef %4, ptr noundef nonnull %1, i32 noundef 12)\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %B2, label %B3\n\nB2:\n%15 = call i64 @listen(i32 noundef %4, i32 noundef 0)\n%16 = icmp eq i64 %15, 0\n%17 = select i1 %16, i32 %4, i32 -1\nbr label %B3\n\nB3:\n%18 = phi i32 [ -1, %B ], [ -1, %B1 ], [ %17, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %1)\nret i32 %18\n}"}, "define internal ptr @get_iface_id(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %4, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.usb_serial_driver ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call ptr @usb_match_id(ptr noundef %6, i32 noundef %9)\nstore ptr %10, ptr %5, align 8\n%11 = load ptr, ptr %5, align 8\n%12 = icmp ne ptr %11, null\nbr i1 %12, label %13, label %15\n\n13:\n%14 = call i32 @dbg(ptr noundef @.str)\nbr label %24\n\n15:\n%16 = load ptr, ptr %4, align 8\n%17 = load ptr, ptr %3, align 8\n%18 = call ptr @match_dynamic_id(ptr noundef %16, ptr noundef %17)\nstore ptr %18, ptr %5, align 8\n%19 = load ptr, ptr %5, align 8\n%20 = icmp ne ptr %19, null\nbr i1 %20, label %21, label %23\n\n21:\n%22 = call i32 @dbg(ptr noundef @.str.1)\nbr label %23\n\n23:\nbr label %24\n\n24:\n%25 = load ptr, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret ptr %25\n}": {"base_truth": "define internal ptr @get_iface_id(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @usb_match_id(ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call ptr @match_dynamic_id(ptr noundef %1, ptr noundef nonnull %0)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = phi ptr [ @.str, %B ], [ @.str.1, %B1 ]\n%8 = phi ptr [ %3, %B ], [ %5, %B1 ]\n%9 = tail call i32 @dbg(ptr noundef nonnull %7)\nbr label %B3\n\nB3:\n%10 = phi ptr [ null, %B1 ], [ %8, %B2 ]\nret ptr %10\n}", "codellama": "define internal ptr @get_iface_id(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @usb_match_id(ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @dbg(ptr noundef nonnull @.str)\nbr label %B4\n\nB2:\n%6 = tail call ptr @match_dynamic_id(ptr noundef %1, ptr noundef nonnull %0)\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = tail call i32 @dbg(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%9 = phi ptr [ %3, %B1 ], [ %6, %B3 ], [ null, %B2 ]\nret ptr %9\n}", "codegemma": "define internal ptr @get_iface_id(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @usb_match_id(ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @dbg(ptr noundef nonnull @.str)\nbr label %B4\n\nB2:\n%6 = tail call ptr @match_dynamic_id(ptr noundef %1, ptr noundef nonnull %0)\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = tail call i32 @dbg(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%9 = phi ptr [ %3, %B1 ], [ %6, %B3 ], [ null, %B2 ]\nret ptr %9\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca ptr, align 8\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\nstore ptr @.str, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @reverseCString(ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @reverseCString(ptr noundef nonnull @.str)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @reverseCString(ptr noundef nonnull @.str)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @reverseCString(ptr noundef nonnull @.str)\nret i32 0\n}"}, "define dso_local i32 @serial_received(i16 noundef zeroext %0) {\n%2 = alloca i16, align 2\nstore i16 %0, ptr %2, align 2\n%3 = load i16, ptr %2, align 2\n%4 = zext i16 %3 to i32\n%5 = add nsw i32 %4, 5\n%6 = trunc i32 %5 to i16\n%7 = call i32 @inb(i16 noundef zeroext %6)\n%8 = and i32 %7, 1\nret i32 %8\n}": {"base_truth": "define dso_local i32 @serial_received(i16 noundef zeroext %0) {\nB:\n%1 = add i16 %0, 5\n%2 = tail call i32 @inb(i16 noundef zeroext %1)\n%3 = and i32 %2, 1\nret i32 %3\n}", "codellama": "define dso_local i32 @serial_received(i16 noundef zeroext %0) {\nB:\n%1 = add i16 %0, 5\n%2 = tail call i32 @inb(i16 noundef zeroext %1)\n%3 = and i32 %2, 1\nret i32 %3\n}", "codegemma": "define dso_local i32 @serial_received(i16 noundef zeroext %0) {\nB:\n%1 = add i16 %0, 5\n%2 = tail call i32 @inb(i16 noundef zeroext %1)\n%3 = and i32 %2, 1\nret i32 %3\n}"}, "define internal void @uniphier_sd_external_dma_dataend(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @uniphier_sd_dma_endisable(ptr noundef %3, i32 noundef 0)\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @tmio_mmc_do_data_irq(ptr noundef %5)\nret void\n}": {"base_truth": "define internal void @uniphier_sd_external_dma_dataend(ptr noundef %0) {\nB:\n%1 = tail call i32 @uniphier_sd_dma_endisable(ptr noundef %0, i32 noundef 0)\n%2 = tail call i32 @tmio_mmc_do_data_irq(ptr noundef %0)\nret void\n}", "codellama": "define internal void @uniphier_sd_external_dma_dataend(ptr noundef %0) {\nB:\n%1 = tail call i32 @uniphier_sd_dma_endisable(ptr noundef %0, i32 noundef 0)\n%2 = tail call i32 @tmio_mmc_do_data_irq(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @uniphier_sd_external_dma_dataend(ptr noundef %0) {\nB:\n%1 = tail call i32 @uniphier_sd_dma_endisable(ptr noundef %0, i32 noundef 0)\n%2 = tail call i32 @tmio_mmc_do_data_irq(ptr noundef %0)\nret void\n}"}, "define internal void @decode_any() {\n%1 = alloca ptr, align 8\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%3 = load i32, ptr @JSON_DECODE_ANY, align 4\n%4 = call ptr @json_loads(ptr noundef @.str, i32 noundef %3, ptr noundef %2)\nstore ptr %4, ptr %1, align 8\n%5 = load ptr, ptr %1, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %7, label %11\n\n7:\n%8 = load ptr, ptr %1, align 8\n%9 = call i32 @json_is_string(ptr noundef %8)\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %13, label %11\n\n11:\n%12 = call i32 @fail(ptr noundef @.str.1)\nbr label %13\n\n13:\n%14 = load ptr, ptr %1, align 8\n%15 = call i32 @json_decref(ptr noundef %14)\n%16 = load i32, ptr @JSON_DECODE_ANY, align 4\n%17 = call ptr @json_loads(ptr noundef @.str.2, i32 noundef %16, ptr noundef %2)\nstore ptr %17, ptr %1, align 8\n%18 = load ptr, ptr %1, align 8\n%19 = icmp ne ptr %18, null\nbr i1 %19, label %20, label %24\n\n20:\n%21 = load ptr, ptr %1, align 8\n%22 = call i32 @json_is_integer(ptr noundef %21)\n%23 = icmp ne i32 %22, 0\nbr i1 %23, label %26, label %24\n\n24:\n%25 = call i32 @fail(ptr noundef @.str.3)\nbr label %26\n\n26:\n%27 = load ptr, ptr %1, align 8\n%28 = call i32 @json_decref(ptr noundef %27)\n%29 = load i32, ptr @JSON_DECODE_ANY, align 4\n%30 = call ptr @json_loads(ptr noundef @.str.4, i32 noundef %29, ptr noundef %2)\nstore ptr %30, ptr %1, align 8\n%31 = load ptr, ptr %1, align 8\n%32 = icmp ne ptr %31, null\nbr i1 %32, label %33, label %37\n\n33:\n%34 = load ptr, ptr %1, align 8\n%35 = call i32 @json_is_true(ptr noundef %34)\n%36 = icmp ne i32 %35, 0\nbr i1 %36, label %39, label %37\n\n37:\n%38 = call i32 @fail(ptr noundef @.str.5)\nbr label %39\n\n39:\n%40 = load ptr, ptr %1, align 8\n%41 = call i32 @json_decref(ptr noundef %40)\n%42 = load i32, ptr @JSON_DECODE_ANY, align 4\n%43 = call ptr @json_loads(ptr noundef @.str.6, i32 noundef %42, ptr noundef %2)\nstore ptr %43, ptr %1, align 8\n%44 = load ptr, ptr %1, align 8\n%45 = icmp ne ptr %44, null\nbr i1 %45, label %46, label %50\n\n46:\n%47 = load ptr, ptr %1, align 8\n%48 = call i32 @json_is_null(ptr noundef %47)\n%49 = icmp ne i32 %48, 0\nbr i1 %49, label %52, label %50\n\n50:\n%51 = call i32 @fail(ptr noundef @.str.7)\nbr label %52\n\n52:\n%53 = load ptr, ptr %1, align 8\n%54 = call i32 @json_decref(ptr noundef %53)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret void\n}": {"base_truth": "define internal void @decode_any() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = load i32, ptr @JSON_DECODE_ANY, align 4\n%2 = call ptr @json_loads(ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = call i32 @json_is_string(ptr noundef nonnull %2)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = call i32 @fail(ptr noundef nonnull @.str.1)\nbr label %B3\n\nB3:\n%7 = call i32 @json_decref(ptr noundef %2)\n%8 = load i32, ptr @JSON_DECODE_ANY, align 4\n%9 = call ptr @json_loads(ptr noundef nonnull @.str.2, i32 noundef %8, ptr noundef nonnull %0)\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %B5, label %B4\n\nB4:\n%11 = call i32 @json_is_integer(ptr noundef nonnull %9)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B5, label %B6\n\nB5:\n%13 = call i32 @fail(ptr noundef nonnull @.str.3)\nbr label %B6\n\nB6:\n%14 = call i32 @json_decref(ptr noundef %9)\n%15 = load i32, ptr @JSON_DECODE_ANY, align 4\n%16 = call ptr @json_loads(ptr noundef nonnull @.str.4, i32 noundef %15, ptr noundef nonnull %0)\n%17 = icmp eq ptr %16, null\nbr i1 %17, label %B8, label %B7\n\nB7:\n%18 = call i32 @json_is_true(ptr noundef nonnull %16)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B8, label %B9\n\nB8:\n%20 = call i32 @fail(ptr noundef nonnull @.str.5)\nbr label %B9\n\nB9:\n%21 = call i32 @json_decref(ptr noundef %16)\n%22 = load i32, ptr @JSON_DECODE_ANY, align 4\n%23 = call ptr @json_loads(ptr noundef nonnull @.str.6, i32 noundef %22, ptr noundef nonnull %0)\n%24 = icmp eq ptr %23, null\nbr i1 %24, label %B11, label %B10\n\nB10:\n%25 = call i32 @json_is_null(ptr noundef nonnull %23)\n%26 = icmp eq i32 %25, 0\nbr i1 %26, label %B11, label %B12\n\nB11:\n%27 = call i32 @fail(ptr noundef nonnull @.str.7)\nbr label %B12\n\nB12:\n%28 = call i32 @json_decref(ptr noundef %23)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}", "codellama": "define internal void @decode_any() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = load i32, ptr @JSON_DECODE_ANY, align 4\n%2 = call ptr @json_loads(ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = call i32 @json_is_string(ptr noundef nonnull %2)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = call i32 @json_decref(ptr noundef nonnull %2)\nbr label %B4\n\nB3:\n%7 = call i32 @fail(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%8 = load i32, ptr @JSON_DECODE_ANY, align 4\n%9 = call ptr @json_loads(ptr noundef nonnull @.str.2, i32 noundef %8, ptr noundef nonnull %0)\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %B6, label %B5\n\nB5:\n%11 = call i32 @json_is_integer(ptr noundef nonnull %9)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B6, label %B7\n\nB6:\n%13 = call i32 @fail(ptr noundef nonnull @.str.3)\nbr label %B7\n\nB7:\n%14 = call i32 @json_decref(ptr noundef %9)\n%15 = load i32, ptr @JSON_DECODE_ANY, align 4\n%16 = call ptr @json_loads(ptr noundef nonnull @.str.4, i32 noundef %15, ptr noundef nonnull %0)\n%17 = icmp eq ptr %16, null\nbr i1 %17, label %B9, label %B8\n\nB8:\n%18 = call i32 @json_is_true(ptr noundef nonnull %16)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B9, label %B10\n\nB9:\n%20 = call i32 @fail(ptr noundef nonnull @.str.5)\nbr label %B10\n\nB10:\n%21 = call i32 @json_decref(ptr noundef %16)\n%22 = load i32, ptr @JSON_DECODE_ANY, align 4\n%23 = call ptr @json_loads(ptr noundef nonnull @.str.6, i32 noundef %22, ptr noundef nonnull %0)\n%24 = icmp eq ptr %23, null\nbr i1 %24, label %B12, label %B11\n\nB11:\n%25 = call i32 @json_is_null(ptr noundef nonnull %23)\n%26 = icmp eq i32 %25, 0\nbr i1 %26, label %B12, label %B13\n\nB12:\n%27 = call i32 @fail(ptr noundef nonnull @.str.7)\nbr label %B13\n\nB13:\n%28 = call i32 @json_decref(ptr noundef %23)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}", "codegemma": "define internal void @decode_any() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = load i32, ptr @JSON_DECODE_ANY, align 4\n%2 = call ptr @json_loads(ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = call i32 @json_is_string(ptr noundef nonnull %2)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = call i32 @fail(ptr noundef nonnull @.str.1)\nbr label %B3\n\nB3:\n%7 = call i32 @json_decref(ptr noundef nonnull %2)\n%8 = load i32, ptr @JSON_DECODE_ANY, align 4\n%9 = call ptr @json_loads(ptr noundef nonnull @.str.2, i32 noundef %8, ptr noundef nonnull %0)\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %B5, label %B4\n\nB4:\n%11 = call i32 @json_is_integer(ptr noundef nonnull %9)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B5, label %B6\n\nB5:\n%13 = call i32 @fail(ptr noundef nonnull @.str.3)\nbr label %B6\n\nB6:\n%14 = call i32 @json_decref(ptr noundef nonnull %9)\n%15 = load i32, ptr @JSON_DECODE_ANY, align 4\n%16 = call ptr @json_loads(ptr noundef nonnull @.str.4, i32 noundef %15, ptr noundef nonnull %0)\n%17 = icmp eq ptr %16, null\nbr i1 %17, label %B8, label %B7\n\nB7:\n%18 = call i32 @json_is_true(ptr noundef nonnull %16)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B8, label %B9\n\nB8:\n%20 = call i32 @fail(ptr noundef nonnull @.str.5)\nbr label %B9\n\nB9:\n%21 = call i32 @json_decref(ptr noundef nonnull %16)\n%22 = load i32, ptr @JSON_DECODE_ANY, align 4\n%23 = call ptr @json_loads(ptr noundef nonnull @.str.6, i32 noundef %22, ptr noundef nonnull %0)\n%24 = icmp eq ptr %23, null\nbr i1 %24, label %B11, label %B10\n\nB10:\n%25 = call i32 @json_is_null(ptr noundef nonnull %23)\n%26 = icmp eq i32 %25, 0\nbr i1 %26, label %B11, label %B12\n\nB11:\n%27 = call i32 @fail(ptr noundef nonnull @.str.7)\nbr label %B12\n\nB12:\n%28 = call i32 @json_decref(ptr noundef nonnull %23)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}"}, "define dso_local i64 @rbegin_cag_float_array(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = sub nsw i64 %5, 1\nret i64 %6\n}": {"base_truth": "define dso_local i64 @rbegin_cag_float_array(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = add nsw i64 %1, -1\nret i64 %2\n}", "codellama": "define dso_local i64 @rbegin_cag_float_array(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = add nsw i64 %1, -1\nret i64 %2\n}", "codegemma": "define dso_local i64 @rbegin_cag_float_array(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = add nsw i64 %1, -1\nret i64 %2\n}"}, "define dso_local i32 @ring_isempty(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.ring ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.ring ptr %6, i32 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %5, %8\n%10 = zext i1 %9 to i32\nret i32 %10\n}": {"base_truth": "define dso_local i32 @ring_isempty(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.ring, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define dso_local i32 @ring_isempty(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.ring, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codegemma": "define dso_local i32 @ring_isempty(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.ring, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}"}, "define dso_local i32 @in_cone_i(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore i32 %0, ptr %6, align 4\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\n%10 = load i32, ptr %7, align 4\n%11 = load i32, ptr %8, align 4\n%12 = load i32, ptr %6, align 4\n%13 = call i64 @left_on_i(i32 noundef %10, i32 noundef %11, i32 noundef %12)\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %30\n\n15:\n%16 = load i32, ptr %7, align 4\n%17 = load i32, ptr %9, align 4\n%18 = load i32, ptr %6, align 4\n%19 = call i64 @left_i(i32 noundef %16, i32 noundef %17, i32 noundef %18)\n%20 = icmp ne i64 %19, 0\nbr i1 %20, label %21, label %27\n\n21:\n%22 = load i32, ptr %9, align 4\n%23 = load i32, ptr %7, align 4\n%24 = load i32, ptr %8, align 4\n%25 = call i64 @left_i(i32 noundef %22, i32 noundef %23, i32 noundef %24)\n%26 = icmp ne i64 %25, 0\nbr label %27\n\n27:\n%28 = phi i1 [ false, %15 ], [ %26, %21 ]\n%29 = zext i1 %28 to i32\nstore i32 %29, ptr %5, align 4\nbr label %46\n\n30:\n%31 = load i32, ptr %7, align 4\n%32 = load i32, ptr %9, align 4\n%33 = load i32, ptr %8, align 4\n%34 = call i64 @left_on_i(i32 noundef %31, i32 noundef %32, i32 noundef %33)\n%35 = icmp ne i64 %34, 0\nbr i1 %35, label %36, label %42\n\n36:\n%37 = load i32, ptr %9, align 4\n%38 = load i32, ptr %7, align 4\n%39 = load i32, ptr %6, align 4\n%40 = call i64 @left_on_i(i32 noundef %37, i32 noundef %38, i32 noundef %39)\n%41 = icmp ne i64 %40, 0\nbr label %42\n\n42:\n%43 = phi i1 [ false, %30 ], [ %41, %36 ]\n%44 = xor i1 %43, true\n%45 = zext i1 %44 to i32\nstore i32 %45, ptr %5, align 4\nbr label %46\n\n46:\n%47 = load i32, ptr %5, align 4\nret i32 %47\n}": {"base_truth": "define dso_local i32 @in_cone_i(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i64 @left_on_i(i32 noundef %1, i32 noundef %2, i32 noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = tail call i64 @left_i(i32 noundef %1, i32 noundef %3, i32 noundef %0)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B5, label %B2\n\nB2:\n%8 = tail call i64 @left_i(i32 noundef %3, i32 noundef %1, i32 noundef %2)\n%9 = icmp ne i64 %8, 0\nbr label %B5\n\nB3:\n%10 = tail call i64 @left_on_i(i32 noundef %1, i32 noundef %3, i32 noundef %2)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B5, label %B4\n\nB4:\n%12 = tail call i64 @left_on_i(i32 noundef %3, i32 noundef %1, i32 noundef %0)\n%13 = icmp eq i64 %12, 0\nbr label %B5\n\nB5:\n%14 = phi i1 [ false, %B1 ], [ %9, %B2 ], [ true, %B3 ], [ %13, %B4 ]\n%15 = zext i1 %14 to i32\nret i32 %15\n}", "codellama": "define dso_local i32 @in_cone_i(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i64 @left_on_i(i32 noundef %1, i32 noundef %2, i32 noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = tail call i64 @left_i(i32 noundef %1, i32 noundef %3, i32 noundef %0)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B5, label %B2\n\nB2:\n%8 = tail call i64 @left_i(i32 noundef %3, i32 noundef %1, i32 noundef %2)\n%9 = icmp ne i64 %8, 0\n%10 = zext i1 %9 to i32\nbr label %B5\n\nB3:\n%11 = tail call i64 @left_on_i(i32 noundef %1, i32 noundef %3, i32 noundef %2)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B5, label %B4\n\nB4:\n%13 = tail call i64 @left_on_i(i32 noundef %3, i32 noundef %1, i32 noundef %0)\n%14 = icmp eq i64 %13, 0\n%15 = zext i1 %14 to i32\nbr label %B5\n\nB5:\n%16 = phi i32 [ 0, %B1 ], [ %10, %B2 ], [ 0, %B3 ], [ %15, %B4 ]\nret i32 %16\n}", "codegemma": "define dso_local i32 @in_cone_i(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i64 @left_on_i(i32 noundef %1, i32 noundef %2, i32 noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i64 @left_i(i32 noundef %1, i32 noundef %3, i32 noundef %0)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B3, label %B4\n\nB2:\n%8 = tail call i64 @left_on_i(i32 noundef %1, i32 noundef %3, i32 noundef %0)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = tail call i64 @left_i(i32 noundef %3, i32 noundef %1, i32 noundef %2)\n%11 = icmp eq i64 %10, 0\n%12 = zext i1 %11 to i32\nbr label %B4\n\nB4:\n%13 = phi i32 [ 0, %B1 ], [ 0, %B2 ], [ %12, %B3 ]\nret i32 %13\n}"}, "define internal void @release_dev(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @to_pci_dev(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @kfree(ptr noundef %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @release_dev(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_pci_dev(ptr noundef %0)\n%2 = tail call i32 @kfree(ptr noundef %1)\nret void\n}", "codellama": "define internal void @release_dev(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_pci_dev(ptr noundef %0)\n%2 = tail call i32 @kfree(ptr noundef %1)\nret void\n}", "codegemma": "define internal void @release_dev(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_pci_dev(ptr noundef %0)\n%2 = tail call i32 @kfree(ptr noundef %1)\nret void\n}"}, "define internal i32 @sc27xx_fgu_save_last_cap(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.sc27xx_fgu_data ptr %8, i32 0, i32 1\n%10 = load i32, ptr %9, align 8\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.sc27xx_fgu_data ptr %11, i32 0, i32 0\n%13 = load i64, ptr %12, align 8\n%14 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%15 = add nsw i64 %13, %14\n%16 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%17 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%18 = call i32 @regmap_update_bits(i32 noundef %10, i64 noundef %15, i32 noundef %16, i32 noundef %17)\nstore i32 %18, ptr %6, align 4\n%19 = load i32, ptr %6, align 4\n%20 = icmp ne i32 %19, 0\nbr i1 %20, label %21, label %23\n\n21:\n%22 = load i32, ptr %6, align 4\nstore i32 %22, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %52\n\n23:\n%24 = call i32 @udelay(i32 noundef 200)\n%25 = load ptr, ptr %4, align 8\n%26 = getelementptr inbounds %struct.sc27xx_fgu_data ptr %25, i32 0, i32 1\n%27 = load i32, ptr %26, align 8\n%28 = load ptr, ptr %4, align 8\n%29 = getelementptr inbounds %struct.sc27xx_fgu_data ptr %28, i32 0, i32 0\n%30 = load i64, ptr %29, align 8\n%31 = load i64, ptr @SC27XX_FGU_USER_AREA_SET, align 8\n%32 = add nsw i64 %30, %31\n%33 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%34 = load i32, ptr %5, align 4\n%35 = call i32 @regmap_update_bits(i32 noundef %27, i64 noundef %32, i32 noundef %33, i32 noundef %34)\nstore i32 %35, ptr %6, align 4\n%36 = load i32, ptr %6, align 4\n%37 = icmp ne i32 %36, 0\nbr i1 %37, label %38, label %40\n\n38:\n%39 = load i32, ptr %6, align 4\nstore i32 %39, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %52\n\n40:\n%41 = call i32 @udelay(i32 noundef 200)\n%42 = load ptr, ptr %4, align 8\n%43 = getelementptr inbounds %struct.sc27xx_fgu_data ptr %42, i32 0, i32 1\n%44 = load i32, ptr %43, align 8\n%45 = load ptr, ptr %4, align 8\n%46 = getelementptr inbounds %struct.sc27xx_fgu_data ptr %45, i32 0, i32 0\n%47 = load i64, ptr %46, align 8\n%48 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%49 = add nsw i64 %47, %48\n%50 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%51 = call i32 @regmap_update_bits(i32 noundef %44, i64 noundef %49, i32 noundef %50, i32 noundef 0)\nstore i32 %51, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %52\n\n52:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%53 = load i32, ptr %3, align 4\nret i32 %53\n}": {"base_truth": "define internal i32 @sc27xx_fgu_save_last_cap(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.sc27xx_fgu_data, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 8\n%4 = load i64, ptr %0, align 8\n%5 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%6 = add nsw i64 %5, %4\n%7 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%8 = tail call i32 @regmap_update_bits(i32 noundef %3, i64 noundef %6, i32 noundef %7, i32 noundef %7)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B1, label %B3\n\nB1:\n%10 = tail call i32 @udelay(i32 noundef 200)\n%11 = load i32, ptr %2, align 8\n%12 = load i64, ptr %0, align 8\n%13 = load i64, ptr @SC27XX_FGU_USER_AREA_SET, align 8\n%14 = add nsw i64 %13, %12\n%15 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%16 = tail call i32 @regmap_update_bits(i32 noundef %11, i64 noundef %14, i32 noundef %15, i32 noundef %1)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B2, label %B3\n\nB2:\n%18 = tail call i32 @udelay(i32 noundef 200)\n%19 = load i32, ptr %2, align 8\n%20 = load i64, ptr %0, align 8\n%21 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%22 = add nsw i64 %21, %20\n%23 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%24 = tail call i32 @regmap_update_bits(i32 noundef %19, i64 noundef %22, i32 noundef %23, i32 noundef 0)\nbr label %B3\n\nB3:\n%25 = phi i32 [ %24, %B2 ], [ %8, %B ], [ %16, %B1 ]\nret i32 %25\n}", "codellama": "define internal i32 @sc27xx_fgu_save_last_cap(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.sc27xx_fgu_data, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 8\n%4 = load i64, ptr %0, align 8\n%5 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%6 = add nsw i64 %5, %4\n%7 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%8 = tail call i32 @regmap_update_bits(i32 noundef %3, i64 noundef %6, i32 noundef %7, i32 noundef %7)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B1, label %B3\n\nB1:\n%10 = tail call i32 @udelay(i32 noundef 200)\n%11 = load i32, ptr %2, align 8\n%12 = load i64, ptr %0, align 8\n%13 = load i64, ptr @SC27XX_FGU_USER_AREA_SET, align 8\n%14 = add nsw i64 %13, %12\n%15 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%16 = tail call i32 @regmap_update_bits(i32 noundef %11, i64 noundef %14, i32 noundef %15, i32 noundef %1)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B2, label %B3\n\nB2:\n%18 = tail call i32 @udelay(i32 noundef 200)\n%19 = load i32, ptr %2, align 8\n%20 = load i64, ptr %0, align 8\n%21 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%22 = add nsw i64 %21, %20\n%23 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%24 = tail call i32 @regmap_update_bits(i32 noundef %19, i64 noundef %22, i32 noundef %23, i32 noundef 0)\nbr label %B3\n\nB3:\n%25 = phi i32 [ %24, %B2 ], [ %8, %B ], [ %16, %B1 ]\nret i32 %25\n}", "codegemma": "define internal i32 @sc27xx_fgu_save_last_cap(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.sc27xx_fgu_data, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 8\n%4 = load i64, ptr %0, align 8\n%5 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%6 = add nsw i64 %5, %4\n%7 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%8 = tail call i32 @regmap_update_bits(i32 noundef %3, i64 noundef %6, i32 noundef %7, i32 noundef %7)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B1, label %B3\n\nB1:\n%10 = tail call i32 @udelay(i32 noundef 200)\n%11 = load i32, ptr %2, align 8\n%12 = load i64, ptr %0, align 8\n%13 = load i64, ptr @SC27XX_FGU_USER_AREA_SET, align 8\n%14 = add nsw i64 %13, %12\n%15 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%16 = tail call i32 @regmap_update_bits(i32 noundef %11, i64 noundef %14, i32 noundef %15, i32 noundef %1)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B2, label %B3\n\nB2:\n%18 = tail call i32 @udelay(i32 noundef 200)\n%19 = load i32, ptr %2, align 8\n%20 = load i64, ptr %0, align 8\n%21 = load i64, ptr @SC27XX_FGU_USER_AREA_CLEAR, align 8\n%22 = add nsw i64 %21, %20\n%23 = load i32, ptr @SC27XX_FGU_CAP_AREA_MASK, align 4\n%24 = tail call i32 @regmap_update_bits(i32 noundef %19, i64 noundef %22, i32 noundef %23, i32 noundef 0)\nbr label %B3\n\nB3:\n%25 = phi i32 [ %24, %B2 ], [ %8, %B ], [ %16, %B1 ]\nret i32 %25\n}"}, "define dso_local void @all_mapped() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 0, ptr %1, align 4\nbr label %3\n\n3:\n%4 = load i32, ptr %1, align 4\n%5 = icmp slt i32 %4, 20\nbr i1 %5, label %6, label %21\n\n6:\nstore i32 0, ptr %2, align 4\nbr label %7\n\n7:\n%8 = load i32, ptr %2, align 4\n%9 = icmp slt i32 %8, 49\nbr i1 %9, label %10, label %17\n\n10:\n%11 = load i32, ptr %1, align 4\n%12 = load i32, ptr %2, align 4\n%13 = call i32 @mark_mapped(i32 noundef %11, i32 noundef %12)\nbr label %14\n\n14:\n%15 = load i32, ptr %2, align 4\n%16 = add nsw i32 %15, 1\nstore i32 %16, ptr %2, align 4\nbr label %7\n\n17:\nbr label %18\n\n18:\n%19 = load i32, ptr %1, align 4\n%20 = add nsw i32 %19, 1\nstore i32 %20, ptr %1, align 4\nbr label %3\n\n21:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @all_mapped() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 0, %B ], [ %50, %B1 ]\n%1 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 0)\n%2 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 1)\n%3 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 2)\n%4 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 3)\n%5 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 4)\n%6 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 5)\n%7 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 6)\n%8 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 7)\n%9 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 8)\n%10 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 9)\n%11 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 10)\n%12 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 11)\n%13 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 12)\n%14 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 13)\n%15 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 14)\n%16 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 15)\n%17 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 16)\n%18 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 17)\n%19 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 18)\n%20 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 19)\n%21 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 20)\n%22 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 21)\n%23 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 22)\n%24 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 23)\n%25 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 24)\n%26 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 25)\n%27 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 26)\n%28 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 27)\n%29 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 28)\n%30 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 29)\n%31 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 30)\n%32 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 31)\n%33 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 32)\n%34 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 33)\n%35 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 34)\n%36 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 35)\n%37 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 36)\n%38 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 37)\n%39 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 38)\n%40 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 39)\n%41 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 40)\n%42 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 41)\n%43 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 42)\n%44 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 43)\n%45 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 44)\n%46 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 45)\n%47 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 46)\n%48 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 47)\n%49 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef 48)\n%50 = add nuw nsw i32 %0, 1\n%51 = icmp eq i32 %50, 20\nbr i1 %51, label %B2, label %B1\n\nB2:\nret void\n}", "codellama": "define dso_local void @all_mapped() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 0, %B ], [ %4, %B3 ]\nbr label %B2\n\nB2:\n%1 = phi i32 [ 0, %B1 ], [ %3, %B2 ]\n%2 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef %1)\n%3 = add nuw nsw i32 %1, 1\n%4 = icmp eq i32 %3, 49\nbr i1 %4, label %B3, label %B2\n\nB3:\n%5 = add nuw nsw i32 %0, 1\n%6 = icmp eq i32 %5, 20\nbr i1 %6, label %B4, label %B1\n\nB4:\nret void\n}", "codegemma": "define dso_local void @all_mapped() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 0, %B ], [ %4, %B3 ]\n%1 = icmp slt i32 %0, 20\nbr i1 %1, label %B2, label %B4\n\nB2:\n%2 = phi i32 [ 0, %B1 ], [ %5, %B2 ]\n%3 = tail call i32 @mark_mapped(i32 noundef %0, i32 noundef %2)\n%4 = add nuw nsw i32 %0, 1\n%5 = add nuw nsw i32 %2, 1\n%6 = icmp eq i32 %5, 49\nbr i1 %6, label %B3, label %B2\n\nB3:\n%7 = add nuw nsw i32 %0, 1\n%8 = icmp eq i32 %7, 20\nbr i1 %8, label %B4, label %B1\n\nB4:\nret void\n}"}, "define dso_local ptr @get_sata_statlog(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call ptr @get_sata_log(i32 noundef %3, i32 noundef 1)\nret ptr %4\n}": {"base_truth": "define dso_local ptr @get_sata_statlog(i32 noundef %0) {\nB:\n%1 = tail call ptr @get_sata_log(i32 noundef %0, i32 noundef 1)\nret ptr %1\n}", "codellama": "define dso_local ptr @get_sata_statlog(i32 noundef %0) {\nB:\n%1 = tail call ptr @get_sata_log(i32 noundef %0, i32 noundef 1)\nret ptr %1\n}", "codegemma": "define dso_local ptr @get_sata_statlog(i32 noundef %0) {\nB:\n%1 = tail call ptr @get_sata_log(i32 noundef %0, i32 noundef 1)\nret ptr %1\n}"}, "define dso_local i32 @zfiWlanQueryCurrentFrequency(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @zmw_get_wlan_dev(ptr noundef %6)\n%8 = load i32, ptr %4, align 4\nswitch i32 %8, label %71 [\ni32 0, label %9\ni32 1, label %66\n]\n\n9:\n%10 = load ptr, ptr @wd, align 8\n%11 = getelementptr inbounds %struct.TYPE_4__, ptr %10, i32 0, i32 1\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\n%14 = icmp sgt i32 %13, 3000\nbr i1 %14, label %15, label %40\n\n15:\n%16 = load ptr, ptr @wd, align 8\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%20 = and i32 %18, %19\n%21 = icmp ne i32 %20, 0\nbr i1 %21, label %22, label %27\n\n22:\n%23 = load ptr, ptr @wd, align 8\n%24 = getelementptr inbounds %struct.TYPE_4__, ptr %23, i32 0, i32 1\n%25 = getelementptr inbounds %struct.TYPE_3__, ptr %24, i32 0, i32 0\n%26 = load i32, ptr %25, align 4\nstore i32 %26, ptr %5, align 4\nbr label %39\n\n27:\n%28 = load ptr, ptr @wd, align 8\n%29 = getelementptr inbounds %struct.TYPE_4__, ptr %28, i32 0, i32 0\n%30 = load i32, ptr %29, align 4\n%31 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%32 = and i32 %30, %31\n%33 = icmp ne i32 %32, 0\nbr i1 %33, label %34, label %37\n\n34:\n%35 = load ptr, ptr %3, align 8\n%36 = call i32 @zfChGetFirst2GhzChannel(ptr noundef %35)\nstore i32 %36, ptr %5, align 4\nbr label %38\n\n37:\nstore i32 0, ptr %5, align 4\nbr label %38\n\n38:\nbr label %39\n\n39:\nbr label %65\n\n40:\n%41 = load ptr, ptr @wd, align 8\n%42 = getelementptr inbounds %struct.TYPE_4__, ptr %41, i32 0, i32 0\n%43 = load i32, ptr %42, align 4\n%44 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%45 = and i32 %43, %44\n%46 = icmp ne i32 %45, 0\nbr i1 %46, label %47, label %52\n\n47:\n%48 = load ptr, ptr @wd, align 8\n%49 = getelementptr inbounds %struct.TYPE_4__, ptr %48, i32 0, i32 1\n%50 = getelementptr inbounds %struct.TYPE_3__, ptr %49, i32 0, i32 0\n%51 = load i32, ptr %50, align 4\nstore i32 %51, ptr %5, align 4\nbr label %64\n\n52:\n%53 = load ptr, ptr @wd, align 8\n%54 = getelementptr inbounds %struct.TYPE_4__, ptr %53, i32 0, i32 0\n%55 = load i32, ptr %54, align 4\n%56 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%57 = and i32 %55, %56\n%58 = icmp ne i32 %57, 0\nbr i1 %58, label %59, label %62\n\n59:\n%60 = load ptr, ptr %3, align 8\n%61 = call i32 @zfChGetLast5GhzChannel(ptr noundef %60)\nstore i32 %61, ptr %5, align 4\nbr label %63\n\n62:\nstore i32 0, ptr %5, align 4\nbr label %63\n\n63:\nbr label %64\n\n64:\nbr label %65\n\n65:\nbr label %72\n\n66:\n%67 = load ptr, ptr @wd, align 8\n%68 = getelementptr inbounds %struct.TYPE_4__, ptr %67, i32 0, i32 1\n%69 = getelementptr inbounds %struct.TYPE_3__, ptr %68, i32 0, i32 0\n%70 = load i32, ptr %69, align 4\nstore i32 %70, ptr %5, align 4\nbr label %72\n\n71:\nstore i32 0, ptr %5, align 4\nbr label %72\n\n72:\n%73 = load i32, ptr %5, align 4\n%74 = mul nsw i32 %73, 1000\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %74\n}": {"base_truth": "define dso_local i32 @zfiWlanQueryCurrentFrequency(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @zmw_get_wlan_dev(ptr noundef %0)\nswitch i32 %1, label %B9 [\ni32 0, label %B1\ni32 1, label %B8\n]\n\nB1:\n%3 = load ptr, ptr @wd, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp sgt i32 %5, 3000\n%7 = load i32, ptr %3, align 4\nbr i1 %6, label %B2, label %B5\n\nB2:\n%8 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%9 = and i32 %8, %7\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B9\n\nB3:\n%11 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%12 = and i32 %11, %7\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B9, label %B4\n\nB4:\n%14 = tail call i32 @zfChGetFirst2GhzChannel(ptr noundef %0)\nbr label %B9\n\nB5:\n%15 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%16 = and i32 %15, %7\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B6, label %B9\n\nB6:\n%18 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%19 = and i32 %18, %7\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B9, label %B7\n\nB7:\n%21 = tail call i32 @zfChGetLast5GhzChannel(ptr noundef %0)\nbr label %B9\n\nB8:\n%22 = load ptr, ptr @wd, align 8\n%23 = getelementptr inbounds %struct.TYPE_4__, ptr %22, i64 0, i32 1\n%24 = load i32, ptr %23, align 4\nbr label %B9\n\nB9:\n%25 = phi i32 [ %24, %B8 ], [ %14, %B4 ], [ %21, %B7 ], [ %5, %B2 ], [ 0, %B3 ], [ %5, %B5 ], [ 0, %B6 ], [ 0, %B ]\n%26 = mul nsw i32 %25, 1000\nret i32 %26\n}", "codellama": "define dso_local i32 @zfiWlanQueryCurrentFrequency(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @zmw_get_wlan_dev(ptr noundef %0)\nswitch i32 %1, label %B10 [\ni32 0, label %B1\ni32 1, label %B9\n]\n\nB1:\n%3 = load ptr, ptr @wd, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp sgt i32 %5, 3000\nbr i1 %6, label %B2, label %B5\n\nB2:\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%9 = and i32 %8, %7\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @zfChGetFirst2GhzChannel(ptr noundef %0)\nbr label %B10\n\nB4:\n%12 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%13 = and i32 %12, %7\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B10, label %B8\n\nB5:\n%15 = load i32, ptr %3, align 4\n%16 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%17 = and i32 %16, %15\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B7, label %B6\n\nB6:\n%19 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i64 0, i32 1\n%20 = load i32, ptr %19, align 4\nbr label %B10\n\nB7:\n%21 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%22 = and i32 %21, %15\n%23 = icmp eq i32 %22, 0\nbr i1 %23, label %B10, label %B8\n\nB8:\n%24 = phi i32 [ %20, %B6 ], [ %10, %B4 ], [ %20, %B7 ]\n%25 = tail call i32 @zfChGetLast5GhzChannel(ptr noundef %0)\nbr label %B10\n\nB9:\n%26 = getelementptr inbounds %struct.TYPE_4</s>", "codegemma": "define dso_local i32 @zfiWlanQueryCurrentFrequency(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @zmw_get_wlan_dev(ptr noundef %0)\nswitch i32 %1, label %B7 [\ni32 0, label %B1\ni32 1, label %B6\n]\n\nB1:\n%3 = load ptr, ptr @wd, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp sgt i32 %5, 3000\nbr i1 %6, label %B2, label %B5\n\nB2:\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @ZM_WIRELESS_MODE_5, align 4\n%9 = and i32 %8, %7\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @zfChGetFirst2GhzChannel(ptr noundef %0)\nbr label %B7\n\nB4:\n%12 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%13 = and i32 %12, %7\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B7, label %B3\n\nB5:\n%15 = load i32, ptr @ZM_WIRELESS_MODE_24, align 4\n%16 = and i32 %15, %7\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B7, label %B6\n\nB6:\n%18 = load ptr, ptr @wd, align 8\n%19 = getelementptr inbounds %struct.TYPE_4__, ptr %18, i64 0, i32 1\n%20 = load i32, ptr %19, align 4\nbr label %B7\n\nB7:\n%21 = phi i32 [ %20, %B6 ], [ %11, %B3 ], [ 0, %B4 ], [ 0, %B5 ], [ 0, %B ]\n%22 = mul nsw i32 %21, 1000\nret i32 %22\n}"}, "define dso_local void @deleteData(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.benchData ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nswitch i32 %5, label %24 [\ni32 129, label %6\ni32 128, label %12\ni32 130, label %18\n]\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.benchData ptr %7, i32 0, i32 1\n%9 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i32 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = call i32 @freeIntArray(i32 noundef %10)\nbr label %24\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = getelementptr inbounds %struct.benchData ptr %13, i32 0, i32 1\n%15 = getelementptr inbounds %struct.TYPE_2__, ptr %14, i32 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = call i32 @freeRealArray(i32 noundef %16)\nbr label %24\n\n18:\n%19 = load ptr, ptr %2, align 8\n%20 = getelementptr inbounds %struct.benchData ptr %19, i32 0, i32 1\n%21 = getelementptr inbounds %struct.TYPE_2__, ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = call i32 @freeFloat4Array(i32 noundef %22)\nbr label %24\n\n24:\nret void\n}": {"base_truth": "define dso_local void @deleteData(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 129, label %B1\ni32 128, label %B2\ni32 130, label %B3\n]\n\nB1:\n%2 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @freeIntArray(i32 noundef %3)\nbr label %B4\n\nB2:\n%5 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @freeRealArray(i32 noundef %6)\nbr label %B4\n\nB3:\n%8 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @freeFloat4Array(i32 noundef %9)\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @deleteData(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 129, label %B1\ni32 128, label %B2\ni32 130, label %B3\n]\n\nB1:\n%2 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @freeIntArray(i32 noundef %3)\nbr label %B4\n\nB2:\n%5 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @freeRealArray(i32 noundef %6)\nbr label %B4\n\nB3:\n%8 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @freeFloat4Array(i32 noundef %9)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @deleteData(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 129, label %B1\ni32 128, label %B2\ni32 130, label %B3\n]\n\nB1:\n%2 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @freeIntArray(i32 noundef %3)\nbr label %B4\n\nB2:\n%5 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @freeRealArray(i32 noundef %6)\nbr label %B4\n\nB3:\n%8 = getelementptr inbounds %struct.benchData, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @freeFloat4Array(i32 noundef %9)\nbr label %B4\n\nB4:\nret void\n}"}, "define internal i32 @sched_shouldpreempt(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore i32 %0, ptr %5, align 4\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr %6, align 4\n%10 = icmp sge i32 %8, %9\nbr i1 %10, label %11, label %12\n\n11:\nstore i32 0, ptr %4, align 4\nbr label %39\n\n12:\n%13 = load i32, ptr %6, align 4\n%14 = load i32, ptr @PRI_MIN_IDLE, align 4\n%15 = icmp sge i32 %13, %14\nbr i1 %15, label %16, label %17\n\n16:\nstore i32 1, ptr %4, align 4\nbr label %39\n\n17:\n%18 = load i32, ptr @preempt_thresh, align 4\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 0, ptr %4, align 4\nbr label %39\n\n21:\n%22 = load i32, ptr %5, align 4\n%23 = load i32, ptr @preempt_thresh, align 4\n%24 = icmp sle i32 %22, %23\nbr i1 %24, label %25, label %26\n\n25:\nstore i32 1, ptr %4, align 4\nbr label %39\n\n26:\n%27 = load i32, ptr %7, align 4\n%28 = icmp ne i32 %27, 0\nbr i1 %28, label %29, label %38\n\n29:\n%30 = load i32, ptr %5, align 4\n%31 = load i32, ptr @PRI_MAX_INTERACT, align 4\n%32 = icmp sle i32 %30, %31\nbr i1 %32, label %33, label %38\n\n33:\n%34 = load i32, ptr %6, align 4\n%35 = load i32, ptr @PRI_MAX_INTERACT, align 4\n%36 = icmp sgt i32 %34, %35\nbr i1 %36, label %37, label %38\n\n37:\nstore i32 1, ptr %4, align 4\nbr label %39\n\n38:\nstore i32 0, ptr %4, align 4\nbr label %39\n\n39:\n%40 = load i32, ptr %4, align 4\nret i32 %40\n}": {"base_truth": "define internal i32 @sched_shouldpreempt(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %0, %1\nbr i1 %3, label %B1, label %B7\n\nB1:\n%4 = load i32, ptr @PRI_MIN_IDLE, align 4\n%5 = icmp sgt i32 %4, %1\nbr i1 %5, label %B2, label %B7\n\nB2:\n%6 = load i32, ptr @preempt_thresh, align 4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B7, label %B3\n\nB3:\n%8 = icmp slt i32 %6, %0\nbr i1 %8, label %B4, label %B7\n\nB4:\n%9 = icmp eq i32 %2, 0\nbr i1 %9, label %B6, label %B5\n\nB5:\n%10 = load i32, ptr @PRI_MAX_INTERACT, align 4\n%11 = icmp sge i32 %10, %0\n%12 = icmp slt i32 %10, %1\n%13 = and i1 %11, %12\nbr i1 %13, label %B7, label %B6\n\nB6:\nbr label %B7\n\nB7:\n%14 = phi i32 [ 0, %B6 ], [ 0, %B ], [ 1, %B1 ], [ 0, %B2 ], [ 1, %B3 ], [ 1, %B5 ]\nret i32 %14\n}", "codellama": "define internal i32 @sched_shouldpreempt(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %0, %1\nbr i1 %3, label %B1, label %B6\n\nB1:\n%4 = load i32, ptr @PRI_MIN_IDLE, align 4\n%5 = icmp sgt i32 %4, %1\n%6 = load i32, ptr @preempt_thresh, align 4\n%7 = icmp eq i32 %6, 0\n%8 = select i1 %5, i1 %7, i1 false\nbr i1 %8, label %B6, label %B2\n\nB2:\n%9 = icmp slt i32 %6, %0\nbr i1 %9, label %B3, label %B6\n\nB3:\n%10 = icmp eq i32 %2, 0\nbr i1 %10, label %B6, label %B4\n\nB4:\n%11 = load i32, ptr @PRI_MAX_INTERACT, align 4\n%12 = icmp slt i32 %11, %0\n%13 = icmp sgt i32 %11, %1\n%14 = select i1 %12, i1 %13, i1 false\nbr i1 %14, label %B5, label %B6\n\nB5:\nbr label %B6\n\nB6:\n%15 = phi i32 [ 1, %B5 ], [ 0, %B ], [ 1, %B1 ], [ 1, %B2 ], [ 0, %B3 ], [ 0, %B4 ], [ 0, %B5 ]\nret i32 %15\n}", "codegemma": "define internal i32 @sched_shouldpreempt(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %0, %1\nbr i1 %3, label %B1, label %B5\n\nB1:\n%4 = load i32, ptr @PRI_MIN_IDLE, align 4\n%5 = icmp sgt i32 %4, %1\nbr i1 %5, label %B2, label %B5\n\nB2:\n%6 = load i32, ptr @preempt_thresh, align 4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B5, label %B3\n\nB3:\n%8 = icmp sgt i32 %6, %0\n%9 = icmp ne i32 %2, 0\n%10 = and i1 %9, %8\nbr i1 %10, label %B4, label %B5\n\nB4:\n%11 = load i32, ptr @PRI_MAX_INTERACT, align 4\n%12 = icmp sgt i32 %11, %0\n%13 = icmp slt i32 %11, %1\n%14 = and i1 %13, %12\n%15 = zext i1 %14 to i32\nbr label %B5\n\nB5:\n%16 = phi i32 [ 0, %B ], [ 1, %B1 ], [ 0, %B2 ], [ 1, %B3 ], [ %15, %B4 ]\nret i32 %16\n}"}, "define dso_local void @V(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i64 @sem_post(ptr noundef %3)\n%5 = icmp slt i64 %4, 0\nbr i1 %5, label %6, label %8\n\n6:\n%7 = call i32 @unix_error(ptr noundef @.str)\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @V(ptr noundef %0) {\nB:\n%1 = tail call i64 @sem_post(ptr noundef %0)\n%2 = icmp slt i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @unix_error(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @V(ptr noundef %0) {\nB:\n%1 = tail call i64 @sem_post(ptr noundef %0)\n%2 = icmp slt i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @unix_error(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @V(ptr noundef %0) {\nB:\n%1 = tail call i64 @sem_post(ptr noundef %0)\n%2 = icmp slt i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @unix_error(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @exp_get_value_int(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load ptr, ptr %6, align 8\n%10 = call i32 @exp_get_vma(ptr noundef %7, i32 noundef %8, ptr noundef %9)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @exp_get_value_int(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @exp_get_vma(ptr noundef %0, i32 noundef %1, ptr noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @exp_get_value_int(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @exp_get_vma(ptr noundef %0, i32 noundef %1, ptr noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @exp_get_value_int(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @exp_get_vma(ptr noundef %0, i32 noundef %1, ptr noundef %2)\nret i32 %3\n}"}, "define internal void @xctrl_reboot() {\n%1 = call i32 @shutdown_nice(i32 noundef 0)\nret void\n}": {"base_truth": "define internal void @xctrl_reboot() {\nB:\n%0 = tail call i32 @shutdown_nice(i32 noundef 0)\nret void\n}", "codellama": "define internal void @xctrl_reboot() {\nB:\n%0 = tail call i32 @shutdown_nice(i32 noundef 0)\nret void\n}", "codegemma": "define internal void @xctrl_reboot() {\nB:\n%0 = tail call i32 @shutdown_nice(i32 noundef 0)\nret void\n}"}, "define dso_local void @GFX_CopyToBuffer(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %4) {\n%6 = alloca i64, align 8\n%7 = alloca i64, align 8\n%8 = alloca i64, align 8\n%9 = alloca i64, align 8\n%10 = alloca ptr, align 8\n%11 = alloca ptr, align 8\n%12 = alloca i32, align 4\nstore i64 %0, ptr %6, align 8\nstore i64 %1, ptr %7, align 8\nstore i64 %2, ptr %8, align 8\nstore i64 %3, ptr %9, align 8\nstore ptr %4, ptr %10, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %11)\n%13 = load i64, ptr %8, align 8\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %15, label %16\n\n15:\nstore i32 1, ptr %12, align 4\nbr label %87\n\n16:\n%17 = load i64, ptr %9, align 8\n%18 = icmp eq i64 %17, 0\nbr i1 %18, label %19, label %20\n\n19:\nstore i32 1, ptr %12, align 4\nbr label %87\n\n20:\n%21 = load i64, ptr %6, align 8\n%22 = icmp slt i64 %21, 0\nbr i1 %22, label %23, label %24\n\n23:\nstore i64 0, ptr %6, align 8\nbr label %24\n\n24:\n%25 = load i64, ptr %6, align 8\n%26 = load i64, ptr @SCREEN_WIDTH, align 8\n%27 = icmp sge i64 %25, %26\nbr i1 %27, label %28, label %31\n\n28:\n%29 = load i64, ptr @SCREEN_WIDTH, align 8\n%30 = sub nsw i64 %29, 1\nstore i64 %30, ptr %6, align 8\nbr label %31\n\n31:\n%32 = load i64, ptr %7, align 8\n%33 = icmp slt i64 %32, 0\nbr i1 %33, label %34, label %35\n\n34:\nstore i64 0, ptr %7, align 8\nbr label %35\n\n35:\n%36 = load i64, ptr %7, align 8\n%37 = load i64, ptr @SCREEN_HEIGHT, align 8\n%38 = icmp sge i64 %36, %37\nbr i1 %38, label %39, label %42\n\n39:\n%40 = load i64, ptr @SCREEN_HEIGHT, align 8\n%41 = sub nsw i64 %40, 1\nstore i64 %41, ptr %7, align 8\nbr label %42\n\n42:\n%43 = load i64, ptr %8, align 8\n%44 = load i64, ptr @SCREEN_WIDTH, align 8\n%45 = load i64, ptr %6, align 8\n%46 = sub nsw i64 %44, %45\n%47 = icmp sgt i64 %43, %46\nbr i1 %47, label %48, label %52\n\n48:\n%49 = load i64, ptr @SCREEN_WIDTH, align 8\n%50 = load i64, ptr %6, align 8\n%51 = sub nsw i64 %49, %50\nstore i64 %51, ptr %8, align 8\nbr label %52\n\n52:\n%53 = load i64, ptr %9, align 8\n%54 = load i64, ptr @SCREEN_HEIGHT, align 8\n%55 = load i64, ptr %7, align 8\n%56 = sub nsw i64 %54, %55\n%57 = icmp sgt i64 %53, %56\nbr i1 %57, label %58, label %62\n\n58:\n%59 = load i64, ptr @SCREEN_HEIGHT, align 8\n%60 = load i64, ptr %7, align 8\n%61 = sub nsw i64 %59, %60\nstore i64 %61, ptr %9, align 8\nbr label %62\n\n62:\n%63 = call ptr @GFX_Screen_Get_ByIndex(i32 noundef 0)\nstore ptr %63, ptr %11, align 8\n%64 = load i64, ptr %7, align 8\n%65 = load i64, ptr @SCREEN_WIDTH, align 8\n%66 = mul nsw i64 %64, %65\n%67 = load i64, ptr %6, align 8\n%68 = add nsw i64 %66, %67\n%69 = load ptr, ptr %11, align 8\n%70 = getelementptr inbounds i32, ptr %69, i64 %68\nstore ptr %70, ptr %11, align 8\nbr label %71\n\n71:\n%72 = load i64, ptr %9, align 8\n%73 = add nsw i64 %72, -1\nstore i64 %73, ptr %9, align 8\n%74 = icmp ne i64 %72, 0\nbr i1 %74, label %75, label %86\n\n75:\n%76 = load ptr, ptr %10, align 8\n%77 = load ptr, ptr %11, align 8\n%78 = load i64, ptr %8, align 8\n%79 = call i32 @memcpy(ptr noundef %76, ptr noundef %77, i64 noundef %78)\n%80 = load i64, ptr @SCREEN_WIDTH, align 8\n%81 = load ptr, ptr %11, align 8\n%82 = getelementptr inbounds i32, ptr %81, i64 %80\nstore ptr %82, ptr %11, align 8\n%83 = load i64, ptr %8, align 8\n%84 = load ptr, ptr %10, align 8\n%85 = getelementptr inbounds i32, ptr %84, i64 %83\nstore ptr %85, ptr %10, align 8\nbr label %71\n\n86:\nstore i32 0, ptr %12, align 4\nbr label %87\n\n87:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %11)\n%88 = load i32, ptr %12, align 4\nswitch i32 %88, label %90 [\ni32 0, label %89\ni32 1, label %89\n]\n\n89:\nret void\n\n90:\nunreachable\n}": {"base_truth": "define dso_local void @GFX_CopyToBuffer(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %4) {\nB:\n%5 = icmp eq i64 %2, 0\n%6 = icmp eq i64 %3, 0\n%7 = or i1 %5, %6\nbr i1 %7, label %B4, label %B1\n\nB1:\n%8 = tail call i64 @llvm.smax.i64(i64 %0, i64 0)\n%9 = load i64, ptr @SCREEN_WIDTH, align 8\n%10 = icmp slt i64 %8, %9\n%11 = add nsw i64 %9, -1\n%12 = select i1 %10, i64 %8, i64 %11\n%13 = tail call i64 @llvm.smax.i64(i64 %1, i64 0)\n%14 = load i64, ptr @SCREEN_HEIGHT, align 8\n%15 = icmp slt i64 %13, %14\n%16 = add nsw i64 %14, -1\n%17 = select i1 %15, i64 %13, i64 %16\n%18 = sub nsw i64 %9, %12\n%19 = tail call i64 @llvm.smin.i64(i64 %18, i64 %2)\n%20 = sub nsw i64 %14, %17\n%21 = tail call ptr @GFX_Screen_Get_ByIndex(i32 noundef 0)\n%22 = tail call i64 @llvm.smin.i64(i64 %20, i64 %3)\n%23 = icmp eq i64 %22, 0\nbr i1 %23, label %B4, label %B2\n\nB2:\n%24 = load i64, ptr @SCREEN_WIDTH, align 8\n%25 = mul nsw i64 %17, %24\n%26 = add nsw i64 %25, %12\n%27 = getelementptr inbounds i32, ptr %21, i64 %26\nbr label %B3\n\nB3:\n%28 = phi ptr [ %34, %B3 ], [ %27, %B2 ]\n%29 = phi ptr [ %35, %B3 ], [ %4, %B2 ]\n%30 = phi i64 [ %31, %B3 ], [ %22, %B2 ]\n%31 = add nsw i64 %30, -1\n%32 = tail call i32 @memcpy(ptr noundef %29, ptr noundef %28, i64 noundef %19)\n%33 = load i64, ptr @SCREEN_WIDTH, align 8\n%34 = getelementptr inbounds i32, ptr %28, i64 %33\n%35 = getelementptr inbounds i32, ptr %29, i64 %19\n%36 = icmp eq i64 %31, 0\nbr i1 %36, label %B4, label %B3\n\nB4:\nret void\n}", "codellama": "define dso_local void @GFX_CopyToBuffer(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %4) {\nB:\n%5 = icmp eq i64 %2, 0\n%6 = icmp eq i64 %3, 0\n%7 = or i1 %5, %6\nbr i1 %7, label %B3, label %B1\n\nB1:\n%8 = tail call i64 @llvm.smax.i64(i64 %0, i64 0)\n%9 = load i64, ptr @SCREEN_WIDTH, align 8\n%10 = icmp slt i64 %8, %9\n%11 = add nsw i64 %9, -1\n%12 = select i1 %10, i64 %8, i64 %11\n%13 = tail call i64 @llvm.smax.i64(i64 %1, i64 0)\n%14 = load i64, ptr @SCREEN_HEIGHT, align 8\n%15 = icmp slt i64 %13, %14\n%16 = add nsw i64 %14, -1\n%17 = select i1 %15, i64 %13, i64 %16\n%18 = sub nsw i64 %9, %12\n%19 = tail call i64 @llvm.smin.i64(i64 %2, i64 %18)\n%20 = sub nsw i64 %14, %17\n%21 = tail call i64 @llvm.smin.i64(i64 %3, i64 %20)\n%22 = tail call ptr @GFX_Screen_Get_ByIndex(i32 noundef 0)\n%23 = load i64, ptr @SCREEN_WIDTH, align 8\n%24 = mul nsw i64 %23, %17\n%25 = add nsw i</s>", "codegemma": "define dso_local void @GFX_CopyToBuffer(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %4) {\nB:\n%5 = icmp eq i64 %2, 0\nbr i1 %5, label %B5, label %B1\n\nB1:\n%6 = icmp eq i64 %3, 0\nbr i1 %6, label %B5, label %B2\n\nB2:\n%7 = icmp slt i64 %0, 0\nbr i1 %7, label %B3, label %B4\n\nB3:\n%8 = load i64, ptr @SCREEN_WIDTH, align 8\n%9 = add nsw i64 %8, -1\nbr label %B4\n\nB4:\n%10 = phi i64 [ %9, %B3 ], [ %0, %B2 ]\n%11 = icmp slt i64 %10, %8\nbr i1 %11, label %B5, label %B6\n\nB5:\n%12 = phi i64 [ 0, %B1 ], [ 0, %B ], [ %8, %B4 ]\n%13 = phi i64 [ 0, %B1 ], [ 0, %B ], [ %3, %B4 ]\n%14 = icmp slt i64 %13, 0\nbr i1 %14, label %B6, label %B6\n\nB6:\n%15 = phi i64 [ %13, %B5 ], [ %12, %B4 ]\n%16 = phi i64 [ %13, %B5 ], [ %12, %B4 ]\n%17 = phi ptr [ %4, %B5 ], [ %4, %B4 ]\n%18 = load i64, ptr @SCREEN_WIDTH, align 8\n%19 = sub nsw i64 %18, %10\n%20 = icmp sgt i64 %19, %15\n%21 = sub nsw i64 %18, %10\n%22 = select i1 %20, i64 %21, i64 %15\n%23 = load i64, ptr @SCREEN_HEIGHT, align 8\n%24 = sub nsw i64 %23, %16\n%25 = icmp sgt i64 %24, %22\n%26 = sub nsw i64 %2<eos>"}, "define internal void @usX2Y_usbpcm_urbs_release(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.snd_usX2Y_substream ptr %4, i32 0, i32 1\n%6 = load i32, ptr %5, align 8\n%7 = call i32 @snd_printdd(ptr noundef @.str, i32 noundef %6)\nstore i32 0, ptr %3, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %3, align 4\n%10 = load i32, ptr @NRURBS, align 4\n%11 = icmp slt i32 %9, %10\nbr i1 %11, label %12, label %23\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = getelementptr inbounds %struct.snd_usX2Y_substream ptr %13, i32 0, i32 0\n%15 = load i64, ptr %14, align 8\n%16 = load i32, ptr %3, align 4\n%17 = sext i32 %16 to i64\n%18 = add nsw i64 %15, %17\n%19 = call i32 @usX2Y_hwdep_urb_release(i64 noundef %18)\nbr label %20\n\n20:\n%21 = load i32, ptr %3, align 4\n%22 = add nsw i32 %21, 1\nstore i32 %22, ptr %3, align 4\nbr label %8\n\n23:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define internal void @usX2Y_usbpcm_urbs_release(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.snd_usX2Y_substream, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 8\n%3 = tail call i32 @snd_printdd(ptr noundef nonnull @.str, i32 noundef %2)\n%4 = load i32, ptr @NRURBS, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = phi i64 [ %10, %B1 ], [ 0, %B ]\n%7 = load i64, ptr %0, align 8\n%8 = add nsw i64 %7, %6\n%9 = tail call i32 @usX2Y_hwdep_urb_release(i64 noundef %8)\n%10 = add nuw nsw i64 %6, 1\n%11 = load i32, ptr @NRURBS, align 4\n%12 = sext i32 %11 to i64\n%13 = icmp slt i64 %10, %12\nbr i1 %13, label %B1, label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @usX2Y_usbpcm_urbs_release(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.snd_usX2Y_substream, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 8\n%3 = tail call i32 @snd_printdd(ptr noundef nonnull @.str, i32 noundef %2)\n%4 = load i32, ptr @NRURBS, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = phi i64 [ %11, %B1 ], [ 0, %B ]\n%7 = load i64, ptr %0, align 8\n%8 = add nsw i64 %7, %6\n%9 = tail call i32 @usX2Y_hwdep_urb_release(i64 noundef %8)\n%10 = load i32, ptr @NRURBS, align 4\n%11 = add nuw nsw i64 %6, 1\n%12 = icmp slt i64 %11, %10\nbr i1 %12, label %B1, label %B2\n\nB2:\nret void\n\nB3:\nret void\n}", "codegemma": "define internal void @usX2Y_usbpcm_urbs_release(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.snd_usX2Y_substream, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 8\n%3 = tail call i32 @snd_printdd(ptr noundef nonnull @.str, i32 noundef %2)\n%4 = load i32, ptr @NRURBS, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = zext i32 %4 to i64\nbr label %B2\n\nB2:\n%7 = phi i64 [ 0, %B1 ], [ %11, %B2 ]\n%8 = load i64, ptr %0, align 8\n%9 = add nsw i64 %8, %7\n%10 = tail call i32 @usX2Y_hwdep_urb_release(i64 noundef %9)\n%11 = add nuw nsw i64 %7, 1\n%12 = icmp eq i64 %11, %6\nbr i1 %12, label %B3, label %B2\n\nB3:\nret void\n}"}, "define dso_local ptr @cb_menu_clr_key_buf_every(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr @g_flg_clr_key_buf, align 4\n%6 = icmp ne i32 %5, 0\n%7 = xor i1 %6, true\n%8 = zext i1 %7 to i32\nstore i32 %8, ptr @g_flg_clr_key_buf, align 4\nret ptr @.str\n}": {"base_truth": "define dso_local nonnull ptr @cb_menu_clr_key_buf_every(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @g_flg_clr_key_buf, align 4\n%3 = icmp eq i32 %2, 0\n%4 = zext i1 %3 to i32\nstore i32 %4, ptr @g_flg_clr_key_buf, align 4\nret ptr @.str\n}", "codellama": "define dso_local nonnull ptr @cb_menu_clr_key_buf_every(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @g_flg_clr_key_buf, align 4\n%3 = icmp eq i32 %2, 0\n%4 = zext i1 %3 to i32\nstore i32 %4, ptr @g_flg_clr_key_buf, align 4\nret ptr @.str\n}", "codegemma": "define dso_local nonnull ptr @cb_menu_clr_key_buf_every(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @g_flg_clr_key_buf, align 4\n%3 = icmp eq i32 %2, 0\n%4 = zext i1 %3 to i32\nstore i32 %4, ptr @g_flg_clr_key_buf, align 4\nret ptr @.str\n}"}, "define dso_local void @lcdNext() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = load i32, ptr @currentPage, align 4\n%5 = icmp eq i32 %4, 1\nbr i1 %5, label %6, label %22\n\n6:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%7 = call i32 (...) @getAutonMode()\nstore i32 %7, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%8 = call i32 (...) @getAutonModeMin()\nstore i32 %8, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%9 = call i32 (...) @getAutonModeMax()\nstore i32 %9, ptr %3, align 4\n%10 = load i32, ptr %1, align 4\n%11 = load i32, ptr %2, align 4\n%12 = icmp sgt i32 %10, %11\nbr i1 %12, label %13, label %17\n\n13:\n%14 = load i32, ptr %1, align 4\n%15 = sub nsw i32 %14, 1\n%16 = call i32 @setAutonMode(i32 noundef %15)\nbr label %20\n\n17:\n%18 = load i32, ptr %3, align 4\n%19 = call i32 @setAutonMode(i32 noundef %18)\nbr label %20\n\n20:\n%21 = call i32 @lcdUpdatePage(i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nbr label %42\n\n22:\n%23 = load i32, ptr @currentPage, align 4\n%24 = icmp eq i32 %23, 2\nbr i1 %24, label %25, label %32\n\n25:\n%26 = call i32 (...) @getAutonPosition()\n%27 = icmp ne i32 %26, 0\n%28 = xor i1 %27, true\n%29 = zext i1 %28 to i32\n%30 = call i32 @setAutonPosition(i32 noundef %29)\n%31 = call i32 @lcdUpdatePage(i32 noundef 1)\nbr label %42\n\n32:\n%33 = load i32, ptr @currentPage, align 4\n%34 = icmp eq i32 %33, 3\nbr i1 %34, label %35, label %42\n\n35:\n%36 = call i32 (...) @getAutonColor()\n%37 = icmp ne i32 %36, 0\n%38 = xor i1 %37, true\n%39 = zext i1 %38 to i32\n%40 = call i32 @setAutonColor(i32 noundef %39)\n%41 = call i32 @lcdUpdatePage(i32 noundef 1)\nbr label %42\n\n42:\nret void\n}": {"base_truth": "define dso_local void @lcdNext() {\nB:\n%0 = load i32, ptr @currentPage, align 4\nswitch i32 %0, label %B5 [\ni32 1, label %B1\ni32 2, label %B2\ni32 3, label %B3\n]\n\nB1:\n%1 = tail call i32 (...) @getAutonMode()\n%2 = tail call i32 (...) @getAutonModeMin()\n%3 = tail call i32 (...) @getAutonModeMax()\n%4 = icmp sgt i32 %1, %2\n%5 = add nsw i32 %1, -1\n%6 = select i1 %4, i32 %5, i32 %3\n%7 = tail call i32 @setAutonMode(i32 noundef %6)\nbr label %B4\n\nB2:\n%8 = tail call i32 (...) @getAutonPosition()\n%9 = icmp eq i32 %8, 0\n%10 = zext i1 %9 to i32\n%11 = tail call i32 @setAutonPosition(i32 noundef %10)\nbr label %B4\n\nB3:\n%12 = tail call i32 (...) @getAutonColor()\n%13 = icmp eq i32 %12, 0\n%14 = zext i1 %13 to i32\n%15 = tail call i32 @setAutonColor(i32 noundef %14)\nbr label %B4\n\nB4:\n%16 = tail call i32 @lcdUpdatePage(i32 noundef 1)\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define dso_local void @lcdNext() {\nB:\n%0 = load i32, ptr @currentPage, align 4\n%1 = icmp eq i32 %0, 1\nbr i1 %1, label %B1, label %B3\n\nB1:\n%2 = tail call i32 (...) @getAutonMode()\n%3 = tail call i32 (...) @getAutonModeMin()\n%4 = tail call i32 (...) @getAutonModeMax()\n%5 = icmp sgt i32 %2, %3\nbr i1 %5, label %B2, label %B4\n\nB2:\n%6 = add nsw i32 %2, -1\n%7 = tail call i32 @setAutonMode(i32 noundef %6)\nbr label %B5\n\nB3:\n%8 = icmp eq i32 %0, 2\nbr i1 %8, label %B4, label %B5\n\nB4:\n%9 = phi i32 [ %4, %B1 ], [ %2, %B3 ]\n%10 = tail call i32 (...) @getAutonPosition()\n%11 = icmp eq i32 %10, 0\n%12 = zext i1 %11 to i32\n%13 = tail call i32 @setAutonPosition(i32 noundef %12)\nbr label %B5\n\nB5:\n%14 = tail call i32 @lcdUpdatePage(i32 noundef 1)\nret void\n}", "codegemma": "define dso_local void @lcdNext() {\nB:\n%0 = load i32, ptr @currentPage, align 4\nswitch i32 %0, label %B5 [\ni32 1, label %B1\ni32 2, label %B3\ni32 3, label %B4\n]\n\nB1:\n%1 = tail call i32 (...) @getAutonMode()\n%2 = tail call i32 (...) @getAutonModeMin()\n%3 = tail call i32 (...) @getAutonModeMax()\n%4 = icmp sgt i32 %1, %2\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = add nsw i32 %1, -1\nbr label %B4\n\nB3:\n%6 = phi i32 [ %3, %B1 ], [ %2, %B2 ]\n%7 = tail call i32 @setAutonMode(i32 noundef %6)\nbr label %B4\n\nB4:\n%8 = phi i32 [ %5, %B2 ], [ %6, %B3 ]\n%9 = tail call i32 @lcdUpdatePage(i32 noundef 1)\nbr label %B5\n\nB5:\nret void\n}"}, "define internal i32 @enic_dev_notify_set(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.enic, ptr %4, i32 0, i32 0\n%6 = call i32 @spin_lock(ptr noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.enic, ptr %7, i32 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = call i32 @vnic_dev_get_intr_mode(i32 noundef %9)\nswitch i32 %10, label %24 [\ni32 129, label %11\ni32 128, label %17\n]\n\n11:\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.enic, ptr %12, i32 0, i32 1\n%14 = load i32, ptr %13, align 4\n%15 = call i32 (...) @enic_legacy_notify_intr()\n%16 = call i32 @vnic_dev_notify_set(i32 noundef %14, i32 noundef %15)\nstore i32 %16, ptr %3, align 4\nbr label %29\n\n17:\n%18 = load ptr, ptr %2, align 8\n%19 = getelementptr inbounds %struct.enic, ptr %18, i32 0, i32 1\n%20 = load i32, ptr %19, align 4\n%21 = load ptr, ptr %2, align 8\n%22 = call i32 @enic_msix_notify_intr(ptr noundef %21)\n%23 = call i32 @vnic_dev_notify_set(i32 noundef %20, i32 noundef %22)\nstore i32 %23, ptr %3, align 4\nbr label %29\n\n24:\n%25 = load ptr, ptr %2, align 8\n%26 = getelementptr inbounds %struct.enic, ptr %25, i32 0, i32 1\n%27 = load i32, ptr %26, align 4\n%28 = call i32 @vnic_dev_notify_set(i32 noundef %27, i32 noundef -1)\nstore i32 %28, ptr %3, align 4\nbr label %29\n\n29:\n%30 = load ptr, ptr %2, align 8\n%31 = getelementptr inbounds %struct.enic, ptr %30, i32 0, i32 0\n%32 = call i32 @spin_unlock(ptr noundef %31)\n%33 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %33\n}": {"base_truth": "define internal i32 @enic_dev_notify_set(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock(ptr noundef %0)\n%2 = getelementptr inbounds %struct.enic, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @vnic_dev_get_intr_mode(i32 noundef %3)\nswitch i32 %4, label %B3 [\ni32 129, label %B1\ni32 128, label %B2\n]\n\nB1:\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 (...) @enic_legacy_notify_intr()\n%7 = tail call i32 @vnic_dev_notify_set(i32 noundef %5, i32 noundef %6)\nbr label %B4\n\nB2:\n%8 = load i32, ptr %2, align 4\n%9 = tail call i32 @enic_msix_notify_intr(ptr noundef nonnull %0)\n%10 = tail call i32 @vnic_dev_notify_set(i32 noundef %8, i32 noundef %9)\nbr label %B4\n\nB3:\n%11 = load i32, ptr %2, align 4\n%12 = tail call i32 @vnic_dev_notify_set(i32 noundef %11, i32 noundef -1)\nbr label %B4\n\nB4:\n%13 = phi i32 [ %12, %B3 ], [ %10, %B2 ], [ %7, %B1 ]\n%14 = tail call i32 @spin_unlock(ptr noundef nonnull %0)\nret i32 %13\n}", "codellama": "define internal i32 @enic_dev_notify_set(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock(ptr noundef %0)\n%2 = getelementptr inbounds %struct.enic, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @vnic_dev_get_intr_mode(i32 noundef %3)\nswitch i32 %4, label %B3 [\ni32 129, label %B1\ni32 128, label %B2\n]\n\nB1:\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 (...) @enic_legacy_notify_intr()\n%7 = tail call i32 @vnic_dev_notify_set(i32 noundef %5, i32 noundef %6)\nbr label %B4\n\nB2:\n%8 = load i32, ptr %2, align 4\n%9 = tail call i32 @enic_msix_notify_intr(ptr noundef nonnull %0)\n%10 = tail call i32 @vnic_dev_notify_set(i32 noundef %8, i32 noundef %9)\nbr label %B4\n\nB3:\n%11 = load i32, ptr %2, align 4\n%12 = tail call i32 @vnic_dev_notify_set(i32 noundef %11, i32 noundef -1)\nbr label %B4\n\nB4:\n%13 = phi i32 [ %12, %B3 ], [ %10, %B2 ], [ %7, %B1 ]\n%14 = tail call i32 @spin_unlock(ptr noundef nonnull %0)\nret i32 %13\n}", "codegemma": "define internal i32 @enic_dev_notify_set(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock(ptr noundef %0)\n%2 = getelementptr inbounds %struct.enic, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @vnic_dev_get_intr_mode(i32 noundef %3)\nswitch i32 %4, label %B3 [\ni32 129, label %B1\ni32 128, label %B2\n]\n\nB1:\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 (...) @enic_legacy_notify_intr()\n%7 = tail call i32 @vnic_dev_notify_set(i32 noundef %5, i32 noundef %6)\nbr label %B4\n\nB2:\n%8 = tail call i32 @enic_msix_notify_intr(ptr noundef nonnull %0)\n%9 = tail call i32 @vnic_dev_notify_set(i32 noundef %3, i32 noundef %8)\nbr label %B4\n\nB3:\n%10 = load i32, ptr %2, align 4\n%11 = tail call i32 @vnic_dev_notify_set(i32 noundef %10, i32 noundef -1)\nbr label %B4\n\nB4:\n%12 = phi i32 [ %11, %B3 ], [ %9, %B2 ], [ %7, %B1 ]\n%13 = tail call i32 @spin_unlock(ptr noundef nonnull %0)\nret i32 %12\n}"}, "define internal i32 @ascii_to_bin(i8 noundef signext %0) {\n%2 = alloca i32, align 4\n%3 = alloca i8, align 1\nstore i8 %0, ptr %3, align 1\n%4 = load i8, ptr %3, align 1\n%5 = sext i8 %4 to i32\n%6 = icmp sgt i32 %5, 122\nbr i1 %6, label %7, label %8\n\n7:\nstore i32 0, ptr %2, align 4\nbr label %45\n\n8:\n%9 = load i8, ptr %3, align 1\n%10 = sext i8 %9 to i32\n%11 = icmp sge i32 %10, 97\nbr i1 %11, label %12, label %17\n\n12:\n%13 = load i8, ptr %3, align 1\n%14 = sext i8 %13 to i32\n%15 = sub nsw i32 %14, 97\n%16 = add nsw i32 %15, 38\nstore i32 %16, ptr %2, align 4\nbr label %45\n\n17:\n%18 = load i8, ptr %3, align 1\n%19 = sext i8 %18 to i32\n%20 = icmp sgt i32 %19, 90\nbr i1 %20, label %21, label %22\n\n21:\nstore i32 0, ptr %2, align 4\nbr label %45\n\n22:\n%23 = load i8, ptr %3, align 1\n%24 = sext i8 %23 to i32\n%25 = icmp sge i32 %24, 65\nbr i1 %25, label %26, label %31\n\n26:\n%27 = load i8, ptr %3, align 1\n%28 = sext i8 %27 to i32\n%29 = sub nsw i32 %28, 65\n%30 = add nsw i32 %29, 12\nstore i32 %30, ptr %2, align 4\nbr label %45\n\n31:\n%32 = load i8, ptr %3, align 1\n%33 = sext i8 %32 to i32\n%34 = icmp sgt i32 %33, 57\nbr i1 %34, label %35, label %36\n\n35:\nstore i32 0, ptr %2, align 4\nbr label %45\n\n36:\n%37 = load i8, ptr %3, align 1\n%38 = sext i8 %37 to i32\n%39 = icmp sge i32 %38, 46\nbr i1 %39, label %40, label %44\n\n40:\n%41 = load i8, ptr %3, align 1\n%42 = sext i8 %41 to i32\n%43 = sub nsw i32 %42, 46\nstore i32 %43, ptr %2, align 4\nbr label %45\n\n44:\nstore i32 0, ptr %2, align 4\nbr label %45\n\n45:\n%46 = load i32, ptr %2, align 4\nret i32 %46\n}": {"base_truth": "define internal i32 @ascii_to_bin(i8 noundef signext %0) {\nB:\n%1 = sext i8 %0 to i32\n%2 = icmp sgt i8 %0, 122\nbr i1 %2, label %B7, label %B1\n\nB1:\n%3 = icmp sgt i8 %0, 96\nbr i1 %3, label %B2, label %B3\n\nB2:\n%4 = add nsw i32 %1, -59\nbr label %B7\n\nB3:\n%5 = icmp sgt i8 %0, 90\nbr i1 %5, label %B7, label %B4\n\nB4:\n%6 = icmp sgt i8 %0, 64\nbr i1 %6, label %B5, label %B6\n\nB5:\n%7 = add nsw i32 %1, -53\nbr label %B7\n\nB6:\n%8 = add i8 %0, -46\n%9 = icmp ult i8 %8, 12\n%10 = add nsw i32 %1, -46\n%11 = select i1 %9, i32 %10, i32 0\nbr label %B7\n\nB7:\n%12 = phi i32 [ %4, %B2 ], [ %7, %B5 ], [ 0, %B ], [ 0, %B3 ], [ %11, %B6 ]\nret i32 %12\n}", "codellama": "define internal i32 @ascii_to_bin(i8 noundef signext %0) {\nB:\n%1 = icmp sgt i8 %0, 122\nbr i1 %1, label %B6, label %B1\n\nB1:\n%2 = icmp sgt i8 %0, 96\nbr i1 %2, label %B2, label %B3\n\nB2:\n%3 = add nsw i8 %0, -97\n%4 = add nsw i8 %3, 38\n%5 = zext i8 %4 to i32\nbr label %B6\n\nB3:\n%6 = icmp sgt i8 %0, 91\nbr i1 %6, label %B6, label %B4\n\nB4:\n%7 = icmp sgt i8 %0, 64\nbr i1 %7, label %B5, label %B6\n\nB5:\n%8 = add nsw i8 %0, -65\n%9 = add nsw i8 %8, 12\n%10 = zext i8 %9 to i32\nbr label %B6\n\nB6:\n%11 = phi i32 [ %5, %B2 ], [ %10, %B5 ], [ 0, %B ], [ 0, %B3 ], [ 0, %B4 ]\nret i32 %11\n}", "codegemma": "define internal i32 @ascii_to_bin(i8 noundef signext %0) {\nB:\n%1 = icmp sgt i8 %0, 122\nbr i1 %1, label %B5, label %B1\n\nB1:\n%2 = icmp sgt i8 %0, 97\nbr i1 %2, label %B2, label %B3\n\nB2:\n%3 = add nsw i8 %0, -97\n%4 = add nsw i8 %3, 38\nbr label %B5\n\nB3:\n%5 = icmp sgt i8 %0, 90\nbr i1 %5, label %B5, label %B4\n\nB4:\n%6 = icmp sgt i8 %0, 57\n%7 = icmp sgt i8 %0, 46\n%8 = add nsw i8 %0, -46\n%9 = select i1 %7, i32 0, i32 %8\n%10 = add nsw i8 %0, -65\n%11 = icmp sgt i8 %10, -23\n%12 = select i1 %11, i32 %9, i32 0\nbr label %B5\n\nB5:\n%13 = phi i32 [ %4, %B2 ], [ 0, %B ], [ 0, %B3 ], [ %12, %B4 ]\nret i32 %13\n}"}, "define dso_local void @app_main() {\n%1 = call i32 @printf(ptr noundef @.str)\n%2 = call i32 (...) @example_print_chip_info()\n%3 = call i32 (...) @example_print_flash_encryption_status()\n%4 = call i32 (...) @example_read_write_flash()\nret void\n}": {"base_truth": "define dso_local void @app_main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 (...) @example_print_chip_info()\n%2 = tail call i32 (...) @example_print_flash_encryption_status()\n%3 = tail call i32 (...) @example_read_write_flash()\nret void\n}", "codellama": "define dso_local void @app_main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 (...) @example_print_chip_info()\n%2 = tail call i32 (...) @example_print_flash_encryption_status()\n%3 = tail call i32 (...) @example_read_write_flash()\nret void\n}", "codegemma": "define dso_local void @app_main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 (...) @example_print_chip_info()\n%2 = tail call i32 (...) @example_print_flash_encryption_status()\n%3 = tail call i32 (...) @example_read_write_flash()\nret void\n}"}, "define dso_local i32 @saveoutput() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load i64, ptr @Nnodes, align 8\n%7 = load i64, ptr @Nlinks, align 8\n%8 = icmp sge i64 %6, %7\nbr i1 %8, label %9, label %11\n\n9:\n%10 = load i64, ptr @Nnodes, align 8\nbr label %13\n\n11:\n%12 = load i64, ptr @Nlinks, align 8\nbr label %13\n\n13:\n%14 = phi i64 [ %10, %9 ], [ %12, %11 ]\n%15 = add nsw i64 %14, 1\n%16 = call i64 @calloc(i64 noundef %15, i32 noundef 4)\n%17 = inttoptr i64 %16 to ptr\nstore ptr %17, ptr %4, align 8\n%18 = load ptr, ptr %4, align 8\n%19 = icmp eq ptr %18, null\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 101, ptr %1, align 4\nstore i32 1, ptr %5, align 4\nbr label %73\n\n21:\n%22 = load i32, ptr @DEMAND, align 4\nstore i32 %22, ptr %2, align 4\nbr label %23\n\n23:\n%24 = load i32, ptr %2, align 4\n%25 = load i32, ptr @QUALITY, align 4\n%26 = icmp sle i32 %24, %25\nbr i1 %26, label %27, label %46\n\n27:\n%28 = load i32, ptr %3, align 4\n%29 = icmp sgt i32 %28, 100\nbr i1 %29, label %30, label %32\n\n30:\n%31 = load i32, ptr %3, align 4\nbr label %41\n\n32:\n%33 = load i32, ptr %2, align 4\n%34 = load ptr, ptr %4, align 8\n%35 = load ptr, ptr @Ucf, align 8\n%36 = load i32, ptr %2, align 4\n%37 = sext i32 %36 to i64\n%38 = getelementptr inbounds i32, ptr %35, i64 %37\n%39 = load i32, ptr %38, align 4\n%40 = call i32 @nodeoutput(i32 noundef %33, ptr noundef %34, i32 noundef %39)\nbr label %41\n\n41:\n%42 = phi i32 [ %31, %30 ], [ %40, %32 ]\nstore i32 %42, ptr %3, align 4\nbr label %43\n\n43:\n%44 = load i32, ptr %2, align 4\n%45 = add nsw i32 %44, 1\nstore i32 %45, ptr %2, align 4\nbr label %23\n\n46:\n%47 = load i32, ptr @FLOW, align 4\nstore i32 %47, ptr %2, align 4\nbr label %48\n\n48:\n%49 = load i32, ptr %2, align 4\n%50 = load i32, ptr @FRICTION, align 4\n%51 = icmp sle i32 %49, %50\nbr i1 %51, label %52, label %71\n\n52:\n%53 = load i32, ptr %3, align 4\n%54 = icmp sgt i32 %53, 100\nbr i1 %54, label %55, label %57\n\n55:\n%56 = load i32, ptr %3, align 4\nbr label %66\n\n57:\n%58 = load i32, ptr %2, align 4\n%59 = load ptr, ptr %4, align 8\n%60 = load ptr, ptr @Ucf, align 8\n%61 = load i32, ptr %2, align 4\n%62 = sext i32 %61 to i64\n%63 = getelementptr inbounds i32, ptr %60, i64 %62\n%64 = load i32, ptr %63, align 4\n%65 = call i32 @linkoutput(i32 noundef %58, ptr noundef %59, i32 noundef %64)\nbr label %66\n\n66:\n%67 = phi i32 [ %56, %55 ], [ %65, %57 ]\nstore i32 %67, ptr %3, align 4\nbr label %68\n\n68:\n%69 = load i32, ptr %2, align 4\n%70 = add nsw i32 %69, 1\nstore i32 %70, ptr %2, align 4\nbr label %48\n\n71:\n%72 = load i32, ptr %3, align 4\nstore i32 %72, ptr %1, align 4\nstore i32 1, ptr %5, align 4\nbr label %73\n\n73:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%74 = load i32, ptr %1, align 4\nret i32 %74\n}": {"base_truth": "define dso_local i32 @saveoutput() {\nB:\n%0 = load i64, ptr @Nnodes, align 8\n%1 = load i64, ptr @Nlinks, align 8\n%2 = tail call i64 @llvm.smax.i64(i64 %0, i64 %1)\n%3 = add nsw i64 %2, 1\n%4 = tail call i64 @calloc(i64 noundef %3, i32 noundef 4)\n%5 = inttoptr i64 %4 to ptr\n%6 = icmp eq i64 %4, 0\nbr i1 %6, label %B11, label %B1\n\nB1:\n%7 = load i32, ptr @DEMAND, align 4\n%8 = load i32, ptr @QUALITY, align 4\n%9 = icmp sgt i32 %7, %8\nbr i1 %9, label %B6, label %B2\n\nB2:\n%10 = sext i32 %7 to i64\nbr label %B3\n\nB3:\n%11 = phi i32 [ %8, %B2 ], [ %21, %B5 ]\n%12 = phi i64 [ %10, %B2 ], [ %23, %B5 ]\n%13 = phi i32 [ 0, %B2 ], [ %22, %B5 ]\n%14 = icmp sgt i32 %13, 100\nbr i1 %14, label %B5, label %B4\n\nB4:\n%15 = load ptr, ptr @Ucf, align 8\n%16 = getelementptr inbounds i32, ptr %15, i64 %12\n%17 = load i32, ptr %16, align 4\n%18 = trunc i64 %12 to i32\n%19 = tail call i32 @nodeoutput(i32 noundef %18, ptr noundef nonnull %5, i32 noundef %17)\n%20 = load i32, ptr @QUALITY, align 4\nbr label %B5\n\nB5:\n%21 = phi i32 [ %20, %B4 ], [ %11, %B3 ]\n%22 = phi i32 [ %19, %B4 ], [ %13, %B3 ]\n%23 = add nsw i64 %12, 1\n%24 = sext i32 %21 to i64\n%25 = icmp slt i64 %12, %24\nbr i1 %25, label %B3, label %B6\n\nB6:\n%26 = phi i32 [ 0, %B1 ], [ %22, %B5 ]\n%27 = load i32, ptr @FLOW, align 4\n%28 = load i32, ptr @FRICTION, align 4\n%29 = icmp sgt i32 %27, %28\nbr i1 %29, label %B11, label %B7\n\nB7:\n%30 = sext i32 %27 to i64\nbr label %B8\n\nB8:\n%31 = phi i32 [ %28, %B7 ], [ %41, %B10 ]\n%32 = phi i64 [ %30, %B7 ], [ %43, %B10 ]\n%33 = phi i32 [ %26, %B7 ], [ %42, %B10 ]\n%34 = icmp sgt i32 %33, 100\nbr i1 %34, label %B10, label %B9\n\nB9:\n%35 = load ptr, ptr @Ucf, align 8\n%36 = getelementptr inbounds i32, ptr %35, i64 %32\n%37 = load i32, ptr %36, align 4\n%38 = trunc i64 %32 to i32\n%39 = tail call i32 @linkoutput(i32 noundef %38, ptr noundef nonnull %5, i32 noundef %37)\n%40 = load i32, ptr @FRICTION, align 4\nbr label %B10\n\nB10:\n%41 = phi i32 [ %40, %B9 ], [ %31, %B8 ]\n%42 = phi i32 [ %39, %B9 ], [ %33, %B8 ]\n%43 = add nsw i64 %32, 1\n%44 = sext i32 %41 to i64\n%45 = icmp slt i64 %32, %44\nbr i1 %45, label %B8, label %B11\n\nB11:\n%46 = phi i32 [ 101, %B ], [ %26, %B6 ], [ %42, %B10 ]\nret i32 %46\n}", "codellama": "define dso_local i32 @saveoutput() {\nB:\n%0 = load i64, ptr @Nnodes, align 8\n%1 = load i64, ptr @Nlinks, align 8\n%2 = tail call i64 @llvm.smax.i64(i64 %0, i64 %1)\n%3 = add nsw i64 %2, 1\n%4 = tail call i64 @calloc(i64 noundef %3, i32 noundef 4)\n%5 = inttoptr i64 %4 to ptr\n%6 = icmp eq i64 %4, 0\nbr i1 %6, label %B10, label %B1\n\nB1:\n%7 = load i32, ptr @DEMAND, align 4\n%8 = load i32, ptr @QUALITY, align 4\n%9 = icmp sgt i32 %7, %8\nbr i1 %9, label %B4, label %B2\n\nB2:\n%10 = phi i32 [ %19, %B3 ], [ %7, %B1 ]\n%11 = phi i32 [ %18, %B3 ], [ 0, %B1 ]\n%12 = icmp sgt i32 %11, 100\nbr i1 %12, label %B3, label %B5\n\nB3:\n%13 = tail call i32 @nodeoutput(i32 noundef %10, ptr noundef nonnull %5, i32 noundef 0)\nbr label %B4\n\nB4:\n%14 = phi i32 [ %13, %B3 ], [ 0, %B1 ]\n%15 = load i32, ptr @FLOW, align 4\n%16 = load i32, ptr @FRICTION, align 4\n%17 = icmp sgt i32 %15, %16\nbr i1 %17, label %B10, label %B6\n\nB5:\n%18 = add nuw nsw i32 %11, 1\n%19 = add nsw i32 %10, 1\n%20 = load i32, ptr @QUALITY, align 4\n%21 = icmp slt i32 %10, %20\nbr i1 %21, label %B2, label %B4\n\nB6:\n%22 = phi i32 [ %31, %B9 ], [ %15, %B4 ]\n%23 = phi i32 [ %30, %B9 ], [ %14, %B4 ]\n%24 = icmp sgt i32 %23, 100\nbr i1 %24, label %B8, label %B7\n\nB7:\n%25 = load ptr, ptr @Ucf, align 8\n%26 = sext i32 %22 to i64\n%27 = getelementptr inbounds i32, ptr %25, i64 %26\n%28 = load i32, ptr %27, align 4\n%29 = tail call i32 @nodeoutput(i32 noundef %23</s>", "codegemma": "define dso_local i32 @saveoutput() {\nB:\n%0 = load i64, ptr @Nnodes, align 8\n%1 = load i64, ptr @Nlinks, align 8\n%2 = tail call i64 @llvm.smin.i64(i64 %0, i64 %1)\n%3 = add nsw i64 %2, 1\n%4 = tail call i64 @calloc(i64 noundef %3, i32 noundef 4)\n%5 = inttoptr i64 %4 to ptr\n%6 = icmp eq i64 %4, 0\nbr i1 %6, label %B10, label %B1\n\nB1:\n%7 = load i32, ptr @DEMAND, align 4\n%8 = load i32, ptr @QUALITY, align 4\n%9 = icmp sgt i32 %7, %8\nbr i1 %9, label %B10, label %B2\n\nB2:\n%10 = phi i32 [ %15, %B3 ], [ %7, %B1 ]\n%11 = phi i32 [ %14, %B3 ], [ 0, %B1 ]\n%12 = icmp sgt i32 %11, 100\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = load ptr, ptr @Ucf, align 8\n%14 = sext i32 %10 to i64\n%15 = getelementptr inbounds i32, ptr %13, i64 %14\n%16 = load i32, ptr %15, align 4\n%17 = tail call i32 @nodeoutput(i32 noundef %10, ptr noundef nonnull %5, i32 noundef %16)\nbr label %B2\n\nB4:\n%18 = load i32, ptr @FLOW, align 4\n%19 = icmp sgt i32 %18, %8\nbr i1 %19, label %B10, label %B5\n\nB5:\n%20 = phi i32 [ %25, %B7 ], [ %18, %B4 ]\n%21 = phi i32 [ %24, %B7 ], [ 0, %B4 ]\n%22 = icmp sgt i32 %21, 100\nbr i1 %22, label %B7, label %B6\n\nB6:\n%23 = load ptr, ptr @Ucf, align 8\n%24 = sext i32 %20 to i64\n%25 = getelementptr inbounds i32, ptr %23, i64 %24\n%26 = load i32, ptr %25, align 4\n%27 = tail call i32 @linkoutput(i32 noundef %20, ptr noundef nonnull %5, i32 noundef %26)\nbr label %B7\n\nB7:\n%28 = add nsw i32 %20, 1\n%29 = icmp slt i32 %20, %8\nbr i1 %29, label %B5, label %B8\n\nB8:\n%30 = icmp sgt i32 %21, 100\nbr i1 %30, label %B10, label %B9\n\nB9:\n%31 = load ptr, ptr @Ucf, align 8\n%32 = sext i32<eos>"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 999, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nbr label %6\n\n6:\n%7 = load i32, ptr %2, align 4\n%8 = icmp sgt i32 %7, 99\nbr i1 %8, label %9, label %33\n\n9:\nstore i32 999, ptr %3, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %3, align 4\n%12 = load i32, ptr %2, align 4\n%13 = icmp sge i32 %11, %12\nbr i1 %13, label %14, label %30\n\n14:\n%15 = load i32, ptr %3, align 4\n%16 = load i32, ptr %2, align 4\n%17 = mul nsw i32 %15, %16\nstore i32 %17, ptr %5, align 4\n%18 = load i32, ptr %5, align 4\n%19 = load i32, ptr %4, align 4\n%20 = icmp sgt i32 %18, %19\nbr i1 %20, label %21, label %27\n\n21:\n%22 = load i32, ptr %5, align 4\n%23 = call i64 @isPalindrome(i32 noundef %22)\n%24 = icmp ne i64 %23, 0\nbr i1 %24, label %25, label %27\n\n25:\n%26 = load i32, ptr %5, align 4\nstore i32 %26, ptr %4, align 4\nbr label %27\n\n27:\n%28 = load i32, ptr %3, align 4\n%29 = add nsw i32 %28, -1\nstore i32 %29, ptr %3, align 4\nbr label %10\n\n30:\n%31 = load i32, ptr %2, align 4\n%32 = add nsw i32 %31, -1\nstore i32 %32, ptr %2, align 4\nbr label %6\n\n33:\n%34 = load i32, ptr %4, align 4\n%35 = call i32 @printf(ptr noundef @.str, i32 noundef %34)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 999, %B ], [ %12, %B5 ]\n%1 = phi i32 [ 0, %B ], [ %9, %B5 ]\nbr label %B2\n\nB2:\n%2 = phi i32 [ %9, %B4 ], [ %1, %B1 ]\n%3 = phi i32 [ %10, %B4 ], [ 999, %B1 ]\n%4 = mul nuw nsw i32 %3, %0\n%5 = icmp sgt i32 %4, %2\nbr i1 %5, label %B3, label %B4\n\nB3:\n%6 = tail call i64 @isPalindrome(i32 noundef %4)\n%7 = icmp eq i64 %6, 0\n%8 = select i1 %7, i32 %2, i32 %4\nbr label %B4\n\nB4:\n%9 = phi i32 [ %2, %B2 ], [ %8, %B3 ]\n%10 = add nsw i32 %3, -1\n%11 = icmp ugt i32 %3, %0\nbr i1 %11, label %B2, label %B5\n\nB5:\n%12 = add nsw i32 %0, -1\n%13 = icmp ugt i32 %0, 100\nbr i1 %13, label %B1, label %B6\n\nB6:\n%14 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %9)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 999, %B ], [ %10, %B4 ]\n%1 = phi i32 [ 0, %B ], [ %9, %B4 ]\nbr label %B2\n\nB2:\n%2 = phi i32 [ %0, %B1 ], [ %7, %B3 ]\n%3 = phi i32 [ %1, %B1 ], [ %8, %B3 ]\n%4 = mul nsw i32 %2, %2\n%5 = icmp sgt i32 %4, %3\nbr i1 %5, label %B3, label %B4\n\nB3:\n%6 = tail call i64 @isPalindrome(i32 noundef %4)\n%7 = select i64 %6, i32 %4, i32 %2\n%8 = tail call i32 @llvm.smax.i32(i32 %7, i32 %3)\n%9 = add nsw i32 %2, -1\n%10 = add nsw i32 %0, -1\n%11 = icmp ugt i32 %0, 100\nbr i1 %11, label %B1, label %B4\n\nB4:\n%12 = phi i32 [ %3, %B2 ], [ %8, %B3 ]\n%13 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %12)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 999, %B ], [ %1, %B3 ]\n%1 = add nsw i32 %0, -1\n%2 = icmp sgt i32 %1, 99\nbr i1 %2, label %B2, label %B3\n\nB2:\n%3 = phi i32 [ %6, %B2 ], [ 999, %B1 ]\n%4 = phi i32 [ %5, %B2 ], [ 0, %B1 ]\n%5 = mul nsw i32 %3, %0\n%6 = tail call i64 @isPalindrome(i32 noundef %5)\n%7 = icmp ne i64 %6, 0\n%8 = select i1 %7, i32 %5, i32 %4\n%9 = icmp sgt i32 %8, %4\nbr i1 %9, label %B2, label %B3\n\nB3:\n%10 = phi i32 [ 0, %B1 ], [ %8, %B2 ]\n%11 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %10)\nret i32 0\n}"}, "define dso_local void @drm_fb_helper_unregister_fbi(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %5, label %15\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.drm_fb_helper ptr %6, i32 0, i32 0\n%8 = load i64, ptr %7, align 8\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %15\n\n10:\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds %struct.drm_fb_helper ptr %11, i32 0, i32 0\n%13 = load i64, ptr %12, align 8\n%14 = call i32 @unregister_framebuffer(i64 noundef %13)\nbr label %15\n\n15:\nret void\n}": {"base_truth": "define dso_local void @drm_fb_helper_unregister_fbi(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = tail call i32 @unregister_framebuffer(i64 noundef %2)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @drm_fb_helper_unregister_fbi(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = tail call i32 @unregister_framebuffer(i64 noundef %2)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @drm_fb_helper_unregister_fbi(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = tail call i32 @unregister_framebuffer(i64 noundef %2)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local i32 @asymmetric_key_id_same(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %8, label %11\n\n8:\n%9 = load ptr, ptr %5, align 8\n%10 = icmp ne ptr %9, null\nbr i1 %10, label %12, label %11\n\n11:\nstore i32 0, ptr %3, align 4\nbr label %34\n\n12:\n%13 = load ptr, ptr %4, align 8\n%14 = getelementptr inbounds %struct.asymmetric_key_id ptr %13, i32 0, i32 0\n%15 = load i64, ptr %14, align 8\n%16 = load ptr, ptr %5, align 8\n%17 = getelementptr inbounds %struct.asymmetric_key_id ptr %16, i32 0, i32 0\n%18 = load i64, ptr %17, align 8\n%19 = icmp ne i64 %15, %18\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 0, ptr %3, align 4\nbr label %34\n\n21:\n%22 = load ptr, ptr %4, align 8\n%23 = getelementptr inbounds %struct.asymmetric_key_id ptr %22, i32 0, i32 1\n%24 = load i32, ptr %23, align 8\n%25 = load ptr, ptr %5, align 8\n%26 = getelementptr inbounds %struct.asymmetric_key_id ptr %25, i32 0, i32 1\n%27 = load i32, ptr %26, align 8\n%28 = load ptr, ptr %4, align 8\n%29 = getelementptr inbounds %struct.asymmetric_key_id ptr %28, i32 0, i32 0\n%30 = load i64, ptr %29, align 8\n%31 = call i64 @memcmp(i32 noundef %24, i32 noundef %27, i64 noundef %30)\n%32 = icmp eq i64 %31, 0\n%33 = zext i1 %32 to i32\nstore i32 %33, ptr %3, align 4\nbr label %34\n\n34:\n%35 = load i32, ptr %3, align 4\nret i32 %35\n}": {"base_truth": "define dso_local i32 @asymmetric_key_id_same(ptr noundef readonly %0, ptr noundef readonly %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i64, ptr %0, align 8\n%6 = load i64, ptr %1, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B2, label %B3\n\nB2:\n%8 = getelementptr inbounds %struct.asymmetric_key_id, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 8\n%10 = getelementptr inbounds %struct.asymmetric_key_id, ptr %1, i64 0, i32 1\n%11 = load i32, ptr %10, align 8\n%12 = tail call i64 @memcmp(i32 noundef %9, i32 noundef %11, i64 noundef %5)\n%13 = icmp eq i64 %12, 0\n%14 = zext i1 %13 to i32\nbr label %B3\n\nB3:\n%15 = phi i32 [ %14, %B2 ], [ 0, %B ], [ 0, %B1 ]\nret i32 %15\n}", "codellama": "define dso_local i32 @asymmetric_key_id_same(ptr noundef readonly %0, ptr noundef readonly %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i64, ptr %0, align 8\n%6 = load i64, ptr %1, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B2, label %B3\n\nB2:\n%8 = getelementptr inbounds %struct.asymmetric_key_id, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 8\n%10 = getelementptr inbounds %struct.asymmetric_key_id, ptr %1, i64 0, i32 1\n%11 = load i32, ptr %10, align 8\n%12 = tail call i64 @memcmp(i32 noundef %9, i32 noundef %11, i64 noundef %5)\n%13 = icmp eq i64 %12, 0\n%14 = zext i1 %13 to i32\nbr label %B3\n\nB3:\n%15 = phi i32 [ %14, %B2 ], [ 0, %B ], [ 0, %B1 ]\nret i32 %15\n}", "codegemma": "define dso_local i32 @asymmetric_key_id_same(ptr noundef readonly %0, ptr noundef readonly %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i64, ptr %0, align 8\n%6 = load i64, ptr %1, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B2, label %B3\n\nB2:\n%8 = getelementptr inbounds %struct.asymmetric_key_id, ptr %1, i64 0, i32 1\n%9 = getelementptr inbounds %struct.asymmetric_key_id, ptr %0, i64 0, i32 1\n%10 = load i32, ptr %9, align 8\n%11 = load i32, ptr %8, align 8\n%12 = tail call i64 @memcmp(i32 noundef %10, i32 noundef %11, i64 noundef %5)\n%13 = icmp eq i64 %12, 0\n%14 = zext i1 %13 to i32\nbr label %B3\n\nB3:\n%15 = phi i32 [ %14, %B2 ], [ 0, %B ], [ 0, %B1 ]\nret i32 %15\n}"}, "define dso_local void @led_off(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %34 [\ni32 0, label %4\ni32 1, label %14\ni32 2, label %24\n]\n\n4:\n%5 = load ptr, ptr @led_config, align 8\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %5, i64 0\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i32 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr @led_config, align 8\n%10 = getelementptr inbounds %struct.TYPE_2__, ptr %9, i64 0\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = call i32 @digitalHi(i32 noundef %8, i32 noundef %12)\nbr label %34\n\n14:\n%15 = load ptr, ptr @led_config, align 8\n%16 = getelementptr inbounds %struct.TYPE_2__, ptr %15, i64 1\n%17 = getelementptr inbounds %struct.TYPE_2__, ptr %16, i32 0, i32 1\n%18 = load i32, ptr %17, align 4\n%19 = load ptr, ptr @led_config, align 8\n%20 = getelementptr inbounds %struct.TYPE_2__, ptr %19, i64 1\n%21 = getelementptr inbounds %struct.TYPE_2__, ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = call i32 @digitalHi(i32 noundef %18, i32 noundef %22)\nbr label %34\n\n24:\n%25 = load ptr, ptr @led_config, align 8\n%26 = getelementptr inbounds %struct.TYPE_2__, ptr %25, i64 2\n%27 = getelementptr inbounds %struct.TYPE_2__, ptr %26, i32 0, i32 1\n%28 = load i32, ptr %27, align 4\n%29 = load ptr, ptr @led_config, align 8\n%30 = getelementptr inbounds %struct.TYPE_2__, ptr %29, i64 2\n%31 = getelementptr inbounds %struct.TYPE_2__, ptr %30, i32 0, i32 0\n%32 = load i32, ptr %31, align 4\n%33 = call i32 @digitalHi(i32 noundef %28, i32 noundef %32)\nbr label %34\n\n34:\nret void\n}": {"base_truth": "define dso_local void @led_off(i32 noundef %0) {\nB:\nswitch i32 %0, label %B5 [\ni32 0, label %B1\ni32 1, label %B2\ni32 2, label %B3\n]\n\nB1:\n%1 = load ptr, ptr @led_config, align 8\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %1, i64 0, i32 1\nbr label %B4\n\nB2:\n%3 = load ptr, ptr @led_config, align 8\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 1\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 1, i32 1\nbr label %B4\n\nB3:\n%6 = load ptr, ptr @led_config, align 8\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i64 2\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i64 2, i32 1\nbr label %B4\n\nB4:\n%9 = phi ptr [ %8, %B3 ], [ %5, %B2 ], [ %2, %B1 ]\n%10 = phi ptr [ %7, %B3 ], [ %4, %B2 ], [ %1, %B1 ]\n%11 = load i32, ptr %9, align 4\n%12 = load i32, ptr %10, align 4\n%13 = tail call i32 @digitalHi(i32 noundef %11, i32 noundef %12)\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define dso_local void @led_off(i32 noundef %0) {\nB:\nswitch i32 %0, label %B4 [\ni32 0, label %B1\ni32 1, label %B2\ni32 2, label %B3\n]\n\nB1:\n%1 = load ptr, ptr @led_config, align 8\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %1, i64 0\n%3 = getelementptr inbounds %struct.TYPE_2__, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @digitalHi(i32 noundef %4, i32 noundef %5)\nbr label %B4\n\nB2:\n%7 = load ptr, ptr @led_config, align 8\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %7, i64 1\n%9 = getelementptr inbounds %struct.TYPE_2__, ptr %7, i64 1, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %7, i64 1\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @digitalHi(i32 noundef %10, i32 noundef %12)\nbr label %B4\n\nB3:\n%14 = load ptr, ptr @led_config, align 8\n%15 = getelementptr inbounds %struct.TYPE_2__, ptr %14, i64 2\n%16 = getelementptr inbounds %struct.TYPE_2__, ptr %14, i64 2, i32 1\n%17 = load i32, ptr %16, align 4\n%18 = getelementptr inbounds %struct.TYPE_2__, ptr %14, i64 2\n%19 = load i32, ptr %18, align 4\n%20 = tail call i32 @digitalHi(i32 noundef %17, i32 noundef %19)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @led_off(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 2\n%2 = icmp eq i32 %0, 1\n%3 = load ptr, ptr @led_config, align 8\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 1\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 2\n%6 = select i1 %1, ptr %5, ptr %4\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = load i32, ptr %6, align 4\n%10 = tail call i32 @digitalHi(i32 noundef %8, i32 noundef %9)\nret void\n}"}, "define dso_local ptr @mpd_getNextHandler(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call ptr @mpd_getNextReturnElementNamed(ptr noundef %3, ptr noundef @.str)\nret ptr %4\n}": {"base_truth": "define dso_local ptr @mpd_getNextHandler(ptr noundef %0) {\nB:\n%1 = tail call ptr @mpd_getNextReturnElementNamed(ptr noundef %0, ptr noundef nonnull @.str)\nret ptr %1\n}", "codellama": "define dso_local ptr @mpd_getNextHandler(ptr noundef %0) {\nB:\n%1 = tail call ptr @mpd_getNextReturnElementNamed(ptr noundef %0, ptr noundef nonnull @.str)\nret ptr %1\n}", "codegemma": "define dso_local ptr @mpd_getNextHandler(ptr noundef %0) {\nB:\n%1 = tail call ptr @mpd_getNextReturnElementNamed(ptr noundef %0, ptr noundef nonnull @.str)\nret ptr %1\n}"}, "define dso_local void @ADC_Start() {\n%1 = load i32, ptr @ADC_initVar, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %3, label %9\n\n3:\n%4 = load i32, ptr @ADC_started, align 4\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %6, label %8\n\n6:\n%7 = call i32 (...) @ADC_Init()\nbr label %8\n\n8:\nstore i32 1, ptr @ADC_initVar, align 4\nbr label %9\n\n9:\n%10 = call i32 (...) @ADC_Enable()\nret void\n}": {"base_truth": "define dso_local void @ADC_Start() {\nB:\n%0 = load i32, ptr @ADC_initVar, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B4\n\nB1:\n%2 = load i32, ptr @ADC_started, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B2, label %B3\n\nB2:\n%4 = tail call i32 (...) @ADC_Init()\nbr label %B3\n\nB3:\nstore i32 1, ptr @ADC_initVar, align 4\nbr label %B4\n\nB4:\n%5 = tail call i32 (...) @ADC_Enable()\nret void\n}", "codellama": "define dso_local void @ADC_Start() {\nB:\n%0 = load i32, ptr @ADC_initVar, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B4\n\nB1:\n%2 = load i32, ptr @ADC_started, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B2, label %B3\n\nB2:\n%4 = tail call i32 (...) @ADC_Init()\nbr label %B3\n\nB3:\nstore i32 1, ptr @ADC_initVar, align 4\nbr label %B4\n\nB4:\n%5 = tail call i32 (...) @ADC_Enable()\nret void\n}", "codegemma": "define dso_local void @ADC_Start() {\nB:\n%0 = load i32, ptr @ADC_initVar, align 4\n%1 = icmp eq i32 %0, 0\n%2 = load i32, ptr @ADC_started, align 4\n%3 = icmp eq i32 %2, 0\n%4 = select i1 %1, i1 %3, i1 false\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 (...) @ADC_Init()\nbr label %B2\n\nB2:\nstore i32 1, ptr @ADC_initVar, align 4\nbr label %B3\n\nB3:\n%6 = tail call i32 (...) @ADC_Enable()\nret void\n}"}, "define internal ptr @dump_boolean(i32 noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\nswitch i32 %4, label %11 [\ni32 131, label %5\ni32 130, label %7\ni32 129, label %9\ni32 128, label %10\n]\n\n5:\n%6 = load ptr, ptr @s_absent, align 8\nstore ptr %6, ptr %2, align 8\nbr label %12\n\n7:\n%8 = load ptr, ptr @s_cancel, align 8\nstore ptr %8, ptr %2, align 8\nbr label %12\n\n9:\nstore ptr @.str, ptr %2, align 8\nbr label %12\n\n10:\nstore ptr @.str.1, ptr %2, align 8\nbr label %12\n\n11:\nstore ptr @.str.2, ptr %2, align 8\nbr label %12\n\n12:\n%13 = load ptr, ptr %2, align 8\nret ptr %13\n}": {"base_truth": "define internal ptr @dump_boolean(i32 noundef %0) {\nB:\nswitch i32 %0, label %B4 [\ni32 131, label %B1\ni32 130, label %B2\ni32 129, label %B5\ni32 128, label %B3\n]\n\nB1:\n%1 = load ptr, ptr @s_absent, align 8\nbr label %B5\n\nB2:\n%2 = load ptr, ptr @s_cancel, align 8\nbr label %B5\n\nB3:\nbr label %B5\n\nB4:\nbr label %B5\n\nB5:\n%3 = phi ptr [ @.str.2, %B4 ], [ @.str.1, %B3 ], [ %2, %B2 ], [ %1, %B1 ], [ @.str, %B ]\nret ptr %3\n}", "codellama": "define internal nonnull ptr @dump_boolean(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 4\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [4 x ptr], ptr @switch.table.dump_boolean, i64 0, i64 %3\n%5 = load ptr, ptr %4, align 8\nbr label %B2\n\nB2:\n%6 = phi ptr [ %5, %B1 ], [ @.str.2, %B ]\nret ptr %6\n}", "codegemma": "define internal ptr @dump_boolean(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 4\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [4 x ptr], ptr @switch.table.dump_boolean, i64 0, i64 %3\n%5 = load ptr, ptr %4, align 8\nbr label %B2\n\nB2:\n%6 = phi ptr [ %5, %B1 ], [ @.str.2, %B ]\nret ptr %6\n}"}, "define internal void @usb_exchange(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\nbr label %5\n\n5:\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.usb_action ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %10, label %68\n\n10:\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.usb_action ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\nswitch i32 %13, label %57 [\ni32 160, label %14\ni32 161, label %23\ni32 170, label %29\ni32 187, label %43\n]\n\n14:\n%15 = load ptr, ptr %3, align 8\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.usb_action ptr %16, i32 0, i32 1\n%18 = load i32, ptr %17, align 4\n%19 = load ptr, ptr %4, align 8\n%20 = getelementptr inbounds %struct.usb_action ptr %19, i32 0, i32 2\n%21 = load i32, ptr %20, align 4\n%22 = call i32 @reg_w(ptr noundef %15, i32 noundef %18, i32 noundef %21)\nbr label %64\n\n23:\n%24 = load ptr, ptr %3, align 8\n%25 = load ptr, ptr %4, align 8\n%26 = getelementptr inbounds %struct.usb_action ptr %25, i32 0, i32 2\n%27 = load i32, ptr %26, align 4\n%28 = call i32 @reg_r(ptr noundef %24, i32 noundef %27)\nbr label %64\n\n29:\n%30 = load ptr, ptr %3, align 8\n%31 = load ptr, ptr %4, align 8\n%32 = getelementptr inbounds %struct.usb_action ptr %31, i32 0, i32 1\n%33 = load i32, ptr %32, align 4\n%34 = load ptr, ptr %4, align 8\n%35 = getelementptr inbounds %struct.usb_action ptr %34, i32 0, i32 2\n%36 = load i32, ptr %35, align 4\n%37 = and i32 %36, 255\n%38 = load ptr, ptr %4, align 8\n%39 = getelementptr inbounds %struct.usb_action ptr %38, i32 0, i32 2\n%40 = load i32, ptr %39, align 4\n%41 = ashr i32 %40, 8\n%42 = call i32 @i2c_write(ptr noundef %30, i32 noundef %33, i32 noundef %37, i32 noundef %41)\nbr label %64\n\n43:\n%44 = load ptr, ptr %3, align 8\n%45 = load ptr, ptr %4, align 8\n%46 = getelementptr inbounds %struct.usb_action ptr %45, i32 0, i32 2\n%47 = load i32, ptr %46, align 4\n%48 = ashr i32 %47, 8\n%49 = load ptr, ptr %4, align 8\n%50 = getelementptr inbounds %struct.usb_action ptr %49, i32 0, i32 2\n%51 = load i32, ptr %50, align 4\n%52 = and i32 %51, 255\n%53 = load ptr, ptr %4, align 8\n%54 = getelementptr inbounds %struct.usb_action ptr %53, i32 0, i32 1\n%55 = load i32, ptr %54, align 4\n%56 = call i32 @i2c_write(ptr noundef %44, i32 noundef %48, i32 noundef %52, i32 noundef %55)\nbr label %64\n\n57:\n%58 = load ptr, ptr %4, align 8\n%59 = getelementptr inbounds %struct.usb_action ptr %58, i32 0, i32 1\n%60 = load i32, ptr %59, align 4\n%61 = sdiv i32 %60, 64\n%62 = add nsw i32 %61, 10\n%63 = call i32 @msleep(i32 noundef %62)\nbr label %64\n\n64:\n%65 = load ptr, ptr %4, align 8\n%66 = getelementptr inbounds %struct.usb_action ptr %65, i32 1\nstore ptr %66, ptr %4, align 8\n%67 = call i32 @msleep(i32 noundef 1)\nbr label %5\n\n68:\nret void\n}": {"base_truth": "define internal void @usb_exchange(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\nbr label %B1\n\nB1:\n%2 = phi ptr [ %1, %B ], [ %31, %B7 ]\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %B6 [\ni32 0, label %B8\ni32 160, label %B2\ni32 161, label %B3\ni32 170, label %B4\ni32 187, label %B5\n]\n\nB2:\n%4 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 2\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @reg_w(ptr noundef %0, i32 noundef %5, i32 noundef %7)\nbr label %B7\n\nB3:\n%9 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @reg_r(ptr noundef %0, i32 noundef %10)\nbr label %B7\n\nB4:\n%12 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 1\n%13 = load i32, ptr %12, align 4\n%14 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 2\n%15 = load i32, ptr %14, align 4\n%16 = and i32 %15, 255\n%17 = ashr i32 %15, 8\n%18 = tail call i32 @i2c_write(ptr noundef %0, i32 noundef %13, i32 noundef %16, i32 noundef %17)\nbr label %B7\n\nB5:\n%19 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 2\n%20 = load i32, ptr %19, align 4\n%21 = ashr i32 %20, 8\n%22 = and i32 %20, 255\n%23 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 1\n%24 = load i32, ptr %23, align 4\n%25 = tail call i32 @i2c_write(ptr noundef %0, i32 noundef %21, i32 noundef %22, i32 noundef %24)\nbr label %B7\n\nB6:\n%26 = getelementptr inbounds %struct.usb_action, ptr %2, i64 0, i32 1\n%27 = load i32, ptr %26, align 4\n%28 = sdiv i32 %27, 64\n%29 = add nsw i32 %28, 10\n%30 = tail call i32 @msleep(i32 noundef %29)\nbr label %B7\n\nB7:\n%31 = getelementptr inbounds %struct.usb_action, ptr %2, i64 1\n%32 = tail call i32 @msleep(i32 noundef 1)\nbr label %B1\n\nB8:\nret void\n}", "codellama": "define internal void @usb_exchange(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B7, label %B1\n\nB1:\n%4 = phi i32 [ %21, %B6 ], [ %2, %B ]\n%5 = phi ptr [ %19, %B6 ], [ %1, %B ]\n%6 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\nswitch i32 %4, label %B5 [\ni32 160, label %B2\ni32 161, label %B3\ni32 170, label %B4\ni32 187, label %B6\n]\n\nB2:\n%8 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @reg_w(ptr noundef %0, i32 noundef %7, i32 noundef %9)\nbr label %B6\n\nB3:\n%11 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @reg_r(ptr noundef %0, i32 noundef %12)\nbr label %B6\n\nB4:\n%14 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%15 = load i32, ptr %14, align 4\n%16 = and i32 %15, 255\n%17 = lshr i32 %15, 8\n%18 = tail call i32 @i2c_write(ptr noundef %0, i32 noundef %7, i32 noundef %16, i32 noundef %17)\nbr label %B6\n\nB5:\n%19 = getelementptr inbounds %struct.usb_action, ptr %5, i64 1\n%20 = lshr i32 %7, 6\n%21 = add nuw nsw i32 %20, 10\n%22 = tail call i32 @msleep(i32 noundef %21)\nbr label %B6\n\nB6:\n%23 = phi ptr [ %5, %B5 ], [ %5, %B4 ], [ %5, %B3 ], [ %5, %B2 ], [ %19, %B1 ]\n%24 = tail call i32 @msleep(i32 noundef 1)\n%25 = load i32, ptr %23, align 4\n%26 = icmp eq i32 %25, 0\nbr i1 %26, label %B7, label %B1\n\nB7:\nret void\n}", "codegemma": "define internal void @usb_exchange(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B7, label %B1\n\nB1:\n%4 = phi i32 [ %13, %B6 ], [ %2, %B ]\n%5 = phi ptr [ %12, %B6 ], [ %1, %B ]\n%6 = switch i32 %4, label %B5 [\ni32 160, label %B2\ni32 161, label %B3\ni32 170, label %B4\ni32 187, label %B6\n]\n\nB2:\n%7 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @reg_w(ptr noundef %0, i32 noundef %8, i32 noundef %10)\nbr label %B6\n\nB3:\n%12 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%13 = load i32, ptr %12, align 4\n%14 = tail call i32 @reg_r(ptr noundef %0, i32 noundef %13)\nbr label %B6\n\nB4:\n%15 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%18 = load i32, ptr %17, align 4\n%19 = and i32 %18, 255\n%20 = ashr i32 %18, 8\n%21 = tail call i32 @i2c_write(ptr noundef %0, i32 noundef %16, i32 noundef %19, i32 noundef %20)\nbr label %B6\n\nB5:\n%22 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 2\n%23 = load i32, ptr %22, align 4\n%24 = ashr i32 %23, 8\n%25 = and i32 %23, 255\n%26 = getelementptr inbounds %struct.usb_action, ptr %5, i64 0, i32 1\n%27 = load i32, ptr %26, align 4\n%28 = tail call i32 @i2c_write(ptr noundef %0, i32 noundef %24, i32 noundef %25, i32 noundef %27)\nbr label %B6\n\nB6:\n%29 = tail call i32 @msleep(i32 noundef 1)\n%30 = getelementptr inbounds %struct.usb_action, ptr %5, i64 1\n%31 = tail call i32 @msleep(i32 noundef 1)\nbr label %B1\n\nB7:\nret void\n}"}, "define dso_local i32 @gfx_set_tv_vga_mode(i64 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\n%4 = load i64, ptr %3, align 8\nswitch i64 %4, label %5 [\ni64 131, label %6\ni64 130, label %6\ni64 129, label %6\ni64 128, label %6\ni64 132, label %7\n]\n\n5:\nstore i32 4096, ptr %2, align 4\nbr label %20\n\n6:\nbr label %12\n\n7:\n%8 = call i32 (...) @houston_Rev()\n%9 = icmp sge i32 %8, 1\nbr i1 %9, label %10, label %11\n\n10:\nbr label %12\n\n11:\nstore i32 4096, ptr %2, align 4\nbr label %20\n\n12:\n%13 = load i64, ptr %3, align 8\n%14 = load i64, ptr @d, align 8\n%15 = icmp ne i64 %13, %14\nbr i1 %15, label %16, label %19\n\n16:\n%17 = load i64, ptr %3, align 8\nstore i64 %17, ptr @d, align 8\n%18 = call i32 @write_config(i32 noundef 4164)\nstore i32 %18, ptr %2, align 4\nbr label %20\n\n19:\nstore i32 0, ptr %2, align 4\nbr label %20\n\n20:\n%21 = load i32, ptr %2, align 4\nret i32 %21\n}": {"base_truth": "define dso_local i32 @gfx_set_tv_vga_mode(i64 noundef %0) {\nB:\nswitch i64 %0, label %B4 [\ni64 131, label %B2\ni64 130, label %B2\ni64 129, label %B2\ni64 128, label %B2\ni64 132, label %B1\n]\n\nB1:\n%1 = tail call i32 (...) @houston_Rev()\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B2, label %B4\n\nB2:\n%3 = load i64, ptr @d, align 8\n%4 = icmp eq i64 %3, %0\nbr i1 %4, label %B4, label %B3\n\nB3:\nstore i64 %0, ptr @d, align 8\n%5 = tail call i32 @write_config(i32 noundef 4164)\nbr label %B4\n\nB4:\n%6 = phi i32 [ %5, %B3 ], [ 4096, %B ], [ 4096, %B1 ], [ 0, %B2 ]\nret i32 %6\n}", "codellama": "define dso_local i32 @gfx_set_tv_vga_mode(i64 noundef %0) {\nB:\nswitch i64 %0, label %B4 [\ni64 131, label %B1\ni64 130, label %B1\ni64 129, label %B1\ni64 128, label %B1\ni64 132, label %B2\n]\n\nB1:\n%1 = tail call i32 (...) @houston_Rev()\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B3, label %B4\n\nB2:\n%3 = load i64, ptr @d, align 8\n%4 = icmp eq i64 %3, %0\nbr i1 %4, label %B4, label %B3\n\nB3:\nstore i64 %0, ptr @d, align 8\n%5 = tail call i32 @write_config(i32 noundef 4164)\nbr label %B4\n\nB4:\n%6 = phi i32 [ %5, %B3 ], [ 4096, %B ], [ 4096, %B1 ], [ 0, %B2 ]\nret i32 %6\n}", "codegemma": "define dso_local i32 @gfx_set_tv_vga_mode(i64 noundef %0) {\nB:\n%1 = add i64 %0, -128\n%2 = icmp ult i64 %1, 5\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = load i64, ptr @d, align 8\n%4 = icmp eq i64 %3, %0\nbr i1 %4, label %B3, label %B2\n\nB2:\nstore i64 %0, ptr @d, align 8\n%5 = tail call i32 @write_config(i32 noundef 4164)\nbr label %B3\n\nB3:\n%6 = phi i32 [ %5, %B2 ], [ 4096, %B ], [ 0, %B1 ]\nret i32 %6\n}"}, "define dso_local void @drawAxis(float noundef nofpclass(nan inf) %0) {\n%2 = alloca float, align 4\nstore float %0, ptr %2, align 4\n%3 = load i32, ptr @GL_LIGHTING, align 4\n%4 = call i32 @glDisable(i32 noundef %3)\n%5 = load i32, ptr @GL_LINES, align 4\n%6 = call i32 @glBegin(i32 noundef %5)\n%7 = call i32 @glColor3f(i32 noundef 1, i32 noundef 0, i32 noundef 0)\n%8 = call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%9 = load float, ptr %2, align 4\n%10 = fmul fast float 1.000000e+00, %9\n%11 = fptosi float %10 to i32\n%12 = call i32 @glVertex3f(i32 noundef %11, i32 noundef 0, i32 noundef 0)\n%13 = call i32 @glColor3f(i32 noundef 0, i32 noundef 1, i32 noundef 0)\n%14 = call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%15 = load float, ptr %2, align 4\n%16 = fmul fast float 1.000000e+00, %15\n%17 = fptosi float %16 to i32\n%18 = call i32 @glVertex3f(i32 noundef 0, i32 noundef %17, i32 noundef 0)\n%19 = call i32 @glColor3f(i32 noundef 0, i32 noundef 0, i32 noundef 1)\n%20 = call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%21 = load float, ptr %2, align 4\n%22 = fmul fast float 1.000000e+00, %21\n%23 = fptosi float %22 to i32\n%24 = call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef %23)\n%25 = call i32 (...) @glEnd()\nret void\n}": {"base_truth": "define dso_local void @drawAxis(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = load i32, ptr @GL_LIGHTING, align 4\n%2 = tail call i32 @glDisable(i32 noundef %1)\n%3 = load i32, ptr @GL_LINES, align 4\n%4 = tail call i32 @glBegin(i32 noundef %3)\n%5 = tail call i32 @glColor3f(i32 noundef 1, i32 noundef 0, i32 noundef 0)\n%6 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%7 = fptosi float %0 to i32\n%8 = tail call i32 @glVertex3f(i32 noundef %7, i32 noundef 0, i32 noundef 0)\n%9 = tail call i32 @glColor3f(i32 noundef 0, i32 noundef 1, i32 noundef 0)\n%10 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%11 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef %7, i32 noundef 0)\n%12 = tail call i32 @glColor3f(i32 noundef 0, i32 noundef 0, i32 noundef 1)\n%13 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%14 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef %7)\n%15 = tail call i32 (...) @glEnd()\nret void\n}", "codellama": "define dso_local void @drawAxis(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = load i32, ptr @GL_LIGHTING, align 4\n%2 = tail call i32 @glDisable(i32 noundef %1)\n%3 = load i32, ptr @GL_LINES, align 4\n%4 = tail call i32 @glBegin(i32 noundef %3)\n%5 = tail call i32 @glColor3f(i32 noundef 1, i32 noundef 0, i32 noundef 0)\n%6 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%7 = fptosi float %0 to i32\n%8 = tail call i32 @glVertex3f(i32 noundef %7, i32 noundef 0, i32 noundef 0)\n%9 = tail call i32 @glColor3f(i32 noundef 0, i32 noundef 1, i32 noundef 0)\n%10 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%11 = tail call i32 @glColor3f(i32 noundef 0, i32 noundef 0, i32 noundef 1)\n%12 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%13 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef %7)\n%14 = tail call i32 (...) @glEnd()\nret void\n}", "codegemma": "define dso_local void @drawAxis(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = load i32, ptr @GL_LIGHTING, align 4\n%2 = tail call i32 @glDisable(i32 noundef %1)\n%3 = load i32, ptr @GL_LINES, align 4\n%4 = tail call i32 @glBegin(i32 noundef %3)\n%5 = tail call i32 @glColor3f(i32 noundef 1, i32 noundef 0, i32 noundef 0)\n%6 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%7 = fptosi float %0 to i32\n%8 = tail call i32 @glVertex3f(i32 noundef %7, i32 noundef 0, i32 noundef 0)\n%9 = tail call i32 @glColor3f(i32 noundef 0, i32 noundef 1, i32 noundef 0)\n%10 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%11 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef %7, i32 noundef 0)\n%12 = tail call i32 @glColor3f(i32 noundef 0, i32 noundef 0, i32 noundef 1)\n%13 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%14 = tail call i32 @glVertex3f(i32 noundef 0, i32 noundef %7, i32 noundef %7)\n%15 = tail call i32 (...) @glEnd()\nret void\n}"}, "define dso_local i32 @ijk_av_strstart(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\nbr label %7\n\n7:\n%8 = load ptr, ptr %5, align 8\n%9 = load i8, ptr %8, align 1\n%10 = sext i8 %9 to i32\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %20\n\n12:\n%13 = load ptr, ptr %5, align 8\n%14 = load i8, ptr %13, align 1\n%15 = sext i8 %14 to i32\n%16 = load ptr, ptr %4, align 8\n%17 = load i8, ptr %16, align 1\n%18 = sext i8 %17 to i32\n%19 = icmp eq i32 %15, %18\nbr label %20\n\n20:\n%21 = phi i1 [ false, %7 ], [ %19, %12 ]\nbr i1 %21, label %22, label %27\n\n22:\n%23 = load ptr, ptr %5, align 8\n%24 = getelementptr inbounds i8, ptr %23, i32 1\nstore ptr %24, ptr %5, align 8\n%25 = load ptr, ptr %4, align 8\n%26 = getelementptr inbounds i8, ptr %25, i32 1\nstore ptr %26, ptr %4, align 8\nbr label %7\n\n27:\n%28 = load ptr, ptr %5, align 8\n%29 = load i8, ptr %28, align 1\n%30 = icmp ne i8 %29, 0\nbr i1 %30, label %37, label %31\n\n31:\n%32 = load ptr, ptr %6, align 8\n%33 = icmp ne ptr %32, null\nbr i1 %33, label %34, label %37\n\n34:\n%35 = load ptr, ptr %4, align 8\n%36 = load ptr, ptr %6, align 8\nstore ptr %35, ptr %36, align 8\nbr label %37\n\n37:\n%38 = load ptr, ptr %5, align 8\n%39 = load i8, ptr %38, align 1\n%40 = icmp ne i8 %39, 0\n%41 = xor i1 %40, true\n%42 = zext i1 %41 to i32\nret i32 %42\n}": {"base_truth": "define dso_local i32 @ijk_av_strstart(ptr noundef %0, ptr nocapture noundef readonly %1, ptr noundef writeonly %2) {\nB:\n%3 = load i8, ptr %1, align 1\n%4 = icmp eq i8 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = phi i8 [ %12, %B2 ], [ %3, %B ]\n%6 = phi ptr [ %11, %B2 ], [ %0, %B ]\n%7 = phi ptr [ %10, %B2 ], [ %1, %B ]\n%8 = load i8, ptr %6, align 1\n%9 = icmp eq i8 %5, %8\nbr i1 %9, label %B2, label %B5\n\nB2:\n%10 = getelementptr inbounds i8, ptr %7, i64 1\n%11 = getelementptr inbounds i8, ptr %6, i64 1\n%12 = load i8, ptr %10, align 1\n%13 = icmp eq i8 %12, 0\nbr i1 %13, label %B3, label %B1\n\nB3:\n%14 = phi ptr [ %1, %B ], [ %10, %B2 ]\n%15 = phi ptr [ %0, %B ], [ %11, %B2 ]\n%16 = icmp eq ptr %2, null\nbr i1 %16, label %B5, label %B4\n\nB4:\nstore ptr %15, ptr %2, align 8\n%17 = load i8, ptr %14, align 1\nbr label %B5\n\nB5:\n%18 = phi i8 [ %17, %B4 ], [ 0, %B3 ], [ %5, %B1 ]\n%19 = icmp eq i8 %18, 0\n%20 = zext i1 %19 to i32\nret i32 %20\n}", "codellama": "define dso_local i32 @ijk_av_strstart(ptr noundef %0, ptr nocapture noundef readonly %1, ptr noundef writeonly %2) {\nB:\n%3 = load i8, ptr %1, align 1\n%4 = icmp eq i8 %3, 0\nbr i1 %4, label %B4, label %B1\n\nB1:\n%5 = phi i8 [ %13, %B2 ], [ %3, %B ]\n%6 = phi ptr [ %12, %B2 ], [ %1, %B ]\n%7 = phi ptr [ %11, %B2 ], [ %0, %B ]\n%8 = load i8, ptr %7, align 1\n%9 = icmp eq i8 %5, %8\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = getelementptr inbounds i8, ptr %6, i64 1\n%11 = getelementptr inbounds i8, ptr %7, i64 1\n%12 = icmp eq ptr %10, null\n%13 = load i8, ptr %10, align 1\n%14 = icmp eq i8 %13, 0\n%15 = select i1 %12, i1 true, i1 %14\nbr i1 %15, label %B4, label %B1\n\nB3:\n%16 = icmp eq ptr %2, null\n%17 = select i1 %16, i1 true, i1 %9\nbr i1 %17, label %B4, label %B5\n\nB4:\n%18 = phi ptr [ %0, %B ], [ %11, %B3 ], [ %7, %B2 ]\n%19 = phi ptr [ %1, %B ], [ %6, %B3 ], [ %10, %B2 ]\n%20 = icmp eq ptr %19, null\n%21 = zext i1 %20 to i32\nbr label %B5\n\nB5:\n%22 = phi i32 [ %21, %B4 ], [ 1, %B3 ]\nret i32 %22\n}", "codegemma": "define dso_local i32 @ijk_av_strstart(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, ptr noundef writeonly %2) {\nB:\n%3 = load i8, ptr %1, align 1\n%4 = icmp eq i8 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = phi i8 [ %10, %B2 ], [ %3, %B ]\n%6 = phi ptr [ %9, %B2 ], [ %1, %B ]\n%7 = phi ptr [ %8, %B2 ], [ %0, %B ]\n%8 = getelementptr inbounds i8, ptr %7, i64 1\n%9 = getelementptr inbounds i8, ptr %6, i64 1\n%10 = load i8, ptr %9, align 1\n%11 = icmp eq i8 %10, 0\nbr i1 %11, label %B3, label %B1\n\nB2:\n%12 = icmp ne ptr %2, null\n%13 = icmp ne i8 %5, 0\n%14 = and i1 %13, %12\nbr i1 %14, label %B3, label %B4\n\nB3:\n%15 = phi ptr [ %6, %B1 ], [ %1, %B ], [ %8, %B2 ]\n%16 = phi ptr [ %7, %B1 ], [ %0, %B ], [ %8, %B2 ]\nstore ptr %16, ptr %2, align 8\nbr label %B4\n\nB4:\n%17 = phi i1 [ %13, %B2 ], [ false, %B3 ]\n%18 = zext i1 %17 to i32\nret i32 %18\n}"}, "define internal i32 @dr_mask_is_dst_addr_set(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.mlx5dr_match_spec ptr %3, i32 0, i32 3\n%5 = load i64, ptr %4, align 8\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %22, label %7\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.mlx5dr_match_spec ptr %8, i32 0, i32 2\n%10 = load i64, ptr %9, align 8\n%11 = icmp ne i64 %10, 0\nbr i1 %11, label %22, label %12\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = getelementptr inbounds %struct.mlx5dr_match_spec ptr %13, i32 0, i32 1\n%15 = load i64, ptr %14, align 8\n%16 = icmp ne i64 %15, 0\nbr i1 %16, label %22, label %17\n\n17:\n%18 = load ptr, ptr %2, align 8\n%19 = getelementptr inbounds %struct.mlx5dr_match_spec ptr %18, i32 0, i32 0\n%20 = load i64, ptr %19, align 8\n%21 = icmp ne i64 %20, 0\nbr label %22\n\n22:\n%23 = phi i1 [ true, %12 ], [ true, %7 ], [ true, %1 ], [ %21, %17 ]\n%24 = zext i1 %23 to i32\nret i32 %24\n}": {"base_truth": "define internal i32 @dr_mask_is_dst_addr_set(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 3\n%2 = load i64, ptr %1, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B2, label %B4\n\nB2:\n%7 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = load i64, ptr %0, align 8\n%11 = icmp ne i64 %10, 0\n%12 = zext i1 %11 to i32\nbr label %B4\n\nB4:\n%13 = phi i32 [ 1, %B2 ], [ 1, %B1 ], [ 1, %B ], [ %12, %B3 ]\nret i32 %13\n}", "codellama": "define internal i32 @dr_mask_is_dst_addr_set(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 3\n%2 = load i64, ptr %1, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B2, label %B4\n\nB2:\n%7 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = load i64, ptr %0, align 8\n%11 = icmp ne i64 %10, 0\n%12 = zext i1 %11 to i32\nbr label %B4\n\nB4:\n%13 = phi i32 [ 1, %B2 ], [ 1, %B1 ], [ 1, %B ], [ %12, %B3 ]\nret i32 %13\n}", "codegemma": "define internal i32 @dr_mask_is_dst_addr_set(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 3\n%2 = load i64, ptr %1, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B2, label %B4\n\nB2:\n%7 = getelementptr inbounds %struct.mlx5dr_match_spec, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = load i64, ptr %0, align 8\n%11 = icmp ne i64 %10, 0\n%12 = zext i1 %11 to i32\nbr label %B4\n\nB4:\n%13 = phi i32 [ 1, %B2 ], [ 1, %B1 ], [ 1, %B ], [ %12, %B3 ]\nret i32 %13\n}"}, "define dso_local i32 @setup_tests() {\n%1 = load i32, ptr @test_param_int, align 4\n%2 = load i32, ptr @raw_values, align 4\n%3 = call i32 @OSSL_NELEM(i32 noundef %2)\n%4 = call i32 @ADD_ALL_TESTS(i32 noundef %1, i32 noundef %3)\n%5 = load i32, ptr @test_param_long, align 4\n%6 = load i32, ptr @raw_values, align 4\n%7 = call i32 @OSSL_NELEM(i32 noundef %6)\n%8 = call i32 @ADD_ALL_TESTS(i32 noundef %5, i32 noundef %7)\n%9 = load i32, ptr @test_param_uint, align 4\n%10 = load i32, ptr @raw_values, align 4\n%11 = call i32 @OSSL_NELEM(i32 noundef %10)\n%12 = call i32 @ADD_ALL_TESTS(i32 noundef %9, i32 noundef %11)\n%13 = load i32, ptr @test_param_ulong, align 4\n%14 = load i32, ptr @raw_values, align 4\n%15 = call i32 @OSSL_NELEM(i32 noundef %14)\n%16 = call i32 @ADD_ALL_TESTS(i32 noundef %13, i32 noundef %15)\n%17 = load i32, ptr @test_param_int32, align 4\n%18 = load i32, ptr @raw_values, align 4\n%19 = call i32 @OSSL_NELEM(i32 noundef %18)\n%20 = call i32 @ADD_ALL_TESTS(i32 noundef %17, i32 noundef %19)\n%21 = load i32, ptr @test_param_uint32, align 4\n%22 = load i32, ptr @raw_values, align 4\n%23 = call i32 @OSSL_NELEM(i32 noundef %22)\n%24 = call i32 @ADD_ALL_TESTS(i32 noundef %21, i32 noundef %23)\n%25 = load i32, ptr @test_param_size_t, align 4\n%26 = load i32, ptr @raw_values, align 4\n%27 = call i32 @OSSL_NELEM(i32 noundef %26)\n%28 = call i32 @ADD_ALL_TESTS(i32 noundef %25, i32 noundef %27)\n%29 = load i32, ptr @test_param_int64, align 4\n%30 = load i32, ptr @raw_values, align 4\n%31 = call i32 @OSSL_NELEM(i32 noundef %30)\n%32 = call i32 @ADD_ALL_TESTS(i32 noundef %29, i32 noundef %31)\n%33 = load i32, ptr @test_param_uint64, align 4\n%34 = load i32, ptr @raw_values, align 4\n%35 = call i32 @OSSL_NELEM(i32 noundef %34)\n%36 = call i32 @ADD_ALL_TESTS(i32 noundef %33, i32 noundef %35)\n%37 = load i32, ptr @test_param_bignum, align 4\n%38 = load i32, ptr @raw_values, align 4\n%39 = call i32 @OSSL_NELEM(i32 noundef %38)\n%40 = call i32 @ADD_ALL_TESTS(i32 noundef %37, i32 noundef %39)\n%41 = load i32, ptr @test_param_real, align 4\n%42 = call i32 @ADD_TEST(i32 noundef %41)\n%43 = load i32, ptr @test_param_construct, align 4\n%44 = call i32 @ADD_TEST(i32 noundef %43)\nret i32 1\n}": {"base_truth": "define dso_local i32 @setup_tests() {\nB:\n%0 = load i32, ptr @test_param_int, align 4\n%1 = load i32, ptr @raw_values, align 4\n%2 = tail call i32 @OSSL_NELEM(i32 noundef %1)\n%3 = tail call i32 @ADD_ALL_TESTS(i32 noundef %0, i32 noundef %2)\n%4 = load i32, ptr @test_param_long, align 4\n%5 = load i32, ptr @raw_values, align 4\n%6 = tail call i32 @OSSL_NELEM(i32 noundef %5)\n%7 = tail call i32 @ADD_ALL_TESTS(i32 noundef %4, i32 noundef %6)\n%8 = load i32, ptr @test_param_uint, align 4\n%9 = load i32, ptr @raw_values, align 4\n%10 = tail call i32 @OSSL_NELEM(i32 noundef %9)\n%11 = tail call i32 @ADD_ALL_TESTS(i32 noundef %8, i32 noundef %10)\n%12 = load i32, ptr @test_param_ulong, align 4\n%13 = load i32, ptr @raw_values, align 4\n%14 = tail call i32 @OSSL_NELEM(i32 noundef %13)\n%15 = tail call i32 @ADD_ALL_TESTS(i32 noundef %12, i32 noundef %14)\n%16 = load i32, ptr @test_param_int32, align 4\n%17 = load i32, ptr @raw_values, align 4\n%18 = tail call i32 @OSSL_NELEM(i32 noundef %17)\n%19 = tail call i32 @ADD_ALL_TESTS(i32 noundef %16, i32 noundef %18)\n%20 = load i32, ptr @test_param_uint32, align 4\n%21 = load i32, ptr @raw_values, align 4\n%22 = tail call i32 @OSSL_NELEM(i32 noundef %21)\n%23 = tail call i32 @ADD_ALL_TESTS(i32 noundef %20, i32 noundef %22)\n%24 = load i32, ptr @test_param_size_t, align 4\n%25 = load i32, ptr @raw_values, align 4\n%26 = tail call i32 @OSSL_NELEM(i32 noundef %25)\n%27 = tail call i32 @ADD_ALL_TESTS(i32 noundef %24, i32 noundef %26)\n%28 = load i32, ptr @test_param_int64, align 4\n%29 = load i32, ptr @raw_values, align 4\n%30 = tail call i32 @OSSL_NELEM(i32 noundef %29)\n%31 = tail call i32 @ADD_ALL_TESTS(i32 noundef %28, i32 noundef %30)\n%32 = load i32, ptr @test_param_uint64, align 4\n%33 = load i32, ptr @raw_values, align 4\n%34 = tail call i32 @OSSL_NELEM(i32 noundef %33)\n%35 = tail call i32 @ADD_ALL_TESTS(i32 noundef %32, i32 noundef %34)\n%36 = load i32, ptr @test_param_bignum, align 4\n%37 = load i32, ptr @raw_values, align 4\n%38 = tail call i32 @OSSL_NELEM(i32 noundef %37)\n%39 = tail call i32 @ADD_ALL_TESTS(i32 noundef %36, i32 noundef %38)\n%40 = load i32, ptr @test_param_real, align 4\n%41 = tail call i32 @ADD_TEST(i32 noundef %40)\n%42 = load i32, ptr @test_param_construct, align 4\n%43 = tail call i32 @ADD_TEST(i32 noundef %42)\nret i32 1\n}", "codellama": "define dso_local i32 @setup_tests() {\nB:\n%0 = load i32, ptr @test_param_int, align 4\n%1 = load i32, ptr @raw_values, align 4\n%2 = tail call i32 @OSSL_NELEM(i32 noundef %1)\n%3 = tail call i32 @ADD_ALL_TESTS(i32 noundef %0, i32 noundef %2)\n%4 = load i32, ptr @test_param_long, align 4\n%5 = load i32, ptr @raw_values, align 4\n%6 = tail call i32 @OSSL_NELEM(i32 noundef %5)\n%7 = tail call i32 @ADD_ALL_TESTS(i32 noundef %4, i32 noundef %6)\n%8 = load i32, ptr @test_param_uint, align 4\n%9 = load i32, ptr @raw_values, align 4\n%10 = tail call i32 @OSSL_NELEM(i32 noundef %9)\n%11 = tail call i32 @ADD_ALL_TESTS(i32 noundef %8, i32 noundef %10)\n%12 = load i32, ptr @test_param_ulong, align 4\n%13 = load i32, ptr @raw_values, align 4\n%14 = tail call i32 @OSSL_NELEM(i32 noundef %13)\n%15 = tail call i32 @ADD_ALL_TESTS(i32 noundef %12, i32 noundef %14)\n%16 = load i32, ptr @test_param_int32, align 4\n%17 = load i32, ptr @raw_values, align 4\n%18 = tail call i32 @OSSL_NELEM(i32 noundef %17)\n%19 = tail call i32 @ADD_ALL_TESTS(i32 noundef %16, i32 noundef %18)\n%20 = load i32, ptr @test_param_uint32, align 4\n%21 = load i32, ptr @raw_values, align 4\n%22 = tail call i32 @OSSL_NELEM(i32 noundef %21)\n%23 = tail call i32 @ADD_ALL_TESTS(i32 noundef %20, i32 noundef %22)\n%24 = load i32, ptr @test_param_size_t, align 4\n%25 = load i32, ptr @raw_values, align 4\n%26 = tail call i32 @OSSL_NELEM(i32 noundef %25)\n%27 = tail call i32 @ADD_ALL_TESTS(i32 noundef %24, i32 noundef %26)\n%28 = load i32, ptr @test_param_int64, align 4\n%29 = load i32, ptr @raw_values, align 4\n%30 = tail call i32 @OSSL_NELEM(i32 noundef %29)\n%31 = tail call i32 @ADD_ALL_TESTS(i32 noundef %28, i32 noundef %30)\n%32 = load i32, ptr @test_param_uint64, align 4\n%33 = load i32, ptr @raw_values, align 4\n%34 = tail call i32 @OSSL_NELEM(i32 noundef %33)\n%35 = tail call i32 @ADD_ALL_TESTS(i32 noundef %32, i32 noundef %34)\n%36 = load i32, ptr @test_param_bignum, align 4\n%37 = load i32, ptr @raw_values, align 4\n%38 = tail call i32 @OSSL_NELEM(i32 noundef %37)\n%39 = tail call i32 @ADD_ALL_TESTS(i32 noundef %36, i32 noundef %38)\n%40 = load i32, ptr @test_param_real, align 4\n%41 = tail call i32 @ADD_TEST(i32 noundef %40)\n%42 = load i32, ptr @test_param_construct, align 4\n%43 = tail call i32 @ADD_TEST(i32 noundef %42)\nret i32 1\n}", "codegemma": "define dso_local i32 @setup_tests() {\nB:\n%0 = load i32, ptr @test_param_int, align 4\n%1 = load i32, ptr @raw_values, align 4\n%2 = tail call i32 @OSSL_NELEM(i32 noundef %1)\n%3 = tail call i32 @ADD_ALL_TESTS(i32 noundef %0, i32 noundef %2)\n%4 = load i32, ptr @test_param_long, align 4\n%5 = load i32, ptr @raw_values, align 4\n%6 = tail call i32 @OSSL_NELEM(i32 noundef %5)\n%7 = tail call i32 @ADD_ALL_TESTS(i32 noundef %4, i32 noundef %6)\n%8 = load i32, ptr @test_param_uint, align 4\n%9 = load i32, ptr @raw_values, align 4\n%10 = tail call i32 @OSSL_NELEM(i32 noundef %9)\n%11 = tail call i32 @ADD_ALL_TESTS(i32 noundef %8, i32 noundef %10)\n%12 = load i32, ptr @test_param_ulong, align 4\n%13 = load i32, ptr @raw_values, align 4\n%14 = tail call i32 @OSSL_NELEM(i32 noundef %13)\n%15 = tail call i32 @ADD_ALL_TESTS(i32 noundef %12, i32 noundef %14)\n%16 = load i32, ptr @test_param_int32, align 4\n%17 = load i32, ptr @raw_values, align 4\n%18 = tail call i32 @OSSL_NELEM(i32 noundef %17)\n%19 = tail call i32 @ADD_ALL_TESTS(i32 noundef %16, i32 noundef %18)\n%20 = load i32, ptr @test_param_uint32, align 4\n%21 = load i32, ptr @raw_values, align 4\n%22 = tail call i32 @OSSL_NELEM(i32 noundef %21)\n%23 = tail call i32 @ADD_ALL_TESTS(i32 noundef %20, i32 noundef %22)\n%24 = load i32, ptr @test_param_size_t, align 4\n%25 = load i32, ptr @raw_values, align 4\n%26 = tail call i32 @OSSL_NELEM(i32 noundef %25)\n%27 = tail call i32 @ADD_ALL_TESTS(i32 noundef %24, i32 noundef %26)\n%28 = load i32, ptr @test_param_int64, align 4\n%29 = load i32, ptr @raw_values, align 4\n%30 = tail call i32 @OSSL_NELEM(i32 noundef %29)\n%31 = tail call i32 @ADD_ALL_TESTS(i32 noundef %28, i32 noundef %30)\n%32 = load i32, ptr @test_param_uint64, align 4\n%33 = load i32, ptr @raw_values, align 4\n%34 = tail call i32 @OSSL_NELEM(i32 noundef %33)\n%35 = tail call i32 @ADD_ALL_TESTS(i32 noundef %32, i32 noundef %34)\n%36 = load i32, ptr @test_param_bignum, align 4\n%37 = load i32, ptr @raw_values, align 4\n%38 = tail call i32 @OSSL_NELEM(i32 noundef %37)\n%39 = tail call i32 @ADD_ALL_TESTS(i32 noundef %36, i32 noundef %38)\n%40 = load i32, ptr @test_param_real, align 4\n%41 = tail call i32 @ADD_TEST(i32 noundef %40)\n%42 = load i32, ptr @test_param_construct, align 4\n%43 = tail call i32 @ADD_TEST(i32 noundef %42)\nret i32 1\n}"}, "define dso_local i32 @HalIRTempRead(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%8 = load i64, ptr @irtSensorState, align 8\n%9 = load i64, ptr @TMP006_DATA_READY, align 8\n%10 = icmp ne i64 %8, %9\nbr i1 %10, label %11, label %12\n\n11:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %50\n\n12:\n%13 = call i32 (...) @HalIRTempSelect()\n%14 = call i32 @HalSensorReadReg(i32 noundef 0, ptr noundef %4, i32 noundef 2)\nstore i32 %14, ptr %6, align 4\n%15 = load i32, ptr %6, align 4\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %17, label %19\n\n17:\n%18 = call i32 @HalSensorReadReg(i32 noundef 1, ptr noundef %5, i32 noundef 2)\nstore i32 %18, ptr %6, align 4\nbr label %19\n\n19:\n%20 = load i32, ptr %6, align 4\n%21 = icmp ne i32 %20, 0\nbr i1 %21, label %22, label %41\n\n22:\n%23 = load i32, ptr %4, align 4\n%24 = ashr i32 %23, 8\n%25 = and i32 %24, 255\n%26 = load ptr, ptr %3, align 8\n%27 = getelementptr inbounds i32, ptr %26, i64 0\nstore i32 %25, ptr %27, align 4\n%28 = load i32, ptr %4, align 4\n%29 = and i32 %28, 255\n%30 = load ptr, ptr %3, align 8\n%31 = getelementptr inbounds i32, ptr %30, i64 1\nstore i32 %29, ptr %31, align 4\n%32 = load i32, ptr %5, align 4\n%33 = ashr i32 %32, 8\n%34 = and i32 %33, 255\n%35 = load ptr, ptr %3, align 8\n%36 = getelementptr inbounds i32, ptr %35, i64 2\nstore i32 %34, ptr %36, align 4\n%37 = load i32, ptr %5, align 4\n%38 = and i32 %37, 255\n%39 = load ptr, ptr %3, align 8\n%40 = getelementptr inbounds i32, ptr %39, i64 3\nstore i32 %38, ptr %40, align 4\nbr label %41\n\n41:\n%42 = load i32, ptr @configSensorOff, align 4\n%43 = call i64 @HalSensorWriteReg(i32 noundef 2, i32 noundef %42, i32 noundef 2)\n%44 = icmp ne i64 %43, 0\nbr i1 %44, label %45, label %47\n\n45:\n%46 = load i64, ptr @TMP006_OFF, align 8\nstore i64 %46, ptr @irtSensorState, align 8\nbr label %47\n\n47:\n%48 = call i32 @HalDcDcControl(i32 noundef 1, i32 noundef 0)\n%49 = load i32, ptr %6, align 4\nstore i32 %49, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %50\n\n50:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%51 = load i32, ptr %2, align 4\nret i32 %51\n}": {"base_truth": "define dso_local i32 @HalIRTempRead(ptr nocapture noundef writeonly %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @irtSensorState, align 8\n%4 = load i64, ptr @TMP006_DATA_READY, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B7\n\nB1:\n%6 = tail call i32 (...) @HalIRTempSelect()\n%7 = call i32 @HalSensorReadReg(i32 noundef 0, ptr noundef nonnull %1, i32 noundef 2)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B2\n\nB2:\n%9 = call i32 @HalSensorReadReg(i32 noundef 1, ptr noundef nonnull %2, i32 noundef 2)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i32, ptr %1, align 4\n%12 = lshr i32 %11, 8\n%13 = load i32, ptr %2, align 4\n%14 = lshr i32 %13, 8\n%15 = insertelement <4 x i32> poison, i32 %12, i64 0\n%16 = insertelement <4 x i32> %15, i32 %11, i64 1\n%17 = insertelement <4 x i32> %16, i32 %14, i64 2\n%18 = insertelement <4 x i32> %17, i32 %13, i64 3\n%19 = and <4 x i32> %18, <i32 255, i32 255, i32 255, i32 255>\nstore <4 x i32> %19, ptr %0, align 4\nbr label %B4\n\nB4:\n%20 = phi i32 [ %9, %B3 ], [ 0, %B2 ], [ 0, %B1 ]\n%21 = load i32, ptr @configSensorOff, align 4\n%22 = call i64 @HalSensorWriteReg(i32 noundef 2, i32 noundef %21, i32 noundef 2)\n%23 = icmp eq i64 %22, 0\nbr i1 %23, label %B6, label %B5\n\nB5:\n%24 = load i64, ptr @TMP006_OFF, align 8\nstore i64 %24, ptr @irtSensorState, align 8\nbr label %B6\n\nB6:\n%25 = call i32 @HalDcDcControl(i32 noundef 1, i32 noundef 0)\nbr label %B7\n\nB7:\n%26 = phi i32 [ %20, %B6 ], [ 0, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %26\n}", "codellama": "define dso_local i32 @HalIRTempRead(ptr nocapture noundef writeonly %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @irtSensorState, align 8\n%4 = load i64, ptr @TMP006_DATA_READY, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B6\n\nB1:\n%6 = tail call i32 (...) @HalIRTempSelect()\n%7 = call i32 @HalSensorReadReg(i32 noundef 0, ptr noundef nonnull %1, i32 noundef 2)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B2\n\nB2:\n%9 = call i32 @HalSensorReadReg(i32 noundef 1, ptr noundef nonnull %2, i32 noundef 2)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i32, ptr %1, align 4\n%12 = lshr i32 %11, 8\n%13 = and i32 %12, 255\nstore i32 %13, ptr %0, align 4\n%14 = and i32 %11, 255\n%15 = getelementptr inbounds i32, ptr %0, i64 1\nstore i32 %14, ptr %15, align 4\n%16 = load i32, ptr %2, align 4\n%17 = lshr i32 %16, 8\n%18 = and i32 %17, 255\n%19 = getelementptr inbounds i32, ptr %0, i64 2\nstore i32 %18, ptr %19, align 4\n%20 = and i32 %16, 255\n%21 = getelementptr inbounds i32, ptr %0, i64 3\nstore i32 %20, ptr %21, align 4\nbr label %B4\n\nB4:\n%22 = phi i32 [ 0, %B1 ], [ 0, %B2 ], [ %9, %B3 ]\n%23 = load i32, ptr @configSensorOff, align 4\n%24 = call i64 @HalSensorWriteReg(i32 noundef 2, i32 noundef %23, i32 noundef 2)\n%25 = icmp eq i64 %24, 0\nbr i1 %25, label %B6, label %B5\n\nB5:\n%26 = load i64, ptr @TMP006_OFF, align 8\nstore i64 %26, ptr @irtSensorState, align 8\nbr label %B6\n\nB6:\n%27 = phi i32 [ 0, %B ], [ %22, %B5 ], [ %22, %B4 ]\n%28 = call i32 @HalDcDcControl(i32 noundef 1, i32 noundef 0)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %27\n}", "codegemma": "define dso_local i32 @HalIRTempRead(ptr nocapture noundef writeonly %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @irtSensorState, align 8\n%4 = load i64, ptr @TMP006_DATA_READY, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B6\n\nB1:\n%6 = call i32 (...) @HalIRTempSelect()\n%7 = call i32 @HalSensorReadReg(i32 noundef 0, ptr noundef nonnull %1, i32 noundef 2)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = call i32 @HalSensorReadReg(i32 noundef 1, ptr noundef nonnull %2, i32 noundef 2)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i32, ptr %1, align 4\n%12 = lshr i32 %11, 8\n%13 = and i32 %12, 255\n%14 = getelementptr inbounds i32, ptr %0, i64 1\nstore i32 %13, ptr %14, align 4\n%15 = and i32 %11, 255\n%16 = getelementptr inbounds i32, ptr %0, i64 2\nstore i32 %15, ptr %16, align 4\n%17 = load i32, ptr %2, align 4\n%18 = lshr i32 %17, 8\n%19 = and i32 %18, 255\n%20 = getelementptr inbounds i32, ptr %0, i64 3\nstore i32 %19, ptr %20, align 4\n%21 = and i32 %17, 255\nbr label %B4\n\nB4:\n%22 = phi i32 [ %21, %B3 ], [ %9, %B2 ]\n%23 = load i32, ptr @configSensorOff, align 4\n%24 = call i64 @HalSensorWriteReg(i32 noundef 2, i32 noundef %23, i32 noundef 2)\n%25 = icmp eq i64 %24, 0\nbr i1 %25, label %B6, label %B5\n\nB5:\n%26 = load i64, ptr @TMP006_OFF, align 8\nstore i64 %26, ptr @irtSensorState, align 8\nbr label %B6\n\nB6:\n%27 = phi i32 [ 0, %B ], [ %22, %B5 ], [ %7, %B4 ]\n%28 = call i32 @HalDcDcControl(i32 noundef 1, i32 noundef 0)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %27\n}"}, "define dso_local void @ipu_cpmem_set_yuv_interleaved(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\nswitch i32 %5, label %26 [\ni32 129, label %6\ni32 128, label %16\n]\n\n6:\n%7 = load ptr, ptr %3, align 8\n%8 = load i32, ptr @IPU_FIELD_BPP, align 4\n%9 = call i32 @ipu_ch_param_write_field(ptr noundef %7, i32 noundef %8, i32 noundef 3)\n%10 = load ptr, ptr %3, align 8\n%11 = load i32, ptr @IPU_FIELD_PFS, align 4\n%12 = call i32 @ipu_ch_param_write_field(ptr noundef %10, i32 noundef %11, i32 noundef 10)\n%13 = load ptr, ptr %3, align 8\n%14 = load i32, ptr @IPU_FIELD_NPB, align 4\n%15 = call i32 @ipu_ch_param_write_field(ptr noundef %13, i32 noundef %14, i32 noundef 31)\nbr label %26\n\n16:\n%17 = load ptr, ptr %3, align 8\n%18 = load i32, ptr @IPU_FIELD_BPP, align 4\n%19 = call i32 @ipu_ch_param_write_field(ptr noundef %17, i32 noundef %18, i32 noundef 3)\n%20 = load ptr, ptr %3, align 8\n%21 = load i32, ptr @IPU_FIELD_PFS, align 4\n%22 = call i32 @ipu_ch_param_write_field(ptr noundef %20, i32 noundef %21, i32 noundef 8)\n%23 = load ptr, ptr %3, align 8\n%24 = load i32, ptr @IPU_FIELD_NPB, align 4\n%25 = call i32 @ipu_ch_param_write_field(ptr noundef %23, i32 noundef %24, i32 noundef 31)\nbr label %26\n\n26:\nret void\n}": {"base_truth": "define dso_local void @ipu_cpmem_set_yuv_interleaved(ptr noundef %0, i32 noundef %1) {\nB:\nswitch i32 %1, label %B3 [\ni32 129, label %B2\ni32 128, label %B1\n]\n\nB1:\nbr label %B2\n\nB2:\n%2 = phi i32 [ 8, %B1 ], [ 10, %B ]\n%3 = load i32, ptr @IPU_FIELD_BPP, align 4\n%4 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %3, i32 noundef 3)\n%5 = load i32, ptr @IPU_FIELD_PFS, align 4\n%6 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %5, i32 noundef %2)\n%7 = load i32, ptr @IPU_FIELD_NPB, align 4\n%8 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %7, i32 noundef 31)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @ipu_cpmem_set_yuv_interleaved(ptr noundef %0, i32 noundef %1) {\nB:\nswitch i32 %1, label %B3 [\ni32 129, label %B2\ni32 128, label %B1\n]\n\nB1:\nbr label %B2\n\nB2:\n%2 = phi i32 [ 8, %B1 ], [ 10, %B ]\n%3 = phi i32 [ 31, %B1 ], [ 31, %B ]\n%4 = phi i32 [ 3, %B1 ], [ 3, %B ]\n%5 = load i32, ptr @IPU_FIELD_BPP, align 4\n%6 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %5, i32 noundef %4)\n%7 = load i32, ptr @IPU_FIELD_PFS, align 4\n%8 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %7, i32 noundef %2)\n%9 = load i32, ptr @IPU_FIELD_NPB, align 4\n%10 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %9, i32 noundef %3)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @ipu_cpmem_set_yuv_interleaved(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 128\n%3 = icmp eq i32 %1, 129\n%4 = load i32, ptr @IPU_FIELD_BPP, align 4\nbr i1 %2, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @IPU_FIELD_PFS, align 4\n%6 = load i32, ptr @IPU_FIELD_NPB, align 4\nbr label %B3\n\nB2:\n%7 = load i32, ptr @IPU_FIELD_PFS, align 4\n%8 = load i32, ptr @IPU_FIELD_NPB, align 4\nbr label %B3\n\nB3:\n%9 = phi i32 [ %6, %B1 ], [ %7, %B2 ]\n%10 = phi i32 [ %4, %B1 ], [ %8, %B2 ]\n%11 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %10, i32 noundef 3)\n%12 = tail call i32 @ipu_ch_param_write_field(ptr noundef %0, i32 noundef %9, i32 noundef 10)\nret void\n}"}, "define dso_local void @exit_graphics() {\n%1 = call i32 (...) @clear_screen()\n%2 = load i32, ptr @TCGETS, align 4\n%3 = call i64 @ioctl(i32 noundef 1, i32 noundef %2, ptr noundef @terminal)\n%4 = icmp ne i64 %3, 0\nbr i1 %4, label %5, label %7\n\n5:\n%6 = call i32 @perror(ptr noundef @.str)\nbr label %29\n\n7:\n%8 = load i32, ptr @ICANON, align 4\n%9 = load i32, ptr @terminal, align 4\n%10 = or i32 %9, %8\nstore i32 %10, ptr @terminal, align 4\n%11 = load i32, ptr @ECHO, align 4\n%12 = load i32, ptr @terminal, align 4\n%13 = or i32 %12, %11\nstore i32 %13, ptr @terminal, align 4\n%14 = load i32, ptr @TCSETS, align 4\n%15 = call i64 @ioctl(i32 noundef 1, i32 noundef %14, ptr noundef @terminal)\n%16 = icmp ne i64 %15, 0\nbr i1 %16, label %17, label %19\n\n17:\n%18 = call i32 @perror(ptr noundef @.str.1)\nbr label %29\n\n19:\n%20 = load i32, ptr @mapPtr, align 4\n%21 = load i32, ptr @memSize, align 4\n%22 = call i64 @munmap(i32 noundef %20, i32 noundef %21)\n%23 = icmp ne i64 %22, 0\nbr i1 %23, label %24, label %26\n\n24:\n%25 = call i32 @perror(ptr noundef @.str.2)\nbr label %26\n\n26:\n%27 = load i32, ptr @fb, align 4\n%28 = call i32 @close(i32 noundef %27)\nbr label %29\n\n29:\nret void\n}": {"base_truth": "define dso_local void @exit_graphics() {\nB:\n%0 = tail call i32 (...) @clear_screen()\n%1 = load i32, ptr @TCGETS, align 4\n%2 = tail call i64 @ioctl(i32 noundef 1, i32 noundef %1, ptr noundef nonnull @terminal)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @perror(ptr noundef nonnull @.str)\nbr label %B7\n\nB2:\n%5 = load i32, ptr @ICANON, align 4\n%6 = load i32, ptr @terminal, align 4\n%7 = or i32 %6, %5\n%8 = load i32, ptr @ECHO, align 4\n%9 = or i32 %8, %7\nstore i32 %9, ptr @terminal, align 4\n%10 = load i32, ptr @TCSETS, align 4\n%11 = tail call i64 @ioctl(i32 noundef 1, i32 noundef %10, ptr noundef nonnull @terminal)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B4, label %B3\n\nB3:\n%13 = tail call i32 @perror(ptr noundef nonnull @.str.1)\nbr label %B7\n\nB4:\n%14 = load i32, ptr @mapPtr, align 4\n%15 = load i32, ptr @memSize, align 4\n%16 = tail call i64 @munmap(i32 noundef %14, i32 noundef %15)\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B6, label %B5\n\nB5:\n%18 = tail call i32 @perror(ptr noundef nonnull @.str.2)\nbr label %B6\n\nB6:\n%19 = load i32, ptr @fb, align 4\n%20 = tail call i32 @close(i32 noundef %19)\nbr label %B7\n\nB7:\nret void\n}", "codellama": "define dso_local void @exit_graphics() {\nB:\n%0 = tail call i32 (...) @clear_screen()\n%1 = load i32, ptr @TCGETS, align 4\n%2 = tail call i64 @ioctl(i32 noundef 1, i32 noundef %1, ptr noundef nonnull @terminal)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @perror(ptr noundef nonnull @.str)\nbr label %B7\n\nB2:\n%5 = load i32, ptr @ICANON, align 4\n%6 = load i32, ptr @terminal, align 4\n%7 = or i32 %6, %5\nstore i32 %7, ptr @terminal, align 4\n%8 = load i32, ptr @ECHO, align 4\n%9 = or i32 %7, %8\nstore i32 %9, ptr @terminal, align 4\n%10 = load i32, ptr @TCSETS, align 4\n%11 = tail call i64 @ioctl(i32 noundef 1, i32 noundef %10, ptr noundef nonnull @terminal)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B4, label %B3\n\nB3:\n%13 = tail call i32 @perror(ptr noundef nonnull @.str.1)\nbr label %B7\n\nB4:\n%14 = load i32, ptr @mapPtr, align 4\n%15 = load i32, ptr @memSize, align 4\n%16 = tail call i64 @munmap(i32 noundef %14, i32 noundef %15)\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B6, label %B5\n\nB5:\n%18 = tail call i32 @perror(ptr noundef nonnull @.str.2)\nbr label %B6\n\nB6:\n%19 = load i32, ptr @fb, align 4\n%20 = tail call i32 @close(i32 noundef %19)\nbr label %B7\n\nB7:\nret void\n}", "codegemma": "define dso_local void @exit_graphics() {\nB:\n%0 = tail call i32 (...) @clear_screen()\n%1 = load i32, ptr @TCGETS, align 4\n%2 = tail call i64 @ioctl(i32 noundef 1, i32 noundef %1, ptr noundef nonnull @terminal)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @perror(ptr noundef nonnull @.str)\nbr label %B6\n\nB2:\n%5 = load i32, ptr @ICANON, align 4\n%6 = load i32, ptr @terminal, align 4\n%7 = or i32 %6, %5\nstore i32 %7, ptr @terminal, align 4\n%8 = load i32, ptr @ECHO, align 4\n%9 = or i32 %8, %7\nstore i32 %9, ptr @terminal, align 4\n%10 = load i32, ptr @TCSETS, align 4\n%11 = tail call i64 @ioctl(i32 noundef 1, i32 noundef %10, ptr noundef nonnull @terminal)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B4, label %B3\n\nB3:\n%13 = tail call i32 @perror(ptr noundef nonnull @.str.1)\nbr label %B6\n\nB4:\n%14 = load i32, ptr @mapPtr, align 4\n%15 = load i32, ptr @memSize, align 4\n%16 = tail call i64 @munmap(i32 noundef %14, i32 noundef %15)\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B6, label %B5\n\nB5:\n%18 = tail call i32 @perror(ptr noundef nonnull @.str.2)\nbr label %B6\n\nB6:\nret void\n}"}, "define internal i32 @kempld_gpio_get_bit(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%8 = load ptr, ptr %4, align 8\n%9 = call i32 @kempld_get_mutex(ptr noundef %8)\n%10 = load ptr, ptr %4, align 8\n%11 = load i32, ptr %5, align 4\n%12 = call i32 @kempld_read8(ptr noundef %10, i32 noundef %11)\nstore i32 %12, ptr %7, align 4\n%13 = load ptr, ptr %4, align 8\n%14 = call i32 @kempld_release_mutex(ptr noundef %13)\n%15 = load i32, ptr %7, align 4\n%16 = load i32, ptr %6, align 4\n%17 = call i32 @KEMPLD_GPIO_MASK(i32 noundef %16)\n%18 = and i32 %15, %17\n%19 = icmp ne i32 %18, 0\n%20 = xor i1 %19, true\n%21 = xor i1 %20, true\n%22 = zext i1 %21 to i32\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret i32 %22\n}": {"base_truth": "define internal i32 @kempld_gpio_get_bit(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @kempld_get_mutex(ptr noundef %0)\n%4 = tail call i32 @kempld_read8(ptr noundef %0, i32 noundef %1)\n%5 = tail call i32 @kempld_release_mutex(ptr noundef %0)\n%6 = tail call i32 @KEMPLD_GPIO_MASK(i32 noundef %2)\n%7 = and i32 %6, %4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nret i32 %9\n}", "codellama": "define internal i32 @kempld_gpio_get_bit(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @kempld_get_mutex(ptr noundef %0)\n%4 = tail call i32 @kempld_read8(ptr noundef %0, i32 noundef %1)\n%5 = tail call i32 @kempld_release_mutex(ptr noundef %0)\n%6 = tail call i32 @KEMPLD_GPIO_MASK(i32 noundef %2)\n%7 = and i32 %6, %4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nret i32 %9\n}", "codegemma": "define internal i32 @kempld_gpio_get_bit(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @kempld_get_mutex(ptr noundef %0)\n%4 = tail call i32 @kempld_read8(ptr noundef %0, i32 noundef %1)\n%5 = tail call i32 @kempld_release_mutex(ptr noundef %0)\n%6 = tail call i32 @KEMPLD_GPIO_MASK(i32 noundef %2)\n%7 = and i32 %6, %4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nret i32 %9\n}"}, "define dso_local void @foo(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr @foo.q, align 4\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %5, label %7\n\n5:\n%6 = load i32, ptr %2, align 4\nstore i32 %6, ptr @foo.q, align 4\nbr label %14\n\n7:\n%8 = load i32, ptr @foo.q, align 4\n%9 = load i32, ptr %2, align 4\n%10 = icmp ne i32 %8, %9\nbr i1 %10, label %11, label %13\n\n11:\n%12 = call i32 (...) @abort()\nunreachable\n\n13:\nbr label %14\n\n14:\nret void\n}": {"base_truth": "define dso_local void @foo(i32 noundef %0) {\nB:\n%1 = load i32, ptr @foo.q, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\nstore i32 %0, ptr @foo.q, align 4\nbr label %B4\n\nB2:\n%3 = icmp eq i32 %1, %0\nbr i1 %3, label %B4, label %B3\n\nB3:\n%4 = tail call i32 (...) @abort()\nunreachable\n\nB4:\nret void\n}", "codellama": "define dso_local void @foo(i32 noundef %0) {\nB:\n%1 = load i32, ptr @foo.q, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\nstore i32 %0, ptr @foo.q, align 4\nbr label %B4\n\nB2:\n%3 = icmp eq i32 %1, %0\nbr i1 %3, label %B4, label %B3\n\nB3:\n%4 = tail call i32 (...) @abort()\nunreachable\n\nB4:\nret void\n}", "codegemma": "define dso_local void @foo(i32 noundef %0) {\nB:\n%1 = load i32, ptr @foo.q, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = icmp eq i32 %1, %0\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = phi i32 [ %0, %B ], [ %1, %B1 ]\nstore i32 %4, ptr @foo.q, align 4\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local i32 @gcd(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = icmp sge i32 %5, 0\nbr i1 %6, label %7, label %11\n\n7:\n%8 = load i32, ptr %4, align 4\n%9 = icmp sge i32 %8, 0\nbr i1 %9, label %10, label %11\n\n10:\nbr label %11\n\n11:\n%12 = phi i1 [ false, %7 ], [ false, %2 ], [ true, %10 ]\n%13 = zext i1 %12 to i32\n%14 = call i32 @assert(i32 noundef %13)\nbr label %15\n\n15:\n%16 = load i32, ptr %3, align 4\n%17 = load i32, ptr %4, align 4\n%18 = icmp ne i32 %16, %17\nbr i1 %18, label %19, label %32\n\n19:\n%20 = load i32, ptr %3, align 4\n%21 = load i32, ptr %4, align 4\n%22 = icmp sgt i32 %20, %21\nbr i1 %22, label %23, label %27\n\n23:\n%24 = load i32, ptr %4, align 4\n%25 = load i32, ptr %3, align 4\n%26 = sub nsw i32 %25, %24\nstore i32 %26, ptr %3, align 4\nbr label %31\n\n27:\n%28 = load i32, ptr %3, align 4\n%29 = load i32, ptr %4, align 4\n%30 = sub nsw i32 %29, %28\nstore i32 %30, ptr %4, align 4\nbr label %31\n\n31:\nbr label %15\n\n32:\n%33 = load i32, ptr %3, align 4\nret i32 %33\n}": {"base_truth": "define dso_local i32 @gcd(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = or i32 %1, %0\n%3 = icmp sgt i32 %2, -1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @assert(i32 noundef %4)\n%6 = icmp eq i32 %0, %1\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = phi i32 [ %13, %B1 ], [ %1, %B ]\n%8 = phi i32 [ %11, %B1 ], [ %0, %B ]\n%9 = icmp sgt i32 %8, %7\n%10 = select i1 %9, i32 %7, i32 0\n%11 = sub nsw i32 %8, %10\n%12 = select i1 %9, i32 0, i32 %8\n%13 = sub nsw i32 %7, %12\n%14 = icmp eq i32 %11, %13\nbr i1 %14, label %B2, label %B1\n\nB2:\n%15 = phi i32 [ %1, %B ], [ %11, %B1 ]\nret i32 %15\n}", "codellama": "define dso_local i32 @gcd(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = or i32 %1, %0\n%3 = icmp sgt i32 %2, -1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @assert(i32 noundef %4)\n%6 = icmp eq i32 %0, %1\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = phi i32 [ %10, %B1 ], [ %0, %B ]\n%8 = phi i32 [ %9, %B1 ], [ %1, %B ]\n%9 = sub nsw i32 %8, %7\n%10 = sub nsw i32 %7, %8\n%11 = icmp eq i32 %10, 0\n%12 = icmp sgt i32 %7, %8\n%13 = select i1 %12, i32 %9, i32 %10\n%14 = select i1 %11, i32 %7, i32 %13\n%15 = icmp eq i32 %14, %1\nbr i1 %15, label %B2, label %B1\n\nB2:\n%16 = phi i32 [ %0, %B ], [ %14, %B1 ]\nret i32 %16\n}", "codegemma": "define dso_local i32 @gcd(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %0, -1\n%3 = icmp sgt i32 %1, -1\n%4 = and i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\nbr label %B1\n\nB1:\n%7 = phi i32 [ %0, %B ], [ %10, %B3 ]\n%8 = phi i32 [ %1, %B ], [ %9, %B3 ]\n%9 = icmp eq i32 %7, %8\nbr i1 %9, label %B4, label %B2\n\nB2:\n%10 = icmp sgt i32 %7, %8\n%11 = sub nsw i32 %7, %8\n%12 = sub nsw i32 %8, %7\n%13 = select i1 %10, i32 %11, i32 %12\nbr label %B3\n\nB3:\n%14 = phi i32 [ %13, %B2 ], [ %8, %B1 ]\n%15 = icmp sgt i32 %14, -1\n%16 = zext i1 %15 to i32\n%17 = tail call i32 @assert(i32 noundef %16)\nbr label %B1\n\nB4:\n%18 = phi i32 [ %7, %B1 ], [ %8, %B3 ]\nret i32 %18\n}"}, "define dso_local void @send_keys_usb() {\n%1 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%2 = load i64, ptr @dbg_threshold, align 8\n%3 = icmp sge i64 %1, %2\nbr i1 %3, label %4, label %29\n\n4:\n%5 = call i64 (...) @dbg_has_active_channels()\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %7, label %29\n\n7:\n%8 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%9 = load i32, ptr @keyboard_modifier_keys, align 4\n%10 = load ptr, ptr @keyboard_keys, align 8\n%11 = getelementptr inbounds i32, ptr %10, i64 0\n%12 = load i32, ptr %11, align 4\n%13 = load ptr, ptr @keyboard_keys, align 8\n%14 = getelementptr inbounds i32, ptr %13, i64 1\n%15 = load i32, ptr %14, align 4\n%16 = load ptr, ptr @keyboard_keys, align 8\n%17 = getelementptr inbounds i32, ptr %16, i64 2\n%18 = load i32, ptr %17, align 4\n%19 = load ptr, ptr @keyboard_keys, align 8\n%20 = getelementptr inbounds i32, ptr %19, i64 3\n%21 = load i32, ptr %20, align 4\n%22 = load ptr, ptr @keyboard_keys, align 8\n%23 = getelementptr inbounds i32, ptr %22, i64 4\n%24 = load i32, ptr %23, align 4\n%25 = load ptr, ptr @keyboard_keys, align 8\n%26 = getelementptr inbounds i32, ptr %25, i64 5\n%27 = load i32, ptr %26, align 4\n%28 = call i32 @dbg_process(i64 noundef %8, ptr noundef @dbg_msg_USB_SEND, i32 noundef %9, i32 noundef %12, i32 noundef %15, i32 noundef %18, i32 noundef %21, i32 noundef %24, i32 noundef %27)\nbr label %29\n\n29:\n%30 = call i32 (...) @usb_keyboard_send()\nret void\n}": {"base_truth": "define dso_local void @send_keys_usb() {\nB:\n%0 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%1 = load i64, ptr @dbg_threshold, align 8\n%2 = icmp slt i64 %0, %1\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = tail call i64 (...) @dbg_has_active_channels()\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%6 = load i32, ptr @keyboard_modifier_keys, align 4\n%7 = load ptr, ptr @keyboard_keys, align 8\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %7, i64 1\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds i32, ptr %7, i64 2\n%12 = load i32, ptr %11, align 4\n%13 = getelementptr inbounds i32, ptr %7, i64 3\n%14 = load i32, ptr %13, align 4\n%15 = getelementptr inbounds i32, ptr %7, i64 4\n%16 = load i32, ptr %15, align 4\n%17 = getelementptr inbounds i32, ptr %7, i64 5\n%18 = load i32, ptr %17, align 4\n%19 = tail call i32 @dbg_process(i64 noundef %5, ptr noundef nonnull @dbg_msg_USB_SEND, i32 noundef %6, i32 noundef %8, i32 noundef %10, i32 noundef %12, i32 noundef %14, i32 noundef %16, i32 noundef %18)\nbr label %B3\n\nB3:\n%20 = tail call i32 (...) @usb_keyboard_send()\nret void\n}", "codellama": "define dso_local void @send_keys_usb() {\nB:\n%0 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%1 = load i64, ptr @dbg_threshold, align 8\n%2 = icmp slt i64 %0, %1\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = tail call i64 (...) @dbg_has_active_channels()\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%6 = load i32, ptr @keyboard_modifier_keys, align 4\n%7 = load ptr, ptr @keyboard_keys, align 8\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %7, i64 1\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds i32, ptr %7, i64 2\n%12 = load i32, ptr %11, align 4\n%13 = getelementptr inbounds i32, ptr %7, i64 3\n%14 = load i32, ptr %13, align 4\n%15 = getelementptr inbounds i32, ptr %7, i64 4\n%16 = load i32, ptr %15, align 4\n%17 = getelementptr inbounds i32, ptr %7, i64 5\n%18 = load i32, ptr %17, align 4\n%19 = tail call i32 @dbg_process(i64 noundef %5, ptr noundef nonnull @dbg_msg_USB_SEND, i32 noundef %6, i32 noundef %8, i32 noundef %10, i32 noundef %12, i32 noundef %14, i32 noundef %16, i32 noundef %18)\nbr label %B3\n\nB3:\n%20 = tail call i32 (...) @usb_keyboard_send()\nret void\n}", "codegemma": "define dso_local void @send_keys_usb() {\nB:\n%0 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%1 = load i64, ptr @dbg_threshold, align 8\n%2 = icmp slt i64 %0, %1\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = tail call i64 (...) @dbg_has_active_channels()\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = load i64, ptr @DBG_LVL_DEBUG, align 8\n%6 = load i32, ptr @keyboard_modifier_keys, align 4\n%7 = load ptr, ptr @keyboard_keys, align 8\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %7, i64 1\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds i32, ptr %7, i64 2\n%12 = load i32, ptr %11, align 4\n%13 = getelementptr inbounds i32, ptr %7, i64 3\n%14 = load i32, ptr %13, align 4\n%15 = getelementptr inbounds i32, ptr %7, i64 4\n%16 = load i32, ptr %15, align 4\n%17 = getelementptr inbounds i32, ptr %7, i64 5\n%18 = load i32, ptr %17, align 4\n%19 = tail call i32 @dbg_process(i64 noundef %5, ptr noundef nonnull @dbg_msg_USB_SEND, i32 noundef %6, i32 noundef %8, i32 noundef %10, i32 noundef %12, i32 noundef %14, i32 noundef %16, i32 noundef %18)\nbr label %B3\n\nB3:\n%20 = tail call i32 (...) @usb_keyboard_send()\nret void\n}"}, "define internal void @kbtab_disconnect(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @usb_get_intfdata(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = call i32 @usb_set_intfdata(ptr noundef %6, ptr noundef null)\n%8 = load ptr, ptr %3, align 8\n%9 = icmp ne ptr %8, null\nbr i1 %9, label %10, label %34\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.kbtab ptr %11, i32 0, i32 2\n%13 = load i32, ptr %12, align 4\n%14 = call i32 @usb_kill_urb(i32 noundef %13)\n%15 = load ptr, ptr %3, align 8\n%16 = getelementptr inbounds %struct.kbtab ptr %15, i32 0, i32 3\n%17 = load i32, ptr %16, align 4\n%18 = call i32 @input_unregister_device(i32 noundef %17)\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.kbtab ptr %19, i32 0, i32 2\n%21 = load i32, ptr %20, align 4\n%22 = call i32 @usb_free_urb(i32 noundef %21)\n%23 = load ptr, ptr %2, align 8\n%24 = call i32 @interface_to_usbdev(ptr noundef %23)\n%25 = load ptr, ptr %3, align 8\n%26 = getelementptr inbounds %struct.kbtab ptr %25, i32 0, i32 1\n%27 = load i32, ptr %26, align 4\n%28 = load ptr, ptr %3, align 8\n%29 = getelementptr inbounds %struct.kbtab ptr %28, i32 0, i32 0\n%30 = load i32, ptr %29, align 4\n%31 = call i32 @usb_buffer_free(i32 noundef %24, i32 noundef 10, i32 noundef %27, i32 noundef %30)\n%32 = load ptr, ptr %3, align 8\n%33 = call i32 @kfree(ptr noundef %32)\nbr label %34\n\n34:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @kbtab_disconnect(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @usb_set_intfdata(ptr noundef %0, ptr noundef null)\n%3 = icmp eq ptr %1, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 2\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @usb_kill_urb(i32 noundef %5)\n%7 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 3\n%8 = load i32, ptr %7, align 4\n%9 = tail call i32 @input_unregister_device(i32 noundef %8)\n%10 = load i32, ptr %4, align 4\n%11 = tail call i32 @usb_free_urb(i32 noundef %10)\n%12 = tail call i32 @interface_to_usbdev(ptr noundef %0)\n%13 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 1\n%14 = load i32, ptr %13, align 4\n%15 = load i32, ptr %1, align 4\n%16 = tail call i32 @usb_buffer_free(i32 noundef %12, i32 noundef 10, i32 noundef %14, i32 noundef %15)\n%17 = tail call i32 @kfree(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @kbtab_disconnect(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @usb_set_intfdata(ptr noundef %0, ptr noundef null)\n%3 = icmp eq ptr %1, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 2\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @usb_kill_urb(i32 noundef %5)\n%7 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 3\n%8 = load i32, ptr %7, align 4\n%9 = tail call i32 @input_unregister_device(i32 noundef %8)\n%10 = load i32, ptr %4, align 4\n%11 = tail call i32 @usb_free_urb(i32 noundef %10)\n%12 = tail call i32 @interface_to_usbdev(ptr noundef %0)\n%13 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 1\n%14 = load i32, ptr %13, align 4\n%15 = load i32, ptr %1, align 4\n%16 = tail call i32 @usb_buffer_free(i32 noundef %12, i32 noundef 10, i32 noundef %14, i32 noundef %15)\n%17 = tail call i32 @kfree(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @kbtab_disconnect(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @usb_set_intfdata(ptr noundef %0, ptr noundef null)\n%3 = icmp eq ptr %1, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 2\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @usb_kill_urb(i32 noundef %5)\n%7 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 3\n%8 = load i32, ptr %7, align 4\n%9 = tail call i32 @input_unregister_device(i32 noundef %8)\n%10 = load i32, ptr %4, align 4\n%11 = tail call i32 @usb_free_urb(i32 noundef %10)\n%12 = tail call i32 @interface_to_usbdev(ptr noundef %0)\n%13 = getelementptr inbounds %struct.kbtab, ptr %1, i64 0, i32 1\n%14 = load i32, ptr %13, align 4\n%15 = load i32, ptr %1, align 4\n%16 = tail call i32 @usb_buffer_free(i32 noundef %12, i32 noundef 10, i32 noundef %14, i32 noundef %15)\n%17 = tail call i32 @kfree(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal void @kmemcheck_read(ptr noundef %0, i64 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca i64, align 8\n%8 = alloca i64, align 8\n%9 = alloca i64, align 8\n%10 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%11 = load i64, ptr %5, align 8\n%12 = load i64, ptr @PAGE_MASK, align 8\n%13 = and i64 %11, %12\nstore i64 %13, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%14 = load i64, ptr %5, align 8\n%15 = load i32, ptr %6, align 4\n%16 = zext i32 %15 to i64\n%17 = add i64 %14, %16\n%18 = sub i64 %17, 1\nstore i64 %18, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%19 = load i64, ptr %8, align 8\n%20 = load i64, ptr @PAGE_MASK, align 8\n%21 = and i64 %19, %20\nstore i64 %21, ptr %9, align 8\n%22 = load i64, ptr %7, align 8\n%23 = load i64, ptr %9, align 8\n%24 = icmp eq i64 %22, %23\n%25 = zext i1 %24 to i32\n%26 = call i64 @likely(i32 noundef %25)\n%27 = icmp ne i64 %26, 0\nbr i1 %27, label %28, label %34\n\n28:\n%29 = load ptr, ptr %4, align 8\n%30 = load i64, ptr %5, align 8\n%31 = load i32, ptr %6, align 4\n%32 = zext i32 %31 to i64\n%33 = call i32 @kmemcheck_read_strict(ptr noundef %29, i64 noundef %30, i64 noundef %32)\nstore i32 1, ptr %10, align 4\nbr label %47\n\n34:\n%35 = load ptr, ptr %4, align 8\n%36 = load i64, ptr %5, align 8\n%37 = load i64, ptr %9, align 8\n%38 = load i64, ptr %5, align 8\n%39 = sub i64 %37, %38\n%40 = call i32 @kmemcheck_read_strict(ptr noundef %35, i64 noundef %36, i64 noundef %39)\n%41 = load ptr, ptr %4, align 8\n%42 = load i64, ptr %9, align 8\n%43 = load i64, ptr %8, align 8\n%44 = load i64, ptr %9, align 8\n%45 = sub i64 %43, %44\n%46 = call i32 @kmemcheck_read_strict(ptr noundef %41, i64 noundef %42, i64 noundef %45)\nstore i32 0, ptr %10, align 4\nbr label %47\n\n47:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\n%48 = load i32, ptr %10, align 4\nswitch i32 %48, label %50 [\ni32 0, label %49\ni32 1, label %49\n]\n\n49:\nret void\n\n50:\nunreachable\n}": {"base_truth": "define internal void @kmemcheck_read(ptr noundef %0, i64 noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr @PAGE_MASK, align 8\n%4 = and i64 %3, %1\n%5 = zext i32 %2 to i64\n%6 = add i64 %1, -1\n%7 = add i64 %6, %5\n%8 = and i64 %3, %7\n%9 = icmp eq i64 %4, %8\n%10 = zext i1 %9 to i32\n%11 = tail call i64 @likely(i32 noundef %10)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B2, label %B1\n\nB1:\n%13 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %1, i64 noundef %5)\nbr label %B3\n\nB2:\n%14 = sub i64 %8, %1\n%15 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %1, i64 noundef %14)\n%16 = sub i64 %7, %8\n%17 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %8, i64 noundef %16)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @kmemcheck_read(ptr noundef %0, i64 noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr @PAGE_MASK, align 8\n%4 = and i64 %3, %1\n%5 = zext i32 %2 to i64\n%6 = add i64 %1, -1\n%7 = add i64 %6, %5\n%8 = and i64 %3, %7\n%9 = icmp eq i64 %4, %8\n%10 = zext i1 %9 to i32\n%11 = tail call i64 @likely(i32 noundef %10)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B2, label %B1\n\nB1:\n%13 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %1, i64 noundef %5)\nbr label %B3\n\nB2:\n%14 = sub i64 %8, %1\n%15 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %1, i64 noundef %14)\n%16 = sub i64 %7, %8\n%17 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %8, i64 noundef %16)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @kmemcheck_read(ptr noundef %0, i64 noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr @PAGE_MASK, align 8\n%4 = and i64 %3, %1\n%5 = zext i32 %2 to i64\n%6 = add i64 %5, -1\n%7 = add i64 %6, %1\n%8 = and i64 %7, %3\n%9 = icmp eq i64 %4, %8\n%10 = zext i1 %9 to i32\n%11 = tail call i64 @likely(i32 noundef %10)\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B2, label %B1\n\nB1:\n%13 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %1, i64 noundef %5)\nbr label %B3\n\nB2:\n%14 = sub i64 %8, %1\n%15 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %1, i64 noundef %14)\n%16 = sub i64 %7, %8\n%17 = tail call i32 @kmemcheck_read_strict(ptr noundef %0, i64 noundef %8, i64 noundef %16)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local void @d_ugen_setup() {\n%1 = call i32 (...) @block_tilde_setup()\n%2 = call i32 (...) @samplerate_tilde_setup()\nret void\n}": {"base_truth": "define dso_local void @d_ugen_setup() {\nB:\n%0 = tail call i32 (...) @block_tilde_setup()\n%1 = tail call i32 (...) @samplerate_tilde_setup()\nret void\n}", "codellama": "define dso_local void @d_ugen_setup() {\nB:\n%0 = tail call i32 (...) @block_tilde_setup()\n%1 = tail call i32 (...) @samplerate_tilde_setup()\nret void\n}", "codegemma": "define dso_local void @d_ugen_setup() {\nB:\n%0 = tail call i32 (...) @block_tilde_setup()\n%1 = tail call i32 (...) @samplerate_tilde_setup()\nret void\n}"}, "define dso_local void @roxml_del_node(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %58\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_7__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = and i32 %9, 16\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %15\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = call i32 @roxml_del_std_node(ptr noundef %13)\nbr label %55\n\n15:\n%16 = load ptr, ptr %2, align 8\n%17 = getelementptr inbounds %struct.TYPE_7__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = and i32 %18, 8\n%20 = icmp ne i32 %19, 0\nbr i1 %20, label %21, label %24\n\n21:\n%22 = load ptr, ptr %2, align 8\n%23 = call i32 @roxml_del_arg_node(ptr noundef %22)\nbr label %54\n\n24:\n%25 = load ptr, ptr %2, align 8\n%26 = getelementptr inbounds %struct.TYPE_7__, ptr %25, i32 0, i32 0\n%27 = load i32, ptr %26, align 4\n%28 = and i32 %27, 128\n%29 = icmp ne i32 %28, 0\nbr i1 %29, label %30, label %33\n\n30:\n%31 = load ptr, ptr %2, align 8\n%32 = call i32 @roxml_del_std_node(ptr noundef %31)\nbr label %53\n\n33:\n%34 = load ptr, ptr %2, align 8\n%35 = getelementptr inbounds %struct.TYPE_7__, ptr %34, i32 0, i32 0\n%36 = load i32, ptr %35, align 4\n%37 = and i32 %36, 64\n%38 = icmp ne i32 %37, 0\nbr i1 %38, label %39, label %42\n\n39:\n%40 = load ptr, ptr %2, align 8\n%41 = call i32 @roxml_del_std_node(ptr noundef %40)\nbr label %52\n\n42:\n%43 = load ptr, ptr %2, align 8\n%44 = getelementptr inbounds %struct.TYPE_7__, ptr %43, i32 0, i32 0\n%45 = load i32, ptr %44, align 4\n%46 = and i32 %45, 32\n%47 = icmp ne i32 %46, 0\nbr i1 %47, label %48, label %51\n\n48:\n%49 = load ptr, ptr %2, align 8\n%50 = call i32 @roxml_del_txt_node(ptr noundef %49)\nbr label %51\n\n51:\nbr label %52\n\n52:\nbr label %53\n\n53:\nbr label %54\n\n54:\nbr label %55\n\n55:\n%56 = load ptr, ptr %2, align 8\n%57 = call i32 @roxml_free_node(ptr noundef %56)\nbr label %58\n\n58:\nret void\n}": {"base_truth": "define dso_local void @roxml_del_node(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B12, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = and i32 %2, 16\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B11\n\nB3:\n%6 = and i32 %2, 8\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B5, label %B4\n\nB4:\n%8 = tail call i32 @roxml_del_arg_node(ptr noundef nonnull %0)\nbr label %B11\n\nB5:\n%9 = and i32 %2, 128\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B7, label %B6\n\nB6:\n%11 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B11\n\nB7:\n%12 = and i32 %2, 64\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B9, label %B8\n\nB8:\n%14 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B11\n\nB9:\n%15 = and i32 %2, 32\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B11, label %B10\n\nB10:\n%17 = tail call i32 @roxml_del_txt_node(ptr noundef nonnull %0)\nbr label %B11\n\nB11:\n%18 = tail call i32 @roxml_free_node(ptr noundef nonnull %0)\nbr label %B12\n\nB12:\nret void\n}", "codellama": "define dso_local void @roxml_del_node(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B10, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = and i32 %2, 16\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B9\n\nB3:\n%6 = and i32 %2, 8\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B5, label %B4\n\nB4:\n%8 = tail call i32 @roxml_del_arg_node(ptr noundef nonnull %0)\nbr label %B9\n\nB5:\n%9 = and i32 %2, 128\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B7, label %B6\n\nB6:\n%11 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B9\n\nB7:\n%12 = and i32 %2, 64\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B9, label %B8\n\nB8:\n%14 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B9\n\nB9:\n%15 = tail call i32 @roxml_free_node(ptr noundef nonnull %0)\nbr label %B10\n\nB10:\nret void\n}", "codegemma": "define dso_local void @roxml_del_node(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B10, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = and i32 %2, 16\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B10\n\nB3:\n%6 = and i32 %2, 8\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B5, label %B4\n\nB4:\n%8 = tail call i32 @roxml_del_arg_node(ptr noundef nonnull %0)\nbr label %B10\n\nB5:\n%9 = and i32 %2, 128\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B7, label %B6\n\nB6:\n%11 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B10\n\nB7:\n%12 = and i32 %2, 64\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B9, label %B8\n\nB8:\n%14 = tail call i32 @roxml_del_std_node(ptr noundef nonnull %0)\nbr label %B10\n\nB9:\n%15 = and i32 %2, 32\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B10, label %B11\n\nB10:\n%17 = tail call i32 @roxml_free_node(ptr noundef %0)\nbr label %B11\n\nB11:\nret void\n}"}, "define dso_local i32 @b43_lptab_read(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%7 = load i32, ptr %4, align 4\n%8 = load i32, ptr @B43_LPTAB_TYPEMASK, align 4\n%9 = and i32 %7, %8\nstore i32 %9, ptr %5, align 4\n%10 = load i32, ptr @B43_LPTAB_TYPEMASK, align 4\n%11 = xor i32 %10, -1\n%12 = load i32, ptr %4, align 4\n%13 = and i32 %12, %11\nstore i32 %13, ptr %4, align 4\n%14 = load i32, ptr %4, align 4\n%15 = icmp sgt i32 %14, 65535\n%16 = zext i1 %15 to i32\n%17 = call i32 @B43_WARN_ON(i32 noundef %16)\n%18 = load i32, ptr %5, align 4\nswitch i32 %18, label %51 [\ni32 128, label %19\ni32 130, label %28\ni32 129, label %36\n]\n\n19:\n%20 = load ptr, ptr %3, align 8\n%21 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%22 = load i32, ptr %4, align 4\n%23 = call i32 @b43_phy_write(ptr noundef %20, i32 noundef %21, i32 noundef %22)\n%24 = load ptr, ptr %3, align 8\n%25 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%26 = call i32 @b43_phy_read(ptr noundef %24, i32 noundef %25)\n%27 = and i32 %26, 255\nstore i32 %27, ptr %6, align 4\nbr label %53\n\n28:\n%29 = load ptr, ptr %3, align 8\n%30 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%31 = load i32, ptr %4, align 4\n%32 = call i32 @b43_phy_write(ptr noundef %29, i32 noundef %30, i32 noundef %31)\n%33 = load ptr, ptr %3, align 8\n%34 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%35 = call i32 @b43_phy_read(ptr noundef %33, i32 noundef %34)\nstore i32 %35, ptr %6, align 4\nbr label %53\n\n36:\n%37 = load ptr, ptr %3, align 8\n%38 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%39 = load i32, ptr %4, align 4\n%40 = call i32 @b43_phy_write(ptr noundef %37, i32 noundef %38, i32 noundef %39)\n%41 = load ptr, ptr %3, align 8\n%42 = load i32, ptr @B43_LPPHY_TABLEDATAHI, align 4\n%43 = call i32 @b43_phy_read(ptr noundef %41, i32 noundef %42)\nstore i32 %43, ptr %6, align 4\n%44 = load i32, ptr %6, align 4\n%45 = shl i32 %44, 16\nstore i32 %45, ptr %6, align 4\n%46 = load ptr, ptr %3, align 8\n%47 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%48 = call i32 @b43_phy_read(ptr noundef %46, i32 noundef %47)\n%49 = load i32, ptr %6, align 4\n%50 = or i32 %49, %48\nstore i32 %50, ptr %6, align 4\nbr label %53\n\n51:\n%52 = call i32 @B43_WARN_ON(i32 noundef 1)\nstore i32 0, ptr %6, align 4\nbr label %53\n\n53:\n%54 = load i32, ptr %6, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %54\n}": {"base_truth": "define dso_local i32 @b43_lptab_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @B43_LPTAB_TYPEMASK, align 4\n%3 = and i32 %2, %1\n%4 = xor i32 %2, -1\n%5 = and i32 %4, %1\n%6 = icmp sgt i32 %5, 65535\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @B43_WARN_ON(i32 noundef %7)\nswitch i32 %3, label %B4 [\ni32 128, label %B1\ni32 130, label %B2\ni32 129, label %B3\n]\n\nB1:\n%9 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%10 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %9, i32 noundef %5)\n%11 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%12 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %11)\n%13 = and i32 %12, 255\nbr label %B5\n\nB2:\n%14 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%15 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %14, i32 noundef %5)\n%16 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%17 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %16)\nbr label %B5\n\nB3:\n%18 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%19 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %18, i32 noundef %5)\n%20 = load i32, ptr @B43_LPPHY_TABLEDATAHI, align 4\n%21 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %20)\n%22 = shl i32 %21, 16\n%23 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%24 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %23)\n%25 = or i32 %24, %22\nbr label %B5\n\nB4:\n%26 = tail call i32 @B43_WARN_ON(i32 noundef 1)\nbr label %B5\n\nB5:\n%27 = phi i32 [ 0, %B4 ], [ %25, %B3 ], [ %17, %B2 ], [ %13, %B1 ]\nret i32 %27\n}", "codellama": "define dso_local i32 @b43_lptab_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @B43_LPTAB_TYPEMASK, align 4\n%3 = and i32 %2, %1\n%4 = xor i32 %2, -1\n%5 = and i32 %4, %1\n%6 = icmp sgt i32 %5, 65535\n%7 = zext i1 %6 to i32\n%8 = tail call i32 @B43_WARN_ON(i32 noundef %7)\nswitch i32 %3, label %B3 [\ni32 128, label %B1\ni32 130, label %B2\ni32 129, label %B4\n]\n\nB1:\n%9 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%10 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %9, i32 noundef %5)\n%11 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%12 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %11)\n%13 = and i32 %12, 255\nbr label %B4\n\nB2:\n%14 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%15 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %14, i32 noundef %5)\n%16 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%17 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %16)\nbr label %B4\n\nB3:\n%18 = tail call i32 @B43_WARN_ON(i32 noundef 1)\nbr label %B4\n\nB4:\n%19 = phi i32 [ 0, %B3 ], [ %17, %B2 ], [ %13, %B1 ], [ 0, %B ]\nret i32 %19\n}", "codegemma": "define dso_local i32 @b43_lptab_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @B43_LPTAB_TYPEMASK, align 4\n%3 = xor i32 %2, -1\n%4 = and i32 %3, %1\n%5 = icmp sgt i32 %4, 65535\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @B43_WARN_ON(i32 noundef %6)\n%8 = and i32 %2, %1\nswitch i32 %8, label %B4 [\ni32 128, label %B1\ni32 130, label %B2\ni32 129, label %B3\n]\n\nB1:\n%9 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%10 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %9, i32 noundef %1)\n%11 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%12 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %11)\n%13 = and i32 %12, 255\nbr label %B5\n\nB2:\n%14 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%15 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %14, i32 noundef %1)\n%16 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%17 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %16)\nbr label %B5\n\nB3:\n%18 = load i32, ptr @B43_LPPHY_TABLE_ADDR, align 4\n%19 = tail call i32 @b43_phy_write(ptr noundef %0, i32 noundef %18, i32 noundef %1)\n%20 = load i32, ptr @B43_LPPHY_TABLEDATAHI, align 4\n%21 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %20)\n%22 = shl i32 %21, 16\n%23 = load i32, ptr @B43_LPPHY_TABLEDATALO, align 4\n%24 = tail call i32 @b43_phy_read(ptr noundef %0, i32 noundef %23)\n%25 = or i32 %24, %22\nbr label %B5\n\nB4:\n%26 = tail call i32 @B43_WARN_ON(i32 noundef 1)\nbr label %B5\n\nB5:\n%27 = phi i32 [ 0, %B4 ], [ %25, %B3 ], [ %17, %B2 ], [ %13, %B1 ]\nret i32 %27\n}"}, "define internal void @goto_stmt_TEST_INIT() {\n%1 = load i64, ptr @test_funcs, align 8\n%2 = icmp ne i64 %1, 0\nbr i1 %2, label %5, label %3\n\n3:\n%4 = call i64 (...) @make_list()\nstore i64 %4, ptr @test_funcs, align 8\nbr label %5\n\n5:\n%6 = load i64, ptr @test_funcs, align 8\n%7 = load ptr, ptr @TEST_goto_stmt, align 8\n%8 = call i32 @list_push(i64 noundef %6, ptr noundef %7)\n%9 = load i64, ptr @test_funcs, align 8\n%10 = call i32 @list_push(i64 noundef %9, ptr noundef @.str)\nret void\n}": {"base_truth": "define internal void @goto_stmt_TEST_INIT() {\nB:\n%0 = load i64, ptr @test_funcs, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i64 (...) @make_list()\nstore i64 %2, ptr @test_funcs, align 8\nbr label %B2\n\nB2:\n%3 = phi i64 [ %2, %B1 ], [ %0, %B ]\n%4 = load ptr, ptr @TEST_goto_stmt, align 8\n%5 = tail call i32 @list_push(i64 noundef %3, ptr noundef %4)\n%6 = load i64, ptr @test_funcs, align 8\n%7 = tail call i32 @list_push(i64 noundef %6, ptr noundef nonnull @.str)\nret void\n}", "codellama": "define internal void @goto_stmt_TEST_INIT() {\nB:\n%0 = load i64, ptr @test_funcs, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i64 (...) @make_list()\nstore i64 %2, ptr @test_funcs, align 8\nbr label %B2\n\nB2:\n%3 = phi i64 [ %2, %B1 ], [ %0, %B ]\n%4 = load ptr, ptr @TEST_goto_stmt, align 8\n%5 = tail call i32 @list_push(i64 noundef %3, ptr noundef %4)\n%6 = load i64, ptr @test_funcs, align 8\n%7 = tail call i32 @list_push(i64 noundef %6, ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define internal void @goto_stmt_TEST_INIT() {\nB:\n%0 = load i64, ptr @test_funcs, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i64 (...) @make_list()\nstore i64 %2, ptr @test_funcs, align 8\nbr label %B2\n\nB2:\n%3 = phi i64 [ %2, %B1 ], [ %0, %B ]\n%4 = load ptr, ptr @TEST_goto_stmt, align 8\n%5 = tail call i32 @list_push(i64 noundef %3, ptr noundef %4)\n%6 = load i64, ptr @test_funcs, align 8\n%7 = tail call i32 @list_push(i64 noundef %6, ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local void @togo_command_build_send_fail(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %7, label %10\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %8, i32 0, i32 0\nstore i32 2, ptr %9, align 4\nbr label %10\n\n10:\nret void\n}": {"base_truth": "define dso_local void @togo_command_build_send_fail(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\nstore i32 2, ptr %0, align 4\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @togo_command_build_send_fail(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\nstore i32 2, ptr %0, align 4\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @togo_command_build_send_fail(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\nstore i32 2, ptr %0, align 4\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local ptr @prefix_undef_type_cons(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i32 %2, ptr %7, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%10 = load ptr, ptr %5, align 8\n%11 = load ptr, ptr %6, align 8\n%12 = load i32, ptr %7, align 4\n%13 = call ptr @prefix_find_type_cons_binding(ptr noundef %10, ptr noundef %11, i32 noundef %12)\nstore ptr %13, ptr %8, align 8\n%14 = load ptr, ptr %8, align 8\n%15 = icmp ne ptr %14, null\nbr i1 %15, label %16, label %21\n\n16:\n%17 = load ptr, ptr %8, align 8\n%18 = call i32 @hash_map_sym_pop_value(ptr noundef %17)\n%19 = sext i32 %18 to i64\n%20 = inttoptr i64 %19 to ptr\nstore ptr %20, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %22\n\n21:\nstore ptr null, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %22\n\n22:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\n%23 = load ptr, ptr %4, align 8\nret ptr %23\n}": {"base_truth": "define dso_local ptr @prefix_undef_type_cons(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call ptr @prefix_find_type_cons_binding(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @hash_map_sym_pop_value(ptr noundef nonnull %3)\n%6 = sext i32 %5 to i64\n%7 = inttoptr i64 %6 to ptr\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ null, %B ]\nret ptr %8\n}", "codellama": "define dso_local ptr @prefix_undef_type_cons(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call ptr @prefix_find_type_cons_binding(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @hash_map_sym_pop_value(ptr noundef nonnull %3)\n%6 = sext i32 %5 to i64\n%7 = inttoptr i64 %6 to ptr\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ null, %B ]\nret ptr %8\n}", "codegemma": "define dso_local ptr @prefix_undef_type_cons(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call ptr @prefix_find_type_cons_binding(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @hash_map_sym_pop_value(ptr noundef nonnull %3)\n%6 = sext i32 %5 to i64\n%7 = inttoptr i64 %6 to ptr\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ null, %B ]\nret ptr %8\n}"}, "define dso_local void @backspace() {\n%1 = call i32 (...) @moveCursorLeft()\n%2 = call i32 @terminal_putchar(i8 noundef signext 32)\n%3 = call i32 (...) @moveCursorLeft()\nret void\n}": {"base_truth": "define dso_local void @backspace() {\nB:\n%0 = tail call i32 (...) @moveCursorLeft()\n%1 = tail call i32 @terminal_putchar(i8 noundef signext 32)\n%2 = tail call i32 (...) @moveCursorLeft()\nret void\n}", "codellama": "define dso_local void @backspace() {\nB:\n%0 = tail call i32 (...) @moveCursorLeft()\n%1 = tail call i32 @terminal_putchar(i8 noundef signext 32)\n%2 = tail call i32 (...) @moveCursorLeft()\nret void\n}", "codegemma": "define dso_local void @backspace() {\nB:\n%0 = tail call i32 (...) @moveCursorLeft()\n%1 = tail call i32 @terminal_putchar(i8 noundef signext 32)\n%2 = tail call i32 (...) @moveCursorLeft()\nret void\n}"}, "define internal i32 @is_const_null(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @Const, align 4\n%5 = call i64 @IsA(ptr noundef %3, i32 noundef %4)\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %7, label %14\n\n7:\n%8 = load i32, ptr @Const, align 4\n%9 = load ptr, ptr %2, align 8\n%10 = call ptr @castNode(i32 noundef %8, ptr noundef %9)\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %10, i32 0, i32 0\n%12 = load i64, ptr %11, align 8\n%13 = icmp ne i64 %12, 0\nbr label %14\n\n14:\n%15 = phi i1 [ false, %1 ], [ %13, %7 ]\n%16 = zext i1 %15 to i32\nret i32 %16\n}": {"base_truth": "define internal i32 @is_const_null(ptr noundef %0) {\nB:\n%1 = load i32, ptr @Const, align 4\n%2 = tail call i64 @IsA(ptr noundef %0, i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @Const, align 4\n%5 = tail call ptr @castNode(i32 noundef %4, ptr noundef %0)\n%6 = load i64, ptr %5, align 8\n%7 = icmp ne i64 %6, 0\n%8 = zext i1 %7 to i32\nbr label %B2\n\nB2:\n%9 = phi i32 [ 0, %B ], [ %8, %B1 ]\nret i32 %9\n}", "codellama": "define internal i32 @is_const_null(ptr noundef %0) {\nB:\n%1 = load i32, ptr @Const, align 4\n%2 = tail call i64 @IsA(ptr noundef %0, i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @Const, align 4\n%5 = tail call ptr @castNode(i32 noundef %4, ptr noundef %0)\n%6 = load i64, ptr %5, align 8\n%7 = icmp ne i64 %6, 0\n%8 = zext i1 %7 to i32\nbr label %B2\n\nB2:\n%9 = phi i32 [ 0, %B ], [ %8, %B1 ]\nret i32 %9\n}", "codegemma": "define internal i32 @is_const_null(ptr noundef %0) {\nB:\n%1 = load i32, ptr @Const, align 4\n%2 = tail call i64 @IsA(ptr noundef %0, i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @Const, align 4\n%5 = tail call ptr @castNode(i32 noundef %4, ptr noundef %0)\n%6 = load i64, ptr %5, align 8\n%7 = icmp ne i64 %6, 0\n%8 = zext i1 %7 to i32\nbr label %B2\n\nB2:\n%9 = phi i32 [ 0, %B ], [ %8, %B1 ]\nret i32 %9\n}"}, "define dso_local void @fun() {\n%1 = load i32, ptr @i, align 4\n%2 = load i32, ptr @j, align 4\n%3 = call i32 @printf(ptr noundef @.str, i32 noundef %1, i32 noundef %2)\n%4 = call i32 (...) @fun1()\nret void\n}": {"base_truth": "define dso_local void @fun() {\nB:\n%0 = load i32, ptr @i, align 4\n%1 = load i32, ptr @j, align 4\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @fun1()\nret void\n}", "codellama": "define dso_local void @fun() {\nB:\n%0 = load i32, ptr @i, align 4\n%1 = load i32, ptr @j, align 4\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @fun1()\nret void\n}", "codegemma": "define dso_local void @fun() {\nB:\n%0 = load i32, ptr @i, align 4\n%1 = load i32, ptr @j, align 4\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @fun1()\nret void\n}"}, "define internal i32 @usbhsh_irq_setup_ack(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @usbhsh_priv_to_hpriv(ptr noundef %7)\nstore ptr %8, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%9 = load ptr, ptr %3, align 8\n%10 = call ptr @usbhs_priv_to_dev(ptr noundef %9)\nstore ptr %10, ptr %6, align 8\n%11 = load ptr, ptr %6, align 8\n%12 = call i32 @dev_dbg(ptr noundef %11, ptr noundef @.str)\n%13 = load ptr, ptr %5, align 8\n%14 = getelementptr inbounds %struct.usbhsh_hpriv ptr %13, i32 0, i32 0\n%15 = call i32 @complete(ptr noundef %14)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 0\n}": {"base_truth": "define internal i32 @usbhsh_irq_setup_ack(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call ptr @usbhsh_priv_to_hpriv(ptr noundef %0)\n%3 = tail call ptr @usbhs_priv_to_dev(ptr noundef %0)\n%4 = tail call i32 @dev_dbg(ptr noundef %3, ptr noundef nonnull @.str)\n%5 = tail call i32 @complete(ptr noundef %2)\nret i32 0\n}", "codellama": "define internal i32 @usbhsh_irq_setup_ack(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call ptr @usbhsh_priv_to_hpriv(ptr noundef %0)\n%3 = tail call ptr @usbhs_priv_to_dev(ptr noundef %0)\n%4 = tail call i32 @dev_dbg(ptr noundef %3, ptr noundef nonnull @.str)\n%5 = tail call i32 @complete(ptr noundef %2)\nret i32 0\n}", "codegemma": "define internal i32 @usbhsh_irq_setup_ack(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call ptr @usbhsh_priv_to_hpriv(ptr noundef %0)\n%3 = tail call ptr @usbhs_priv_to_dev(ptr noundef %0)\n%4 = tail call i32 @dev_dbg(ptr noundef %3, ptr noundef nonnull @.str)\n%5 = tail call i32 @complete(ptr noundef %2)\nret i32 0\n}"}, "define dso_local void @MicroProfile_end() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\nbr label %2\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = load i32, ptr @mprof_func_num, align 4\n%5 = icmp slt i32 %3, %4\nbr i1 %5, label %6, label %44\n\n6:\n%7 = load ptr, ptr @mprof_funcs, align 8\n%8 = load i32, ptr %1, align 4\n%9 = sext i32 %8 to i64\n%10 = getelementptr inbounds %struct.TYPE_2__, ptr %7, i64 %9\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %10, i32 0, i32 0\n%12 = load ptr, ptr %11, align 8\n%13 = load ptr, ptr @mprof_funcs, align 8\n%14 = load i32, ptr %1, align 4\n%15 = sext i32 %14 to i64\n%16 = getelementptr inbounds %struct.TYPE_2__, ptr %13, i64 %15\n%17 = getelementptr inbounds %struct.TYPE_2__, ptr %16, i32 0, i32 1\n%18 = load i32, ptr %17, align 8\n%19 = load ptr, ptr @mprof_funcs, align 8\n%20 = load i32, ptr %1, align 4\n%21 = sext i32 %20 to i64\n%22 = getelementptr inbounds %struct.TYPE_2__, ptr %19, i64 %21\n%23 = getelementptr inbounds %struct.TYPE_2__, ptr %22, i32 0, i32 2\n%24 = load i64, ptr %23, align 8\n%25 = load ptr, ptr @mprof_funcs, align 8\n%26 = load i32, ptr %1, align 4\n%27 = sext i32 %26 to i64\n%28 = getelementptr inbounds %struct.TYPE_2__, ptr %25, i64 %27\n%29 = getelementptr inbounds %struct.TYPE_2__, ptr %28, i32 0, i32 2\n%30 = load i64, ptr %29, align 8\n%31 = sitofp i64 %30 to double\n%32 = load ptr, ptr @mprof_funcs, align 8\n%33 = load i32, ptr %1, align 4\n%34 = sext i32 %33 to i64\n%35 = getelementptr inbounds %struct.TYPE_2__, ptr %32, i64 %34\n%36 = getelementptr inbounds %struct.TYPE_2__, ptr %35, i32 0, i32 1\n%37 = load i32, ptr %36, align 8\n%38 = sitofp i32 %37 to double\n%39 = fdiv fast double %31, %38\n%40 = call i32 @printf(ptr noundef @.str, ptr noundef %12, i32 noundef %18, i64 noundef %24, double noundef nofpclass(nan inf) %39)\nbr label %41\n\n41:\n%42 = load i32, ptr %1, align 4\n%43 = add nsw i32 %42, 1\nstore i32 %43, ptr %1, align 4\nbr label %2\n\n44:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @MicroProfile_end() {\nB:\n%0 = load i32, ptr @mprof_func_num, align 4\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i64 [ %14, %B1 ], [ 0, %B ]\n%3 = load ptr, ptr @mprof_funcs, align 8\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2\n%5 = load ptr, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2, i32 1\n%7 = load i32, ptr %6, align 8\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2, i32 2\n%9 = load i64, ptr %8, align 8\n%10 = sitofp i64 %9 to double\n%11 = sitofp i32 %7 to double\n%12 = fdiv fast double %10, %11\n%13 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %5, i32 noundef %7, i64 noundef %9, double noundef nofpclass(nan inf) %12)\n%14 = add nuw nsw i64 %2, 1\n%15 = load i32, ptr @mprof_func_num, align 4\n%16 = sext i32 %15 to i64\n%17 = icmp slt i64 %14, %16\nbr i1 %17, label %B1, label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @MicroProfile_end() {\nB:\n%0 = load i32, ptr @mprof_func_num, align 4\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i64 [ %16, %B1 ], [ 0, %B ]\n%3 = load ptr, ptr @mprof_funcs, align 8\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2\n%5 = load ptr, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2, i32 1\n%7 = load i32, ptr %6, align 8\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2, i32 2\n%9 = load i64, ptr %8, align 8\n%10 = sitofp i64 %9 to double\n%11 = sitofp i32 %7 to double\n%12 = fdiv fast double %10, %11\n%13 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %5, i32 noundef %7, i64 noundef %9, double noundef nofpclass(nan inf) %12)\n%14 = load i32, ptr @mprof_func_num, align 4\n%15 = sext i32 %14 to i64\n%16 = add nsw i64 %2, 1\n%17 = icmp slt i64 %16, %15\nbr i1 %17, label %B1, label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @MicroProfile_end() {\nB:\n%0 = load i32, ptr @mprof_func_num, align 4\n%1 = icmp sgt i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\n%2 = phi i64 [ %11, %B1 ], [ 0, %B ]\n%3 = load ptr, ptr @mprof_funcs, align 8\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2\n%5 = load ptr, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2, i32 1\n%7 = load i32, ptr %6, align 8\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %2, i32 2\n%9 = load i64, ptr %8, align 8\n%10 = sitofp i64 %9 to double\n%11 = add nuw nsw i64 %2, 1\n%12 = sext i32 %7 to i64\n%13 = sitofp i64 %12 to double\n%14 = fdiv fast double %10, %13\n%15 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %5, i32 noundef %7, i64 noundef %9, double noundef nofpclass(nan inf) %14)\n%16 = load i32, ptr @mprof_func_num, align 4\n%17 = sext i32 %16 to i64\n%18 = icmp slt i64 %11, %17\nbr i1 %18, label %B1, label %B3\n\nB2:\n%19 = add nuw nsw i64 %21, 1\n%20 = icmp eq i64 %19, %17\nbr i1 %20, label %B3, label %B2\n\nB3:\nret void\n}"}, "define dso_local void @Act_DoorExit() {\n%1 = alloca ptr, align 8\n%2 = alloca ptr, align 8\n%3 = alloca i16, align 2\n%4 = alloca i16, align 2\n%5 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%6 = call ptr (...) @ArgItem()\nstore ptr %6, ptr %1, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%7 = call ptr (...) @ArgItem()\nstore ptr %7, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 2, ptr %3)\n%8 = call i64 (...) @ArgNum()\n%9 = trunc i64 %8 to i16\nstore i16 %9, ptr %3, align 2\ncall void @llvm.lifetime.start.p0(i64 2, ptr %4)\nstore i16 0, ptr %4, align 2\nbr label %10\n\n10:\n%11 = load i16, ptr %4, align 2\n%12 = sext i16 %11 to i32\n%13 = icmp slt i32 %12, 12\nbr i1 %13, label %14, label %28\n\n14:\n%15 = load ptr, ptr %1, align 8\n%16 = load i16, ptr %4, align 2\n%17 = call ptr @DoorOf(ptr noundef %15, i16 noundef signext %16)\n%18 = load ptr, ptr %2, align 8\n%19 = icmp eq ptr %17, %18\nbr i1 %19, label %20, label %25\n\n20:\n%21 = load i16, ptr %3, align 2\n%22 = load i16, ptr %4, align 2\n%23 = sext i16 %22 to i32\n%24 = call i32 @SetFlag(i16 noundef signext %21, i32 noundef %23)\nstore i32 1, ptr %5, align 4\nbr label %31\n\n25:\n%26 = load i16, ptr %4, align 2\n%27 = add i16 %26, 1\nstore i16 %27, ptr %4, align 2\nbr label %10\n\n28:\n%29 = load i16, ptr %3, align 2\n%30 = call i32 @SetFlag(i16 noundef signext %29, i32 noundef 255)\nstore i32 1, ptr %5, align 4\nbr label %31\n\n31:\ncall void @llvm.lifetime.end.p0(i64 2, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 2, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @Act_DoorExit() {\nB:\n%0 = tail call ptr (...) @ArgItem()\n%1 = tail call ptr (...) @ArgItem()\n%2 = tail call i64 (...) @ArgNum()\n%3 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 0)\n%4 = icmp eq ptr %3, %1\nbr i1 %4, label %B12, label %B1\n\nB1:\n%5 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 1)\n%6 = icmp eq ptr %5, %1\nbr i1 %6, label %B12, label %B2\n\nB2:\n%7 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 2)\n%8 = icmp eq ptr %7, %1\nbr i1 %8, label %B12, label %B3\n\nB3:\n%9 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 3)\n%10 = icmp eq ptr %9, %1\nbr i1 %10, label %B12, label %B4\n\nB4:\n%11 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 4)\n%12 = icmp eq ptr %11, %1\nbr i1 %12, label %B12, label %B5\n\nB5:\n%13 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 5)\n%14 = icmp eq ptr %13, %1\nbr i1 %14, label %B12, label %B6\n\nB6:\n%15 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 6)\n%16 = icmp eq ptr %15, %1\nbr i1 %16, label %B12, label %B7\n\nB7:\n%17 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 7)\n%18 = icmp eq ptr %17, %1\nbr i1 %18, label %B12, label %B8\n\nB8:\n%19 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 8)\n%20 = icmp eq ptr %19, %1\nbr i1 %20, label %B12, label %B9\n\nB9:\n%21 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 9)\n%22 = icmp eq ptr %21, %1\nbr i1 %22, label %B12, label %B10\n\nB10:\n%23 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 10)\n%24 = icmp eq ptr %23, %1\nbr i1 %24, label %B12, label %B11\n\nB11:\n%25 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 11)\n%26 = icmp eq ptr %25, %1\n%27 = select i1 %26, i32 11, i32 255\nbr label %B12\n\nB12:\n%28 = phi i32 [ 0, %B ], [ 1, %B1 ], [ 2, %B2 ], [ 3, %B3 ], [ 4, %B4 ], [ 5, %B5 ], [ 6, %B6 ], [ 7, %B7 ], [ 8, %B8 ], [ 9, %B9 ], [ 10, %B10 ], [ %27, %B11 ]\n%29 = trunc i64 %2 to i16\n%30 = tail call i32 @SetFlag(i16 noundef signext %29, i32 noundef %28)\nret void\n}", "codellama": "define dso_local void @Act_DoorExit() {\nB:\n%0 = tail call ptr (...) @ArgItem()\n%1 = tail call ptr (...) @ArgItem()\n%2 = tail call i64 (...) @ArgNum()\n%3 = trunc i64 %2 to i16\n%4 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 0)\n%5 = icmp eq ptr %4, %1\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 0)\nbr label %B5\n\nB2:\n%7 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 1)\n%8 = icmp eq ptr %7, %1\nbr i1 %8, label %B3, label %B4\n\nB3:\n%9 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 1)\nbr label %B5\n\nB4:\n%10 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 2)\n%11 = icmp eq ptr %10, %1\nbr i1 %11, label %B5, label %B6\n\nB5:\n%12 = phi i32 [ 0, %B1 ], [ 1, %B3 ], [ 2, %B4 ]\n%13 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef %12)\nbr label %B6\n\nB6:\n%14 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 3)\n%15 = icmp eq ptr %14, %1\nbr i1 %15, label %B7, label %B8\n\nB7:\n%16 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 3)\nbr label %B8\n\nB8:\n%17 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 4)\n%18 = icmp eq ptr %17, %1\nbr i1 %18, label %B9, label %B10\n\nB9:\n%19 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 4)\nbr label %B10\n\nB10:\n%20 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 5)\n%21 = icmp eq ptr %20, %1\nbr i1 %21, label %B11, label %B12\n\nB11:\n%22 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 5)\nbr label %B12\n\nB12:\n%23 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 6)\n%24 = icmp eq ptr %23, %1\nbr i1 %24, label %B13, label %B14\n\nB13:\n%25 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 6)\nbr label %B14\n\nB14:\n%26 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 7)\n%27 = icmp eq ptr %26, %1\nbr i1 %27, label %B15, label %B16\n\nB15:\n%28 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 7)\nbr label %B16\n\nB16:\n%29 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 8)\n%30 = icmp eq ptr %29, %1\nbr i1 %30, label %B17, label %B18\n\nB17:\n%31 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 8)\nbr label %B18\n\nB18:\n%32 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 9)\n%33 = icmp eq ptr %32, %1\nbr i1 %33, label %B19, label %B20\n\nB19:\n%34 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 9)\nbr label %B20\n\nB20:\n%35 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 10)\n%36 = icmp eq ptr %35, %1\nbr i1 %36, label %B21, label %B22\n\nB21:\n%37 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 10)\nbr label %B22\n\nB22:\n%38 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 11)\n%39 = icmp eq ptr %38, %1\nbr i1 %39, label %B23, label %B24\n\nB23:\n%40 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 11)\nbr label %B24\n\nB24:\n%41 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 255)\nret void\n}", "codegemma": "define dso_local void @Act_DoorExit() {\nB:\n%0 = tail call ptr (...) @ArgItem()\n%1 = tail call ptr (...) @ArgItem()\n%2 = tail call i64 (...) @ArgNum()\n%3 = trunc i64 %2 to i16\n%4 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 0)\n%5 = icmp eq ptr %4, %1\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 0)\nbr label %B12\n\nB2:\n%7 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 1)\n%8 = icmp eq ptr %7, %1\nbr i1 %8, label %B3, label %B4\n\nB3:\n%9 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 1)\nbr label %B12\n\nB4:\n%10 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 2)\n%11 = icmp eq ptr %10, %1\nbr i1 %11, label %B5, label %B6\n\nB5:\n%12 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 2)\nbr label %B12\n\nB6:\n%13 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 3)\n%14 = icmp eq ptr %13, %1\nbr i1 %14, label %B7, label %B8\n\nB7:\n%15 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 3)\nbr label %B12\n\nB8:\n%16 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 4)\n%17 = icmp eq ptr %16, %1\nbr i1 %17, label %B9, label %B10\n\nB9:\n%18 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 4)\nbr label %B12\n\nB10:\n%19 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 5)\n%20 = icmp eq ptr %19, %1\nbr i1 %20, label %B11, label %B12\n\nB11:\n%21 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 5)\nbr label %B12\n\nB12:\n%22 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 6)\n%23 = icmp eq ptr %22, %1\nbr i1 %23, label %B13, label %B14\n\nB13:\n%24 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 6)\nbr label %B12\n\nB14:\n%25 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 7)\n%26 = icmp eq ptr %25, %1\nbr i1 %26, label %B15, label %B16\n\nB15:\n%27 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 7)\nbr label %B12\n\nB16:\n%28 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 8)\n%29 = icmp eq ptr %28, %1\nbr i1 %29, label %B17, label %B18\n\nB17:\n%30 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 8)\nbr label %B12\n\nB18:\n%31 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 9)\n%32 = icmp eq ptr %31, %1\nbr i1 %32, label %B19, label %B20\n\nB19:\n%33 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 9)\nbr label %B12\n\nB20:\n%34 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 10)\n%35 = icmp eq ptr %34, %1\nbr i1 %35, label %B21, label %B22\n\nB21:\n%36 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 10)\nbr label %B12\n\nB22:\n%37 = tail call ptr @DoorOf(ptr noundef %0, i16 noundef signext 11)\n%38 = icmp eq ptr %37, %1\nbr i1 %38, label %B23, label %B24\n\nB23:\n%39 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 11)\nbr label %B12\n\nB24:\n%40 = tail call i32 @SetFlag(i16 noundef signext %3, i32 noundef 255)\nret void\n}"}, "define internal void @xgene_sgmac_enable_tx_pause(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.xgene_enet_pdata ptr %7, i32 0, i32 0\n%9 = load i64, ptr %8, align 8\n%10 = load i64, ptr @XGENE_ENET1, align 8\n%11 = icmp eq i64 %9, %10\nbr i1 %11, label %12, label %24\n\n12:\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.xgene_enet_pdata ptr %13, i32 0, i32 1\n%15 = load i32, ptr %14, align 8\n%16 = srem i32 %15, 2\n%17 = icmp ne i32 %16, 0\nbr i1 %17, label %20, label %18\n\n18:\n%19 = load i32, ptr @CSR_ECM_CFG_0_ADDR, align 4\nbr label %22\n\n20:\n%21 = load i32, ptr @CSR_ECM_CFG_1_ADDR, align 4\nbr label %22\n\n22:\n%23 = phi i32 [ %19, %18 ], [ %21, %20 ]\nstore i32 %23, ptr %6, align 4\nbr label %26\n\n24:\n%25 = load i32, ptr @XG_MCX_ECM_CFG_0_ADDR, align 4\nstore i32 %25, ptr %6, align 4\nbr label %26\n\n26:\n%27 = load ptr, ptr %3, align 8\n%28 = load i32, ptr %6, align 4\n%29 = call i32 @xgene_enet_rd_mcx_csr(ptr noundef %27, i32 noundef %28)\nstore i32 %29, ptr %5, align 4\n%30 = load i32, ptr %4, align 4\n%31 = icmp ne i32 %30, 0\nbr i1 %31, label %32, label %38\n\n32:\n%33 = load i32, ptr @MULTI_DPF_AUTOCTRL, align 4\n%34 = load i32, ptr @PAUSE_XON_EN, align 4\n%35 = or i32 %33, %34\n%36 = load i32, ptr %5, align 4\n%37 = or i32 %36, %35\nstore i32 %37, ptr %5, align 4\nbr label %45\n\n38:\n%39 = load i32, ptr @MULTI_DPF_AUTOCTRL, align 4\n%40 = load i32, ptr @PAUSE_XON_EN, align 4\n%41 = or i32 %39, %40\n%42 = xor i32 %41, -1\n%43 = load i32, ptr %5, align 4\n%44 = and i32 %43, %42\nstore i32 %44, ptr %5, align 4\nbr label %45\n\n45:\n%46 = load ptr, ptr %3, align 8\n%47 = load i32, ptr %6, align 4\n%48 = load i32, ptr %5, align 4\n%49 = call i32 @xgene_enet_wr_mcx_csr(ptr noundef %46, i32 noundef %47, i32 noundef %48)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @xgene_sgmac_enable_tx_pause(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @XGENE_ENET1, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = getelementptr inbounds %struct.xgene_enet_pdata, ptr %0, i64 0, i32 1\n%6 = load i32, ptr %5, align 8\n%7 = and i32 %6, 1\n%8 = icmp eq i32 %7, 0\n%9 = load i32, ptr @CSR_ECM_CFG_0_ADDR, align 4\n%10 = load i32, ptr @CSR_ECM_CFG_1_ADDR, align 4\n%11 = select i1 %8, i32 %9, i32 %10\nbr label %B3\n\nB2:\n%12 = load i32, ptr @XG_MCX_ECM_CFG_0_ADDR, align 4\nbr label %B3\n\nB3:\n%13 = phi i32 [ %11, %B1 ], [ %12, %B2 ]\n%14 = tail call i32 @xgene_enet_rd_mcx_csr(ptr noundef nonnull %0, i32 noundef %13)\n%15 = icmp eq i32 %1, 0\n%16 = load i32, ptr @MULTI_DPF_AUTOCTRL, align 4\n%17 = load i32, ptr @PAUSE_XON_EN, align 4\nbr i1 %15, label %B5, label %B4\n\nB4:\n%18 = or i32 %16, %17\n%19 = or i32 %18, %14\nbr label %B6\n\nB5:\n%20 = or i32 %17, %16\n%21 = xor i32 %20, -1\n%22 = and i32 %14, %21\nbr label %B6\n\nB6:\n%23 = phi i32 [ %19, %B4 ], [ %22, %B5 ]\n%24 = tail call i32 @xgene_enet_wr_mcx_csr(ptr noundef nonnull %0, i32 noundef %13, i32 noundef %23)\nret void\n}", "codellama": "define internal void @xgene_sgmac_enable_tx_pause(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @XGENE_ENET1, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = getelementptr inbounds %struct.xgene_enet_pdata, ptr %0, i64 0, i32 1\n%6 = load i32, ptr %5, align 8\n%7 = and i32 %6, 1\n%8 = icmp eq i32 %7, 0\n%9 = load i32, ptr @CSR_ECM_CFG_0_ADDR, align 4\n%10 = load i32, ptr @CSR_ECM_CFG_1_ADDR, align 4\n%11 = select i1 %8, i32 %9, i32 %10\nbr label %B2\n\nB2:\n%12 = phi i32 [ %11, %B1 ], [ 0, %B ]\n%13 = tail call i32 @xgene_enet_rd_mcx_csr(ptr noundef nonnull %0, i32 noundef %12)\n%14 = icmp eq i32 %1, 0\n%15 = load i32, ptr @MULTI_DPF_AUTOCTRL, align 4\n%16 = load i32, ptr @PAUSE_XON_EN, align 4\n%17 = or i32 %15, %16\n%18 = or i32 %17, %13\n%19 = xor i32 %17, -1\n%20 = and i32 %13, %19\n%21 = select i1 %14, i32 %20, i32 %18\n%22 = tail call i32 @xgene_enet_wr_mcx_csr(ptr noundef nonnull %0, i32 noundef %12, i32 noundef %21)\nret void\n}", "codegemma": "define internal void @xgene_sgmac_enable_tx_pause(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @XGENE_ENET1, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = getelementptr inbounds %struct.xgene_enet_pdata, ptr %0, i64 0, i32 1\n%6 = load i32, ptr %5, align 8\n%7 = and i32 %6, 1\n%8 = icmp eq i32 %7, 0\n%9 = load i32, ptr @CSR_ECM_CFG_0_ADDR, align 4\n%10 = load i32, ptr @CSR_ECM_CFG_1_ADDR, align 4\n%11 = select i1 %8, i32 %9, i32 %10\nbr label %B2\n\nB2:\n%12 = phi i32 [ %11, %B1 ], [ @XG_MCX_ECM_CFG_0_ADDR, %B ]\n%13 = tail call i32 @xgene_enet_rd_mcx_csr(ptr noundef nonnull %0, i32 noundef %12)\n%14 = icmp eq i32 %1, 0\n%15 = load i32, ptr @MULTI_DPF_AUTOCTRL, align 4\n%16 = load i32, ptr @PAUSE_XON_EN, align 4\n%17 = or i32 %15, %16\n%18 = xor i32 %17, -1\n%19 = and i32 %13, %18\n%20 = or i32 %17, %13\n%21 = select i1 %14, i32 %19, i32 %20\n%22 = tail call i32 @xgene_enet_wr_mcx_csr(ptr noundef nonnull %0, i32 noundef %12, i32 noundef %21)\nret void\n}"}, "define internal i32 @ffsUmountVol(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @EXFAT_SB(ptr noundef %5)\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i32 0, i32 0\nstore ptr %7, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%8 = load i32, ptr @FFS_SUCCESS, align 4\nstore i32 %8, ptr %4, align 4\n%9 = call i32 @pr_info(ptr noundef @.str)\n%10 = call i32 @down(ptr noundef @z_sem)\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.fs_info_t ptr %11, i32 0, i32 1\n%13 = call i32 @down(ptr noundef %12)\n%14 = load ptr, ptr %2, align 8\n%15 = call i32 @fs_sync(ptr noundef %14, i32 noundef 0)\n%16 = load ptr, ptr %2, align 8\n%17 = load i32, ptr @VOL_CLEAN, align 4\n%18 = call i32 @fs_set_vol_flags(ptr noundef %16, i32 noundef %17)\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.fs_info_t ptr %19, i32 0, i32 0\n%21 = load i64, ptr %20, align 8\n%22 = load i64, ptr @EXFAT, align 8\n%23 = icmp eq i64 %21, %22\nbr i1 %23, label %24, label %29\n\n24:\n%25 = load ptr, ptr %2, align 8\n%26 = call i32 @free_upcase_table(ptr noundef %25)\n%27 = load ptr, ptr %2, align 8\n%28 = call i32 @free_alloc_bitmap(ptr noundef %27)\nbr label %29\n\n29:\n%30 = load ptr, ptr %2, align 8\n%31 = call i32 @FAT_release_all(ptr noundef %30)\n%32 = load ptr, ptr %2, align 8\n%33 = call i32 @buf_release_all(ptr noundef %32)\n%34 = load ptr, ptr %2, align 8\n%35 = call i32 @bdev_close(ptr noundef %34)\n%36 = load ptr, ptr %3, align 8\n%37 = getelementptr inbounds %struct.fs_info_t ptr %36, i32 0, i32 2\n%38 = load i64, ptr %37, align 8\n%39 = icmp ne i64 %38, 0\nbr i1 %39, label %40, label %43\n\n40:\n%41 = call i32 @pr_info(ptr noundef @.str.1)\n%42 = load i32, ptr @FFS_MEDIAERR, align 4\nstore i32 %42, ptr %4, align 4\nbr label %43\n\n43:\n%44 = load ptr, ptr %2, align 8\n%45 = call i32 @buf_shutdown(ptr noundef %44)\n%46 = load ptr, ptr %3, align 8\n%47 = getelementptr inbounds %struct.fs_info_t ptr %46, i32 0, i32 1\n%48 = call i32 @up(ptr noundef %47)\n%49 = call i32 @up(ptr noundef @z_sem)\n%50 = call i32 @pr_info(ptr noundef @.str.2)\n%51 = load i32, ptr %4, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %51\n}": {"base_truth": "define internal i32 @ffsUmountVol(ptr noundef %0) {\nB:\n%1 = tail call ptr @EXFAT_SB(ptr noundef %0)\n%2 = load i32, ptr @FFS_SUCCESS, align 4\n%3 = tail call i32 @pr_info(ptr noundef nonnull @.str)\n%4 = tail call i32 @down(ptr noundef nonnull @z_sem)\n%5 = getelementptr inbounds %struct.fs_info_t, ptr %1, i64 0, i32 1\n%6 = tail call i32 @down(ptr noundef nonnull %5)\n%7 = tail call i32 @fs_sync(ptr noundef %0, i32 noundef 0)\n%8 = load i32, ptr @VOL_CLEAN, align 4\n%9 = tail call i32 @fs_set_vol_flags(ptr noundef %0, i32 noundef %8)\n%10 = load i64, ptr %1, align 8\n%11 = load i64, ptr @EXFAT, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = tail call i32 @free_upcase_table(ptr noundef %0)\n%14 = tail call i32 @free_alloc_bitmap(ptr noundef %0)\nbr label %B2\n\nB2:\n%15 = tail call i32 @FAT_release_all(ptr noundef %0)\n%16 = tail call i32 @buf_release_all(ptr noundef %0)\n%17 = tail call i32 @bdev_close(ptr noundef %0)\n%18 = getelementptr inbounds %struct.fs_info_t, ptr %1, i64 0, i32 2\n%19 = load i64, ptr %18, align 8\n%20 = icmp eq i64 %19, 0\nbr i1 %20, label %B4, label %B3\n\nB3:\n%21 = tail call i32 @pr_info(ptr noundef nonnull @.str.1)\n%22 = load i32, ptr @FFS_MEDIAERR, align 4\nbr label %B4\n\nB4:\n%23 = phi i32 [ %22, %B3 ], [ %2, %B2 ]\n%24 = tail call i32 @buf_shutdown(ptr noundef %0)\n%25 = tail call i32 @up(ptr noundef nonnull %5)\n%26 = tail call i32 @up(ptr noundef nonnull @z_sem)\n%27 = tail call i32 @pr_info(ptr noundef nonnull @.str.2)\nret i32 %23\n}", "codellama": "define internal i32 @ffsUmountVol(ptr noundef %0) {\nB:\n%1 = tail call ptr @EXFAT_SB(ptr noundef %0)\n%2 = load i32, ptr @FFS_SUCCESS, align 4\n%3 = tail call i32 @pr_info(ptr noundef nonnull @.str)\n%4 = tail call i32 @down(ptr noundef nonnull @z_sem)\n%5 = getelementptr inbounds %struct.fs_info_t, ptr %1, i64 0, i32 1\n%6 = tail call i32 @down(ptr noundef nonnull %5)\n%7 = tail call i32 @fs_sync(ptr noundef %0, i32 noundef 0)\n%8 = load i32, ptr @VOL_CLEAN, align 4\n%9 = tail call i32 @fs_set_vol_flags(ptr noundef %0, i32 noundef %8)\n%10 = load i64, ptr %1, align 8\n%11 = load i64, ptr @EXFAT, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = tail call i32 @free_upcase_table(ptr noundef %0)\n%14 = tail call i32 @free_alloc_bitmap(ptr noundef %0)\nbr label %B2\n\nB2:\n%15 = tail call i32 @FAT_release_all(ptr noundef %0)\n%16 = tail call i32 @buf_release_all(ptr noundef %0)\n%17 = tail call i32 @bdev_close(ptr noundef %0)\n%18 = getelementptr inbounds %struct.fs_info_t, ptr %1, i64 0, i32 2\n%19 = load i64, ptr %18, align 8\n%20 = icmp eq i64 %19, 0\nbr i1 %20, label %B4, label %B3\n\nB3:\n%21 = tail call i32 @pr_info(ptr noundef nonnull @.str.1)\n%22 = load i32, ptr @FFS_MEDIAERR, align 4\nbr label %B4\n\nB4:\n%23 = phi i32 [ %22, %B3 ], [ %2, %B2 ]\n%24 = tail call i32 @buf_shutdown(ptr noundef %0)\n%25 = tail call i32 @up(ptr noundef nonnull %5)\n%26 = tail call i32 @up(ptr noundef nonnull @z_sem)\n%27 = tail call i32 @pr_info(ptr noundef nonnull @.str.2)\nret i32 %23\n}", "codegemma": "define internal i32 @ffsUmountVol(ptr noundef %0) {\nB:\n%1 = tail call ptr @EXFAT_SB(ptr noundef %0)\n%2 = load i32, ptr @FFS_SUCCESS, align 4\n%3 = tail call i32 @pr_info(ptr noundef nonnull @.str)\n%4 = tail call i32 @down(ptr noundef nonnull @z_sem)\n%5 = getelementptr inbounds %struct.fs_info_t, ptr %1, i64 0, i32 1\n%6 = tail call i32 @down(ptr noundef nonnull %5)\n%7 = tail call i32 @fs_sync(ptr noundef %0, i32 noundef 0)\n%8 = load i32, ptr @VOL_CLEAN, align 4\n%9 = tail call i32 @fs_set_vol_flags(ptr noundef %0, i32 noundef %8)\n%10 = load i64, ptr %1, align 8\n%11 = load i64, ptr @EXFAT, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = tail call i32 @free_upcase_table(ptr noundef %0)\n%14 = tail call i32 @free_alloc_bitmap(ptr noundef %0)\nbr label %B2\n\nB2:\n%15 = tail call i32 @FAT_release_all(ptr noundef %0)\n%16 = tail call i32 @buf_release_all(ptr noundef %0)\n%17 = tail call i32 @bdev_close(ptr noundef %0)\n%18 = getelementptr inbounds %struct.fs_info_t, ptr %1, i64 0, i32 2\n%19 = load i64, ptr %18, align 8\n%20 = icmp eq i64 %19, 0\nbr i1 %20, label %B4, label %B3\n\nB3:\n%21 = tail call i32 @pr_info(ptr noundef nonnull @.str.1)\n%22 = load i32, ptr @FFS_MEDIAERR, align 4\nbr label %B4\n\nB4:\n%23 = phi i32 [ %22, %B3 ], [ %2, %B2 ]\n%24 = tail call i32 @buf_shutdown(ptr noundef %0)\n%25 = tail call i32 @up(ptr noundef nonnull %5)\n%26 = tail call i32 @up(ptr noundef nonnull @z_sem)\n%27 = tail call i32 @pr_info(ptr noundef nonnull @.str.2)\nret i32 %23\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 1, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 1, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 4000000, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\nbr label %7\n\n7:\n%8 = load i32, ptr %2, align 4\n%9 = load i32, ptr %3, align 4\n%10 = add i32 %8, %9\nstore i32 %10, ptr %4, align 4\n%11 = load i32, ptr %3, align 4\nstore i32 %11, ptr %2, align 4\n%12 = load i32, ptr %4, align 4\nstore i32 %12, ptr %3, align 4\n%13 = load i32, ptr %4, align 4\n%14 = load i32, ptr %5, align 4\n%15 = icmp ugt i32 %13, %14\nbr i1 %15, label %16, label %17\n\n16:\nbr label %29\n\n17:\n%18 = load i32, ptr %4, align 4\n%19 = urem i32 %18, 2\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %21, label %27\n\n21:\n%22 = load i32, ptr %4, align 4\n%23 = call i32 @printf(ptr noundef @.str, i32 noundef %22)\n%24 = load i32, ptr %4, align 4\n%25 = load i32, ptr %6, align 4\n%26 = add i32 %25, %24\nstore i32 %26, ptr %6, align 4\nbr label %27\n\n27:\nbr label %28\n\n28:\nbr label %7\n\n29:\n%30 = load i32, ptr %6, align 4\n%31 = call i32 @printf(ptr noundef @.str.1, i32 noundef %30)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 2, %B ], [ %8, %B3 ]\n%1 = phi i32 [ 0, %B ], [ %7, %B3 ]\n%2 = phi i32 [ 1, %B ], [ %0, %B3 ]\n%3 = and i32 %0, 1\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = add i32 %1, %0\n%6 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nbr label %B3\n\nB3:\n%7 = phi i32 [ %5, %B2 ], [ %1, %B1 ]\n%8 = add nuw nsw i32 %2, %0\n%9 = icmp ugt i32 %8, 4000000\nbr i1 %9, label %B4, label %B1\n\nB4:\n%10 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %7)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 1, %B ], [ %10, %B1 ]\n%1 = phi i32 [ 1, %B ], [ %9, %B1 ]\n%2 = phi i32 [ 0, %B ], [ %8, %B1 ]\n%3 = add i32 %1, %0\n%4 = icmp ugt i32 %3, 4000000\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %2)\nret i32 0\n\nB3:\n%6 = and i32 %3, 1\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B4, label %B5\n\nB4:\n%8 = add i32 %2, %3\n%9 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %3)\nbr label %B1\n\nB5:\n%10 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %2)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 1, %B ], [ %1, %B2 ]\n%1 = phi i32 [ 1, %B ], [ %2, %B2 ]\n%2 = add nuw i32 %1, %0\n%3 = icmp ugt i32 %2, 4000000\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = and i32 %2, 1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB3:\n%6 = phi i32 [ 0, %B2 ], [ %2, %B1 ]\n%7 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6)\nret i32 0\n}"}, "define dso_local void @snd_hdac_ext_bus_ppcap_enable(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.hdac_bus ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = icmp ne i32 %7, 0\nbr i1 %8, label %14, label %9\n\n9:\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.hdac_bus ptr %10, i32 0, i32 1\n%12 = load i32, ptr %11, align 4\n%13 = call i32 @dev_err(i32 noundef %12, ptr noundef @.str)\nbr label %32\n\n14:\n%15 = load i32, ptr %4, align 4\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %17, label %25\n\n17:\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.hdac_bus ptr %18, i32 0, i32 0\n%20 = load i32, ptr %19, align 4\n%21 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%22 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%23 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%24 = call i32 @snd_hdac_updatel(i32 noundef %20, i32 noundef %21, i32 noundef %22, i32 noundef %23)\nbr label %32\n\n25:\n%26 = load ptr, ptr %3, align 8\n%27 = getelementptr inbounds %struct.hdac_bus ptr %26, i32 0, i32 0\n%28 = load i32, ptr %27, align 4\n%29 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%30 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%31 = call i32 @snd_hdac_updatel(i32 noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef 0)\nbr label %32\n\n32:\nret void\n}": {"base_truth": "define dso_local void @snd_hdac_ext_bus_ppcap_enable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = getelementptr inbounds %struct.hdac_bus, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @dev_err(i32 noundef %5, ptr noundef nonnull @.str)\nbr label %B5\n\nB2:\n%7 = icmp eq i32 %1, 0\n%8 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%9 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\nbr i1 %7, label %B4, label %B3\n\nB3:\n%10 = tail call i32 @snd_hdac_updatel(i32 noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef %9)\nbr label %B5\n\nB4:\n%11 = tail call i32 @snd_hdac_updatel(i32 noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef 0)\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define dso_local void @snd_hdac_ext_bus_ppcap_enable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = getelementptr inbounds %struct.hdac_bus, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @dev_err(i32 noundef %5, ptr noundef nonnull @.str)\nbr label %B5\n\nB2:\n%7 = icmp eq i32 %1, 0\n%8 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%9 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%10 = select i1 %7, i32 0, i32 %9\n%11 = tail call i32 @snd_hdac_updatel(i32 noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef %10)\n%12 = load i32, ptr %0, align 4\n%13 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%14 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%15 = tail call i32 @snd_hdac_updatel(i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef 0)\nbr label %B5\n\nB3:\n%16 = load i32, ptr %0, align 4\n%17 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%18 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%19 = tail call i32 @snd_hdac_updatel(i32 noundef %16, i32 noundef %17, i32 noundef %18, i32 noundef 0)\nbr label %B5\n\nB4:\n%20 = load i32, ptr %0, align 4\n%21 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%22 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\n%23 = tail call i32 @snd_hdac_updatel(i32 noundef %20, i32 noundef %21, i32 noundef %22, i32 noundef 0)\nbr label %B5\n\nB5:\nret void\n}", "codegemma": "define dso_local void @snd_hdac_ext_bus_ppcap_enable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = getelementptr inbounds %struct.hdac_bus, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @dev_err(i32 noundef %5, ptr noundef nonnull @.str)\nbr label %B5\n\nB2:\n%7 = icmp eq i32 %1, 0\n%8 = load i32, ptr @AZX_REG_PP_PPCTL, align 4\n%9 = load i32, ptr @AZX_PPCTL_GPROCEN, align 4\nbr i1 %7, label %B4, label %B3\n\nB3:\n%10 = tail call i32 @snd_hdac_updatel(i32 noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef %9)\nbr label %B5\n\nB4:\n%11 = tail call i32 @snd_hdac_updatel(i32 noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef 0)\nbr label %B5\n\nB5:\nret void\n}"}, "define dso_local i32 @option_read_dynfile(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr @LOG_DAEMON, align 4\n%7 = load i32, ptr @LOG_INFO, align 4\n%8 = or i32 %6, %7\n%9 = load ptr, ptr %4, align 8\n%10 = call i32 @my_syslog(i32 noundef %8, ptr noundef @.str, ptr noundef %9)\n%11 = load i32, ptr %5, align 4\n%12 = and i32 %11, 16\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %14, label %17\n\n14:\n%15 = load ptr, ptr %4, align 8\n%16 = call i32 @one_file(ptr noundef %15, i32 noundef 272)\nstore i32 %16, ptr %3, align 4\nbr label %26\n\n17:\n%18 = load i32, ptr %5, align 4\n%19 = and i32 %18, 32\n%20 = icmp ne i32 %19, 0\nbr i1 %20, label %21, label %24\n\n21:\n%22 = load ptr, ptr %4, align 8\n%23 = call i32 @one_file(ptr noundef %22, i32 noundef 279)\nstore i32 %23, ptr %3, align 4\nbr label %26\n\n24:\nbr label %25\n\n25:\nstore i32 0, ptr %3, align 4\nbr label %26\n\n26:\n%27 = load i32, ptr %3, align 4\nret i32 %27\n}": {"base_truth": "define dso_local i32 @option_read_dynfile(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @LOG_DAEMON, align 4\n%3 = load i32, ptr @LOG_INFO, align 4\n%4 = or i32 %3, %2\n%5 = tail call i32 @my_syslog(i32 noundef %4, ptr noundef nonnull @.str, ptr noundef %0)\n%6 = and i32 %1, 16\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = and i32 %1, 32\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = phi i32 [ 272, %B ], [ 279, %B1 ]\n%11 = tail call i32 @one_file(ptr noundef %0, i32 noundef %10)\nbr label %B3\n\nB3:\n%12 = phi i32 [ 0, %B1 ], [ %11, %B2 ]\nret i32 %12\n}", "codellama": "define dso_local i32 @option_read_dynfile(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @LOG_DAEMON, align 4\n%3 = load i32, ptr @LOG_INFO, align 4\n%4 = or i32 %3, %2\n%5 = tail call i32 @my_syslog(i32 noundef %4, ptr noundef nonnull @.str, ptr noundef %0)\n%6 = and i32 %1, 16\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = tail call i32 @one_file(ptr noundef %0, i32 noundef 272)\nbr label %B4\n\nB2:\n%9 = and i32 %1, 32\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @one_file(ptr noundef %0, i32 noundef 279)\nbr label %B4\n\nB4:\n%12 = phi i32 [ %8, %B1 ], [ %11, %B3 ], [ 0, %B2 ]\nret i32 %12\n}", "codegemma": "define dso_local i32 @option_read_dynfile(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @LOG_DAEMON, align 4\n%3 = load i32, ptr @LOG_INFO, align 4\n%4 = or i32 %3, %2\n%5 = tail call i32 @my_syslog(i32 noundef %4, ptr noundef nonnull @.str, ptr noundef %0)\n%6 = and i32 %1, 16\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = tail call i32 @one_file(ptr noundef %0, i32 noundef 272)\nbr label %B4\n\nB2:\n%9 = and i32 %1, 32\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @one_file(ptr noundef %0, i32 noundef 279)\nbr label %B4\n\nB4:\n%12 = phi i32 [ %8, %B1 ], [ %11, %B3 ], [ 0, %B2 ]\nret i32 %12\n}"}, "define dso_local nofpclass(nan inf) double @get_n_triangle(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3) {\n%5 = alloca double, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca ptr, align 8\n%9 = alloca ptr, align 8\n%10 = alloca [3 x double], align 16\n%11 = alloca [3 x double], align 16\nstore ptr %0, ptr %6, align 8\nstore ptr %1, ptr %7, align 8\nstore ptr %2, ptr %8, align 8\nstore ptr %3, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 24, ptr %11)\n%12 = load ptr, ptr %6, align 8\n%13 = getelementptr inbounds double, ptr %12, i64 0\n%14 = load double, ptr %13, align 8\n%15 = load ptr, ptr %7, align 8\n%16 = getelementptr inbounds double, ptr %15, i64 0\n%17 = load double, ptr %16, align 8\n%18 = fsub fast double %14, %17\n%19 = getelementptr inbounds [3 x double], ptr %10, i64 0, i64 0\nstore double %18, ptr %19, align 16\n%20 = load ptr, ptr %6, align 8\n%21 = getelementptr inbounds double, ptr %20, i64 1\n%22 = load double, ptr %21, align 8\n%23 = load ptr, ptr %7, align 8\n%24 = getelementptr inbounds double, ptr %23, i64 1\n%25 = load double, ptr %24, align 8\n%26 = fsub fast double %22, %25\n%27 = getelementptr inbounds [3 x double], ptr %10, i64 0, i64 1\nstore double %26, ptr %27, align 8\n%28 = load ptr, ptr %6, align 8\n%29 = getelementptr inbounds double, ptr %28, i64 2\n%30 = load double, ptr %29, align 8\n%31 = load ptr, ptr %7, align 8\n%32 = getelementptr inbounds double, ptr %31, i64 2\n%33 = load double, ptr %32, align 8\n%34 = fsub fast double %30, %33\n%35 = getelementptr inbounds [3 x double], ptr %10, i64 0, i64 2\nstore double %34, ptr %35, align 16\n%36 = load ptr, ptr %8, align 8\n%37 = getelementptr inbounds double, ptr %36, i64 0\n%38 = load double, ptr %37, align 8\n%39 = load ptr, ptr %7, align 8\n%40 = getelementptr inbounds double, ptr %39, i64 0\n%41 = load double, ptr %40, align 8\n%42 = fsub fast double %38, %41\n%43 = getelementptr inbounds [3 x double], ptr %11, i64 0, i64 0\nstore double %42, ptr %43, align 16\n%44 = load ptr, ptr %8, align 8\n%45 = getelementptr inbounds double, ptr %44, i64 1\n%46 = load double, ptr %45, align 8\n%47 = load ptr, ptr %7, align 8\n%48 = getelementptr inbounds double, ptr %47, i64 1\n%49 = load double, ptr %48, align 8\n%50 = fsub fast double %46, %49\n%51 = getelementptr inbounds [3 x double], ptr %11, i64 0, i64 1\nstore double %50, ptr %51, align 8\n%52 = load ptr, ptr %8, align 8\n%53 = getelementptr inbounds double, ptr %52, i64 2\n%54 = load double, ptr %53, align 8\n%55 = load ptr, ptr %7, align 8\n%56 = getelementptr inbounds double, ptr %55, i64 2\n%57 = load double, ptr %56, align 8\n%58 = fsub fast double %54, %57\n%59 = getelementptr inbounds [3 x double], ptr %11, i64 0, i64 2\nstore double %58, ptr %59, align 16\n%60 = getelementptr inbounds [3 x double], ptr %10, i64 0, i64 0\n%61 = getelementptr inbounds [3 x double], ptr %11, i64 0, i64 0\n%62 = load ptr, ptr %9, align 8\n%63 = call i32 @CrossProduct(ptr noundef %60, ptr noundef %61, ptr noundef %62)\ncall void @llvm.lifetime.end.p0(i64 24, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 24, ptr %10)\n%64 = load double, ptr %5, align 8\nret double %64\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @get_n_triangle(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2, ptr noundef %3) {\nB:\n%4 = alloca [3 x double], align 16\n%5 = alloca [3 x double], align 16\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %5)\n%6 = load <2 x double>, ptr %0, align 8\n%7 = load <2 x double>, ptr %1, align 8\n%8 = fsub fast <2 x double> %6, %7\nstore <2 x double> %8, ptr %4, align 16\n%9 = getelementptr inbounds double, ptr %0, i64 2\n%10 = load double, ptr %9, align 8\n%11 = getelementptr inbounds double, ptr %1, i64 2\n%12 = load double, ptr %11, align 8\n%13 = fsub fast double %10, %12\n%14 = getelementptr inbounds [3 x double], ptr %4, i64 0, i64 2\nstore double %13, ptr %14, align 16\n%15 = load <2 x double>, ptr %2, align 8\n%16 = fsub fast <2 x double> %15, %7\nstore <2 x double> %16, ptr %5, align 16\n%17 = getelementptr inbounds double, ptr %2, i64 2\n%18 = load double, ptr %17, align 8\n%19 = fsub fast double %18, %12\n%20 = getelementptr inbounds [3 x double], ptr %5, i64 0, i64 2\nstore double %19, ptr %20, align 16\n%21 = call i32 @CrossProduct(ptr noundef nonnull %4, ptr noundef nonnull %5, ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)\nret double undef\n}", "codellama": "define dso_local nofpclass(nan inf) double @get_n_triangle(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2, ptr noundef %3) {\nB:\n%4 = alloca [3 x double], align 16\n%5 = alloca [3 x double], align 16\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %5)\n%6 = load <2 x double>, ptr %0, align 8\n%7 = load <2 x double>, ptr %1, align 8\n%8 = fsub fast <2 x double> %6, %7\nstore <2 x double> %8, ptr %4, align 16\n%9 = getelementptr inbounds double, ptr %0, i64 2\n%10 = getelementptr inbounds double, ptr %1, i64 2\n%11 = fsub fast <2 x double> %9, %10\nstore <2 x double> %11, ptr %5, align 16\n%12 = call i32 @CrossProduct(ptr noundef nonnull %4, ptr noundef nonnull %5, ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)\nret double undef\n}", "codegemma": "define dso_local nofpclass(nan inf) double @get_n_triangle(ptr nocapture noundef %0, ptr nocapture noundef %1, ptr nocapture noundef %2, ptr noundef %3) {\nB:\n%4 = alloca [3 x double], align 16\n%5 = alloca [3 x double], align 16\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %5)\n%6 = load double, ptr %0, align 8\n%7 = load double, ptr %1, align 8\n%8 = fsub fast double %6, %7\nstore double %8, ptr %4, align 16\n%9 = getelementptr inbounds double, ptr %0, i64 1\n%10 = load <2 x double>, ptr %9, align 8\n%11 = getelementptr inbounds double, ptr %1, i64 1\n%12 = load <2 x double>, ptr %11, align 8\n%13 = fsub fast <2 x double> %10, %12\n%14 = getelementptr inbounds double, ptr %0, i64 2\n%15 = load double, ptr %14, align 8\n%16 = getelementptr inbounds double, ptr %1, i64 2\n%17 = load double, ptr %16, align 8\n%18 = fsub fast double %15, %17\n%19 = getelementptr inbounds [3 x double], ptr %5, i64 0, i64 0\nstore double %18, ptr %19, align 16\n%20 = load double, ptr %2, align 8\n%21 = load double, ptr %1, align 8\n%22 = fsub fast double %20, %21\nstore double %22, ptr %5, align 16\n%23 = getelementptr inbounds double, ptr %2, i64 1\n%24 = load double, ptr %23, align 8\n%25 = getelementptr inbounds double, ptr %1, i64 1\n%26 = load double, ptr %25, align 8\n%27 = fsub fast double %24, %26\n%28 = getelementptr inbounds double, ptr %2, i64 2\n%29 = load double, ptr %28, align 8\n%30 = getelementptr inbounds double, ptr %1, i64 2\n%31 = load double, ptr %30, align 8\n%32 = fsub fast double %29, %31\n%33 = call i32 @CrossProduct(ptr noundef nonnull %4, ptr noundef nonnull %5, ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)\nret double undef\n}"}, "define dso_local i32 @is_same_repeating_digits(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%7 = load ptr, ptr @cardbuf, align 8\n%8 = getelementptr inbounds i32, ptr %7, i64 0\n%9 = load i32, ptr %8, align 4\nstore i32 %9, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%10 = load ptr, ptr @cardbuf, align 8\n%11 = getelementptr inbounds i32, ptr %10, i64 1\n%12 = load i32, ptr %11, align 4\nstore i32 %12, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\nstore i32 0, ptr %3, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %3, align 4\n%15 = load i32, ptr %2, align 4\n%16 = icmp slt i32 %14, %15\nbr i1 %16, label %17, label %45\n\n17:\n%18 = load ptr, ptr @cardbuf, align 8\n%19 = load i32, ptr %3, align 4\n%20 = sext i32 %19 to i64\n%21 = getelementptr inbounds i32, ptr %18, i64 %20\n%22 = load i32, ptr %21, align 4\n%23 = load i32, ptr %4, align 4\n%24 = icmp eq i32 %22, %23\nbr i1 %24, label %25, label %40\n\n25:\n%26 = load i32, ptr %3, align 4\n%27 = add nsw i32 %26, 1\n%28 = load i32, ptr %2, align 4\n%29 = icmp sge i32 %27, %28\nbr i1 %29, label %39, label %30\n\n30:\n%31 = load ptr, ptr @cardbuf, align 8\n%32 = load i32, ptr %3, align 4\n%33 = add nsw i32 %32, 1\n%34 = sext i32 %33 to i64\n%35 = getelementptr inbounds i32, ptr %31, i64 %34\n%36 = load i32, ptr %35, align 4\n%37 = load i32, ptr %5, align 4\n%38 = icmp eq i32 %36, %37\nbr i1 %38, label %39, label %40\n\n39:\nstore i32 1, ptr %6, align 4\nbr label %41\n\n40:\nstore i32 0, ptr %6, align 4\nbr label %45\n\n41:\nbr label %42\n\n42:\n%43 = load i32, ptr %3, align 4\n%44 = add nsw i32 %43, 2\nstore i32 %44, ptr %3, align 4\nbr label %13\n\n45:\n%46 = load i32, ptr %6, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %46\n}": {"base_truth": "define dso_local i32 @is_same_repeating_digits(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @cardbuf, align 8\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds i32, ptr %1, i64 1\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %0, 0\nbr i1 %5, label %B1, label %B6\n\nB1:\n%6 = zext i32 %0 to i64\nbr label %B2\n\nB2:\n%7 = phi i64 [ 0, %B1 ], [ %16, %B5 ]\n%8 = getelementptr inbounds i32, ptr %1, i64 %7\n%9 = load i32, ptr %8, align 4\n%10 = icmp eq i32 %9, %2\nbr i1 %10, label %B3, label %B6\n\nB3:\n%11 = or i64 %7, 1\n%12 = icmp slt i64 %11, %6\nbr i1 %12, label %B4, label %B5\n\nB4:\n%13 = getelementptr inbounds i32, ptr %1, i64 %11\n%14 = load i32, ptr %13, align 4\n%15 = icmp eq i32 %14, %4\nbr i1 %15, label %B5, label %B6\n\nB5:\n%16 = add nuw i64 %7, 2\n%17 = trunc i64 %16 to i32\n%18 = icmp slt i32 %17, %0\nbr i1 %18, label %B2, label %B6\n\nB6:\n%19 = phi i32 [ 0, %B ], [ 0, %B2 ], [ 0, %B4 ], [ 1, %B5 ]\nret i32 %19\n}", "codellama": "define dso_local i32 @is_same_repeating_digits(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @cardbuf, align 8\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds i32, ptr %1, i64 1\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %0, 0\nbr i1 %5, label %B1, label %B5\n\nB1:\n%6 = zext i32 %0 to i64\nbr label %B2\n\nB2:\n%7 = phi i64 [ 0, %B1 ], [ %14, %B4 ]\n%8 = phi i32 [ 0, %B1 ], [ %13, %B4 ]\n%9 = getelementptr inbounds i32, ptr %1, i64 %7\n%10 = load i32, ptr %9, align 4\n%11 = icmp eq i32 %10, %2\nbr i1 %11, label %B3, label %B4\n\nB3:\n%12 = icmp slt i64 %7, %6\nbr i1 %12, label %B4, label %B5\n\nB4:\n%13 = phi i32 [ %8, %B2 ], [ 0, %B3 ]\n%14 = add nuw nsw i64 %7, 2\n%15 = icmp eq i64 %14, %6\nbr i1 %15, label %B5, label %B2\n\nB5:\n%16 = phi i32 [ 0, %B ], [ %13, %B3 ], [ 0, %B4 ]\nret i32 %16\n}", "codegemma": "define dso_local i32 @is_same_repeating_digits(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @cardbuf, align 8\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds i32, ptr %1, i64 1\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %0, 0\nbr i1 %5, label %B1, label %B5\n\nB1:\n%6 = zext i32 %0 to i64\nbr label %B2\n\nB2:\n%7 = phi i64 [ 0, %B1 ], [ %12, %B4 ]\n%8 = phi i32 [ %2, %B1 ], [ %13, %B4 ]\n%9 = phi i32 [ %4, %B1 ], [ %14, %B4 ]\n%10 = getelementptr inbounds i32, ptr %1, i64 %7\n%11 = load i32, ptr %10, align 4\n%12 = add nuw nsw i64 %7, 1\n%13 = icmp eq i32 %11, %8\n%14 = icmp slt i64 %12, %6\n%15 = and i1 %13, %14\nbr i1 %15, label %B4, label %B3\n\nB3:\n%16 = icmp eq i64 %12, %6\nbr i1 %16, label %B5, label %B4\n\nB4:\n%17 = icmp eq i32 %11, %9\n%18 = zext i1 %17 to i32\nbr label %B5\n\nB5:\n%19 = phi i32 [ 0, %B ], [ 1, %B3 ], [ %18, %B4 ]\nret i32 %19\n}"}, "define dso_local ptr @r455strings() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i32, ptr @fBC32strings, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %4, label %12\n\n4:\nstore i32 1, ptr @fBC32strings, align 4\n%5 = call i64 @se_malloc(i32 noundef 4)\n%6 = inttoptr i64 %5 to ptr\nstore ptr %6, ptr %1, align 8\n%7 = load i32, ptr @M59, align 4\n%8 = load ptr, ptr %1, align 8\nstore i32 %7, ptr %8, align 4\n%9 = load ptr, ptr %1, align 8\n%10 = call i32 @r59make(ptr noundef %9)\n%11 = load ptr, ptr %1, align 8\nstore ptr %11, ptr @oBC32strings, align 8\nbr label %12\n\n12:\n%13 = load ptr, ptr @oBC32strings, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @r455strings() {\nB:\n%0 = load i32, ptr @fBC32strings, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32strings, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32strings, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M59, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r59make(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32strings, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}", "codellama": "define dso_local ptr @r455strings() {\nB:\n%0 = load i32, ptr @fBC32strings, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32strings, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32strings, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M59, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r59make(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32strings, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}", "codegemma": "define dso_local ptr @r455strings() {\nB:\n%0 = load i32, ptr @fBC32strings, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32strings, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32strings, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M59, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r59make(ptr noundef nonnull %4)\n%7 = load ptr, ptr @oBC32strings, align 8\nbr label %B3\n\nB3:\n%8 = phi ptr [ %2, %B1 ], [ %7, %B2 ]\nret ptr %8\n}"}, "define dso_local ptr @r904echo() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i32, ptr @fBC32echo, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %4, label %12\n\n4:\nstore i32 1, ptr @fBC32echo, align 4\n%5 = call i64 @se_malloc(i32 noundef 4)\n%6 = inttoptr i64 %5 to ptr\nstore ptr %6, ptr %1, align 8\n%7 = load i32, ptr @M126, align 4\n%8 = load ptr, ptr %1, align 8\nstore i32 %7, ptr %8, align 4\n%9 = load ptr, ptr %1, align 8\n%10 = call i32 @r126make(ptr noundef %9)\n%11 = load ptr, ptr %1, align 8\nstore ptr %11, ptr @oBC32echo, align 8\nbr label %12\n\n12:\n%13 = load ptr, ptr @oBC32echo, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @r904echo() {\nB:\n%0 = load i32, ptr @fBC32echo, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32echo, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32echo, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M126, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r126make(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32echo, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}", "codellama": "define dso_local ptr @r904echo() {\nB:\n%0 = load i32, ptr @fBC32echo, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32echo, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32echo, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M126, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r126make(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32echo, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}", "codegemma": "define dso_local ptr @r904echo() {\nB:\n%0 = load i32, ptr @fBC32echo, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32echo, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32echo, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M126, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r126make(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32echo, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}"}, "define dso_local void @outputaddr(i64 noundef %0) {\n%2 = alloca i64, align 8\n%3 = alloca [20 x i8], align 16\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore i64 %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 20, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = getelementptr inbounds [20 x i8], ptr %3, i64 0, i64 0\nstore ptr %6, ptr %5, align 8\nstore i32 28, ptr %4, align 4\n%7 = load i32, ptr @asmflags, align 4\n%8 = and i32 %7, 1024\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %10, label %11\n\n10:\nstore i32 20, ptr %4, align 4\nbr label %17\n\n11:\n%12 = load i32, ptr @asmflags, align 4\n%13 = and i32 %12, 512\n%14 = icmp ne i32 %13, 0\nbr i1 %14, label %15, label %16\n\n15:\nstore i32 12, ptr %4, align 4\nbr label %16\n\n16:\nbr label %17\n\n17:\nbr label %18\n\n18:\n%19 = load i32, ptr %4, align 4\n%20 = icmp sge i32 %19, 0\nbr i1 %20, label %21, label %36\n\n21:\n%22 = load ptr, ptr @hexa, align 8\n%23 = load i64, ptr %2, align 8\n%24 = load i32, ptr %4, align 4\n%25 = zext i32 %24 to i64\n%26 = lshr i64 %23, %25\n%27 = and i64 %26, 15\n%28 = getelementptr inbounds i32, ptr %22, i64 %27\n%29 = load i32, ptr %28, align 4\n%30 = trunc i32 %29 to i8\n%31 = load ptr, ptr %5, align 8\n%32 = getelementptr inbounds i8, ptr %31, i32 1\nstore ptr %32, ptr %5, align 8\nstore i8 %30, ptr %31, align 1\nbr label %33\n\n33:\n%34 = load i32, ptr %4, align 4\n%35 = sub nsw i32 %34, 4\nstore i32 %35, ptr %4, align 4\nbr label %18\n\n36:\n%37 = load ptr, ptr %5, align 8\n%38 = getelementptr inbounds i8, ptr %37, i32 1\nstore ptr %38, ptr %5, align 8\nstore i8 32, ptr %37, align 1\n%39 = load ptr, ptr %5, align 8\nstore i8 0, ptr %39, align 1\n%40 = getelementptr inbounds [20 x i8], ptr %3, i64 0, i64 0\n%41 = call i32 @output(ptr noundef %40)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 20, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @outputaddr(i64 noundef %0) {\nB:\n%1 = alloca [20 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 20, ptr nonnull %1)\n%2 = load i32, ptr @asmflags, align 4\n%3 = and i32 %2, 1024\n%4 = icmp eq i32 %3, 0\n%5 = and i32 %2, 512\n%6 = icmp eq i32 %5, 0\n%7 = select i1 %6, i32 28, i32 12\n%8 = select i1 %4, i32 %7, i32 20\n%9 = load ptr, ptr @hexa, align 8\n%10 = lshr exact i32 %8, 2\n%11 = zext i32 %10 to i64\n%12 = getelementptr i8, ptr %1, i64 %11\n%13 = zext i32 %8 to i64\n%14 = lshr i64 %0, %13\n%15 = and i64 %14, 15\n%16 = getelementptr inbounds i32, ptr %9, i64 %15\n%17 = load i32, ptr %16, align 4\n%18 = trunc i32 %17 to i8\n%19 = getelementptr inbounds i8, ptr %1, i64 1\nstore i8 %18, ptr %1, align 16\n%20 = add nsw i32 %8, -4\n%21 = zext i32 %20 to i64\n%22 = lshr i64 %0, %21\n%23 = and i64 %22, 15\n%24 = getelementptr inbounds i32, ptr %9, i64 %23\n%25 = load i32, ptr %24, align 4\n%26 = trunc i32 %25 to i8\n%27 = getelementptr inbounds i8, ptr %1, i64 2\nstore i8 %26, ptr %19, align 1\n%28 = icmp eq ptr %19, %12\nbr i1 %28, label %B7, label %B1\n\nB1:\n%29 = add nsw i32 %8, -8\n%30 = zext i32 %29 to i64\n%31 = lshr i64 %0, %30\n%32 = and i64 %31, 15\n%33 = getelementptr inbounds i32, ptr %9, i64 %32\n%34 = load i32, ptr %33, align 4\n%35 = trunc i32 %34 to i8\n%36 = getelementptr inbounds i8, ptr %1, i64 3\nstore i8 %35, ptr %27, align 2\n%37 = icmp eq ptr %27, %12\nbr i1 %37, label %B7, label %B2\n\nB2:\n%38 = add nsw i32 %8, -12\n%39 = zext i32 %38 to i64\n%40 = lshr i64 %0, %39\n%41 = and i64 %40, 15\n%42 = getelementptr inbounds i32, ptr %9, i64 %41\n%43 = load i32, ptr %42, align 4\n%44 = trunc i32 %43 to i8\n%45 = getelementptr inbounds i8, ptr %1, i64 4\nstore i8 %44, ptr %36, align 1\n%46 = icmp eq ptr %36, %12\nbr i1 %46, label %B7, label %B3\n\nB3:\n%47 = add nsw i32 %8, -16\n%48 = zext i32 %47 to i64\n%49 = lshr i64 %0, %48\n%50 = and i64 %49, 15\n%51 = getelementptr inbounds i32, ptr %9, i64 %50\n%52 = load i32, ptr %51, align 4\n%53 = trunc i32 %52 to i8\n%54 = getelementptr inbounds i8, ptr %1, i64 5\nstore i8 %53, ptr %45, align 4\n%55 = icmp eq ptr %45, %12\nbr i1 %55, label %B7, label %B4\n\nB4:\n%56 = add nsw i32 %8, -20\n%57 = zext i32 %56 to i64\n%58 = lshr i64 %0, %57\n%59 = and i64 %58, 15\n%60 = getelementptr inbounds i32, ptr %9, i64 %59\n%61 = load i32, ptr %60, align 4\n%62 = trunc i32 %61 to i8\n%63 = getelementptr inbounds i8, ptr %1, i64 6\nstore i8 %62, ptr %54, align 1\n%64 = icmp eq ptr %54, %12\nbr i1 %64, label %B7, label %B5\n\nB5:\n%65 = add nsw i32 %8, -24\n%66 = zext i32 %65 to i64\n%67 = lshr i64 %0, %66\n%68 = and i64 %67, 15\n%69 = getelementptr inbounds i32, ptr %9, i64 %68\n%70 = load i32, ptr %69, align 4\n%71 = trunc i32 %70 to i8\n%72 = getelementptr inbounds i8, ptr %1, i64 7\nstore i8 %71, ptr %63, align 2\n%73 = icmp eq ptr %63, %12\nbr i1 %73, label %B7, label %B6\n\nB6:\n%74 = add nsw i32 %8, -28\n%75 = zext i32 %74 to i64\n%76 = lshr i64 %0, %75\n%77 = and i64 %76, 15\n%78 = getelementptr inbounds i32, ptr %9, i64 %77\n%79 = load i32, ptr %78, align 4\n%80 = trunc i32 %79 to i8\n%81 = getelementptr inbounds i8, ptr %1, i64 8\nstore i8 %80, ptr %72, align 1\nbr label %B7\n\nB7:\n%82 = phi ptr [ %27, %B ], [ %36, %B1 ], [ %45, %B2 ], [ %54, %B3 ], [ %63, %B4 ], [ %72, %B5 ], [ %81, %B6 ]\n%83 = getelementptr inbounds i8, ptr %12, i64 2\nstore i8 32, ptr %82, align 1\nstore i8 0, ptr %83, align 1\n%84 = call i32 @output(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 20, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @outputaddr(i64 noundef %0) {\nB:\n%1 = alloca [20 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 20, ptr nonnull %1)\n%2 = load i32, ptr @asmflags, align 4\n%3 = and i32 %2, 1024\n%4 = icmp eq i32 %3, 0\n%5 = and i32 %2, 512\n%6 = icmp eq i32 %5, 0\n%7 = select i1 %4, i32 28, i32 20\n%8 = select i1 %6, i32 %7, i32 12\n%9 = zext i32 %8 to i64\n%10 = icmp sgt i32 %8, 0\nbr i1 %10, label %B1, label %B3\n\nB1:\n%11 = load ptr, ptr @hexa, align 8\nbr label %B2\n\nB2:\n%12 = phi i64 [ %9, %B1 ], [ %19, %B2 ]\n%13 = phi ptr [ %1, %B1 ], [ %18, %B2 ]\n%14 = phi i32 [ %8, %B1 ], [ %15, %B2 ]\n%15 = add nsw i32 %14, -4\n%16 = lshr i64 %0, %12\n%17 = and i64 %16, 15\n%18 = getelementptr inbounds i32, ptr %11, i64 %17\n%19 = add nuw nsw i64 %12, -4\n%20 = load i32, ptr %18, align 4\n%21 = trunc i32 %20 to i8\n%22 = getelementptr inbounds i8, ptr %13, i64 1\nstore i8 %21, ptr %13, align 1\n%23 = icmp ugt i32 %14, 4\nbr i1 %23, label %B2, label %B3\n\nB3:\n%24 = phi ptr [ %1, %B ], [ %18, %B2 ]\n%25 = phi i32 [ 28, %B ], [ %15, %B2 ]\n%26 = getelementptr inbounds i8, ptr %24, i64 1\nstore i8 32, ptr %24, align 1\nstore i8 0, ptr %26, align 1\n%27 = call i32 @output(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 20, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @outputaddr(i64 noundef %0) {\nB:\n%1 = alloca [20 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 20, ptr nonnull %1)\n%2 = load i32, ptr @asmflags, align 4\n%3 = and i32 %2, 1024\n%4 = icmp eq i32 %3, 0\n%5 = and i32 %2, 512\n%6 = icmp eq i32 %5, 0\n%7 = select i1 %6, i32 28, i32 12\n%8 = select i1 %4, i32 28, i32 %7\n%9 = icmp sgt i32 %8, -1\nbr i1 %9, label %B1, label %B3\n\nB1:\n%10 = phi i64 [ %14, %B1 ], [ %0, %B ]\n%11 = phi ptr [ %13, %B1 ], [ %1, %B ]\n%12 = phi i32 [ %15, %B1 ], [ %8, %B ]\n%13 = getelementptr inbounds i8, ptr %11, i64 1\n%14 = lshr i64 %10, %12\n%15 = and i64 %14, 15\n%16 = load ptr, ptr @hexa, align 8\n%17 = getelementptr inbounds i32, ptr %16, i64 %15\n%18 = load i32, ptr %17, align 4\n%19 = trunc i32 %18 to i8\nstore i8 %19, ptr %13, align 1\n%20 = add nsw i32 %12, -4\n%21 = icmp sgt i32 %20, -1\nbr i1 %21, label %B1, label %B2\n\nB2:\n%22 = getelementptr inbounds i8, ptr %13, i64 1\nstore i8 32, ptr %13, align 1\nstore i8 0, ptr %22, align 1\nbr label %B3\n\nB3:\n%23 = phi ptr [ %1, %B ], [ %22, %B2 ]\n%24 = call i32 @output(ptr noundef nonnull %23)\ncall void @llvm.lifetime.end.p0(i64 20, ptr nonnull %1)\nret void\n}"}, "define internal i32 @uif_set_format(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = load ptr, ptr %6, align 8\n%10 = load i32, ptr @uif_codes, align 4\n%11 = load i32, ptr @uif_codes, align 4\n%12 = call i32 @ARRAY_SIZE(i32 noundef %11)\n%13 = load i32, ptr @UIF_MIN_SIZE, align 4\n%14 = load i32, ptr @UIF_MIN_SIZE, align 4\n%15 = load i32, ptr @UIF_MAX_SIZE, align 4\n%16 = load i32, ptr @UIF_MAX_SIZE, align 4\n%17 = call i32 @vsp1_subdev_set_pad_format(ptr noundef %7, ptr noundef %8, ptr noundef %9, i32 noundef %10, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15, i32 noundef %16)\nret i32 %17\n}": {"base_truth": "define internal i32 @uif_set_format(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = load i32, ptr @uif_codes, align 4\n%4 = tail call i32 @ARRAY_SIZE(i32 noundef %3)\n%5 = load i32, ptr @UIF_MIN_SIZE, align 4\n%6 = load i32, ptr @UIF_MAX_SIZE, align 4\n%7 = tail call i32 @vsp1_subdev_set_pad_format(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %5, i32 noundef %6, i32 noundef %6)\nret i32 %7\n}", "codellama": "define internal i32 @uif_set_format(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = load i32, ptr @uif_codes, align 4\n%4 = tail call i32 @ARRAY_SIZE(i32 noundef %3)\n%5 = load i32, ptr @UIF_MIN_SIZE, align 4\n%6 = load i32, ptr @UIF_MAX_SIZE, align 4\n%7 = tail call i32 @vsp1_subdev_set_pad_format(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %5, i32 noundef %6, i32 noundef %6)\nret i32 %7\n}", "codegemma": "define internal i32 @uif_set_format(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = load i32, ptr @uif_codes, align 4\n%4 = tail call i32 @ARRAY_SIZE(i32 noundef %3)\n%5 = load i32, ptr @UIF_MIN_SIZE, align 4\n%6 = load i32, ptr @UIF_MAX_SIZE, align 4\n%7 = tail call i32 @vsp1_subdev_set_pad_format(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %5, i32 noundef %6, i32 noundef %6)\nret i32 %7\n}"}, "define dso_local i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load ptr, ptr %5, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 2\n%9 = call i32 @xdr_post_op_attr(ptr noundef %6, ptr noundef %8)\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %13, label %11\n\n11:\n%12 = load i32, ptr @FALSE, align 4\nstore i32 %12, ptr %3, align 4\nbr label %32\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = load ptr, ptr %5, align 8\n%16 = getelementptr inbounds %struct.TYPE_3__, ptr %15, i32 0, i32 1\n%17 = load i32, ptr %16, align 4\n%18 = call i32 @xdr_cookieverf3(ptr noundef %14, i32 noundef %17)\n%19 = icmp ne i32 %18, 0\nbr i1 %19, label %22, label %20\n\n20:\n%21 = load i32, ptr @FALSE, align 4\nstore i32 %21, ptr %3, align 4\nbr label %32\n\n22:\n%23 = load ptr, ptr %4, align 8\n%24 = load ptr, ptr %5, align 8\n%25 = getelementptr inbounds %struct.TYPE_3__, ptr %24, i32 0, i32 0\n%26 = call i32 @xdr_dirlistplus3(ptr noundef %23, ptr noundef %25)\n%27 = icmp ne i32 %26, 0\nbr i1 %27, label %30, label %28\n\n28:\n%29 = load i32, ptr @FALSE, align 4\nstore i32 %29, ptr %3, align 4\nbr label %32\n\n30:\n%31 = load i32, ptr @TRUE, align 4\nstore i32 %31, ptr %3, align 4\nbr label %32\n\n32:\n%33 = load i32, ptr %3, align 4\nret i32 %33\n}": {"base_truth": "define dso_local i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = tail call i32 @xdr_post_op_attr(ptr noundef %0, ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @xdr_cookieverf3(ptr noundef %0, i32 noundef %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = tail call i32 @xdr_dirlistplus3(ptr noundef %0, ptr noundef nonnull %1)\n%10 = icmp eq i32 %9, 0\n%11 = select i1 %10, ptr @FALSE, ptr @TRUE\nbr label %B3\n\nB3:\n%12 = phi ptr [ @FALSE, %B ], [ @FALSE, %B1 ], [ %11, %B2 ]\n%13 = load i32, ptr %12, align 4\nret i32 %13\n}", "codellama": "define dso_local i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = tail call i32 @xdr_post_op_attr(ptr noundef %0, ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @xdr_cookieverf3(ptr noundef %0, i32 noundef %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = tail call i32 @xdr_dirlistplus3(ptr noundef %0, ptr noundef nonnull %1)\n%10 = icmp eq i32 %9, 0\n%11 = select i1 %10, ptr @FALSE, ptr @TRUE\nbr label %B3\n\nB3:\n%12 = phi ptr [ @FALSE, %B ], [ @FALSE, %B1 ], [ %11, %B2 ]\n%13 = load i32, ptr %12, align 4\nret i32 %13\n}", "codegemma": "define dso_local i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = tail call i32 @xdr_post_op_attr(ptr noundef %0, ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @xdr_cookieverf3(ptr noundef %0, i32 noundef %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = tail call i32 @xdr_dirlistplus3(ptr noundef %0, ptr noundef %1)\n%10 = icmp eq i32 %9, 0\n%11 = select i1 %10, ptr @FALSE, ptr @TRUE\nbr label %B3\n\nB3:\n%12 = phi ptr [ @FALSE, %B ], [ @FALSE, %B1 ], [ %11, %B2 ]\n%13 = load i32, ptr %12, align 4\nret i32 %13\n}"}, "define dso_local void @gen6_ppgtt_unpin(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @to_gen6_ppgtt(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.gen6_ppgtt ptr %7, i32 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp ne i64 %9, 0\n%11 = xor i1 %10, true\n%12 = zext i1 %11 to i32\n%13 = call i32 @GEM_BUG_ON(i32 noundef %12)\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.gen6_ppgtt ptr %14, i32 0, i32 1\n%16 = load i64, ptr %15, align 8\n%17 = add nsw i64 %16, -1\nstore i64 %17, ptr %15, align 8\n%18 = icmp ne i64 %17, 0\nbr i1 %18, label %19, label %20\n\n19:\nstore i32 1, ptr %4, align 4\nbr label %25\n\n20:\n%21 = load ptr, ptr %3, align 8\n%22 = getelementptr inbounds %struct.gen6_ppgtt ptr %21, i32 0, i32 0\n%23 = load i32, ptr %22, align 8\n%24 = call i32 @i915_vma_unpin(i32 noundef %23)\nstore i32 0, ptr %4, align 4\nbr label %25\n\n25:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\n%26 = load i32, ptr %4, align 4\nswitch i32 %26, label %28 [\ni32 0, label %27\ni32 1, label %27\n]\n\n27:\nret void\n\n28:\nunreachable\n}": {"base_truth": "define dso_local void @gen6_ppgtt_unpin(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_gen6_ppgtt(ptr noundef %0)\n%2 = getelementptr inbounds %struct.gen6_ppgtt, ptr %1, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @GEM_BUG_ON(i32 noundef %5)\n%7 = load i64, ptr %2, align 8\n%8 = add nsw i64 %7, -1\nstore i64 %8, ptr %2, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = load i32, ptr %1, align 8\n%11 = tail call i32 @i915_vma_unpin(i32 noundef %10)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @gen6_ppgtt_unpin(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_gen6_ppgtt(ptr noundef %0)\n%2 = getelementptr inbounds %struct.gen6_ppgtt, ptr %1, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @GEM_BUG_ON(i32 noundef %5)\n%7 = load i64, ptr %2, align 8\n%8 = add nsw i64 %7, -1\nstore i64 %8, ptr %2, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = load i32, ptr %1, align 8\n%11 = tail call i32 @i915_vma_unpin(i32 noundef %10)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @gen6_ppgtt_unpin(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_gen6_ppgtt(ptr noundef %0)\n%2 = getelementptr inbounds %struct.gen6_ppgtt, ptr %1, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @GEM_BUG_ON(i32 noundef %5)\n%7 = load i64, ptr %2, align 8\n%8 = add nsw i64 %7, -1\nstore i64 %8, ptr %2, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = load i32, ptr %1, align 8\n%11 = tail call i32 @i915_vma_unpin(i32 noundef %10)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @rtk_cpu_acceptLength_set(i64 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i64 %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nbr label %6\n\n6:\n%7 = call i64 (...) @rtk_switch_initialState_get()\n%8 = load i64, ptr @INIT_COMPLETED, align 8\n%9 = icmp ne i64 %7, %8\nbr i1 %9, label %10, label %12\n\n10:\n%11 = load i32, ptr @RT_ERR_NOT_INIT, align 4\nstore i32 %11, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %29\n\n12:\nbr label %13\n\n13:\nbr label %14\n\n14:\n%15 = load i64, ptr %3, align 8\n%16 = load i64, ptr @CPU_RX_END, align 8\n%17 = icmp sge i64 %15, %16\nbr i1 %17, label %18, label %20\n\n18:\n%19 = load i32, ptr @RT_ERR_INPUT, align 4\nstore i32 %19, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %29\n\n20:\n%21 = load i64, ptr %3, align 8\n%22 = call i32 @rtl8367c_setAsicCputagRxMinLength(i64 noundef %21)\nstore i32 %22, ptr %4, align 4\n%23 = load i32, ptr @RT_ERR_OK, align 4\n%24 = icmp ne i32 %22, %23\nbr i1 %24, label %25, label %27\n\n25:\n%26 = load i32, ptr %4, align 4\nstore i32 %26, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %29\n\n27:\n%28 = load i32, ptr @RT_ERR_OK, align 4\nstore i32 %28, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %29\n\n29:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%30 = load i32, ptr %2, align 4\nret i32 %30\n}": {"base_truth": "define dso_local i32 @rtk_cpu_acceptLength_set(i64 noundef %0) {\nB:\n%1 = tail call i64 (...) @rtk_switch_initialState_get()\n%2 = load i64, ptr @INIT_COMPLETED, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @RT_ERR_NOT_INIT, align 4\nbr label %B5\n\nB2:\n%5 = load i64, ptr @CPU_RX_END, align 8\n%6 = icmp sgt i64 %5, %0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = load i32, ptr @RT_ERR_INPUT, align 4\nbr label %B5\n\nB4:\n%8 = tail call i32 @rtl8367c_setAsicCputagRxMinLength(i64 noundef %0)\nbr label %B5\n\nB5:\n%9 = phi i32 [ %4, %B1 ], [ %7, %B3 ], [ %8, %B4 ]\nret i32 %9\n}", "codellama": "define dso_local i32 @rtk_cpu_acceptLength_set(i64 noundef %0) {\nB:\n%1 = tail call i64 (...) @rtk_switch_initialState_get()\n%2 = load i64, ptr @INIT_COMPLETED, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @RT_ERR_NOT_INIT, align 4\nbr label %B5\n\nB2:\n%5 = load i64, ptr @CPU_RX_END, align 8\n%6 = icmp sgt i64 %5, %0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = load i32, ptr @RT_ERR_INPUT, align 4\nbr label %B5\n\nB4:\n%8 = tail call i32 @rtl8367c_setAsicCputagRxMinLength(i64 noundef %0)\nbr label %B5\n\nB5:\n%9 = phi i32 [ %4, %B1 ], [ %7, %B3 ], [ %8, %B4 ]\nret i32 %9\n}", "codegemma": "define dso_local i32 @rtk_cpu_acceptLength_set(i64 noundef %0) {\nB:\n%1 = tail call i64 (...) @rtk_switch_initialState_get()\n%2 = load i64, ptr @INIT_COMPLETED, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @RT_ERR_NOT_INIT, align 4\nbr label %B5\n\nB2:\n%5 = load i64, ptr @CPU_RX_END, align 8\n%6 = icmp sgt i64 %5, %0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = load i32, ptr @RT_ERR_INPUT, align 4\nbr label %B5\n\nB4:\n%8 = tail call i32 @rtl8367c_setAsicCputagRxMinLength(i64 noundef %0)\nbr label %B5\n\nB5:\n%9 = phi i32 [ %4, %B1 ], [ %7, %B3 ], [ %8, %B4 ]\nret i32 %9\n}"}, "define internal void @mpt_raid_sysctl_attach(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.mpt_softc ptr %5, i32 0, i32 1\n%7 = load i32, ptr %6, align 4\n%8 = call ptr @device_get_sysctl_ctx(i32 noundef %7)\nstore ptr %8, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.mpt_softc ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\n%12 = call ptr @device_get_sysctl_tree(i32 noundef %11)\nstore ptr %12, ptr %4, align 8\n%13 = load ptr, ptr %3, align 8\n%14 = load ptr, ptr %4, align 8\n%15 = call i32 @SYSCTL_CHILDREN(ptr noundef %14)\n%16 = load i32, ptr @OID_AUTO, align 4\n%17 = load i32, ptr @CTLTYPE_STRING, align 4\n%18 = load i32, ptr @CTLFLAG_RW, align 4\n%19 = or i32 %17, %18\n%20 = load ptr, ptr %2, align 8\n%21 = load i32, ptr @mpt_raid_sysctl_vol_member_wce, align 4\n%22 = call i32 @SYSCTL_ADD_PROC(ptr noundef %13, i32 noundef %15, i32 noundef %16, ptr noundef @.str, i32 noundef %19, ptr noundef %20, i32 noundef 0, i32 noundef %21, ptr noundef @.str.1, ptr noundef @.str.2)\n%23 = load ptr, ptr %3, align 8\n%24 = load ptr, ptr %4, align 8\n%25 = call i32 @SYSCTL_CHILDREN(ptr noundef %24)\n%26 = load i32, ptr @OID_AUTO, align 4\n%27 = load i32, ptr @CTLTYPE_INT, align 4\n%28 = load i32, ptr @CTLFLAG_RW, align 4\n%29 = or i32 %27, %28\n%30 = load ptr, ptr %2, align 8\n%31 = load i32, ptr @mpt_raid_sysctl_vol_queue_depth, align 4\n%32 = call i32 @SYSCTL_ADD_PROC(ptr noundef %23, i32 noundef %25, i32 noundef %26, ptr noundef @.str.3, i32 noundef %29, ptr noundef %30, i32 noundef 0, i32 noundef %31, ptr noundef @.str.4, ptr noundef @.str.5)\n%33 = load ptr, ptr %3, align 8\n%34 = load ptr, ptr %4, align 8\n%35 = call i32 @SYSCTL_CHILDREN(ptr noundef %34)\n%36 = load i32, ptr @OID_AUTO, align 4\n%37 = load i32, ptr @CTLTYPE_INT, align 4\n%38 = load i32, ptr @CTLFLAG_RW, align 4\n%39 = or i32 %37, %38\n%40 = load ptr, ptr %2, align 8\n%41 = load i32, ptr @mpt_raid_sysctl_vol_resync_rate, align 4\n%42 = call i32 @SYSCTL_ADD_PROC(ptr noundef %33, i32 noundef %35, i32 noundef %36, ptr noundef @.str.6, i32 noundef %39, ptr noundef %40, i32 noundef 0, i32 noundef %41, ptr noundef @.str.4, ptr noundef @.str.7)\n%43 = load ptr, ptr %3, align 8\n%44 = load ptr, ptr %4, align 8\n%45 = call i32 @SYSCTL_CHILDREN(ptr noundef %44)\n%46 = load i32, ptr @OID_AUTO, align 4\n%47 = load i32, ptr @CTLFLAG_RD, align 4\n%48 = load ptr, ptr %2, align 8\n%49 = getelementptr inbounds %struct.mpt_softc ptr %48, i32 0, i32 0\n%50 = call i32 @SYSCTL_ADD_UINT(ptr noundef %43, i32 noundef %45, i32 noundef %46, ptr noundef @.str.8, i32 noundef %47, ptr noundef %49, i32 noundef 0, ptr noundef @.str.9)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @mpt_raid_sysctl_attach(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.mpt_softc, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @device_get_sysctl_ctx(i32 noundef %2)\n%4 = load i32, ptr %1, align 4\n%5 = tail call ptr @device_get_sysctl_tree(i32 noundef %4)\n%6 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%7 = load i32, ptr @OID_AUTO, align 4\n%8 = load i32, ptr @CTLTYPE_STRING, align 4\n%9 = load i32, ptr @CTLFLAG_RW, align 4\n%10 = or i32 %9, %8\n%11 = load i32, ptr @mpt_raid_sysctl_vol_member_wce, align 4\n%12 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %6, i32 noundef %7, ptr noundef nonnull @.str, i32 noundef %10, ptr noundef %0, i32 noundef 0, i32 noundef %11, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2)\n%13 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%14 = load i32, ptr @OID_AUTO, align 4\n%15 = load i32, ptr @CTLTYPE_INT, align 4\n%16 = load i32, ptr @CTLFLAG_RW, align 4\n%17 = or i32 %16, %15\n%18 = load i32, ptr @mpt_raid_sysctl_vol_queue_depth, align 4\n%19 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %13, i32 noundef %14, ptr noundef nonnull @.str.3, i32 noundef %17, ptr noundef %0, i32 noundef 0, i32 noundef %18, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.5)\n%20 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%21 = load i32, ptr @OID_AUTO, align 4\n%22 = load i32, ptr @CTLTYPE_INT, align 4\n%23 = load i32, ptr @CTLFLAG_RW, align 4\n%24 = or i32 %23, %22\n%25 = load i32, ptr @mpt_raid_sysctl_vol_resync_rate, align 4\n%26 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %20, i32 noundef %21, ptr noundef nonnull @.str.6, i32 noundef %24, ptr noundef %0, i32 noundef 0, i32 noundef %25, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.7)\n%27 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%28 = load i32, ptr @OID_AUTO, align 4\n%29 = load i32, ptr @CTLFLAG_RD, align 4\n%30 = tail call i32 @SYSCTL_ADD_UINT(ptr noundef %3, i32 noundef %27, i32 noundef %28, ptr noundef nonnull @.str.8, i32 noundef %29, ptr noundef %0, i32 noundef 0, ptr noundef nonnull @.str.9)\nret void\n}", "codellama": "define internal void @mpt_raid_sysctl_attach(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.mpt_softc, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @device_get_sysctl_ctx(i32 noundef %2)\n%4 = load i32, ptr %1, align 4\n%5 = tail call ptr @device_get_sysctl_tree(i32 noundef %4)\n%6 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%7 = load i32, ptr @OID_AUTO, align 4\n%8 = load i32, ptr @CTLTYPE_STRING, align 4\n%9 = load i32, ptr @CTLFLAG_RW, align 4\n%10 = or i32 %9, %8\n%11 = load i32, ptr @mpt_raid_sysctl_vol_member_wce, align 4\n%12 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %6, i32 noundef %7, ptr noundef nonnull @.str, i32 noundef %10, ptr noundef %0, i32 noundef 0, i32 noundef %11, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2)\n%13 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%14 = load i32, ptr @OID_AUTO, align 4\n%15 = load i32, ptr @CTLTYPE_INT, align 4\n%16 = load i32, ptr @CTLFLAG_RW, align 4\n%17 = or i32 %16, %15\n%18 = load i32, ptr @mpt_raid_sysctl_vol_queue_depth, align 4\n%19 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %13, i32 noundef %14, ptr noundef nonnull @.str.3, i32 noundef %17, ptr noundef %0, i32 noundef 0, i32 noundef %18, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.5)\n%20 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%21 = load i32, ptr @OID_AUTO, align 4\n%22 = load i32, ptr @CTLTYPE_INT, align 4\n%23 = load i32, ptr @CTLFLAG_RW, align 4\n%24 = or i32 %23, %22\n%25 = load i32, ptr @mpt_raid_sysctl_vol_resync_rate, align 4\n%26 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %20, i32 noundef %21, ptr noundef nonnull @.str.6, i32 noundef %24, ptr noundef %0, i32 noundef 0, i32 noundef %25, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.7)\n%27 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%28 = load i32, ptr</s>", "codegemma": "define internal void @mpt_raid_sysctl_attach(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.mpt_softc, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @device_get_sysctl_ctx(i32 noundef %2)\n%4 = load i32, ptr %1, align 4\n%5 = tail call ptr @device_get_sysctl_tree(i32 noundef %4)\n%6 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%7 = load i32, ptr @OID_AUTO, align 4\n%8 = load i32, ptr @CTLTYPE_STRING, align 4\n%9 = load i32, ptr @CTLFLAG_RW, align 4\n%10 = or i32 %9, %8\n%11 = load i32, ptr @mpt_raid_sysctl_vol_member_wce, align 4\n%12 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %6, i32 noundef %7, ptr noundef nonnull @.str, i32 noundef %10, ptr noundef %0, i32 noundef 0, i32 noundef %11, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2)\n%13 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%14 = load i32, ptr @OID_AUTO, align 4\n%15 = load i32, ptr @CTLTYPE_INT, align 4\n%16 = load i32, ptr @CTLFLAG_RW, align 4\n%17 = or i32 %16, %15\n%18 = load i32, ptr @mpt_raid_sysctl_vol_queue_depth, align 4\n%19 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %13, i32 noundef %14, ptr noundef nonnull @.str.3, i32 noundef %17, ptr noundef %0, i32 noundef 0, i32 noundef %18, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.5)\n%20 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%21 = load i32, ptr @OID_AUTO, align 4\n%22 = load i32, ptr @CTLTYPE_INT, align 4\n%23 = load i32, ptr @CTLFLAG_RW, align 4\n%24 = or i32 %23, %22\n%25 = load i32, ptr @mpt_raid_sysctl_vol_resync_rate, align 4\n%26 = tail call i32 @SYSCTL_ADD_PROC(ptr noundef %3, i32 noundef %20, i32 noundef %21, ptr noundef nonnull @.str.6, i32 noundef %24, ptr noundef %0, i32 noundef 0, i32 noundef %25, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.7)\n%27 = tail call i32 @SYSCTL_CHILDREN(ptr noundef %5)\n%28 = load i32, ptr @OID_AUTO, align 4\n%29 = load i32, ptr @CTLFLAG_RD, align 4\n%30 = tail call i32 @SYSCTL_ADD_UINT(ptr noundef %3, i32 noundef %27, i32 noundef %28, ptr noundef nonnull @.str.8, i32 noundef %29, ptr noundef %0, i32 noundef 0, ptr noundef nonnull @.str.9)\nret<eos>"}, "define dso_local void @ooaofooa_ACT_FNB_R695_Unlink(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 1\nstore i64 0, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %7, i32 0, i32 0\nstore i64 0, ptr %8, align 8\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %9, i32 0, i32 0\nstore i64 0, ptr %10, align 8\nret void\n}": {"base_truth": "define dso_local void @ooaofooa_ACT_FNB_R695_Unlink(ptr nocapture noundef writeonly %0, ptr nocapture noundef writeonly %1) {\nB:\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\nstore i64 0, ptr %0, align 8\nret void\n}", "codellama": "define dso_local void @ooaofooa_ACT_FNB_R695_Unlink(ptr nocapture noundef writeonly %0, ptr nocapture noundef writeonly %1) {\nB:\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\nstore i64 0, ptr %0, align 8\nret void\n}", "codegemma": "define dso_local void @ooaofooa_ACT_FNB_R695_Unlink(ptr nocapture noundef writeonly %0, ptr nocapture noundef writeonly %1) {\nB:\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\nstore i64 0, ptr %0, align 8\nret void\n}"}, "define dso_local i32 @lj_opt_narrow_forl(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i64, align 8\n%7 = alloca i64, align 8\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = load ptr, ptr %4, align 8\n%11 = load ptr, ptr %5, align 8\n%12 = load i64, ptr @FORL_IDX, align 8\n%13 = getelementptr inbounds i32, ptr %11, i64 %12\n%14 = call i64 @narrow_forl(ptr noundef %10, ptr noundef %13)\n%15 = icmp ne i64 %14, 0\nbr i1 %15, label %16, label %57\n\n16:\n%17 = load ptr, ptr %4, align 8\n%18 = load ptr, ptr %5, align 8\n%19 = load i64, ptr @FORL_STOP, align 8\n%20 = getelementptr inbounds i32, ptr %18, i64 %19\n%21 = call i64 @narrow_forl(ptr noundef %17, ptr noundef %20)\n%22 = icmp ne i64 %21, 0\nbr i1 %22, label %23, label %57\n\n23:\n%24 = load ptr, ptr %4, align 8\n%25 = load ptr, ptr %5, align 8\n%26 = load i64, ptr @FORL_STEP, align 8\n%27 = getelementptr inbounds i32, ptr %25, i64 %26\n%28 = call i64 @narrow_forl(ptr noundef %24, ptr noundef %27)\n%29 = icmp ne i64 %28, 0\nbr i1 %29, label %30, label %57\n\n30:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%31 = load ptr, ptr %5, align 8\n%32 = load i64, ptr @FORL_STEP, align 8\n%33 = getelementptr inbounds i32, ptr %31, i64 %32\n%34 = call i64 @numberVnum(ptr noundef %33)\nstore i64 %34, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%35 = load ptr, ptr %5, align 8\n%36 = load i64, ptr @FORL_STOP, align 8\n%37 = getelementptr inbounds i32, ptr %35, i64 %36\n%38 = call i64 @numberVnum(ptr noundef %37)\n%39 = load i64, ptr %6, align 8\n%40 = add nsw i64 %38, %39\nstore i64 %40, ptr %7, align 8\n%41 = load i64, ptr %6, align 8\n%42 = icmp sle i64 0, %41\nbr i1 %42, label %43, label %47\n\n43:\n%44 = load i64, ptr %7, align 8\n%45 = sitofp i64 %44 to double\n%46 = fcmp fast ole double %45, 0x41DFFFFFFFC00000\nbr i1 %46, label %51, label %53\n\n47:\n%48 = load i64, ptr %7, align 8\n%49 = sitofp i64 %48 to double\n%50 = fcmp fast oge double %49, 0xC1E0000000000000\nbr i1 %50, label %51, label %53\n\n51:\n%52 = load i32, ptr @IRT_INT, align 4\nstore i32 %52, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %54\n\n53:\nstore i32 0, ptr %8, align 4\nbr label %54\n\n54:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%55 = load i32, ptr %8, align 4\nswitch i32 %55, label %61 [\ni32 0, label %56\ni32 1, label %59\n]\n\n56:\nbr label %57\n\n57:\n%58 = load i32, ptr @IRT_NUM, align 4\nstore i32 %58, ptr %3, align 4\nbr label %59\n\n59:\n%60 = load i32, ptr %3, align 4\nret i32 %60\n\n61:\nunreachable\n}": {"base_truth": "define dso_local i32 @lj_opt_narrow_forl(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i64, ptr @FORL_IDX, align 8\n%3 = getelementptr inbounds i32, ptr %1, i64 %2\n%4 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %3)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B6, label %B1\n\nB1:\n%6 = load i64, ptr @FORL_STOP, align 8\n%7 = getelementptr inbounds i32, ptr %1, i64 %6\n%8 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B6, label %B2\n\nB2:\n%10 = load i64, ptr @FORL_STEP, align 8\n%11 = getelementptr inbounds i32, ptr %1, i64 %10\n%12 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B6, label %B3\n\nB3:\n%14 = load i64, ptr @FORL_STEP, align 8\n%15 = getelementptr inbounds i32, ptr %1, i64 %14\n%16 = tail call i64 @numberVnum(ptr noundef %15)\n%17 = load i64, ptr @FORL_STOP, align 8\n%18 = getelementptr inbounds i32, ptr %1, i64 %17\n%19 = tail call i64 @numberVnum(ptr noundef %18)\n%20 = add nsw i64 %19, %16\n%21 = icmp sgt i64 %16, -1\nbr i1 %21, label %B4, label %B5\n\nB4:\n%22 = icmp slt i64 %20, 2147483648\nbr i1 %22, label %B7, label %B6\n\nB5:\n%23 = icmp sgt i64 %20, -2147483649\nbr i1 %23, label %B7, label %B6\n\nB6:\nbr label %B7\n\nB7:\n%24 = phi ptr [ @IRT_NUM, %B6 ], [ @IRT_INT, %B4 ], [ @IRT_INT, %B5 ]\n%25 = load i32, ptr %24, align 4\nret i32 %25\n}", "codellama": "define dso_local i32 @lj_opt_narrow_forl(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i64, ptr @FORL_IDX, align 8\n%3 = getelementptr inbounds i32, ptr %1, i64 %2\n%4 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %3)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B5, label %B1\n\nB1:\n%6 = load i64, ptr @FORL_STOP, align 8\n%7 = getelementptr inbounds i32, ptr %1, i64 %6\n%8 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B5, label %B2\n\nB2:\n%10 = load i64, ptr @FORL_STEP, align 8\n%11 = getelementptr inbounds i32, ptr %1, i64 %10\n%12 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B5, label %B3\n\nB3:\n%14 = load i64, ptr @FORL_STEP, align 8\n%15 = getelementptr inbounds i32, ptr %1, i64 %14\n%16 = tail call i64 @numberVnum(ptr noundef %15)\n%17 = load i64, ptr @FORL_STOP, align 8\n%18 = getelementptr inbounds i32, ptr %1, i64 %17\n%19 = tail call i64 @numberVnum(ptr noundef %18)\n%20 = add nsw i64 %19, %16\n%21 = icmp sgt i64 %16, -1\nbr i1 %21, label %B4, label %B5\n\nB4:\n%22 = sitofp i64 %20 to double\n%23 = fcmp fast ole double %22, 0x41DFFFFFFFC00000\n%24 = fcmp fast oge double %22, 0xC1E0000000000000\n%25 = select i1 %23, i1 true, i1 %24\nbr i1 %25, label %B6, label %B5\n\nB5:\nbr label %B6\n\nB6:\n%26 = phi ptr [ @IRT_NUM, %B5 ], [ @IRT_INT, %B4 ]\n%27 = load i32, ptr %26, align 4\nret i32 %27\n}", "codegemma": "define dso_local i32 @lj_opt_narrow_forl(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i64, ptr @FORL_IDX, align 8\n%3 = getelementptr inbounds i32, ptr %1, i64 %2\n%4 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %3)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B5, label %B1\n\nB1:\n%6 = load i64, ptr @FORL_STOP, align 8\n%7 = getelementptr inbounds i32, ptr %1, i64 %6\n%8 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B5, label %B2\n\nB2:\n%10 = load i64, ptr @FORL_STEP, align 8\n%11 = getelementptr inbounds i32, ptr %1, i64 %10\n%12 = tail call i64 @narrow_forl(ptr noundef %0, ptr noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B5, label %B3\n\nB3:\n%14 = load i64, ptr @FORL_STEP, align 8\n%15 = getelementptr inbounds i32, ptr %1, i64 %14\n%16 = tail call i64 @numberVnum(ptr noundef %15)\n%17 = load i64, ptr @FORL_STOP, align 8\n%18 = getelementptr inbounds i32, ptr %1, i64 %17\n%19 = tail call i64 @numberVnum(ptr noundef %18)\n%20 = add nsw i64 %19, %16\n%21 = icmp sgt i64 %20, 0\nbr i1 %21, label %B4, label %B5\n\nB4:\n%22 = sitofp i64 %20 to double\n%23 = fcmp fast ole double %22, 0x41DFFFFFFFC00000\n%24 = fcmp fast oge double %22, 0xC1E0000000000000\n%25 = select i1 %23, i1 true, i1 %24\nbr i1 %25, label %B6, label %B5\n\nB5:\n%26 = load i32, ptr @IRT_NUM, align 4\nbr label %B6\n\nB6:\n%27 = phi i32 [ %26, %B5 ], [ 0, %B4 ]\nret i32 %27\n}"}, "define internal i32 @mlx4_wq_overflow(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\n%9 = alloca ptr, align 8\n%10 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore ptr %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%11 = load ptr, ptr %5, align 8\n%12 = getelementptr inbounds %struct.mlx4_ib_wq ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\n%14 = load ptr, ptr %5, align 8\n%15 = getelementptr inbounds %struct.mlx4_ib_wq ptr %14, i32 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = sub i32 %13, %16\nstore i32 %17, ptr %8, align 4\n%18 = load i32, ptr %8, align 4\n%19 = load i32, ptr %6, align 4\n%20 = add i32 %18, %19\n%21 = load ptr, ptr %5, align 8\n%22 = getelementptr inbounds %struct.mlx4_ib_wq ptr %21, i32 0, i32 2\n%23 = load i32, ptr %22, align 4\n%24 = icmp ult i32 %20, %23\n%25 = zext i1 %24 to i32\n%26 = call i64 @likely(i32 noundef %25)\n%27 = icmp ne i64 %26, 0\nbr i1 %27, label %28, label %29\n\n28:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %53\n\n29:\n%30 = load ptr, ptr %7, align 8\n%31 = call ptr @to_mcq(ptr noundef %30)\nstore ptr %31, ptr %9, align 8\n%32 = load ptr, ptr %9, align 8\n%33 = getelementptr inbounds %struct.mlx4_ib_cq ptr %32, i32 0, i32 0\n%34 = call i32 @spin_lock(ptr noundef %33)\n%35 = load ptr, ptr %5, align 8\n%36 = getelementptr inbounds %struct.mlx4_ib_wq ptr %35, i32 0, i32 0\n%37 = load i32, ptr %36, align 4\n%38 = load ptr, ptr %5, align 8\n%39 = getelementptr inbounds %struct.mlx4_ib_wq ptr %38, i32 0, i32 1\n%40 = load i32, ptr %39, align 4\n%41 = sub i32 %37, %40\nstore i32 %41, ptr %8, align 4\n%42 = load ptr, ptr %9, align 8\n%43 = getelementptr inbounds %struct.mlx4_ib_cq ptr %42, i32 0, i32 0\n%44 = call i32 @spin_unlock(ptr noundef %43)\n%45 = load i32, ptr %8, align 4\n%46 = load i32, ptr %6, align 4\n%47 = add i32 %45, %46\n%48 = load ptr, ptr %5, align 8\n%49 = getelementptr inbounds %struct.mlx4_ib_wq ptr %48, i32 0, i32 2\n%50 = load i32, ptr %49, align 4\n%51 = icmp uge i32 %47, %50\n%52 = zext i1 %51 to i32\nstore i32 %52, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %53\n\n53:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\n%54 = load i32, ptr %4, align 4\nret i32 %54\n}": {"base_truth": "define internal i32 @mlx4_wq_overflow(ptr nocapture noundef readonly %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = load i32, ptr %0, align 4\n%4 = getelementptr inbounds %struct.mlx4_ib_wq, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = add i32 %3, %1\n%7 = sub i32 %6, %5\n%8 = getelementptr inbounds %struct.mlx4_ib_wq, ptr %0, i64 0, i32 2\n%9 = load i32, ptr %8, align 4\n%10 = icmp ult i32 %7, %9\n%11 = zext i1 %10 to i32\n%12 = tail call i64 @likely(i32 noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B1, label %B2\n\nB1:\n%14 = tail call ptr @to_mcq(ptr noundef %2)\n%15 = tail call i32 @spin_lock(ptr noundef %14)\n%16 = load i32, ptr %0, align 4\n%17 = load i32, ptr %4, align 4\n%18 = tail call i32 @spin_unlock(ptr noundef %14)\n%19 = add i32 %16, %1\n%20 = sub i32 %19, %17\n%21 = load i32, ptr %8, align 4\n%22 = icmp uge i32 %20, %21\n%23 = zext i1 %22 to i32\nbr label %B2\n\nB2:\n%24 = phi i32 [ %23, %B1 ], [ 0, %B ]\nret i32 %24\n}", "codellama": "define internal i32 @mlx4_wq_overflow(ptr nocapture noundef readonly %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = load i32, ptr %0, align 4\n%4 = getelementptr inbounds %struct.mlx4_ib_wq, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = sub i32 %3, %5\n%7 = add i32 %6, %1\n%8 = getelementptr inbounds %struct.mlx4_ib_wq, ptr %0, i64 0, i32 2\n%9 = load i32, ptr %8, align 4\n%10 = icmp ult i32 %7, %9\n%11 = zext i1 %10 to i32\n%12 = tail call i64 @likely(i32 noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B1, label %B2\n\nB1:\n%14 = tail call ptr @to_mcq(ptr noundef %2)\n%15 = tail call i32 @spin_lock(ptr noundef %14)\n%16 = load i32, ptr %0, align 4\n%17 = load i32, ptr %4, align 4\n%18 = sub i32 %16, %17\n%19 = tail call i32 @spin_unlock(ptr noundef %14)\n%20 = add i32 %18, %1\n%21 = load i32, ptr %8, align 4\n%22 = icmp uge i32 %20, %21\n%23 = zext i1 %22 to i32\nbr label %B2\n\nB2:\n%24 = phi i32 [ %23, %B1 ], [ 0, %B ]\nret i32 %24\n}", "codegemma": "define internal i32 @mlx4_wq_overflow(ptr nocapture noundef readonly %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = load i32, ptr %0, align 4\n%4 = getelementptr inbounds %struct.mlx4_ib_wq, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = sub i32 %3, %5\n%7 = add i32 %6, %1\n%8 = getelementptr inbounds %struct.mlx4_ib_wq, ptr %0, i64 0, i32 2\n%9 = load i32, ptr %8, align 4\n%10 = icmp ult i32 %7, %9\n%11 = zext i1 %10 to i32\n%12 = tail call i64 @likely(i32 noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B1, label %B2\n\nB1:\n%14 = tail call ptr @to_mcq(ptr noundef %2)\n%15 = tail call i32 @spin_lock(ptr noundef %14)\n%16 = load i32, ptr %0, align 4\n%17 = load i32, ptr %4, align 4\n%18 = sub i32 %16, %17\n%19 = tail call i32 @spin_unlock(ptr noundef %14)\n%20 = add i32 %18, %1\n%21 = load i32, ptr %8, align 4\n%22 = icmp ult i32 %20, %21\n%23 = zext i1 %22 to i32\nbr label %B2\n\nB2:\n%24 = phi i32 [ %23, %B1 ], [ 0, %B ]\nret i32 %24\n}"}, "define dso_local void @square_mask(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%9 = load i32, ptr @mod_bits, align 4\n%10 = load i32, ptr %4, align 4\n%11 = call i32 @mul_2exp_mod(i32 noundef 1, i32 noundef %9, i32 noundef %10)\nstore i32 %11, ptr %5, align 4\n%12 = load i32, ptr %5, align 4\n%13 = load i32, ptr %4, align 4\n%14 = call i32 @neg_mod(i32 noundef %12, i32 noundef %13)\nstore i32 %14, ptr %5, align 4\n%15 = load i32, ptr %3, align 4\n%16 = call i32 @mpz_set_ui(i32 noundef %15, i64 noundef 0)\nstore i32 0, ptr %6, align 4\nbr label %17\n\n17:\n%18 = load i32, ptr %6, align 4\n%19 = load i32, ptr %4, align 4\n%20 = icmp slt i32 %18, %19\nbr i1 %20, label %21, label %39\n\n21:\n%22 = load i32, ptr %6, align 4\n%23 = load i32, ptr %6, align 4\n%24 = mul nsw i32 %22, %23\n%25 = load i32, ptr %4, align 4\n%26 = srem i32 %24, %25\nstore i32 %26, ptr %7, align 4\n%27 = load i32, ptr %7, align 4\n%28 = load i32, ptr %5, align 4\n%29 = mul nsw i32 %27, %28\n%30 = load i32, ptr %4, align 4\n%31 = srem i32 %29, %30\nstore i32 %31, ptr %8, align 4\n%32 = load i32, ptr %3, align 4\n%33 = load i32, ptr %8, align 4\n%34 = sext i32 %33 to i64\n%35 = call i32 @mpz_setbit(i32 noundef %32, i64 noundef %34)\nbr label %36\n\n36:\n%37 = load i32, ptr %6, align 4\n%38 = add nsw i32 %37, 1\nstore i32 %38, ptr %6, align 4\nbr label %17\n\n39:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @square_mask(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @mod_bits, align 4\n%3 = tail call i32 @mul_2exp_mod(i32 noundef 1, i32 noundef %2, i32 noundef %1)\n%4 = tail call i32 @neg_mod(i32 noundef %3, i32 noundef %1)\n%5 = tail call i32 @mpz_set_ui(i32 noundef %0, i64 noundef 0)\n%6 = icmp sgt i32 %1, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = phi i32 [ %14, %B1 ], [ 0, %B ]\n%8 = mul nsw i32 %7, %7\n%9 = srem i32 %8, %1\n%10 = mul nsw i32 %9, %4\n%11 = srem i32 %10, %1\n%12 = sext i32 %11 to i64\n%13 = tail call i32 @mpz_setbit(i32 noundef %0, i64 noundef %12)\n%14 = add nuw nsw i32 %7, 1\n%15 = icmp eq i32 %14, %1\nbr i1 %15, label %B2, label %B1\n\nB2:\nret void\n}", "codellama": "define dso_local void @square_mask(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @mod_bits, align 4\n%3 = tail call i32 @mul_2exp_mod(i32 noundef 1, i32 noundef %2, i32 noundef %1)\n%4 = tail call i32 @neg_mod(i32 noundef %3, i32 noundef %1)\n%5 = icmp sgt i32 %1, 0\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = zext i32 %1 to i64\nbr label %B2\n\nB2:\n%7 = phi i64 [ 0, %B1 ], [ %15, %B2 ]\n%8 = shl nsw i64 %7, %7\n%9 = srem i64 %8, %6\n%10 = mul nsw i64 %9, %6\n%11 = srem i64 %10, %6\n%12 = sext i64 %11 to i32\n%13 = tail call i32 @mpz_setbit(i32 noundef %0, i64 noundef %11)\n%14 = add nuw nsw i64 %7, 1\n%15 = icmp eq i64 %14, %6\nbr i1 %15, label %B3, label %B2\n\nB3:\nret void\n}", "codegemma": "define dso_local void @square_mask(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @mod_bits, align 4\n%3 = tail call i32 @mul_2exp_mod(i32 noundef 1, i32 noundef %2, i32 noundef %1)\n%4 = tail call i32 @neg_mod(i32 noundef %3, i32 noundef %1)\n%5 = tail call i32 @mpz_set_ui(i32 noundef %0, i64 noundef 0)\n%6 = icmp sgt i32 %1, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = phi i32 [ %12, %B1 ], [ 0, %B ]\n%8 = mul nsw i32 %7, %7\n%9 = srem i32 %8, %1\n%10 = mul nsw i32 %9, %4\n%11 = srem i32 %10, %1\n%12 = add nuw nsw i32 %7, 1\n%13 = icmp eq i32 %12, %1\nbr i1 %13, label %B2, label %B1\n\nB2:\nret void\n}"}, "define dso_local i32 @printChats() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\nstore ptr null, ptr %4, align 8\n%6 = load i64, ptr @lines, align 8\n%7 = icmp sgt i64 %6, 0\nbr i1 %7, label %8, label %32\n\n8:\n%9 = load i32, ptr @screenTopIndex, align 4\nstore i32 %9, ptr %3, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %3, align 4\n%12 = load i32, ptr @screenBottomIndex, align 4\n%13 = icmp sle i32 %11, %12\nbr i1 %13, label %14, label %31\n\n14:\n%15 = load i32, ptr %2, align 4\n%16 = call i32 @move(i32 noundef %15, i32 noundef 0)\n%17 = load i32, ptr %3, align 4\n%18 = call ptr @listGet(ptr noundef @lines, i32 noundef %17)\nstore ptr %18, ptr %4, align 8\n%19 = load ptr, ptr %4, align 8\n%20 = icmp ne ptr %19, null\nbr i1 %20, label %23, label %21\n\n21:\n%22 = call i32 @cclog(i32 noundef 3, ptr noundef @.str, i32 noundef 25, ptr noundef @.str.1)\nstore i32 -1, ptr %1, align 4\nstore i32 1, ptr %5, align 4\nbr label %33\n\n23:\n%24 = load ptr, ptr %4, align 8\n%25 = call i32 @printw(ptr noundef @.str.2, ptr noundef %24)\n%26 = load i32, ptr %2, align 4\n%27 = add nsw i32 %26, 1\nstore i32 %27, ptr %2, align 4\nbr label %28\n\n28:\n%29 = load i32, ptr %3, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %3, align 4\nbr label %10\n\n31:\nbr label %32\n\n32:\nstore i32 0, ptr %1, align 4\nstore i32 1, ptr %5, align 4\nbr label %33\n\n33:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%34 = load i32, ptr %1, align 4\nret i32 %34\n}": {"base_truth": "define dso_local i32 @printChats() {\nB:\n%0 = load i64, ptr @lines, align 8\n%1 = icmp sgt i64 %0, 0\nbr i1 %1, label %B1, label %B5\n\nB1:\n%2 = load i32, ptr @screenTopIndex, align 4\n%3 = load i32, ptr @screenBottomIndex, align 4\n%4 = icmp sgt i32 %2, %3\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = phi i32 [ %13, %B4 ], [ %2, %B1 ]\n%6 = phi i32 [ %12, %B4 ], [ 0, %B1 ]\n%7 = tail call i32 @move(i32 noundef %6, i32 noundef 0)\n%8 = tail call ptr @listGet(ptr noundef nonnull @lines, i32 noundef %5)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = tail call i32 @cclog(i32 noundef 3, ptr noundef nonnull @.str, i32 noundef 25, ptr noundef nonnull @.str.1)\nbr label %B5\n\nB4:\n%11 = tail call i32 @printw(ptr noundef nonnull @.str.2, ptr noundef nonnull %8)\n%12 = add nuw nsw i32 %6, 1\n%13 = add nsw i32 %5, 1\n%14 = load i32, ptr @screenBottomIndex, align 4\n%15 = icmp slt i32 %5, %14\nbr i1 %15, label %B2, label %B5\n\nB5:\n%16 = phi i32 [ -1, %B3 ], [ 0, %B ], [ 0, %B1 ], [ 0, %B4 ]\nret i32 %16\n}", "codellama": "define dso_local i32 @printChats() {\nB:\n%0 = load i64, ptr @lines, align 8\n%1 = icmp sgt i64 %0, 0\n%2 = load i32, ptr @screenTopIndex, align 4\n%3 = icmp sgt i32 %2, -1\n%4 = select i1 %1, i1 %3, i1 false\nbr i1 %4, label %B1, label %B4\n\nB1:\n%5 = phi i32 [ %12, %B3 ], [ %2, %B ]\n%6 = phi i32 [ %11, %B3 ], [ 0, %B ]\n%7 = tail call i32 @move(i32 noundef %6, i32 noundef 0)\n%8 = tail call ptr @listGet(ptr noundef nonnull @lines, i32 noundef %5)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = tail call i32 @cclog(i32 noundef 3, ptr noundef nonnull @.str, i32 noundef 25, ptr noundef nonnull @.str.1)\nbr label %B4\n\nB3:\n%11 = add nuw nsw i32 %6, 1\n%12 = add nsw i32 %5, 1\n%13 = load i32, ptr @screenBottomIndex, align 4\n%14 = icmp slt i32 %5, %13\nbr i1 %14, label %B1, label %B4\n\nB4:\n%15 = phi i32 [ -1, %B2 ], [ 0, %B ], [ 0, %B3 ]\nret i32 %15\n}", "codegemma": "define dso_local i32 @printChats() {\nB:\n%0 = load i64, ptr @lines, align 8\n%1 = icmp sgt i64 %0, 0\nbr i1 %1, label %B1, label %B4\n\nB1:\n%2 = load i32, ptr @screenTopIndex, align 4\n%3 = load i32, ptr @screenBottomIndex, align 4\n%4 = icmp sgt i32 %2, %3\nbr i1 %4, label %B4, label %B2\n\nB2:\n%5 = phi i32 [ %10, %B3 ], [ %2, %B1 ]\n%6 = phi i32 [ %9, %B3 ], [ 0, %B1 ]\n%7 = tail call i32 @move(i32 noundef %6, i32 noundef 0)\n%8 = tail call ptr @listGet(ptr noundef nonnull @lines, i32 noundef %5)\n%9 = add nuw nsw i32 %6, 1\n%10 = add nuw i32 %5, 1\n%11 = icmp eq ptr %8, null\nbr i1 %11, label %B3, label %B2\n\nB3:\n%12 = tail call i32 @cclog(i32 noundef 3, ptr noundef nonnull @.str, i32 noundef 25, ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%13 = phi i32 [ -1, %B3 ], [ 0, %B1 ], [ 0, %B ]\nret i32 %13\n}"}, "define dso_local nofpclass(nan inf) float @saturate(float noundef nofpclass(nan inf) %0) {\n%2 = alloca float, align 4\nstore float %0, ptr %2, align 4\n%3 = load float, ptr %2, align 4\n%4 = call fast nofpclass(nan inf) float @max(float noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) 0.000000e+00)\nstore float %4, ptr %2, align 4\n%5 = load float, ptr %2, align 4\n%6 = call fast nofpclass(nan inf) float @min(float noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) 1.000000e+00)\nstore float %6, ptr %2, align 4\n%7 = load float, ptr %2, align 4\nret float %7\n}": {"base_truth": "define dso_local nofpclass(nan inf) float @saturate(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) float @max(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) 0.000000e+00)\n%2 = tail call fast nofpclass(nan inf) float @min(float noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) 1.000000e+00)\nret float %2\n}", "codellama": "define dso_local nofpclass(nan inf) float @saturate(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) float @max(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) 0.000000e+00)\n%2 = tail call fast nofpclass(nan inf) float @min(float noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) 1.000000e+00)\nret float %2\n}", "codegemma": "define dso_local nofpclass(nan inf) float @saturate(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) float @max(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) 0.000000e+00)\n%2 = tail call fast nofpclass(nan inf) float @min(float noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) 1.000000e+00)\nret float %2\n}"}, "define dso_local void @GUI_OP_31_SUB_1132(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @GUI_OP_31_SUB_1132(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @GUI_OP_31_SUB_1132(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @GUI_OP_31_SUB_1132(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define internal i32 @si476x_radio_range_is_inside_of_the_band(i64 noundef %0, i64 noundef %1, i32 noundef %2) {\n%4 = alloca i64, align 8\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\nstore i64 %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\n%7 = load i64, ptr %4, align 8\n%8 = load ptr, ptr @si476x_bands, align 8\n%9 = load i32, ptr %6, align 4\n%10 = sext i32 %9 to i64\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i64 %10\n%12 = getelementptr inbounds %struct.TYPE_2__, ptr %11, i32 0, i32 0\n%13 = load i64, ptr %12, align 8\n%14 = icmp sge i64 %7, %13\nbr i1 %14, label %15, label %24\n\n15:\n%16 = load i64, ptr %5, align 8\n%17 = load ptr, ptr @si476x_bands, align 8\n%18 = load i32, ptr %6, align 4\n%19 = sext i32 %18 to i64\n%20 = getelementptr inbounds %struct.TYPE_2__, ptr %17, i64 %19\n%21 = getelementptr inbounds %struct.TYPE_2__, ptr %20, i32 0, i32 1\n%22 = load i64, ptr %21, align 8\n%23 = icmp sle i64 %16, %22\nbr label %24\n\n24:\n%25 = phi i1 [ false, %3 ], [ %23, %15 ]\n%26 = zext i1 %25 to i32\nret i32 %26\n}": {"base_truth": "define internal i32 @si476x_radio_range_is_inside_of_the_band(i64 noundef %0, i64 noundef %1, i32 noundef %2) {\nB:\n%3 = load ptr, ptr @si476x_bands, align 8\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %4\n%6 = load i64, ptr %5, align 8\n%7 = icmp sgt i64 %6, %0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %4, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp sge i64 %9, %1\n%11 = zext i1 %10 to i32\nbr label %B2\n\nB2:\n%12 = phi i32 [ 0, %B ], [ %11, %B1 ]\nret i32 %12\n}", "codellama": "define internal i32 @si476x_radio_range_is_inside_of_the_band(i64 noundef %0, i64 noundef %1, i32 noundef %2) {\nB:\n%3 = load ptr, ptr @si476x_bands, align 8\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %4\n%6 = load i64, ptr %5, align 8\n%7 = icmp sgt i64 %6, %0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %4, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp sge i64 %9, %1\n%11 = zext i1 %10 to i32\nbr label %B2\n\nB2:\n%12 = phi i32 [ 0, %B ], [ %11, %B1 ]\nret i32 %12\n}", "codegemma": "define internal i32 @si476x_radio_range_is_inside_of_the_band(i64 noundef %0, i64 noundef %1, i32 noundef %2) {\nB:\n%3 = load ptr, ptr @si476x_bands, align 8\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %4\n%6 = load i64, ptr %5, align 8\n%7 = icmp sgt i64 %6, %0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i64 %4, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp slt i64 %9, %1\n%11 = zext i1 %10 to i32\nbr label %B2\n\nB2:\n%12 = phi i32 [ 0, %B ], [ %11, %B1 ]\nret i32 %12\n}"}, "define internal i32 @init_format_block_info(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 0, ptr %5, align 4\nbr label %7\n\n7:\n%8 = load i32, ptr %5, align 4\n%9 = load ptr, ptr @format_block_info, align 8\n%10 = call i32 @ARRAY_SIZE(ptr noundef %9)\n%11 = icmp ult i32 %8, %10\nbr i1 %11, label %12, label %67\n\n12:\n%13 = load ptr, ptr %3, align 8\n%14 = load ptr, ptr @format_block_info, align 8\n%15 = load i32, ptr %5, align 4\n%16 = zext i32 %15 to i64\n%17 = getelementptr inbounds %struct.TYPE_3__, ptr %14, i64 %16\n%18 = getelementptr inbounds %struct.TYPE_3__, ptr %17, i32 0, i32 4\n%19 = load i32, ptr %18, align 4\n%20 = call ptr @get_format_internal(ptr noundef %13, i32 noundef %19)\nstore ptr %20, ptr %4, align 8\n%21 = icmp ne ptr %20, null\nbr i1 %21, label %24, label %22\n\n22:\n%23 = load i32, ptr @FALSE, align 4\nstore i32 %23, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %69\n\n24:\n%25 = load ptr, ptr @format_block_info, align 8\n%26 = load i32, ptr %5, align 4\n%27 = zext i32 %26 to i64\n%28 = getelementptr inbounds %struct.TYPE_3__, ptr %25, i64 %27\n%29 = getelementptr inbounds %struct.TYPE_3__, ptr %28, i32 0, i32 3\n%30 = load i32, ptr %29, align 4\n%31 = load ptr, ptr %4, align 8\n%32 = getelementptr inbounds %struct.wined3d_format ptr %31, i32 0, i32 2\nstore i32 %30, ptr %32, align 4\n%33 = load ptr, ptr @format_block_info, align 8\n%34 = load i32, ptr %5, align 4\n%35 = zext i32 %34 to i64\n%36 = getelementptr inbounds %struct.TYPE_3__, ptr %33, i64 %35\n%37 = getelementptr inbounds %struct.TYPE_3__, ptr %36, i32 0, i32 2\n%38 = load i32, ptr %37, align 4\n%39 = load ptr, ptr %4, align 8\n%40 = getelementptr inbounds %struct.wined3d_format ptr %39, i32 0, i32 1\nstore i32 %38, ptr %40, align 4\n%41 = load ptr, ptr @format_block_info, align 8\n%42 = load i32, ptr %5, align 4\n%43 = zext i32 %42 to i64\n%44 = getelementptr inbounds %struct.TYPE_3__, ptr %41, i64 %43\n%45 = getelementptr inbounds %struct.TYPE_3__, ptr %44, i32 0, i32 1\n%46 = load i32, ptr %45, align 4\n%47 = load ptr, ptr %4, align 8\n%48 = getelementptr inbounds %struct.wined3d_format ptr %47, i32 0, i32 0\nstore i32 %46, ptr %48, align 4\n%49 = load ptr, ptr %4, align 8\n%50 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS, align 4\n%51 = call i32 @format_set_flag(ptr noundef %49, i32 noundef %50)\n%52 = load ptr, ptr @format_block_info, align 8\n%53 = load i32, ptr %5, align 4\n%54 = zext i32 %53 to i64\n%55 = getelementptr inbounds %struct.TYPE_3__, ptr %52, i64 %54\n%56 = getelementptr inbounds %struct.TYPE_3__, ptr %55, i32 0, i32 0\n%57 = load i32, ptr %56, align 4\n%58 = icmp ne i32 %57, 0\nbr i1 %58, label %63, label %59\n\n59:\n%60 = load ptr, ptr %4, align 8\n%61 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS_NO_VERIFY, align 4\n%62 = call i32 @format_set_flag(ptr noundef %60, i32 noundef %61)\nbr label %63\n\n63:\nbr label %64\n\n64:\n%65 = load i32, ptr %5, align 4\n%66 = add i32 %65, 1\nstore i32 %66, ptr %5, align 4\nbr label %7\n\n67:\n%68 = load i32, ptr @TRUE, align 4\nstore i32 %68, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %69\n\n69:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%70 = load i32, ptr %2, align 4\nret i32 %70\n}": {"base_truth": "define internal i32 @init_format_block_info(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @format_block_info, align 8\n%2 = tail call i32 @ARRAY_SIZE(ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = phi i64 [ %26, %B4 ], [ 0, %B ]\n%5 = load ptr, ptr @format_block_info, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i64 %4, i32 4\n%7 = load i32, ptr %6, align 4\n%8 = tail call ptr @get_format_internal(ptr noundef %0, i32 noundef %7)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B5, label %B2\n\nB2:\n%10 = load ptr, ptr @format_block_info, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i64 %4, i32 3\n%12 = load i32, ptr %11, align 4\n%13 = getelementptr inbounds %struct.wined3d_format, ptr %8, i64 0, i32 2\nstore i32 %12, ptr %13, align 4\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i64 %4, i32 1\n%15 = load <2 x i32>, ptr %14, align 4\nstore <2 x i32> %15, ptr %8, align 4\n%16 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS, align 4\n%17 = tail call i32 @format_set_flag(ptr noundef nonnull %8, i32 noundef %16)\n%18 = load ptr, ptr @format_block_info, align 8\n%19 = getelementptr inbounds %struct.TYPE_3__, ptr %18, i64 %4\n%20 = load i32, ptr %19, align 4\n%21 = icmp eq i32 %20, 0\nbr i1 %21, label %B3, label %B4\n\nB3:\n%22 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS_NO_VERIFY, align 4\n%23 = tail call i32 @format_set_flag(ptr noundef nonnull %8, i32 noundef %22)\n%24 = load ptr, ptr @format_block_info, align 8\nbr label %B4\n\nB4:\n%25 = phi ptr [ %18, %B2 ], [ %24, %B3 ]\n%26 = add nuw nsw i64 %4, 1\n%27 = tail call i32 @ARRAY_SIZE(ptr noundef %25)\n%28 = zext i32 %27 to i64\n%29 = icmp ult i64 %26, %28\nbr i1 %29, label %B1, label %B5\n\nB5:\n%30 = phi ptr [ @TRUE, %B ], [ @TRUE, %B4 ], [ @FALSE, %B1 ]\n%31 = load i32, ptr %30, align 4\nret i32 %31\n}", "codellama": "define internal i32 @init_format_block_info(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @format_block_info, align 8\n%2 = tail call i32 @ARRAY_SIZE(ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = phi i64 [ %21, %B4 ], [ 0, %B ]\n%5 = load ptr, ptr @format_block_info, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i64 %4, i32 4\n%7 = load i32, ptr %6, align 4\n%8 = tail call ptr @get_format_internal(ptr noundef %0, i32 noundef %7)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B5, label %B2\n\nB2:\n%10 = load ptr, ptr @format_block_info, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i64 %4, i32 3\n%12 = load i32, ptr %11, align 4\n%13 = getelementptr inbounds %struct.wined3d_format, ptr %8, i64 0, i32 2\nstore i32 %12, ptr %13, align 4\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i64 %4, i32 2\n%15 = load i32, ptr %14, align 4\n%16 = getelementptr inbounds %struct.wined3d_format, ptr %8, i64 0, i32 1\nstore i32 %15, ptr %16, align 4\n%17 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i64 %4\n%18 = load <4 x i32>, ptr %17, align 4\nstore <4 x i32> %18, ptr %8, align 4\n%19 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS, align 4\n%20 = tail call i32 @format_set_flag(ptr noundef nonnull %8, i32 noundef %19)\n%21 = add nuw nsw i64 %4, 1\n%22 = load ptr, ptr @format_block_info, align 8\n%23 = tail call i32 @ARRAY_SIZE(ptr noundef %22)\n%24 = zext i32 %23 to i64\n%25 = icmp ult i64 %21, %24\nbr i1 %25, label %B1, label %B5\n\nB3:\n%26 = add nuw nsw i64 %30, 1\n%2</s>", "codegemma": "define internal i32 @init_format_block_info(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @format_block_info, align 8\n%2 = tail call i32 @ARRAY_SIZE(ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = phi i64 [ %12, %B4 ], [ 0, %B ]\n%5 = load ptr, ptr @format_block_info, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i64 %4, i32 4\n%7 = load i32, ptr %6, align 4\n%8 = tail call ptr @get_format_internal(ptr noundef %0, i32 noundef %7)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = load i32, ptr @FALSE, align 4\nbr label %B5\n\nB3:\n%11 = getelementptr inbounds %struct.wined3d_format, ptr %8, i64 0, i32 2\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i64 %4, i32 2\n%13 = load i32, ptr %12, align 4\n%14 = getelementptr inbounds %struct.wined3d_format, ptr %8, i64 0, i32 1\n%15 = load i32, ptr %14, align 4\n%16 = load i32, ptr %11, align 4\nstore i32 %16, ptr %14, align 4\n%17 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS, align 4\n%18 = tail call i32 @format_set_flag(ptr noundef nonnull %8, i32 noundef %17)\n%19 = load ptr, ptr @format_block_info, align 8\n%20 = getelementptr inbounds %struct.TYPE_3__, ptr %19, i64 %4\n%21 = load i32, ptr %20, align 4\n%22 = icmp eq i32 %21, 0\nbr i1 %22, label %B4, label %B5\n\nB4:\n%23 = load i32, ptr @WINED3DFMT_FLAG_BLOCKS_NO_VERIFY, align 4\n%24 = tail call i32 @format_set_flag(ptr noundef nonnull %8, i32 noundef %23)\nbr label %B5\n\nB5:\n%25 = phi i32 [ %10, %B2 ], [ @TRUE, %B4 ], [ @TRUE, %B3 ], [ @TRUE, %B ]\n%26 = load i32, ptr %25, align 4\nret i32 %26\n}"}, "define dso_local i64 @OvsNewServerSessionId(ptr noundef %0) {\n%2 = alloca i64, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%9 = load ptr, ptr %3, align 8\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %11, label %12\n\n11:\nstore i64 0, ptr %2, align 8\nbr label %54\n\n12:\nbr label %13\n\n13:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%14 = call i64 (...) @Rand64()\nstore i64 %14, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\n%15 = load i64, ptr %4, align 8\n%16 = icmp eq i64 %15, 0\nbr i1 %16, label %20, label %17\n\n17:\n%18 = load i64, ptr %4, align 8\n%19 = icmp eq i64 %18, -1\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 2, ptr %7, align 4\nbr label %51\n\n21:\nstore i64 0, ptr %5, align 8\nbr label %22\n\n22:\n%23 = load i64, ptr %5, align 8\n%24 = load ptr, ptr %3, align 8\n%25 = getelementptr inbounds %struct.TYPE_6__, ptr %24, i32 0, i32 0\n%26 = load i32, ptr %25, align 4\n%27 = call i64 @LIST_NUM(i32 noundef %26)\n%28 = icmp slt i64 %23, %27\nbr i1 %28, label %29, label %45\n\n29:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%30 = load ptr, ptr %3, align 8\n%31 = getelementptr inbounds %struct.TYPE_6__, ptr %30, i32 0, i32 0\n%32 = load i32, ptr %31, align 4\n%33 = load i64, ptr %5, align 8\n%34 = call ptr @LIST_DATA(i32 noundef %32, i64 noundef %33)\nstore ptr %34, ptr %8, align 8\n%35 = load ptr, ptr %8, align 8\n%36 = getelementptr inbounds %struct.TYPE_5__, ptr %35, i32 0, i32 0\n%37 = load i64, ptr %36, align 8\n%38 = load i64, ptr %4, align 8\n%39 = icmp eq i64 %37, %38\nbr i1 %39, label %40, label %41\n\n40:\nstore i32 1, ptr %6, align 4\nbr label %41\n\n41:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\nbr label %42\n\n42:\n%43 = load i64, ptr %5, align 8\n%44 = add nsw i64 %43, 1\nstore i64 %44, ptr %5, align 8\nbr label %22\n\n45:\n%46 = load i32, ptr %6, align 4\n%47 = icmp eq i32 %46, 0\nbr i1 %47, label %48, label %50\n\n48:\n%49 = load i64, ptr %4, align 8\nstore i64 %49, ptr %2, align 8\nstore i32 1, ptr %7, align 4\nbr label %51\n\n50:\nstore i32 0, ptr %7, align 4\nbr label %51\n\n51:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%52 = load i32, ptr %7, align 4\nswitch i32 %52, label %56 [\ni32 0, label %53\ni32 2, label %13\ni32 1, label %54\n]\n\n53:\nbr label %13\n\n54:\n%55 = load i64, ptr %2, align 8\nret i64 %55\n\n56:\nunreachable\n}": {"base_truth": "define dso_local i64 @OvsNewServerSessionId(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B6, label %B1\n\nB1:\n%2 = tail call i64 (...) @Rand64()\n%3 = add i64 %2, 1\n%4 = icmp ult i64 %3, 2\nbr i1 %4, label %B2, label %B3\n\nB2:\nbr label %B1\n\nB3:\n%5 = load i32, ptr %0, align 4\n%6 = tail call i64 @LIST_NUM(i32 noundef %5)\n%7 = icmp sgt i64 %6, 0\nbr i1 %7, label %B4, label %B6\n\nB4:\n%8 = phi i32 [ %14, %B4 ], [ 0, %B3 ]\n%9 = phi i64 [ %15, %B4 ], [ 0, %B3 ]\n%10 = load i32, ptr %0, align 4\n%11 = tail call ptr @LIST_DATA(i32 noundef %10, i64 noundef %9)\n%12 = load i64, ptr %11, align 8\n%13 = icmp eq i64 %12, %2\n%14 = select i1 %13, i32 1, i32 %8\n%15 = add nuw nsw i64 %9, 1\n%16 = load i32, ptr %0, align 4\n%17 = tail call i64 @LIST_NUM(i32 noundef %16)\n%18 = icmp slt i64 %15, %17\nbr i1 %18, label %B4, label %B5\n\nB5:\n%19 = icmp eq i32 %14, 0\nbr i1 %19, label %B6, label %B2\n\nB6:\n%20 = phi i64 [ 0, %B ], [ %2, %B5 ], [ %2, %B3 ]\nret i64 %20\n}", "codellama": "define dso_local i64 @OvsNewServerSessionId(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B5, label %B1\n\nB1:\n%2 = tail call i64 (...) @Rand64()\n%3 = icmp eq i64 %2, 0\n%4 = icmp eq i64 %2, -1\n%5 = or i1 %3, %4\nbr i1 %5, label %B5, label %B2\n\nB2:\n%6 = phi i64 [ %14, %B4 ], [ 0, %B1 ]\n%7 = load i32, ptr %0, align 4\n%8 = tail call i64 @LIST_NUM(i32 noundef %7)\n%9 = icmp sgt i64 %8, %6\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = phi i64 [ %14, %B3 ], [ 0, %B2 ]\n%11 = load i32, ptr %0, align 4\n%12 = tail call ptr @LIST_DATA(i32 noundef %11, i64 noundef %10)\n%13 = load i64, ptr %12, align 8\n%14 = add nuw nsw i64 %10, 1\n%15 = load i32, ptr %0, align 4\n%16 = tail call i64 @LIST_NUM(i32 noundef %15)\n%17 = icmp slt i64 %14, %16\nbr i1 %17, label %B3, label %B2\n\nB4:\n%18 = icmp eq i64 %8, %6\nbr i1 %18, label %B5, label %B2\n\nB5:\n%19 = phi i64 [ 0, %B ], [ %2, %B1 ], [ %6, %B4 ], [ %2, %B2 ]\nret i64 %19\n}", "codegemma": "define dso_local i64 @OvsNewServerSessionId(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B6, label %B1\n\nB1:\n%2 = phi i64 [ %11, %B5 ], [ 0, %B ]\n%3 = tail call i64 (...) @Rand64()\n%4 = icmp eq i64 %3, 0\n%5 = icmp eq i64 %3, -1\n%6 = or i1 %4, %5\nbr i1 %6, label %B6, label %B2\n\nB2:\n%7 = load i32, ptr %0, align 4\n%8 = tail call i64 @LIST_NUM(i32 noundef %7)\n%9 = icmp sgt i64 %8, 0\nbr i1 %9, label %B3, label %B5\n\nB3:\n%10 = phi i64 [ %14, %B4 ], [ 0, %B2 ]\n%11 = phi i64 [ %13, %B4 ], [ %3, %B2 ]\n%12 = load i32, ptr %0, align 4\n%13 = tail call ptr @LIST_DATA(i32 noundef %12, i64 noundef %10)\n%14 = load i64, ptr %13, align 8\n%15 = icmp eq i64 %14, %11\nbr i1 %15, label %B5, label %B4\n\nB4:\n%16 = icmp eq i64 %11, 0\nbr i1 %16, label %B6, label %B3\n\nB5:\n%17 = icmp eq i64 %2, 0\nbr i1 %17, label %B6, label %B1\n\nB6:\n%18 = phi i64 [ 0, %B ], [ %3, %B1 ], [ 0, %B4 ], [ %11, %B3 ], [ 0, %B5 ]\nret i64 %18\n}"}, "define internal void @check_speed_bin(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%7 = load ptr, ptr %2, align 8\n%8 = call ptr @nvmem_cell_get(ptr noundef %7, ptr noundef @.str)\nstore ptr %8, ptr %3, align 8\n%9 = load ptr, ptr %3, align 8\n%10 = call i64 @IS_ERR(ptr noundef %9)\n%11 = icmp ne i64 %10, 0\nbr i1 %11, label %12, label %13\n\n12:\nstore i32 1, ptr %6, align 4\nbr label %24\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = call i64 @nvmem_cell_read(ptr noundef %14, ptr noundef null)\n%16 = inttoptr i64 %15 to ptr\n%17 = load i32, ptr %16, align 4\nstore i32 %17, ptr %4, align 4\n%18 = load ptr, ptr %3, align 8\n%19 = call i32 @nvmem_cell_put(ptr noundef %18)\n%20 = load i32, ptr %4, align 4\n%21 = shl i32 1, %20\nstore i32 %21, ptr %5, align 4\n%22 = load ptr, ptr %2, align 8\n%23 = call i32 @dev_pm_opp_set_supported_hw(ptr noundef %22, ptr noundef %5, i32 noundef 1)\nstore i32 0, ptr %6, align 4\nbr label %24\n\n24:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\n%25 = load i32, ptr %6, align 4\nswitch i32 %25, label %27 [\ni32 0, label %26\ni32 1, label %26\n]\n\n26:\nret void\n\n27:\nunreachable\n}": {"base_truth": "define internal void @check_speed_bin(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = tail call ptr @nvmem_cell_get(ptr noundef %0, ptr noundef nonnull @.str)\n%3 = tail call i64 @IS_ERR(ptr noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i64 @nvmem_cell_read(ptr noundef %2, ptr noundef null)\n%6 = inttoptr i64 %5 to ptr\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @nvmem_cell_put(ptr noundef %2)\n%9 = shl nuw i32 1, %7\nstore i32 %9, ptr %1, align 4\n%10 = call i32 @dev_pm_opp_set_supported_hw(ptr noundef %0, ptr noundef nonnull %1, i32 noundef 1)\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codellama": "define internal void @check_speed_bin(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = tail call ptr @nvmem_cell_get(ptr noundef %0, ptr noundef nonnull @.str)\n%3 = tail call i64 @IS_ERR(ptr noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i64 @nvmem_cell_read(ptr noundef %2, ptr noundef null)\n%6 = inttoptr i64 %5 to ptr\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @nvmem_cell_put(ptr noundef %2)\n%9 = shl nuw i32 1, %7\nstore i32 %9, ptr %1, align 4\n%10 = call i32 @dev_pm_opp_set_supported_hw(ptr noundef %0, ptr noundef nonnull %1, i32 noundef 1)\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codegemma": "define internal void @check_speed_bin(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = tail call ptr @nvmem_cell_get(ptr noundef %0, ptr noundef nonnull @.str)\n%3 = tail call i64 @IS_ERR(ptr noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i64 @nvmem_cell_read(ptr noundef %2, ptr noundef null)\n%6 = inttoptr i64 %5 to ptr\n%7 = load i32, ptr %6, align 4\n%8 = shl nuw i32 1, %7\nstore i32 %8, ptr %1, align 4\n%9 = call i32 @nvmem_cell_put(ptr noundef %2)\n%10 = call i32 @dev_pm_opp_set_supported_hw(ptr noundef %0, ptr noundef nonnull %1, i32 noundef 1)\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}"}, "define dso_local i32 @DelayDisp(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 150, ptr %4, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %4, align 4\n%8 = icmp ne i32 %7, 0\nbr i1 %8, label %9, label %13\n\n9:\n%10 = call i32 @Delay(i32 noundef 60000)\n%11 = load i32, ptr %4, align 4\n%12 = add nsw i32 %11, -1\nstore i32 %12, ptr %4, align 4\nbr label %6\n\n13:\n%14 = load i32, ptr %3, align 4\n%15 = icmp eq i32 %14, 108\nbr i1 %15, label %16, label %17\n\n16:\nstore i32 109, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %19\n\n17:\n%18 = load i32, ptr %4, align 4\nstore i32 %18, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %19\n\n19:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%20 = load i32, ptr %2, align 4\nret i32 %20\n}": {"base_truth": "define dso_local i32 @DelayDisp(i32 noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i32 [ 150, %B ], [ %3, %B1 ]\n%2 = tail call i32 @Delay(i32 noundef 60000)\n%3 = add nsw i32 %1, -1\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB2:\n%5 = icmp eq i32 %0, 108\n%6 = select i1 %5, i32 109, i32 0\nret i32 %6\n}", "codellama": "define dso_local i32 @DelayDisp(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 108\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 150, %B ]\n%3 = tail call i32 @Delay(i32 noundef 60000)\n%4 = add nsw i32 %2, -1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B1\n\nB2:\n%6 = phi i32 [ 109, %B ], [ %2, %B1 ]\nret i32 %6\n}", "codegemma": "define dso_local i32 @DelayDisp(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 108\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 150, %B ]\n%3 = tail call i32 @Delay(i32 noundef 60000)\n%4 = add nsw i32 %2, -1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B1\n\nB2:\n%6 = phi i32 [ 109, %B ], [ %4, %B1 ]\nret i32 %6\n}"}, "define dso_local i32 @WaypointActiveHandle() {\n%1 = load i32, ptr @handle, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @WaypointActiveHandle() {\nB:\n%0 = load i32, ptr @handle, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @WaypointActiveHandle() {\nB:\n%0 = load i32, ptr @handle, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @WaypointActiveHandle() {\nB:\n%0 = load i32, ptr @handle, align 4\nret i32 %0\n}"}, "define dso_local i32 @Gmenudisplay(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%9 = load i32, ptr %4, align 4\n%10 = icmp slt i32 %9, 0\nbr i1 %10, label %23, label %11\n\n11:\n%12 = load i32, ptr %4, align 4\n%13 = load i32, ptr @Gwidgetn, align 4\n%14 = icmp sgt i32 %12, %13\nbr i1 %14, label %23, label %15\n\n15:\n%16 = load ptr, ptr @Gwidgets, align 8\n%17 = load i32, ptr %4, align 4\n%18 = sext i32 %17 to i64\n%19 = getelementptr inbounds %struct.TYPE_5__, ptr %16, i64 %18\n%20 = getelementptr inbounds %struct.TYPE_5__, ptr %19, i32 0, i32 0\n%21 = load i32, ptr %20, align 4\n%22 = icmp ne i32 %21, 0\nbr i1 %22, label %26, label %23\n\n23:\n%24 = load i32, ptr %5, align 4\n%25 = call i32 @Gerr(ptr noundef @.str, i32 noundef 423, i32 noundef 4, i32 noundef %24)\nstore i32 -1, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %56\n\n26:\n%27 = load i32, ptr %5, align 4\n%28 = icmp slt i32 %27, 0\nbr i1 %28, label %41, label %29\n\n29:\n%30 = load i32, ptr %5, align 4\n%31 = load i32, ptr @Gwidgetn, align 4\n%32 = icmp sgt i32 %30, %31\nbr i1 %32, label %41, label %33\n\n33:\n%34 = load ptr, ptr @Gwidgets, align 8\n%35 = load i32, ptr %5, align 4\n%36 = sext i32 %35 to i64\n%37 = getelementptr inbounds %struct.TYPE_5__, ptr %34, i64 %36\n%38 = getelementptr inbounds %struct.TYPE_5__, ptr %37, i32 0, i32 0\n%39 = load i32, ptr %38, align 4\n%40 = icmp ne i32 %39, 0\nbr i1 %40, label %44, label %41\n\n41:\n%42 = load i32, ptr %5, align 4\n%43 = call i32 @Gerr(ptr noundef @.str, i32 noundef 427, i32 noundef 5, i32 noundef %42)\nstore i32 -1, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %56\n\n44:\n%45 = load ptr, ptr @Gwidgets, align 8\n%46 = load i32, ptr %4, align 4\n%47 = sext i32 %46 to i64\n%48 = getelementptr inbounds %struct.TYPE_5__, ptr %45, i64 %47\nstore ptr %48, ptr %6, align 8\n%49 = load ptr, ptr @Gwidgets, align 8\n%50 = load i32, ptr %5, align 4\n%51 = sext i32 %50 to i64\n%52 = getelementptr inbounds %struct.TYPE_5__, ptr %49, i64 %51\nstore ptr %52, ptr %7, align 8\n%53 = load ptr, ptr %6, align 8\n%54 = load ptr, ptr %7, align 8\n%55 = call i32 @GMmenudisplay(ptr noundef %53, ptr noundef %54)\nstore i32 %55, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %56\n\n56:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%57 = load i32, ptr %3, align 4\nret i32 %57\n}": {"base_truth": "define dso_local i32 @Gmenudisplay(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %0, 0\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = load i32, ptr @Gwidgetn, align 4\n%4 = icmp slt i32 %3, %0\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = load ptr, ptr @Gwidgets, align 8\n%6 = zext i32 %0 to i64\n%7 = getelementptr inbounds %struct.TYPE_5__, ptr %5, i64 %6\n%8 = load i32, ptr %7, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = tail call i32 @Gerr(ptr noundef nonnull @.str, i32 noundef 423, i32 noundef 4, i32 noundef %1)\nbr label %B8\n\nB4:\n%11 = icmp slt i32 %1, 0\n%12 = icmp slt i32 %3, %1\n%13 = or i1 %11, %12\nbr i1 %13, label %B6, label %B5\n\nB5:\n%14 = zext i32 %1 to i64\n%15 = getelementptr inbounds %struct.TYPE_5__, ptr %5, i64 %14\n%16 = load i32, ptr %15, align 4\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B6, label %B7\n\nB6:\n%18 = tail call i32 @Gerr(ptr noundef nonnull @.str, i32 noundef 427, i32 noundef 5, i32 noundef %1)\nbr label %B8\n\nB7:\n%19 = tail call i32 @GMmenudisplay(ptr noundef nonnull %7, ptr noundef nonnull %15)\nbr label %B8\n\nB8:\n%20 = phi i32 [ -1, %B3 ], [ -1, %B6 ], [ %19, %B7 ]\nret i32 %20\n}", "codellama": "define dso_local i32 @Gmenudisplay(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %0, 0\n%3 = load i32, ptr @Gwidgetn, align 4\n%4 = icmp slt i32 %3, %0\n%5 = select i1 %2, i1 true, i1 %4\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = load ptr, ptr @Gwidgets, align 8\n%7 = zext i32 %0 to i64\n%8 = getelementptr inbounds %struct.TYPE_5__, ptr %6, i64 %7\n%9 = load i32, ptr %8, align 4\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = icmp sgt i32 %1, %3\n%12 = icmp sgt i32 %1, %0\n%13 = or i1 %11, %12\nbr i1 %13, label %B3, label %B4\n\nB3:\n%14 = tail call i32 @Gerr(ptr noundef nonnull @.str, i32 noundef 423, i32 noundef 4, i32 noundef %1)\nbr label %B6\n\nB4:\n%15 = zext i32 %1 to i64\n%16 = getelementptr inbounds %struct.TYPE_5__, ptr %6, i64 %15\n%17 = load i32, ptr %16, align 4\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B3, label %B5\n\nB5:\n%19 = tail call i32 @GMmenudisplay(ptr noundef nonnull %8, ptr noundef nonnull %16)\nbr label %B6\n\nB6:\n%20 = phi i32 [ -1, %B3 ], [ %19, %B5 ]\nret i32 %20\n}", "codegemma": "define dso_local i32 @Gmenudisplay(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %0, 0\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = load i32, ptr @Gwidgetn, align 4\n%4 = icmp slt i32 %3, %0\nbr i1 %4, label %B4, label %B2\n\nB2:\n%5 = load ptr, ptr @Gwidgets, align 8\n%6 = sext i32 %0 to i64\n%7 = getelementptr inbounds %struct.TYPE_5__, ptr %5, i64 %6\n%8 = load i32, ptr %7, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = icmp slt i32 %1, 0\n%11 = icmp sgt i32 %1, %3\n%12 = or i1 %10, %11\nbr i1 %12, label %B4, label %B5\n\nB4:\n%13 = phi ptr [ @.str, %B1 ], [ @.str, %B ], [ @.str, %B2 ], [ @.str, %B3 ]\n%14 = tail call i32 @Gerr(ptr noundef nonnull %13, i32 noundef 423, i32 noundef 4, i32 noundef %1)\nbr label %B7\n\nB5:\n%15 = sext i32 %1 to i64\n%16 = getelementptr inbounds %struct.TYPE_5__, ptr %5, i64 %15\n%17 = getelementptr inbounds %struct.TYPE_5__, ptr %5, i64 %6\n%18 = tail call i32 @GMmenudisplay(ptr noundef %17, ptr noundef %16)\nbr label %B7\n\nB6:\n%19 = tail call i32 @Gerr(ptr noundef nonnull @.str, i32 noundef 427, i32 noundef 5, i32 noundef %1)\nbr label %B7\n\nB7:\n%20 = phi i32 [ -1, %B4 ], [ %18, %B5 ], [ -1, %B6 ]\nret i32 %20\n}"}, "define dso_local i32 @XGMCommand_isFrame(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define dso_local i32 @XGMCommand_isFrame(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define dso_local i32 @XGMCommand_isFrame(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define dso_local i32 @XGMCommand_isFrame(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define dso_local void @legacyInit() {\n%1 = alloca [512 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 512, ptr %1)\n%2 = call i32 @vspace(i32 noundef 3)\n%3 = call i32 @commentln(ptr noundef @.str)\n%4 = call i32 @codeln(ptr noundef @.str.1)\n%5 = call i32 (...) @pushIndent()\n%6 = call i32 @codeln(ptr noundef @.str.2)\n%7 = call i32 @codeln(ptr noundef @.str.3)\n%8 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%9 = call i32 @sprintf(ptr noundef %8, ptr noundef @.str.4)\n%10 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%11 = call i32 @codeln(ptr noundef %10)\n%12 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%13 = call i32 @sprintf(ptr noundef %12, ptr noundef @.str.5)\n%14 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%15 = call i32 @codeln(ptr noundef %14)\n%16 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%17 = call i32 @sprintf(ptr noundef %16, ptr noundef @.str.6)\n%18 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%19 = call i32 @codeln(ptr noundef %18)\n%20 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%21 = call i32 @sprintf(ptr noundef %20, ptr noundef @.str.7)\n%22 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%23 = call i32 @codeln(ptr noundef %22)\n%24 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%25 = call i32 @sprintf(ptr noundef %24, ptr noundef @.str.8)\n%26 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%27 = call i32 @codeln(ptr noundef %26)\n%28 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%29 = call i32 @sprintf(ptr noundef %28, ptr noundef @.str.9)\n%30 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%31 = call i32 @codeln(ptr noundef %30)\n%32 = call i32 (...) @ini_biased()\n%33 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%34 = call i32 @sprintf(ptr noundef %33, ptr noundef @.str.10)\n%35 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%36 = call i32 @codeln(ptr noundef %35)\n%37 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%38 = call i32 @sprintf(ptr noundef %37, ptr noundef @.str.11)\n%39 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%40 = call i32 @codeln(ptr noundef %39)\n%41 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%42 = call i32 @sprintf(ptr noundef %41, ptr noundef @.str.12)\n%43 = getelementptr inbounds [512 x i8], ptr %1, i64 0, i64 0\n%44 = call i32 @codeln(ptr noundef %43)\n%45 = call i32 (...) @popIndent()\n%46 = call i32 @codeln(ptr noundef @.str.13)\ncall void @llvm.lifetime.end.p0(i64 512, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @legacyInit() {\nB:\n%0 = alloca [512 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 512, ptr nonnull %0)\n%1 = tail call i32 @vspace(i32 noundef 3)\n%2 = tail call i32 @commentln(ptr noundef nonnull @.str)\n%3 = tail call i32 @codeln(ptr noundef nonnull @.str.1)\n%4 = tail call i32 (...) @pushIndent()\n%5 = tail call i32 @codeln(ptr noundef nonnull @.str.2)\n%6 = tail call i32 @codeln(ptr noundef nonnull @.str.3)\n%7 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.4)\n%8 = call i32 @codeln(ptr noundef nonnull %0)\n%9 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)\n%10 = call i32 @codeln(ptr noundef nonnull %0)\n%11 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.6)\n%12 = call i32 @codeln(ptr noundef nonnull %0)\n%13 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.7)\n%14 = call i32 @codeln(ptr noundef nonnull %0)\n%15 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.8)\n%16 = call i32 @codeln(ptr noundef nonnull %0)\n%17 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.9)\n%18 = call i32 @codeln(ptr noundef nonnull %0)\n%19 = call i32 (...) @ini_biased()\n%20 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.10)\n%21 = call i32 @codeln(ptr noundef nonnull %0)\n%22 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.11)\n%23 = call i32 @codeln(ptr noundef nonnull %0)\n%24 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.12)\n%25 = call i32 @codeln(ptr noundef nonnull %0)\n%26 = call i32 (...) @popIndent()\n%27 = call i32 @codeln(ptr noundef nonnull @.str.13)\ncall void @llvm.lifetime.end.p0(i64 512, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @legacyInit() {\nB:\n%0 = alloca [512 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 512, ptr nonnull %0)\n%1 = tail call i32 @vspace(i32 noundef 3)\n%2 = tail call i32 @commentln(ptr noundef nonnull @.str)\n%3 = tail call i32 @codeln(ptr noundef nonnull @.str.1)\n%4 = tail call i32 (...) @pushIndent()\n%5 = tail call i32 @codeln(ptr noundef nonnull @.str.2)\n%6 = tail call i32 @codeln(ptr noundef nonnull @.str.3)\n%7 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.4)\n%8 = call i32 @codeln(ptr noundef nonnull %0)\n%9 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)\n%10 = call i32 @codeln(ptr noundef nonnull %0)\n%11 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.6)\n%12 = call i32 @codeln(ptr noundef nonnull %0)\n%13 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.7)\n%14 = call i32 @codeln(ptr noundef nonnull %0)\n%15 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.8)\n%16 = call i32 @codeln(ptr noundef nonnull %0)\n%17 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.9)\n%18 = call i32 @codeln(ptr noundef nonnull %0)\n%19 = call i32 (...) @ini_biased()\n%20 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.10)\n%21 = call i32 @codeln(ptr noundef nonnull %0)\n%22 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.11)\n%23 = call i32 @codeln(ptr noundef nonnull %0)\n%24 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.12)\n%25 = call i32 @codeln(ptr noundef nonnull %0)\n%26 = call i32 (...) @popIndent()\n%27 = call i32 @codeln(ptr noundef nonnull @.str.13)\ncall void @llvm.lifetime.end.p0(i64 512, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @legacyInit() {\nB:\n%0 = alloca [512 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 512, ptr nonnull %0)\n%1 = tail call i32 @vspace(i32 noundef 3)\n%2 = tail call i32 @commentln(ptr noundef nonnull @.str)\n%3 = tail call i32 @codeln(ptr noundef nonnull @.str.1)\n%4 = tail call i32 (...) @pushIndent()\n%5 = tail call i32 @codeln(ptr noundef nonnull @.str.2)\n%6 = tail call i32 @codeln(ptr noundef nonnull @.str.3)\n%7 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.4)\n%8 = call i32 @codeln(ptr noundef nonnull %0)\n%9 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)\n%10 = call i32 @codeln(ptr noundef nonnull %0)\n%11 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.6)\n%12 = call i32 @codeln(ptr noundef nonnull %0)\n%13 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.7)\n%14 = call i32 @codeln(ptr noundef nonnull %0)\n%15 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.8)\n%16 = call i32 @codeln(ptr noundef nonnull %0)\n%17 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.9)\n%18 = call i32 @codeln(ptr noundef nonnull %0)\n%19 = call i32 (...) @ini_biased()\n%20 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.10)\n%21 = call i32 @codeln(ptr noundef nonnull %0)\n%22 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.11)\n%23 = call i32 @codeln(ptr noundef nonnull %0)\n%24 = call i32 @sprintf(ptr noundef nonnull %0, ptr noundef nonnull @.str.12)\n%25 = call i32 @codeln(ptr noundef nonnull %0)\n%26 = call i32 (...) @popIndent()\n%27 = call i32 @codeln(ptr noundef nonnull @.str.13)\ncall void @llvm.lifetime.end.p0(i64 512, ptr nonnull %0)\nret void\n}"}, "define dso_local nofpclass(nan inf) double @c_modf(double noundef nofpclass(nan inf) %0, ptr noundef %1) {\n%3 = alloca double, align 8\n%4 = alloca ptr, align 8\nstore double %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load double, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call fast nofpclass(nan inf) double @modf(double noundef nofpclass(nan inf) %5, ptr noundef %6)\nret double %7\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @c_modf(double noundef nofpclass(nan inf) %0, ptr noundef %1) {\nB:\n%2 = tail call fast nofpclass(nan inf) double @modf(double noundef nofpclass(nan inf) %0, ptr noundef %1)\nret double %2\n}", "codellama": "define dso_local nofpclass(nan inf) double @c_modf(double noundef nofpclass(nan inf) %0, ptr noundef %1) {\nB:\n%2 = tail call fast nofpclass(nan inf) double @modf(double noundef nofpclass(nan inf) %0, ptr noundef %1)\nret double %2\n}", "codegemma": "define dso_local nofpclass(nan inf) double @c_modf(double noundef nofpclass(nan inf) %0, ptr noundef %1) {\nB:\n%2 = tail call fast nofpclass(nan inf) double @modf(double noundef nofpclass(nan inf) %0, ptr noundef %1)\nret double %2\n}"}, "define dso_local void @hoc_check_intupt(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca %struct.TYPE_3__, align 8\n%4 = alloca i8, align 1\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 16, ptr %3)\n%5 = load i32, ptr @keyDownMask, align 4\n%6 = call i64 @EventAvail(i32 noundef %5, ptr noundef %3)\n%7 = icmp ne i64 %6, 0\nbr i1 %7, label %8, label %28\n\n8:\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%10 = load i64, ptr %9, align 8\n%11 = load i64, ptr @keyDown, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %13, label %27\n\n13:\ncall void @llvm.lifetime.start.p0(i64 1, ptr %4)\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 1\n%15 = load i8, ptr %14, align 8\n%16 = sext i8 %15 to i32\n%17 = load i8, ptr @charCodeMask, align 1\n%18 = sext i8 %17 to i32\n%19 = and i32 %16, %18\n%20 = trunc i32 %19 to i8\nstore i8 %20, ptr %4, align 1\n%21 = load i8, ptr %4, align 1\n%22 = sext i8 %21 to i32\n%23 = icmp eq i32 %22, 3\nbr i1 %23, label %24, label %26\n\n24:\n%25 = call i32 (...) @set_intset()\nbr label %26\n\n26:\ncall void @llvm.lifetime.end.p0(i64 1, ptr %4)\nbr label %27\n\n27:\nbr label %28\n\n28:\ncall void @llvm.lifetime.end.p0(i64 16, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @hoc_check_intupt(i32 noundef %0) {\nB:\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %1)\n%2 = load i32, ptr @keyDownMask, align 4\n%3 = call i64 @EventAvail(i32 noundef %2, ptr noundef nonnull %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B4, label %B1\n\nB1:\n%5 = load i64, ptr %1, align 8\n%6 = load i64, ptr @keyDown, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B2, label %B4\n\nB2:\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%9 = load i8, ptr %8, align 8\n%10 = load i8, ptr @charCodeMask, align 1\n%11 = and i8 %10, %9\n%12 = icmp eq i8 %11, 3\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = call i32 (...) @set_intset()\nbr label %B4\n\nB4:\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @hoc_check_intupt(i32 noundef %0) {\nB:\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %1)\n%2 = load i32, ptr @keyDownMask, align 4\n%3 = call i64 @EventAvail(i32 noundef %2, ptr noundef nonnull %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B4, label %B1\n\nB1:\n%5 = load i64, ptr %1, align 8\n%6 = load i64, ptr @keyDown, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B2, label %B4\n\nB2:\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%9 = load i8, ptr %8, align 8\n%10 = load i8, ptr @charCodeMask, align 1\n%11 = and i8 %10, %9\n%12 = icmp eq i8 %11, 3\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = call i32 (...) @set_intset()\nbr label %B4\n\nB4:\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @hoc_check_intupt(i32 noundef %0) {\nB:\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %1)\n%2 = load i32, ptr @keyDownMask, align 4\n%3 = call i64 @EventAvail(i32 noundef %2, ptr noundef nonnull %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B4, label %B1\n\nB1:\n%5 = load i64, ptr @keyDown, align 8\n%6 = load i64, ptr %1, align 8\n%7 = icmp eq i64 %6, %5\nbr i1 %7, label %B2, label %B4\n\nB2:\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%9 = load i8, ptr %8, align 8\n%10 = load i8, ptr @charCodeMask, align 1\n%11 = and i8 %10, %9\n%12 = icmp eq i8 %11, 3\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = call i32 (...) @set_intset()\nbr label %B4\n\nB4:\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %1)\nret void\n}"}, "define dso_local i32 @run_single_spot_on_entire_puzzle(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 1, ptr %4, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %4, align 4\n%10 = icmp sle i32 %9, 3\nbr i1 %10, label %12, label %11\n\n11:\nstore i32 2, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\nbr label %42\n\n12:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %6, align 4\n%15 = icmp slt i32 %14, 9\nbr i1 %15, label %17, label %16\n\n16:\nstore i32 5, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\nbr label %38\n\n17:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\nstore i32 1, ptr %7, align 4\nbr label %18\n\n18:\n%19 = load i32, ptr %7, align 4\n%20 = icmp sle i32 %19, 9\nbr i1 %20, label %22, label %21\n\n21:\nstore i32 8, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nbr label %34\n\n22:\n%23 = load i32, ptr %4, align 4\n%24 = load i32, ptr %6, align 4\n%25 = load i32, ptr %7, align 4\n%26 = load ptr, ptr %2, align 8\n%27 = call i64 @single_spot_algorithm(i32 noundef %23, i32 noundef %24, i32 noundef %25, ptr noundef %26)\n%28 = icmp ne i64 %27, 0\nbr i1 %28, label %29, label %30\n\n29:\nstore i32 1, ptr %3, align 4\nbr label %30\n\n30:\nbr label %31\n\n31:\n%32 = load i32, ptr %7, align 4\n%33 = add nsw i32 %32, 1\nstore i32 %33, ptr %7, align 4\nbr label %18\n\n34:\nbr label %35\n\n35:\n%36 = load i32, ptr %6, align 4\n%37 = add nsw i32 %36, 1\nstore i32 %37, ptr %6, align 4\nbr label %13\n\n38:\nbr label %39\n\n39:\n%40 = load i32, ptr %4, align 4\n%41 = add nsw i32 %40, 1\nstore i32 %41, ptr %4, align 4\nbr label %8\n\n42:\n%43 = load i32, ptr %3, align 4\nstore i32 1, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %43\n}": {"base_truth": "define dso_local i32 @run_single_spot_on_entire_puzzle(ptr noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i32 [ 0, %B ], [ %27, %B1 ]\n%2 = phi i32 [ 0, %B ], [ %26, %B1 ]\n%3 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 1, ptr noundef %0)\n%4 = icmp eq i64 %3, 0\n%5 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 2, ptr noundef %0)\n%6 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 3, ptr noundef %0)\n%7 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 4, ptr noundef %0)\n%8 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 5, ptr noundef %0)\n%9 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 6, ptr noundef %0)\n%10 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 7, ptr noundef %0)\n%11 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 8, ptr noundef %0)\n%12 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef %1, i32 noundef 9, ptr noundef %0)\n%13 = insertelement <8 x i64> poison, i64 %11, i64 0\n%14 = insertelement <8 x i64> %13, i64 %12, i64 1\n%15 = insertelement <8 x i64> %14, i64 %10, i64 2\n%16 = insertelement <8 x i64> %15, i64 %9, i64 3\n%17 = insertelement <8 x i64> %16, i64 %8, i64 4\n%18 = insertelement <8 x i64> %17, i64 %7, i64 5\n%19 = insertelement <8 x i64> %18, i64 %6, i64 6\n%20 = insertelement <8 x i64> %19, i64 %5, i64 7\n%21 = freeze <8 x i64> %20\n%22 = icmp ne <8 x i64> %21, zeroinitializer\n%23 = bitcast <8 x i1> %22 to i8\n%24 = icmp eq i8 %23, 0\n%25 = select i1 %24, i1 %4, i1 false\n%26 = select i1 %25, i32 %2, i32 1\n%27 = add nuw nsw i32 %1, 1\n%28 = icmp eq i32 %27, 9\nbr i1 %28, label %B2, label %B1\n\nB2:\n%29 = phi i32 [ %55, %B2 ], [ 0, %B1 ]\n%30 = phi i32 [ %54, %B2 ], [ %26, %B1 ]\n%31 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 1, ptr noundef %0)\n%32 = icmp eq i64 %31, 0\n%33 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 2, ptr noundef %0)\n%34 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 3, ptr noundef %0)\n%35 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 4, ptr noundef %0)\n%36 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 5, ptr noundef %0)\n%37 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 6, ptr noundef %0)\n%38 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 7, ptr noundef %0)\n%39 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 8, ptr noundef %0)\n%40 = tail call i64 @single_spot_algorithm(i32 noundef 2, i32 noundef %29, i32 noundef 9, ptr noundef %0)\n%41 = insertelement <8 x i64> poison, i64 %39, i64 0\n%42 = insertelement <8 x i64> %41, i64 %40, i64 1\n%43 = insertelement <8 x i64> %42, i64 %38, i64 2\n%44 = insertelement <8 x i64> %43, i64 %37, i64 3\n%45 = insertelement <8 x i64> %44, i64 %36, i64 4\n%46 = insertelement <8 x i64> %45, i64 %35, i64 5\n%47 = insertelement <8 x i64> %46, i64 %34, i64 6\n%48 = insertelement <8 x i64> %47, i64 %33, i64 7\n%49 = freeze <8 x i64> %48\n%50 = icmp ne <8 x i64> %49, zeroinitializer\n%51 = bitcast <8 x i1> %50 to i8\n%52 = icmp eq i8 %51, 0\n%53 = select i1 %52, i1 %32, i1 false\n%54 = select i1 %53, i32 %30, i32 1\n%55 = add nuw nsw i32 %29, 1\n%56 = icmp eq i32 %55, 9\nbr i1 %56, label %B3, label %B2\n\nB3:\n%57 = phi i32 [ %83, %B3 ], [ 0, %B2 ]\n%58 = phi i32 [ %82, %B3 ], [ %54, %B2 ]\n%59 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 1, ptr noundef %0)\n%60 = icmp eq i64 %59, 0\n%61 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 2, ptr noundef %0)\n%62 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 3, ptr noundef %0)\n%63 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 4, ptr noundef %0)\n%64 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 5, ptr noundef %0)\n%65 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 6, ptr noundef %0)\n%66 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 7, ptr noundef %0)\n%67 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 8, ptr noundef %0)\n%68 = tail call i64 @single_spot_algorithm(i32 noundef 3, i32 noundef %57, i32 noundef 9, ptr noundef %0)\n%69 = insertelement <8 x i64> poison, i64 %67, i64 0\n%70 = insertelement <8 x i64> %69, i64 %68, i64 1\n%71 = insertelement <8 x i64> %70, i64 %66, i64 2\n%72 = insertelement <8 x i64> %71, i64 %65, i64 3\n%73 = insertelement <8 x i64> %72, i64 %64, i64 4\n%74 = insertelement <8 x i64> %73, i64 %63, i64 5\n%75 = insertelement <8 x i64> %74, i64 %62, i64 6\n%76 = insertelement <8 x i64> %75, i64 %61, i64 7\n%77 = freeze <8 x i64> %76\n%78 = icmp ne <8 x i64> %77, zeroinitializer\n%79 = bitcast <8 x i1> %78 to i8\n%80 = icmp eq i8 %79, 0\n%81 = select i1 %80, i1 %60, i1 false\n%82 = select i1 %81, i32 %58, i32 1\n%83 = add nuw nsw i32 %57, 1\n%84 = icmp eq i32 %83, 9\nbr i1 %84, label %B4, label %B3\n\nB4:\nret i32 %82\n}", "codellama": "define dso_local i32 @run_single_spot_on_entire_puzzle(ptr noundef %0) {\nB:\n%1 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 0, i32 noundef 1, ptr noundef %0)\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\n%4 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 1, ptr noundef %0)\n%5 = icmp eq i64 %4, 0\n%6 = select i1 %5, i32 0, i32 1\n%7 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 2, ptr noundef %0)\n%8 = icmp eq i64 %7, 0\n%9 = select i1 %8, i32 0, i32 1\n%10 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 3, ptr noundef %0)\n%11 = icmp eq i64 %10, 0\n%12 = select i1 %11, i32 0, i32 1\n%13 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 4, ptr noundef %0)\n%14 = icmp eq i64 %13, 0\n%15 = select i1 %14, i32 0, i32 1\n%16 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 5, ptr noundef %0)\n%17 = icmp eq i64 %16, 0\n%18 = select i1 %17, i32 0, i32 1\n%19 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 6, ptr noundef %0)\n%20 = icmp eq i64 %19, 0\n%21 = select i1 %20, i32 0, i32 1\n%22 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 7, ptr noundef %0)\n%23 = icmp eq i64 %22, 0\n%24 = select i1 %23, i32 0, i32 1\n%25 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 8, ptr noundef %0)\n%26 = icmp eq i64 %25, 0\n%27 = select i1 %26, i32 0, i32 1\n%28 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 9, ptr noundef %0)\n%29 = icmp eq i64 %28, 0\n%30 = select i1 %29, i32 0, i32 1\n%31 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 2, i32 noundef 1, ptr noundef %0)\n%32 = icmp eq i64 %31, 0\n%33 = select i1 %32, i32 0, i32 1\n%34 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 2, i32 noundef 2, ptr noundef %0)\n%35 = icmp eq i64 %34, 0\n%36 = select i1 %35, i32 0, i32 1\n%37 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 2, i32 noundef 3, ptr noundef %0)\n%38 = icmp eq i64 %37, 0\n%39 = select i1 %38, i32 0, i32 1\n%40 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 2, i32 noundef 4, ptr noundef %0)\n%41 = icmp eq i64 %40, 0\n%42 = select i1 %41, i32 0, i32 1\n%43 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 2, i32 noundef 5, ptr noundef %0)\n%44 = icmp eq i64 %43, 0\n</s>", "codegemma": "define dso_local i32 @run_single_spot_on_entire_puzzle(ptr noundef %0) {\nB:\n%1 = tail call i64 @single_spot_algorithm(i32 noundef 1, i32 noundef 1, i32 noundef 1, ptr noundef %0)\n%2 = icmp ne i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define internal void @g2d_fini_cmdlist(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.g2d_data ptr %3, i32 0, i32 4\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @kfree(i32 noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.g2d_data ptr %7, i32 0, i32 2\n%9 = load i64, ptr %8, align 8\n%10 = icmp ne i64 %9, 0\nbr i1 %10, label %11, label %32\n\n11:\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.g2d_data ptr %12, i32 0, i32 1\n%14 = load i64, ptr %13, align 8\n%15 = icmp ne i64 %14, 0\nbr i1 %15, label %16, label %32\n\n16:\n%17 = load ptr, ptr %2, align 8\n%18 = getelementptr inbounds %struct.g2d_data ptr %17, i32 0, i32 3\n%19 = load i32, ptr %18, align 8\n%20 = call i32 @to_dma_dev(i32 noundef %19)\n%21 = load i32, ptr @G2D_CMDLIST_POOL_SIZE, align 4\n%22 = load ptr, ptr %2, align 8\n%23 = getelementptr inbounds %struct.g2d_data ptr %22, i32 0, i32 2\n%24 = load i64, ptr %23, align 8\n%25 = load ptr, ptr %2, align 8\n%26 = getelementptr inbounds %struct.g2d_data ptr %25, i32 0, i32 1\n%27 = load i64, ptr %26, align 8\n%28 = load ptr, ptr %2, align 8\n%29 = getelementptr inbounds %struct.g2d_data ptr %28, i32 0, i32 0\n%30 = load i32, ptr %29, align 8\n%31 = call i32 @dma_free_attrs(i32 noundef %20, i32 noundef %21, i64 noundef %24, i64 noundef %27, i32 noundef %30)\nbr label %32\n\n32:\nret void\n}": {"base_truth": "define internal void @g2d_fini_cmdlist(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 4\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @kfree(i32 noundef %2)\n%4 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 3\n%11 = load i32, ptr %10, align 8\n%12 = tail call i32 @to_dma_dev(i32 noundef %11)\n%13 = load i32, ptr @G2D_CMDLIST_POOL_SIZE, align 4\n%14 = load i64, ptr %4, align 8\n%15 = load i64, ptr %7, align 8\n%16 = load i32, ptr %0, align 8\n%17 = tail call i32 @dma_free_attrs(i32 noundef %12, i32 noundef %13, i64 noundef %14, i64 noundef %15, i32 noundef %16)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @g2d_fini_cmdlist(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 4\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @kfree(i32 noundef %2)\n%4 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 3\n%11 = load i32, ptr %10, align 8\n%12 = tail call i32 @to_dma_dev(i32 noundef %11)\n%13 = load i32, ptr @G2D_CMDLIST_POOL_SIZE, align 4\n%14 = load i64, ptr %4, align 8\n%15 = load i64, ptr %7, align 8\n%16 = load i32, ptr %0, align 8\n%17 = tail call i32 @dma_free_attrs(i32 noundef %12, i32 noundef %13, i64 noundef %14, i64 noundef %15, i32 noundef %16)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @g2d_fini_cmdlist(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 4\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @kfree(i32 noundef %2)\n%4 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = getelementptr inbounds %struct.g2d_data, ptr %0, i64 0, i32 3\n%11 = load i32, ptr %10, align 8\n%12 = tail call i32 @to_dma_dev(i32 noundef %11)\n%13 = load i32, ptr @G2D_CMDLIST_POOL_SIZE, align 4\n%14 = load i64, ptr %4, align 8\n%15 = load i64, ptr %7, align 8\n%16 = load i32, ptr %0, align 8\n%17 = tail call i32 @dma_free_attrs(i32 noundef %12, i32 noundef %13, i64 noundef %14, i64 noundef %15, i32 noundef %16)\nbr label %B3\n\nB3:\nret void\n}"}, "define internal i32 @hclgevf_ring_space(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.hclgevf_cmq_ring ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\nstore i32 %8, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.hclgevf_cmq_ring ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\nstore i32 %11, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%12 = load i32, ptr %4, align 4\n%13 = load i32, ptr %3, align 4\n%14 = sub nsw i32 %12, %13\n%15 = load ptr, ptr %2, align 8\n%16 = getelementptr inbounds %struct.hclgevf_cmq_ring ptr %15, i32 0, i32 2\n%17 = load i32, ptr %16, align 4\n%18 = add nsw i32 %14, %17\n%19 = load ptr, ptr %2, align 8\n%20 = getelementptr inbounds %struct.hclgevf_cmq_ring ptr %19, i32 0, i32 2\n%21 = load i32, ptr %20, align 4\n%22 = srem i32 %18, %21\nstore i32 %22, ptr %5, align 4\n%23 = load ptr, ptr %2, align 8\n%24 = getelementptr inbounds %struct.hclgevf_cmq_ring ptr %23, i32 0, i32 2\n%25 = load i32, ptr %24, align 4\n%26 = load i32, ptr %5, align 4\n%27 = sub nsw i32 %25, %26\n%28 = sub nsw i32 %27, 1\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %28\n}": {"base_truth": "define internal i32 @hclgevf_ring_space(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = getelementptr inbounds %struct.hclgevf_cmq_ring, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = sub i32 %3, %1\n%5 = getelementptr inbounds %struct.hclgevf_cmq_ring, ptr %0, i64 0, i32 2\n%6 = load i32, ptr %5, align 4\n%7 = add nsw i32 %4, %6\n%8 = srem i32 %7, %6\n%9 = xor i32 %8, -1\n%10 = add i32 %6, %9\nret i32 %10\n}", "codellama": "define internal i32 @hclgevf_ring_space(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = getelementptr inbounds %struct.hclgevf_cmq_ring, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = sub i32 %3, %1\n%5 = getelementptr inbounds %struct.hclgevf_cmq_ring, ptr %0, i64 0, i32 2\n%6 = load i32, ptr %5, align 4\n%7 = add nsw i32 %6, %4\n%8 = srem i32 %7, %6\n%9 = xor i32 %8, %6\n%10 = add i32 %9, -1\nret i32 %10\n}", "codegemma": "define internal i32 @hclgevf_ring_space(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = getelementptr inbounds %struct.hclgevf_cmq_ring, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = sub i32 %3, %1\n%5 = getelementptr inbounds %struct.hclgevf_cmq_ring, ptr %0, i64 0, i32 2\n%6 = load i32, ptr %5, align 4\n%7 = add nsw i32 %4, %6\n%8 = srem i32 %7, %6\n%9 = xor i32 %8, -1\n%10 = add i32 %9, %6\nret i32 %10\n}"}, "define dso_local nofpclass(nan inf) double @iniparser_getdouble(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\n%4 = alloca double, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca double, align 8\n%8 = alloca ptr, align 8\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore double %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%10 = load ptr, ptr %5, align 8\n%11 = load ptr, ptr %6, align 8\n%12 = call ptr @iniparser_getstr(ptr noundef %10, ptr noundef %11)\nstore ptr %12, ptr %8, align 8\n%13 = load ptr, ptr %8, align 8\n%14 = icmp eq ptr %13, null\nbr i1 %14, label %15, label %17\n\n15:\n%16 = load double, ptr %7, align 8\nstore double %16, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %20\n\n17:\n%18 = load ptr, ptr %8, align 8\n%19 = call fast nofpclass(nan inf) double @atof(ptr noundef %18)\nstore double %19, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %20\n\n20:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\n%21 = load double, ptr %4, align 8\nret double %21\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @iniparser_getdouble(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = tail call ptr @iniparser_getstr(ptr noundef %0, ptr noundef %1)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call fast nofpclass(nan inf) double @atof(ptr noundef nonnull %3)\nbr label %B2\n\nB2:\n%6 = phi double [ %5, %B1 ], [ %2, %B ]\nret double %6\n}", "codellama": "define dso_local nofpclass(nan inf) double @iniparser_getdouble(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = tail call ptr @iniparser_getstr(ptr noundef %0, ptr noundef %1)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call fast nofpclass(nan inf) double @atof(ptr noundef nonnull %3)\nbr label %B2\n\nB2:\n%6 = phi double [ %5, %B1 ], [ %2, %B ]\nret double %6\n}", "codegemma": "define dso_local nofpclass(nan inf) double @iniparser_getdouble(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = tail call ptr @iniparser_getstr(ptr noundef %0, ptr noundef %1)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call fast nofpclass(nan inf) double @atof(ptr noundef nonnull %3)\nbr label %B2\n\nB2:\n%6 = phi double [ %5, %B1 ], [ %2, %B ]\nret double %6\n}"}, "define internal void @pps_tty_close(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @pps_lookup_dev(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @alias_n_tty_close(ptr noundef %7)\n%9 = load ptr, ptr %3, align 8\n%10 = icmp ne ptr %9, null\n%11 = xor i1 %10, true\n%12 = zext i1 %11 to i32\n%13 = call i64 @WARN_ON(i32 noundef %12)\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %16\n\n15:\nstore i32 1, ptr %4, align 4\nbr label %23\n\n16:\n%17 = load ptr, ptr %3, align 8\n%18 = getelementptr inbounds %struct.pps_device ptr %17, i32 0, i32 0\n%19 = load i32, ptr %18, align 4\n%20 = call i32 @dev_info(i32 noundef %19, ptr noundef @.str)\n%21 = load ptr, ptr %3, align 8\n%22 = call i32 @pps_unregister_source(ptr noundef %21)\nstore i32 0, ptr %4, align 4\nbr label %23\n\n23:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\n%24 = load i32, ptr %4, align 4\nswitch i32 %24, label %26 [\ni32 0, label %25\ni32 1, label %25\n]\n\n25:\nret void\n\n26:\nunreachable\n}": {"base_truth": "define internal void @pps_tty_close(ptr noundef %0) {\nB:\n%1 = tail call ptr @pps_lookup_dev(ptr noundef %0)\n%2 = tail call i32 @alias_n_tty_close(ptr noundef %0)\n%3 = icmp eq ptr %1, null\n%4 = zext i1 %3 to i32\n%5 = tail call i64 @WARN_ON(i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = load i32, ptr %1, align 4\n%8 = tail call i32 @dev_info(i32 noundef %7, ptr noundef nonnull @.str)\n%9 = tail call i32 @pps_unregister_source(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @pps_tty_close(ptr noundef %0) {\nB:\n%1 = tail call ptr @pps_lookup_dev(ptr noundef %0)\n%2 = tail call i32 @alias_n_tty_close(ptr noundef %0)\n%3 = icmp eq ptr %1, null\n%4 = zext i1 %3 to i32\n%5 = tail call i64 @WARN_ON(i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = load i32, ptr %1, align 4\n%8 = tail call i32 @dev_info(i32 noundef %7, ptr noundef nonnull @.str)\n%9 = tail call i32 @pps_unregister_source(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @pps_tty_close(ptr noundef %0) {\nB:\n%1 = tail call ptr @pps_lookup_dev(ptr noundef %0)\n%2 = tail call i32 @alias_n_tty_close(ptr noundef %0)\n%3 = icmp eq ptr %1, null\n%4 = zext i1 %3 to i32\n%5 = tail call i64 @WARN_ON(i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = load i32, ptr %1, align 4\n%8 = tail call i32 @dev_info(i32 noundef %7, ptr noundef nonnull @.str)\n%9 = tail call i32 @pps_unregister_source(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @strcat_null_dst(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @strcat(i32 noundef 0, ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @strcat_null_dst(ptr noundef %0) {\nB:\n%1 = tail call i32 @strcat(i32 noundef 0, ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @strcat_null_dst(ptr noundef %0) {\nB:\n%1 = tail call i32 @strcat(i32 noundef 0, ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @strcat_null_dst(ptr noundef %0) {\nB:\n%1 = tail call i32 @strcat(i32 noundef 0, ptr noundef %0)\nret void\n}"}, "define dso_local { ptr, ptr } @gai_allocator_init(ptr noundef %0, ptr noundef %1) {\n%3 = alloca %struct.TYPE_3__, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %11, label %8\n\n8:\n%9 = load ptr, ptr %5, align 8\n%10 = icmp ne ptr %9, null\nbr label %11\n\n11:\n%12 = phi i1 [ true, %2 ], [ %10, %8 ]\n%13 = zext i1 %12 to i32\n%14 = call i32 @assert(i32 noundef %13)\n%15 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%16 = load ptr, ptr %4, align 8\nstore ptr %16, ptr %15, align 8\n%17 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 1\n%18 = load ptr, ptr %5, align 8\nstore ptr %18, ptr %17, align 8\n%19 = load { ptr, ptr }, ptr %3, align 8\nret { ptr, ptr } %19\n}": {"base_truth": "define dso_local { ptr, ptr } @gai_allocator_init(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = or i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\n%7 = insertvalue { ptr, ptr } poison, ptr %0, 0\n%8 = insertvalue { ptr, ptr } %7, ptr %1, 1\nret { ptr, ptr } %8\n}", "codellama": "define dso_local { ptr, ptr } @gai_allocator_init(ptr noundef readnone %0, ptr noundef readnone %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = or i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\n%7 = insertvalue { ptr, ptr } poison, ptr %0, 0\n%8 = insertvalue { ptr, ptr } %7, ptr %1, 1\nret { ptr, ptr } %8\n}", "codegemma": "define dso_local { ptr, ptr } @gai_allocator_init(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = or i1 %2, %3\n%5 = zext i1 %4 to i32\n%6 = tail call i32 @assert(i32 noundef %5)\n%7 = insertvalue { ptr, ptr } poison, ptr %0, 0\n%8 = insertvalue { ptr, ptr } %7, ptr %1, 1\nret { ptr, ptr } %8\n}"}, "define dso_local i32 @canLz4() {\n%1 = load i32, ptr @canLz4.tested, align 4\n%2 = icmp ne i32 %1, 0\nbr i1 %2, label %9, label %3\n\n3:\nstore i32 1, ptr @canLz4.tested, align 4\n%4 = load i32, ptr @redirectArgs, align 4\n%5 = call i64 @systemf(ptr noundef @.str, i32 noundef %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %7, label %8\n\n7:\nstore i32 1, ptr @canLz4.value, align 4\nbr label %8\n\n8:\nbr label %9\n\n9:\n%10 = load i32, ptr @canLz4.value, align 4\nret i32 %10\n}": {"base_truth": "define dso_local i32 @canLz4() {\nB:\n%0 = load i32, ptr @canLz4.tested, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\nstore i32 1, ptr @canLz4.tested, align 4\n%2 = load i32, ptr @redirectArgs, align 4\n%3 = tail call i64 @systemf(ptr noundef nonnull @.str, i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\nstore i32 1, ptr @canLz4.value, align 4\nbr label %B3\n\nB3:\n%5 = load i32, ptr @canLz4.value, align 4\nret i32 %5\n}", "codellama": "define dso_local i32 @canLz4() {\nB:\n%0 = load i32, ptr @canLz4.tested, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\nstore i32 1, ptr @canLz4.tested, align 4\n%2 = load i32, ptr @redirectArgs, align 4\n%3 = tail call i64 @systemf(ptr noundef nonnull @.str, i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\nstore i32 1, ptr @canLz4.value, align 4\nbr label %B3\n\nB3:\n%5 = load i32, ptr @canLz4.value, align 4\nret i32 %5\n}", "codegemma": "define dso_local i32 @canLz4() {\nB:\n%0 = load i32, ptr @canLz4.tested, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\nstore i32 1, ptr @canLz4.tested, align 4\n%2 = load i32, ptr @redirectArgs, align 4\n%3 = tail call i64 @systemf(ptr noundef nonnull @.str, i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\nstore i32 1, ptr @canLz4.value, align 4\nbr label %B3\n\nB3:\n%5 = load i32, ptr @canLz4.value, align 4\nret i32 %5\n}"}, "define internal i32 @renesas_sdhi_sys_dmac_probe(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @renesas_sdhi_probe(ptr noundef %3, ptr noundef @renesas_sdhi_sys_dmac_dma_ops)\nret i32 %4\n}": {"base_truth": "define internal i32 @renesas_sdhi_sys_dmac_probe(ptr noundef %0) {\nB:\n%1 = tail call i32 @renesas_sdhi_probe(ptr noundef %0, ptr noundef nonnull @renesas_sdhi_sys_dmac_dma_ops)\nret i32 %1\n}", "codellama": "define internal i32 @renesas_sdhi_sys_dmac_probe(ptr noundef %0) {\nB:\n%1 = tail call i32 @renesas_sdhi_probe(ptr noundef %0, ptr noundef nonnull @renesas_sdhi_sys_dmac_dma_ops)\nret i32 %1\n}", "codegemma": "define internal i32 @renesas_sdhi_sys_dmac_probe(ptr noundef %0) {\nB:\n%1 = tail call i32 @renesas_sdhi_probe(ptr noundef %0, ptr noundef nonnull @renesas_sdhi_sys_dmac_dma_ops)\nret i32 %1\n}"}, "define dso_local void @FreeStructuralElement(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %11\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i32 @Free(i32 noundef %9)\nbr label %11\n\n11:\nret void\n}": {"base_truth": "define dso_local void @FreeStructuralElement(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @Free(i32 noundef %2)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @FreeStructuralElement(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @Free(i32 noundef %2)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @FreeStructuralElement(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @Free(i32 noundef %2)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local nofpclass(nan inf) double @iw_freq2float(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca double, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.iw_freq ptr %5, i32 0, i32 1\n%7 = load i64, ptr %6, align 8\n%8 = sitofp i64 %7 to double\nstore double %8, ptr %4, align 8\nstore i32 0, ptr %3, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %3, align 4\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds %struct.iw_freq ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 8\n%14 = icmp slt i32 %10, %13\nbr i1 %14, label %15, label %21\n\n15:\n%16 = load double, ptr %4, align 8\n%17 = fmul fast double %16, 1.000000e+01\nstore double %17, ptr %4, align 8\nbr label %18\n\n18:\n%19 = load i32, ptr %3, align 4\n%20 = add nsw i32 %19, 1\nstore i32 %20, ptr %3, align 4\nbr label %9\n\n21:\n%22 = load double, ptr %4, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret double %22\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @iw_freq2float(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.iw_freq, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = sitofp i64 %2 to double\n%4 = load i32, ptr %0, align 8\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B7\n\nB1:\n%6 = icmp ult i32 %4, 16\nbr i1 %6, label %B5, label %B2\n\nB2:\n%7 = and i32 %4, -16\n%8 = insertelement <4 x double> <double poison, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, double %3, i64 0\nbr label %B3\n\nB3:\n%9 = phi i32 [ 0, %B2 ], [ %18, %B3 ]\n%10 = phi <4 x double> [ %8, %B2 ], [ %14, %B3 ]\n%11 = phi <4 x double> [ <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, %B2 ], [ %15, %B3 ]\n%12 = phi <4 x double> [ <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, %B2 ], [ %16, %B3 ]\n%13 = phi <4 x double> [ <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, %B2 ], [ %17, %B3 ]\n%14 = fmul fast <4 x double> %10, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%15 = fmul fast <4 x double> %11, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%16 = fmul fast <4 x double> %12, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%17 = fmul fast <4 x double> %13, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%18 = add nuw i32 %9, 16\n%19 = icmp eq i32 %18, %7\nbr i1 %19, label %B4, label %B3\n\nB4:\n%20 = fmul fast <4 x double> %15, %14\n%21 = fmul fast <4 x double> %16, %20\n%22 = fmul fast <4 x double> %17, %21\n%23 = tail call fast double @llvm.vector.reduce.fmul.v4f64(double 1.000000e+00, <4 x double> %22)\n%24 = icmp eq i32 %4, %7\nbr i1 %24, label %B7, label %B5\n\nB5:\n%25 = phi double [ %3, %B1 ], [ %23, %B4 ]\n%26 = phi i32 [ 0, %B1 ], [ %7, %B4 ]\nbr label %B6\n\nB6:\n%27 = phi double [ %29, %B6 ], [ %25, %B5 ]\n%28 = phi i32 [ %30, %B6 ], [ %26, %B5 ]\n%29 = fmul fast double %27, 1.000000e+01\n%30 = add nuw nsw i32 %28, 1\n%31 = icmp eq i32 %30, %4\nbr i1 %31, label %B7, label %B6\n\nB7:\n%32 = phi double [ %3, %B ], [ %23, %B4 ], [ %29, %B6 ]\nret double %32\n}", "codellama": "define dso_local nofpclass(nan inf) double @iw_freq2float(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.iw_freq, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = sitofp i64 %2 to double\n%4 = load i32, ptr %0, align 8\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B7\n\nB1:\n%6 = icmp ult i32 %4, 16\nbr i1 %6, label %B5, label %B2\n\nB2:\n%7 = and i32 %4, -16\n%8 = insertelement <4 x double> poison, double %3, i64 0\n%9 = shufflevector <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x double> zeroinitializer\n%10 = insertelement <4 x double> poison, double %3, i64 0\n%11 = shufflevector <4 x i32> %9, <4 x double> %10, <4 x i32> zeroinitializer\n%12 = insertelement <4 x double> poison, double %3, i64 0\n%13 = shufflevector <4 x i32> %9, <4 x double> %12, <4 x i32> zeroinitializer\n%14 = insertelement <4 x double> poison, double %3, i64 0\n%15 = shufflevector <4 x i32> %9, <4 x double> %14, <4 x i32> zeroinitializer\nbr label %B3\n\nB3:\n%16 = phi i32 [ 0, %B2 ], [ %29, %B3 ]\n%17 = phi <4 x double> [ %11, %B2 ], [ %25, %B3 ]\n%18 = phi <4 x double> [ %13, %B2 ], [ %26, %B3 ]\n%19 = phi <4 x double> [ %15, %B2 ], [ %27, %B3 ]\n%20 = phi <4 x i32> [ zeroinitializer, %B2 ], [ %28, %B3 ]\n%21 = phi <4 x double> [ %11, %B2 ], [ %25, %B3 ]\n%22 = phi <4 x double> [ %13, %B2 ], [ %26, %B3 ]\n%23 = phi <4 x double> [ %15, %B2 ], [ %27, %B3 ]\n%24 = phi <4 x i32> [ zeroinitializer, %B2 ], [ %20, %B3 ]\n%25 = fmul fast <4 x double> %21, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%26 = fmul fast <4 x double> %22, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%27 = fmul fast <4 x double> %23, <double 1.000000e+01, double 1.000000e+01, double 1.000000e+01, double 1.000000e+01>\n%28 = fadd fast <4 x i32> %24, <i32 4, i32 4, i32 4, i32 4>\n%29 = add nuw nsw i32 %16, 16\n%30 = icmp eq i32 %29, %7\nbr i1 %30, label %B4, label %B3\n\nB4:\n%31 = fmul fast <4 x double> %26, %25\n%32 = fmul fast <4 x double> %27, %31\n%33 = fmul fast <4 x double> %28, %32\n%34 = tail call fast double @llvm.vector.reduce.fmul.v4f64(double 1.000000e+00, <4 x double> %33)\n%35 = icmp eq i32 %4, %7\nbr i1 %35, label %B7, label %B5\n\nB5:\n%36 = phi double [ %3, %B1 ], [ %34, %B4 ]\n%37 = ph i32 [ 0, %B1 ], [ %7, %B4 ]\nbr label %B6\n\nB6:\n%38 = ph i32 [ %39, %B6 ], [ %37, %B5 ]\n%39 = add nuw nsw i32 %38, 1\n%40 = icmp eq i32 %39, %4\nbr i1 %40, label %B7, label %B8\n\nB7:\n%41 = phi double [ %3, %B ], [ %34, %B4 ], [ %3, %B6 ]\nret double %41\n\nB8:\n%42 = ph i32 [ %43, %B8 ], [ %39, %B6 ]\n%43 = ph i32 [ %44, %B8 ], [ %39, %B6 ]\n%44 = ph i32 [ %45, %B8 ], [ %43, %B6 ]\n%45 = ph i32 [ %46, %B8 ], [ %44, %B6 ]\n%46 = mul nuw nsw i32 %42, 10\n%47 = mul nuw nsw i32 %43, 10\n%48 = mul nuw nsw i32 %44, 10\n%49 = mul nuw nsw i32 %45, 10\n%50 = add nuw nsw i32 %46, 1\n%51 = add nuw nsw i32 %47, 1\n%52 = add nuw nsw i32 %48, 1\n%53 = add nuw nsw i32 %49, 1\n%54 = mul nuw nsw i32 %50, %5\n%55 = mul nuw nsw i32 %51, %5\n%56 = mul nuw nsw i32 %52, %5\n%57 = mul nuw nsw i32 %53, %5\n%58 = add nuw nsw i32 %54, 1\n%59 = add nuw nsw i32 %55, 1\n%60 = add nuw nsw i32 %56, 1\n%61 = add nuw nsw i32 %57, 1\n%62 = mul nuw nsw i32 %58, %5\n%63 = mul nuw nsw i32 %59, %5\n%64 = mul nuw nsw i32 %60, %5\n%65 = mul nuw nsw i3</s>", "codegemma": "define dso_local nofpclass(nan inf) double @iw_freq2float(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.iw_freq, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = sitofp i64 %2 to double\n%4 = load i32, ptr %0, align 8\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = phi double [ %8, %B1 ], [ %3, %B ]\n%7 = phi i32 [ %9, %B1 ], [ 0, %B ]\n%8 = fmul fast double %6, 1.000000e+01\n%9 = add nuw nsw i32 %7, 1\n%10 = icmp eq i32 %9, %4\nbr i1 %10, label %B2, label %B1\n\nB2:\n%11 = phi double [ %3, %B ], [ %8, %B1 ]\nret double %11\n}"}, "define internal void @sdcard_chipselect_high() {\n%1 = load i32, ptr @m_ss_pin, align 4\n%2 = load i32, ptr @PLATFORM_GPIO_HIGH, align 4\n%3 = call i32 @platform_gpio_write(i32 noundef %1, i32 noundef %2)\n%4 = load i32, ptr @m_spi_no, align 4\n%5 = call i32 @platform_spi_send_recv(i32 noundef %4, i32 noundef 8, i32 noundef 255)\nret void\n}": {"base_truth": "define internal void @sdcard_chipselect_high() {\nB:\n%0 = load i32, ptr @m_ss_pin, align 4\n%1 = load i32, ptr @PLATFORM_GPIO_HIGH, align 4\n%2 = tail call i32 @platform_gpio_write(i32 noundef %0, i32 noundef %1)\n%3 = load i32, ptr @m_spi_no, align 4\n%4 = tail call i32 @platform_spi_send_recv(i32 noundef %3, i32 noundef 8, i32 noundef 255)\nret void\n}", "codellama": "define internal void @sdcard_chipselect_high() {\nB:\n%0 = load i32, ptr @m_ss_pin, align 4\n%1 = load i32, ptr @PLATFORM_GPIO_HIGH, align 4\n%2 = tail call i32 @platform_gpio_write(i32 noundef %0, i32 noundef %1)\n%3 = load i32, ptr @m_spi_no, align 4\n%4 = tail call i32 @platform_spi_send_recv(i32 noundef %3, i32 noundef 8, i32 noundef 255)\nret void\n}", "codegemma": "define internal void @sdcard_chipselect_high() {\nB:\n%0 = load i32, ptr @m_ss_pin, align 4\n%1 = load i32, ptr @PLATFORM_GPIO_HIGH, align 4\n%2 = tail call i32 @platform_gpio_write(i32 noundef %0, i32 noundef %1)\n%3 = load i32, ptr @m_spi_no, align 4\n%4 = tail call i32 @platform_spi_send_recv(i32 noundef %3, i32 noundef 8, i32 noundef 255)\nret void\n}"}, "define dso_local void @IN_DownUp() {\n%1 = load ptr, ptr @kb, align 8\n%2 = load i64, ptr @KB_DOWN, align 8\n%3 = getelementptr inbounds i32, ptr %1, i64 %2\n%4 = call i32 @IN_KeyUp(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @IN_DownUp() {\nB:\n%0 = load ptr, ptr @kb, align 8\n%1 = load i64, ptr @KB_DOWN, align 8\n%2 = getelementptr inbounds i32, ptr %0, i64 %1\n%3 = tail call i32 @IN_KeyUp(ptr noundef %2)\nret void\n}", "codellama": "define dso_local void @IN_DownUp() {\nB:\n%0 = load ptr, ptr @kb, align 8\n%1 = load i64, ptr @KB_DOWN, align 8\n%2 = getelementptr inbounds i32, ptr %0, i64 %1\n%3 = tail call i32 @IN_KeyUp(ptr noundef %2)\nret void\n}", "codegemma": "define dso_local void @IN_DownUp() {\nB:\n%0 = load ptr, ptr @kb, align 8\n%1 = load i64, ptr @KB_DOWN, align 8\n%2 = getelementptr inbounds i32, ptr %0, i64 %1\n%3 = tail call i32 @IN_KeyUp(ptr noundef %2)\nret void\n}"}, "define internal i32 @nand_instr_is_data(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %5, label %19\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.nand_op_instr ptr %6, i32 0, i32 0\n%8 = load i64, ptr %7, align 8\n%9 = load i64, ptr @NAND_OP_DATA_IN_INSTR, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %17, label %11\n\n11:\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.nand_op_instr ptr %12, i32 0, i32 0\n%14 = load i64, ptr %13, align 8\n%15 = load i64, ptr @NAND_OP_DATA_OUT_INSTR, align 8\n%16 = icmp eq i64 %14, %15\nbr label %17\n\n17:\n%18 = phi i1 [ true, %5 ], [ %16, %11 ]\nbr label %19\n\n19:\n%20 = phi i1 [ false, %1 ], [ %18, %17 ]\n%21 = zext i1 %20 to i32\nret i32 %21\n}": {"base_truth": "define internal i32 @nand_instr_is_data(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @NAND_OP_DATA_IN_INSTR, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = load i64, ptr @NAND_OP_DATA_OUT_INSTR, align 8\n%6 = icmp eq i64 %2, %5\n%7 = zext i1 %6 to i32\nbr label %B3\n\nB3:\n%8 = phi i32 [ 0, %B ], [ 1, %B1 ], [ %7, %B2 ]\nret i32 %8\n}", "codellama": "define internal i32 @nand_instr_is_data(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @NAND_OP_DATA_IN_INSTR, align 8\n%4 = icmp eq i64 %2, %3\n%5 = load i64, ptr @NAND_OP_DATA_OUT_INSTR, align 8\n%6 = icmp eq i64 %2, %5\n%7 = select i1 %4, i1 true, i1 %6\n%8 = zext i1 %7 to i32\nbr label %B2\n\nB2:\n%9 = phi i32 [ 0, %B ], [ %8, %B1 ]\nret i32 %9\n}", "codegemma": "define internal i32 @nand_instr_is_data(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @NAND_OP_DATA_IN_INSTR, align 8\n%4 = icmp eq i64 %2, %3\n%5 = load i64, ptr @NAND_OP_DATA_OUT_INSTR, align 8\n%6 = icmp eq i64 %2, %5\n%7 = select i1 %4, i1 true, i1 %6\n%8 = zext i1 %7 to i32\nbr label %B2\n\nB2:\n%9 = phi i32 [ 0, %B ], [ %8, %B1 ]\nret i32 %9\n}"}, "define dso_local i32 @CachedPlanIsValid(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = load i64, ptr @CACHEDPLANSOURCE_MAGIC, align 8\n%7 = icmp eq i64 %5, %6\n%8 = zext i1 %7 to i32\n%9 = call i32 @Assert(i32 noundef %8)\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 1\n%12 = load i32, ptr %11, align 8\nret i32 %12\n}": {"base_truth": "define dso_local i32 @CachedPlanIsValid(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @CACHEDPLANSOURCE_MAGIC, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @Assert(i32 noundef %4)\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%7 = load i32, ptr %6, align 8\nret i32 %7\n}", "codellama": "define dso_local i32 @CachedPlanIsValid(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @CACHEDPLANSOURCE_MAGIC, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @Assert(i32 noundef %4)\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%7 = load i32, ptr %6, align 8\nret i32 %7\n}", "codegemma": "define dso_local i32 @CachedPlanIsValid(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @CACHEDPLANSOURCE_MAGIC, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @Assert(i32 noundef %4)\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%7 = load i32, ptr %6, align 8\nret i32 %7\n}"}, "define dso_local void @load_map_on_player(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.player_t, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @net_emit_uint8(i32 noundef %5, i32 noundef 1)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.player_t, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = load ptr, ptr @mapname, align 8\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = call i32 @net_emit_string(i32 noundef %9, i32 noundef %12)\n%14 = load ptr, ptr %2, align 8\n%15 = getelementptr inbounds %struct.player_t, ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 4\n%17 = load i32, ptr @map_size, align 4\n%18 = call i32 @net_emit_uint32(i32 noundef %16, i32 noundef %17)\n%19 = load ptr, ptr %2, align 8\n%20 = getelementptr inbounds %struct.player_t, ptr %19, i32 0, i32 0\n%21 = load i32, ptr %20, align 4\n%22 = load i32, ptr @map_hash, align 4\n%23 = call i32 @net_emit_buf(i32 noundef %21, i32 noundef %22, i32 noundef 20)\nret void\n}": {"base_truth": "define dso_local void @load_map_on_player(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @net_emit_uint8(i32 noundef %1, i32 noundef 1)\n%3 = load i32, ptr %0, align 4\n%4 = load ptr, ptr @mapname, align 8\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @net_emit_string(i32 noundef %3, i32 noundef %5)\n%7 = load i32, ptr %0, align 4\n%8 = load i32, ptr @map_size, align 4\n%9 = tail call i32 @net_emit_uint32(i32 noundef %7, i32 noundef %8)\n%10 = load i32, ptr %0, align 4\n%11 = load i32, ptr @map_hash, align 4\n%12 = tail call i32 @net_emit_buf(i32 noundef %10, i32 noundef %11, i32 noundef 20)\nret void\n}", "codellama": "define dso_local void @load_map_on_player(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @net_emit_uint8(i32 noundef %1, i32 noundef 1)\n%3 = load i32, ptr %0, align 4\n%4 = load ptr, ptr @mapname, align 8\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @net_emit_string(i32 noundef %3, i32 noundef %5)\n%7 = load i32, ptr %0, align 4\n%8 = load i32, ptr @map_size, align 4\n%9 = tail call i32 @net_emit_uint32(i32 noundef %7, i32 noundef %8)\n%10 = load i32, ptr %0, align 4\n%11 = load i32, ptr @map_hash, align 4\n%12 = tail call i32 @net_emit_buf(i32 noundef %10, i32 noundef %11, i32 noundef 20)\nret void\n}", "codegemma": "define dso_local void @load_map_on_player(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @net_emit_uint8(i32 noundef %1, i32 noundef 1)\n%3 = load i32, ptr %0, align 4\n%4 = load ptr, ptr @mapname, align 8\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @net_emit_string(i32 noundef %3, i32 noundef %5)\n%7 = load i32, ptr %0, align 4\n%8 = load i32, ptr @map_size, align 4\n%9 = tail call i32 @net_emit_uint32(i32 noundef %7, i32 noundef %8)\n%10 = load i32, ptr %0, align 4\n%11 = load i32, ptr @map_hash, align 4\n%12 = tail call i32 @net_emit_buf(i32 noundef %10, i32 noundef %11, i32 noundef 20)\nret void\n}"}, "define dso_local nofpclass(nan inf) double @okPLL22150_GetReference(i32 noundef %0) {\n%2 = alloca double, align 8\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nbr i1 true, label %4, label %7\n\n4:\n%5 = load i32, ptr %3, align 4\n%6 = call fast nofpclass(nan inf) double @_okPLL22150_GetReference(i32 noundef %5)\nstore double %6, ptr %2, align 8\nbr label %8\n\n7:\nstore double 0.000000e+00, ptr %2, align 8\nbr label %8\n\n8:\n%9 = load double, ptr %2, align 8\nret double %9\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @okPLL22150_GetReference(i32 noundef %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) double @_okPLL22150_GetReference(i32 noundef %0)\nret double %1\n}", "codellama": "define dso_local nofpclass(nan inf) double @okPLL22150_GetReference(i32 noundef %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) double @_okPLL22150_GetReference(i32 noundef %0)\nret double %1\n}", "codegemma": "define dso_local nofpclass(nan inf) double @okPLL22150_GetReference(i32 noundef %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) double @_okPLL22150_GetReference(i32 noundef %0)\nret double %1\n}"}, "define dso_local i32 @foo(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.A ptr %3, i32 0, i32 0\nstore i32 1, ptr %4, align 4\nret i32 123\n}": {"base_truth": "define dso_local i32 @foo(ptr nocapture noundef writeonly %0) {\nB:\nstore i32 1, ptr %0, align 4\nret i32 123\n}", "codellama": "define dso_local i32 @foo(ptr nocapture noundef writeonly %0) {\nB:\nstore i32 1, ptr %0, align 4\nret i32 123\n}", "codegemma": "define dso_local i32 @foo(ptr nocapture noundef writeonly %0) {\nB:\nstore i32 1, ptr %0, align 4\nret i32 123\n}"}, "define dso_local i32 @uv_kill(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %4, align 4\n%7 = load i32, ptr %5, align 4\n%8 = call i64 @kill(i32 noundef %6, i32 noundef %7)\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %13\n\n10:\n%11 = load i32, ptr @errno, align 4\n%12 = call i32 @UV__ERR(i32 noundef %11)\nstore i32 %12, ptr %3, align 4\nbr label %14\n\n13:\nstore i32 0, ptr %3, align 4\nbr label %14\n\n14:\n%15 = load i32, ptr %3, align 4\nret i32 %15\n}": {"base_truth": "define dso_local i32 @uv_kill(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i64 @kill(i32 noundef %0, i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @errno, align 4\n%5 = tail call i32 @UV__ERR(i32 noundef %4)\nbr label %B2\n\nB2:\n%6 = phi i32 [ %5, %B1 ], [ 0, %B ]\nret i32 %6\n}", "codellama": "define dso_local i32 @uv_kill(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i64 @kill(i32 noundef %0, i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @errno, align 4\n%5 = tail call i32 @UV__ERR(i32 noundef %4)\nbr label %B2\n\nB2:\n%6 = phi i32 [ %5, %B1 ], [ 0, %B ]\nret i32 %6\n}", "codegemma": "define dso_local i32 @uv_kill(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i64 @kill(i32 noundef %0, i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @errno, align 4\n%5 = tail call i32 @UV__ERR(i32 noundef %4)\nbr label %B2\n\nB2:\n%6 = phi i32 [ %5, %B1 ], [ 0, %B ]\nret i32 %6\n}"}, "define dso_local void @test_most_a() {\n%1 = alloca [63 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 63, ptr %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 16 %1, ptr align 16 @__const.test_most_a.a, i64 63, i1 false)\n%2 = getelementptr inbounds [63 x i8], ptr %1, i64 0, i64 0\n%3 = call i32 @use(ptr noundef %2)\ncall void @llvm.lifetime.end.p0(i64 63, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @test_most_a() {\nB:\n%0 = alloca [63 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 63, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(63) %0, ptr noundef nonnull align 16 dereferenceable(63) @__const.test_most_a.a, i64 63, i1 false)\n%1 = call i32 @use(ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 63, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @test_most_a() {\nB:\n%0 = alloca [63 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 63, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(63) %0, ptr noundef nonnull align 16 dereferenceable(63) @__const.test_most_a.a, i64 63, i1 false)\n%1 = call i32 @use(ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 63, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @test_most_a() {\nB:\n%0 = alloca [63 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 63, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(63) %0, ptr noundef nonnull align 16 dereferenceable(63) @__const.test_most_a.a, i64 63, i1 false)\n%1 = call i32 @use(ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 63, ptr nonnull %0)\nret void\n}"}, "define internal void @legacy_read_register_gen(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = icmp sge i32 %5, 0\nbr i1 %6, label %7, label %13\n\n7:\n%8 = load i32, ptr %3, align 4\n%9 = load i32, ptr @NUM_REGS, align 4\n%10 = load i32, ptr @NUM_PSEUDO_REGS, align 4\n%11 = add nsw i32 %9, %10\n%12 = icmp slt i32 %8, %11\nbr label %13\n\n13:\n%14 = phi i1 [ false, %2 ], [ %12, %7 ]\n%15 = zext i1 %14 to i32\n%16 = call i32 @gdb_assert(i32 noundef %15)\n%17 = load i32, ptr @registers_ptid, align 4\n%18 = load i32, ptr @inferior_ptid, align 4\n%19 = call i32 @ptid_equal(i32 noundef %17, i32 noundef %18)\n%20 = icmp ne i32 %19, 0\nbr i1 %20, label %24, label %21\n\n21:\n%22 = call i32 (...) @registers_changed()\n%23 = load i32, ptr @inferior_ptid, align 4\nstore i32 %23, ptr @registers_ptid, align 4\nbr label %24\n\n24:\n%25 = load i32, ptr %3, align 4\n%26 = call i32 @register_cached(i32 noundef %25)\n%27 = icmp ne i32 %26, 0\nbr i1 %27, label %31, label %28\n\n28:\n%29 = load i32, ptr %3, align 4\n%30 = call i32 @target_fetch_registers(i32 noundef %29)\nbr label %31\n\n31:\n%32 = load ptr, ptr %4, align 8\n%33 = load i32, ptr @current_regcache, align 4\n%34 = load i32, ptr %3, align 4\n%35 = call i32 @register_buffer(i32 noundef %33, i32 noundef %34)\n%36 = load i32, ptr %3, align 4\n%37 = call i32 @DEPRECATED_REGISTER_RAW_SIZE(i32 noundef %36)\n%38 = call i32 @memcpy(ptr noundef %32, i32 noundef %35, i32 noundef %37)\nret void\n}": {"base_truth": "define internal void @legacy_read_register_gen(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = icmp sgt i32 %0, -1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @NUM_REGS, align 4\n%4 = load i32, ptr @NUM_PSEUDO_REGS, align 4\n%5 = add nsw i32 %4, %3\n%6 = icmp sgt i32 %5, %0\n%7 = zext i1 %6 to i32\nbr label %B2\n\nB2:\n%8 = phi i32 [ 0, %B ], [ %7, %B1 ]\n%9 = tail call i32 @gdb_assert(i32 noundef %8)\n%10 = load i32, ptr @registers_ptid, align 4\n%11 = load i32, ptr @inferior_ptid, align 4\n%12 = tail call i32 @ptid_equal(i32 noundef %10, i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B3, label %B4\n\nB3:\n%14 = tail call i32 (...) @registers_changed()\n%15 = load i32, ptr @inferior_ptid, align 4\nstore i32 %15, ptr @registers_ptid, align 4\nbr label %B4\n\nB4:\n%16 = tail call i32 @register_cached(i32 noundef %0)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B5, label %B6\n\nB5:\n%18 = tail call i32 @target_fetch_registers(i32 noundef %0)\nbr label %B6\n\nB6:\n%19 = load i32, ptr @current_regcache, align 4\n%20 = tail call i32 @register_buffer(i32 noundef %19, i32 noundef %0)\n%21 = tail call i32 @DEPRECATED_REGISTER_RAW_SIZE(i32 noundef %0)\n%22 = tail call i32 @memcpy(ptr noundef %1, i32 noundef %20, i32 noundef %21)\nret void\n}", "codellama": "define internal void @legacy_read_register_gen(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = icmp sgt i32 %0, -1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @NUM_REGS, align 4\n%4 = load i32, ptr @NUM_PSEUDO_REGS, align 4\n%5 = add nsw i32 %4, %3\n%6 = icmp sgt i32 %5, %0\n%7 = zext i1 %6 to i32\nbr label %B2\n\nB2:\n%8 = phi i32 [ 0, %B ], [ %7, %B1 ]\n%9 = tail call i32 @gdb_assert(i32 noundef %8)\n%10 = load i32, ptr @registers_ptid, align 4\n%11 = load i32, ptr @inferior_ptid, align 4\n%12 = tail call i32 @ptid_equal(i32 noundef %10, i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B3, label %B4\n\nB3:\n%14 = tail call i32 (...) @registers_changed()\n%15 = load i32, ptr @inferior_ptid, align 4\nstore i32 %15, ptr @registers_ptid, align 4\nbr label %B4\n\nB4:\n%16 = tail call i32 @register_cached(i32 noundef %0)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B5, label %B6\n\nB5:\n%18 = tail call i32 @target_fetch_registers(i32 noundef %0)\nbr label %B6\n\nB6:\n%19 = load i32, ptr @current_regcache, align 4\n%20 = tail call i32 @register_buffer(i32 noundef %19, i32 noundef %0)\n%21 = tail call i32 @DEPRECATED_REGISTER_RAW_SIZE(i32 noundef %0)\n%22 = tail call i32 @memcpy(ptr noundef %1, i32 noundef %20, i32 noundef %21)\nret void\n}", "codegemma": "define internal void @legacy_read_register_gen(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = icmp sgt i32 %0, -1\n%3 = load i32, ptr @NUM_REGS, align 4\n%4 = load i32, ptr @NUM_PSEUDO_REGS, align 4\n%5 = add nsw i32 %4, %3\n%6 = icmp sgt i32 %5, %0\n%7 = select i1 %2, i1 %6, i1 false\n%8 = zext i1 %7 to i32\n%9 = tail call i32 @gdb_assert(i32 noundef %8)\n%10 = load i32, ptr @registers_ptid, align 4\n%11 = load i32, ptr @inferior_ptid, align 4\n%12 = tail call i32 @ptid_equal(i32 noundef %10, i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B1, label %B2\n\nB1:\n%14 = tail call i32 (...) @registers_changed()\n%15 = load i32, ptr @inferior_ptid, align 4\nstore i32 %15, ptr @registers_ptid, align 4\nbr label %B2\n\nB2:\n%16 = tail call i32 @register_cached(i32 noundef %0)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B3, label %B4\n\nB3:\n%18 = tail call i32 @target_fetch_registers(i32 noundef %0)\nbr label %B4\n\nB4:\n%19 = load i32, ptr @current_regcache, align 4\n%20 = tail call i32 @register_buffer(i32 noundef %19, i32 noundef %0)\n%21 = tail call i32 @DEPRECATED_REGISTER_RAW_SIZE(i32 noundef %0)\n%22 = tail call i32 @memcpy(ptr noundef %1, i32 noundef %20, i32 noundef %21)\nret void\n}"}, "define internal i32 @pt_blk_cond_branch(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%9 = load ptr, ptr %4, align 8\n%10 = icmp ne ptr %9, null\nbr i1 %10, label %14, label %11\n\n11:\n%12 = load i32, ptr @pte_internal, align 4\n%13 = sub nsw i32 0, %12\nstore i32 %13, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %44\n\n14:\n%15 = load ptr, ptr %4, align 8\n%16 = getelementptr inbounds %struct.pt_block_decoder ptr %15, i32 0, i32 2\n%17 = load ptr, ptr %5, align 8\n%18 = call i32 @pt_qry_cond_branch(ptr noundef %16, ptr noundef %17)\nstore i32 %18, ptr %6, align 4\n%19 = load i32, ptr %6, align 4\n%20 = icmp slt i32 %19, 0\nbr i1 %20, label %21, label %23\n\n21:\n%22 = load i32, ptr %6, align 4\nstore i32 %22, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %44\n\n23:\n%24 = load ptr, ptr %4, align 8\n%25 = getelementptr inbounds %struct.pt_block_decoder ptr %24, i32 0, i32 1\n%26 = getelementptr inbounds %struct.TYPE_6__, ptr %25, i32 0, i32 0\n%27 = getelementptr inbounds %struct.TYPE_5__, ptr %26, i32 0, i32 0\n%28 = getelementptr inbounds %struct.TYPE_4__, ptr %27, i32 0, i32 0\n%29 = load i64, ptr %28, align 8\n%30 = icmp ne i64 %29, 0\nbr i1 %30, label %31, label %42\n\n31:\n%32 = load ptr, ptr %4, align 8\n%33 = load ptr, ptr %4, align 8\n%34 = getelementptr inbounds %struct.pt_block_decoder ptr %33, i32 0, i32 0\n%35 = load i32, ptr %34, align 8\n%36 = call i32 @pt_blk_tick(ptr noundef %32, i32 noundef %35)\nstore i32 %36, ptr %7, align 4\n%37 = load i32, ptr %7, align 4\n%38 = icmp slt i32 %37, 0\nbr i1 %38, label %39, label %41\n\n39:\n%40 = load i32, ptr %7, align 4\nstore i32 %40, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %44\n\n41:\nbr label %42\n\n42:\n%43 = load i32, ptr %6, align 4\nstore i32 %43, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %44\n\n44:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%45 = load i32, ptr %3, align 4\nret i32 %45\n}": {"base_truth": "define internal i32 @pt_blk_cond_branch(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @pte_internal, align 4\n%4 = sub nsw i32 0, %3\nbr label %B6\n\nB2:\n%5 = getelementptr inbounds %struct.pt_block_decoder, ptr %0, i64 0, i32 2\n%6 = tail call i32 @pt_qry_cond_branch(ptr noundef nonnull %5, ptr noundef %1)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B6, label %B3\n\nB3:\n%8 = getelementptr inbounds %struct.pt_block_decoder, ptr %0, i64 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B5, label %B4\n\nB4:\n%11 = load i32, ptr %0, align 8\n%12 = tail call i32 @pt_blk_tick(ptr noundef nonnull %0, i32 noundef %11)\n%13 = icmp slt i32 %12, 0\nbr i1 %13, label %B6, label %B5\n\nB5:\nbr label %B6\n\nB6:\n%14 = phi i32 [ %6, %B5 ], [ %4, %B1 ], [ %6, %B2 ], [ %12, %B4 ]\nret i32 %14\n}", "codellama": "define internal i32 @pt_blk_cond_branch(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @pte_internal, align 4\n%4 = sub nsw i32 0, %3\nbr label %B6\n\nB2:\n%5 = getelementptr inbounds %struct.pt_block_decoder, ptr %0, i64 0, i32 2\n%6 = tail call i32 @pt_qry_cond_branch(ptr noundef nonnull %5, ptr noundef %1)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B6, label %B3\n\nB3:\n%8 = getelementptr inbounds %struct.pt_block_decoder, ptr %0, i64 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B5, label %B4\n\nB4:\n%11 = load i32, ptr %0, align 8\n%12 = tail call i32 @pt_blk_tick(ptr noundef nonnull %0, i32 noundef %11)\n%13 = icmp slt i32 %12, 0\nbr i1 %13, label %B6, label %B5\n\nB5:\nbr label %B6\n\nB6:\n%14 = phi i32 [ %6, %B5 ], [ %4, %B1 ], [ %6, %B2 ], [ %12, %B4 ]\nret i32 %14\n}", "codegemma": "define internal i32 @pt_blk_cond_branch(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @pte_internal, align 4\n%4 = sub nsw i32 0, %3\nbr label %B5\n\nB2:\n%5 = getelementptr inbounds %struct.pt_block_decoder, ptr %0, i64 0, i32 2\n%6 = tail call i32 @pt_qry_cond_branch(ptr noundef nonnull %5, ptr noundef %1)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B5, label %B3\n\nB3:\n%8 = getelementptr inbounds %struct.pt_block_decoder, ptr %0, i64 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B5, label %B4\n\nB4:\n%11 = load i32, ptr %0, align 8\n%12 = tail call i32 @pt_blk_tick(ptr noundef nonnull %0, i32 noundef %11)\n%13 = tail call i32 @llvm.smin.i32(i32 %12, i32 %6)\nbr label %B5\n\nB5:\n%14 = phi i32 [ %4, %B1 ], [ %6, %B2 ], [ %13, %B4 ], [ %12, %B3 ]\nret i32 %14\n}"}, "define dso_local void @closeAll(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr @g_dbase, align 8\nstore ptr %5, ptr %4, align 8\nstore i32 0, ptr %3, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %3, align 4\n%8 = icmp slt i32 %7, 128\nbr i1 %8, label %9, label %29\n\n9:\n%10 = load ptr, ptr %4, align 8\n%11 = getelementptr inbounds %struct.client ptr %10, i32 0, i32 0\n%12 = load i64, ptr %11, align 8\n%13 = icmp ne i64 %12, 0\nbr i1 %13, label %14, label %23\n\n14:\n%15 = load i32, ptr @TYPE, align 4\n%16 = load i32, ptr @CONNECTION, align 4\n%17 = load i32, ptr %3, align 4\n%18 = load i32, ptr @_END, align 4\n%19 = call i32 @emit(i32 noundef %15, ptr noundef @.str, i32 noundef %16, i32 noundef %17, i32 noundef %18)\n%20 = load ptr, ptr %4, align 8\n%21 = load i32, ptr %3, align 4\n%22 = call i32 @done(ptr noundef %20, i32 noundef %21)\nbr label %23\n\n23:\nbr label %24\n\n24:\n%25 = load i32, ptr %3, align 4\n%26 = add nsw i32 %25, 1\nstore i32 %26, ptr %3, align 4\n%27 = load ptr, ptr %4, align 8\n%28 = getelementptr inbounds %struct.client ptr %27, i32 1\nstore ptr %28, ptr %4, align 8\nbr label %6\n\n29:\n%30 = load i32, ptr @TYPE, align 4\n%31 = load i32, ptr @CONNECTION, align 4\n%32 = load i32, ptr @_END, align 4\n%33 = call i32 @emit(i32 noundef %30, ptr noundef @.str, i32 noundef %31, i32 noundef -1, i32 noundef %32)\n%34 = load i32, ptr @g_proxyfd, align 4\n%35 = load i32, ptr @SHUT_RDWR, align 4\n%36 = call i32 @shutdown(i32 noundef %34, i32 noundef %35)\n%37 = load i32, ptr @g_proxyfd, align 4\n%38 = call i32 @close(i32 noundef %37)\n%39 = call i32 @exit(i32 noundef 0)\nunreachable\n}": {"base_truth": "define dso_local void @closeAll(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @g_dbase, align 8\nbr label %B1\n\nB1:\n%2 = phi ptr [ %1, %B ], [ %12, %B3 ]\n%3 = phi i32 [ 0, %B ], [ %11, %B3 ]\n%4 = load i64, ptr %2, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = load i32, ptr @TYPE, align 4\n%7 = load i32, ptr @CONNECTION, align 4\n%8 = load i32, ptr @_END, align 4\n%9 = tail call i32 @emit(i32 noundef %6, ptr noundef nonnull @.str, i32 noundef %7, i32 noundef %3, i32 noundef %8)\n%10 = tail call i32 @done(ptr noundef nonnull %2, i32 noundef %3)\nbr label %B3\n\nB3:\n%11 = add nuw nsw i32 %3, 1\n%12 = getelementptr inbounds %struct.client, ptr %2, i64 1\n%13 = icmp eq i32 %11, 128\nbr i1 %13, label %B4, label %B1\n\nB4:\n%14 = load i32, ptr @TYPE, align 4\n%15 = load i32, ptr @CONNECTION, align 4\n%16 = load i32, ptr @_END, align 4\n%17 = tail call i32 @emit(i32 noundef %14, ptr noundef nonnull @.str, i32 noundef %15, i32 noundef -1, i32 noundef %16)\n%18 = load i32, ptr @g_proxyfd, align 4\n%19 = load i32, ptr @SHUT_RDWR, align 4\n%20 = tail call i32 @shutdown(i32 noundef %18, i32 noundef %19)\n%21 = load i32, ptr @g_proxyfd, align 4\n%22 = tail call i32 @close(i32 noundef %21)\n%23 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codellama": "define dso_local void @closeAll(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @g_dbase, align 8\nbr label %B1\n\nB1:\n%2 = phi ptr [ %1, %B ], [ %11, %B3 ]\n%3 = phi i32 [ 0, %B ], [ %10, %B3 ]\n%4 = load i64, ptr %2, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = load i32, ptr @TYPE, align 4\n%7 = load i32, ptr @CONNECTION, align 4\n%8 = load i32, ptr @_END, align 4\n%9 = tail call i32 @emit(i32 noundef %6, ptr noundef nonnull @.str, i32 noundef %7, i32 noundef %3, i32 noundef %8)\n%10 = tail call i32 @done(ptr noundef nonnull %2, i32 noundef %3)\nbr label %B3\n\nB3:\n%11 = getelementptr inbounds %struct.client, ptr %2, i64 1\n%12 = icmp eq i32 %3, 127\nbr i1 %12, label %B4, label %B1\n\nB4:\n%13 = load i32, ptr @TYPE, align 4\n%14 = load i32, ptr @CONNECTION, align 4\n%15 = load i32, ptr @_END, align 4\n%16 = tail call i32 @emit(i32 noundef %13, ptr noundef nonnull @.str, i32 noundef %14, i32 noundef -1, i32 noundef %15)\n%17 = load i32, ptr @g_proxyfd, align 4\n%18 = load i32, ptr @SHUT_RDWR, align 4\n%19 = tail call i32 @shutdown(i32 noundef %17, i32 noundef %18)\n%20 = load i32, ptr @g_proxyfd, align 4\n%21 = tail call i32 @close(i32 noundef %20)\n%22 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codegemma": "define dso_local void @closeAll(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @g_dbase, align 8\n%2 = icmp slt i32 %0, 128\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = phi i32 [ %10, %B3 ], [ 0, %B ]\n%4 = phi ptr [ %9, %B3 ], [ %1, %B ]\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr @TYPE, align 4\n%8 = load i32, ptr @CONNECTION, align 4\n%9 = load i32, ptr @_END, align 4\n%10 = add nuw nsw i32 %3, 1\n%11 = tail call i32 @emit(i32 noundef %7, ptr noundef nonnull @.str, i32 noundef %8, i32 noundef %10, i32 noundef %9)\n%12 = tail call i32 @done(ptr noundef nonnull %4, i32 noundef %10)\n%13 = icmp eq i32 %10, 128\nbr i1 %13, label %B4, label %B1\n\nB3:\n%14 = load i32, ptr @TYPE, align 4\n%15 = load i32, ptr @CONNECTION, align 4\n%16 = load i32, ptr @_END, align 4\n%17 = tail call i32 @emit(i32 noundef %14, ptr noundef nonnull @.str, i32 noundef %15, i32 noundef -1, i32 noundef %16)\n%18 = load i32, ptr @g_proxyfd, align 4\n%19 = load i32, ptr @SHUT_RDWR, align 4\n%20 = tail call i32 @shutdown(i32 noundef %18, i32 noundef %19)\n%21 = load i32, ptr @g_proxyfd, align 4\n%22 = tail call i32 @close(i32 noundef %21)\n%23 = tail call i32 @exit(i32 noundef 0)\nunreachable\n\nB4:\nret void\n}"}, "define internal i32 @ieee80211_del_station(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca ptr, align 8\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore ptr %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%10 = load ptr, ptr %6, align 8\n%11 = call ptr @IEEE80211_DEV_TO_SUB_IF(ptr noundef %10)\nstore ptr %11, ptr %8, align 8\n%12 = load ptr, ptr %7, align 8\n%13 = icmp ne ptr %12, null\nbr i1 %13, label %14, label %18\n\n14:\n%15 = load ptr, ptr %8, align 8\n%16 = load ptr, ptr %7, align 8\n%17 = call i32 @sta_info_destroy_addr_bss(ptr noundef %15, ptr noundef %16)\nstore i32 %17, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %21\n\n18:\n%19 = load ptr, ptr %8, align 8\n%20 = call i32 @sta_info_flush(ptr noundef %19)\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %21\n\n21:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\n%22 = load i32, ptr %4, align 4\nret i32 %22\n}": {"base_truth": "define internal i32 @ieee80211_del_station(ptr nocapture noundef readnone %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @IEEE80211_DEV_TO_SUB_IF(ptr noundef %1)\n%4 = icmp eq ptr %2, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @sta_info_destroy_addr_bss(ptr noundef %3, ptr noundef nonnull %2)\nbr label %B3\n\nB2:\n%6 = tail call i32 @sta_info_flush(ptr noundef %3)\nbr label %B3\n\nB3:\n%7 = phi i32 [ %5, %B1 ], [ 0, %B2 ]\nret i32 %7\n}", "codellama": "define internal i32 @ieee80211_del_station(ptr nocapture noundef readnone %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @IEEE80211_DEV_TO_SUB_IF(ptr noundef %1)\n%4 = icmp eq ptr %2, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @sta_info_destroy_addr_bss(ptr noundef %3, ptr noundef nonnull %2)\nbr label %B3\n\nB2:\n%6 = tail call i32 @sta_info_flush(ptr noundef %3)\nbr label %B3\n\nB3:\n%7 = phi i32 [ %5, %B1 ], [ 0, %B2 ]\nret i32 %7\n}", "codegemma": "define internal i32 @ieee80211_del_station(ptr nocapture noundef readnone %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @IEEE80211_DEV_TO_SUB_IF(ptr noundef %1)\n%4 = icmp eq ptr %2, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @sta_info_destroy_addr_bss(ptr noundef %3, ptr noundef nonnull %2)\nbr label %B3\n\nB2:\n%6 = tail call i32 @sta_info_flush(ptr noundef %3)\nbr label %B3\n\nB3:\n%7 = phi i32 [ %5, %B1 ], [ 0, %B2 ]\nret i32 %7\n}"}, "define dso_local i32 @ddt_pti(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\nstore i32 %0, ptr %5, align 4\nstore i32 %1, ptr %6, align 4\nstore ptr %2, ptr %7, align 8\n%8 = load i32, ptr %5, align 4\n%9 = icmp eq i32 %8, 109\nbr i1 %9, label %10, label %11\n\n10:\nstore i32 1, ptr %4, align 4\nbr label %16\n\n11:\n%12 = load i32, ptr %5, align 4\n%13 = load i32, ptr %6, align 4\n%14 = load ptr, ptr %7, align 8\n%15 = call i32 @ddt_e21(i32 noundef %12, i32 noundef %13, i8 noundef signext 80, i8 noundef signext 78, ptr noundef %14)\nstore i32 %15, ptr %4, align 4\nbr label %16\n\n16:\n%17 = load i32, ptr %4, align 4\nret i32 %17\n}": {"base_truth": "define dso_local i32 @ddt_pti(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i32 %0, 109\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @ddt_e21(i32 noundef %0, i32 noundef %1, i8 noundef signext 80, i8 noundef signext 78, ptr noundef %2)\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ 1, %B ]\nret i32 %5\n}", "codellama": "define dso_local i32 @ddt_pti(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i32 %0, 109\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @ddt_e21(i32 noundef %0, i32 noundef %1, i8 noundef signext 80, i8 noundef signext 78, ptr noundef %2)\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ 1, %B ]\nret i32 %5\n}", "codegemma": "define dso_local i32 @ddt_pti(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i32 %0, 109\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @ddt_e21(i32 noundef %0, i32 noundef %1, i8 noundef signext 80, i8 noundef signext 78, ptr noundef %2)\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ 1, %B ]\nret i32 %5\n}"}, "define internal signext i8 @gxemul_cons_read() {\n%1 = call i32 (...) @GC_LOCK_ASSERT()\nbr label %2\n\n2:\n%3 = call i32 (...) @gxemul_cons_readable()\n%4 = icmp ne i32 %3, 0\n%5 = xor i1 %4, true\nbr i1 %5, label %6, label %7\n\n6:\nbr label %2\n\n7:\nstore i64 0, ptr @buffer_valid, align 8\n%8 = load i8, ptr @buffer_data, align 1\nret i8 %8\n}": {"base_truth": "define internal signext i8 @gxemul_cons_read() {\nB:\n%0 = tail call i32 (...) @GC_LOCK_ASSERT()\nbr label %B1\n\nB1:\n%1 = tail call i32 (...) @gxemul_cons_readable()\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB2:\nstore i64 0, ptr @buffer_valid, align 8\n%3 = load i8, ptr @buffer_data, align 1\nret i8 %3\n}", "codellama": "define internal signext i8 @gxemul_cons_read() {\nB:\n%0 = tail call i32 (...) @GC_LOCK_ASSERT()\nbr label %B1\n\nB1:\n%1 = tail call i32 (...) @gxemul_cons_readable()\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB2:\nstore i64 0, ptr @buffer_valid, align 8\n%3 = load i8, ptr @buffer_data, align 1\nret i8 %3\n}", "codegemma": "define internal signext i8 @gxemul_cons_read() {\nB:\nbr label %B1\n\nB1:\n%0 = tail call i32 (...) @GC_LOCK_ASSERT()\nbr label %B2\n\nB2:\n%1 = tail call i32 (...) @gxemul_cons_readable()\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B3\n\nB3:\nstore i64 0, ptr @buffer_valid, align 8\n%3 = load i8, ptr @buffer_data, align 1\nret i8 %3\n}"}, "define internal i32 @psc_i2s_of_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @mpc5200_audio_dma_destroy(ptr noundef %3)\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.platform_device, ptr %5, i32 0, i32 0\n%7 = call i32 @snd_soc_unregister_component(ptr noundef %6)\nret i32 0\n}": {"base_truth": "define internal i32 @psc_i2s_of_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @mpc5200_audio_dma_destroy(ptr noundef %0)\n%2 = tail call i32 @snd_soc_unregister_component(ptr noundef %0)\nret i32 0\n}", "codellama": "define internal i32 @psc_i2s_of_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @mpc5200_audio_dma_destroy(ptr noundef %0)\n%2 = tail call i32 @snd_soc_unregister_component(ptr noundef %0)\nret i32 0\n}", "codegemma": "define internal i32 @psc_i2s_of_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @mpc5200_audio_dma_destroy(ptr noundef %0)\n%2 = tail call i32 @snd_soc_unregister_component(ptr noundef %0)\nret i32 0\n}"}, "define internal i32 @twl4030_can_write_to_chip(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 0, ptr %5, align 4\n%6 = load i32, ptr %4, align 4\nswitch i32 %6, label %54 [\ni32 133, label %7\ni32 129, label %14\ni32 128, label %21\ni32 131, label %28\ni32 130, label %35\ni32 132, label %42\n]\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.twl4030_priv ptr %8, i32 0, i32 6\n%10 = load i32, ptr %9, align 4\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %13\n\n12:\nstore i32 1, ptr %5, align 4\nbr label %13\n\n13:\nbr label %55\n\n14:\n%15 = load ptr, ptr %3, align 8\n%16 = getelementptr inbounds %struct.twl4030_priv ptr %15, i32 0, i32 5\n%17 = load i32, ptr %16, align 4\n%18 = icmp ne i32 %17, 0\nbr i1 %18, label %19, label %20\n\n19:\nstore i32 1, ptr %5, align 4\nbr label %20\n\n20:\nbr label %55\n\n21:\n%22 = load ptr, ptr %3, align 8\n%23 = getelementptr inbounds %struct.twl4030_priv ptr %22, i32 0, i32 4\n%24 = load i32, ptr %23, align 4\n%25 = icmp ne i32 %24, 0\nbr i1 %25, label %26, label %27\n\n26:\nstore i32 1, ptr %5, align 4\nbr label %27\n\n27:\nbr label %55\n\n28:\n%29 = load ptr, ptr %3, align 8\n%30 = getelementptr inbounds %struct.twl4030_priv ptr %29, i32 0, i32 3\n%31 = load i32, ptr %30, align 4\n%32 = icmp ne i32 %31, 0\nbr i1 %32, label %33, label %34\n\n33:\nstore i32 1, ptr %5, align 4\nbr label %34\n\n34:\nbr label %55\n\n35:\n%36 = load ptr, ptr %3, align 8\n%37 = getelementptr inbounds %struct.twl4030_priv ptr %36, i32 0, i32 2\n%38 = load i32, ptr %37, align 4\n%39 = icmp ne i32 %38, 0\nbr i1 %39, label %40, label %41\n\n40:\nstore i32 1, ptr %5, align 4\nbr label %41\n\n41:\nbr label %55\n\n42:\n%43 = load ptr, ptr %3, align 8\n%44 = getelementptr inbounds %struct.twl4030_priv ptr %43, i32 0, i32 1\n%45 = load i32, ptr %44, align 4\n%46 = icmp ne i32 %45, 0\nbr i1 %46, label %52, label %47\n\n47:\n%48 = load ptr, ptr %3, align 8\n%49 = getelementptr inbounds %struct.twl4030_priv ptr %48, i32 0, i32 0\n%50 = load i32, ptr %49, align 4\n%51 = icmp ne i32 %50, 0\nbr i1 %51, label %52, label %53\n\n52:\nstore i32 1, ptr %5, align 4\nbr label %53\n\n53:\nbr label %55\n\n54:\nstore i32 1, ptr %5, align 4\nbr label %55\n\n55:\n%56 = load i32, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %56\n}": {"base_truth": "define internal i32 @twl4030_can_write_to_chip(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\nswitch i32 %1, label %B9 [\ni32 133, label %B1\ni32 129, label %B2\ni32 128, label %B3\ni32 131, label %B4\ni32 130, label %B5\ni32 132, label %B6\n]\n\nB1:\n%2 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 6\n%3 = load i32, ptr %2, align 4\n%4 = icmp ne i32 %3, 0\nbr label %B9\n\nB2:\n%5 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 5\n%6 = load i32, ptr %5, align 4\n%7 = icmp ne i32 %6, 0\nbr label %B9\n\nB3:\n%8 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 4\n%9 = load i32, ptr %8, align 4\n%10 = icmp ne i32 %9, 0\nbr label %B9\n\nB4:\n%11 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 3\n%12 = load i32, ptr %11, align 4\n%13 = icmp ne i32 %12, 0\nbr label %B9\n\nB5:\n%14 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 2\n%15 = load i32, ptr %14, align 4\n%16 = icmp ne i32 %15, 0\nbr label %B9\n\nB6:\n%17 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 1\n%18 = load i32, ptr %17, align 4\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B7, label %B8\n\nB7:\n%20 = load i32, ptr %0, align 4\n%21 = icmp eq i32 %20, 0\nbr i1 %21, label %B9, label %B8\n\nB8:\nbr label %B9\n\nB9:\n%22 = phi i1 [ true, %B8 ], [ false, %B7 ], [ %4, %B1 ], [ %7, %B2 ], [ %10, %B3 ], [ %13, %B4 ], [ %16, %B5 ], [ true, %B ]\n%23 = zext i1 %22 to i32\nret i32 %23\n}", "codellama": "define internal i32 @twl4030_can_write_to_chip(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\nswitch i32 %1, label %B8 [\ni32 133, label %B1\ni32 129, label %B2\ni32 128, label %B3\ni32 131, label %B4\ni32 130, label %B5\ni32 132, label %B6\n]\n\nB1:\n%2 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 6\n%3 = load i32, ptr %2, align 4\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B8, label %B7\n\nB2:\n%5 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 5\n%6 = load i32, ptr %5, align 4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B8, label %B7\n\nB3:\n%8 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 4\n%9 = load i32, ptr %8, align 4\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B8, label %B7\n\nB4:\n%11 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 3\n%12 = load i32, ptr %11, align 4\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B8, label %B7\n\nB5:\n%14 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 2\n%15 = load i32, ptr %14, align 4\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B8, label %B7\n\nB6:\n%17 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 1\n%18 = load i32, ptr %17, align 4\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B7, label %B8\n\nB7:\nbr label %B8\n\nB8:\n%20 = phi i32 [ 0, %B7 ], [ 1, %B1 ], [ 1, %B2 ], [ 1, %B3 ], [ 1, %B4 ], [ 1, %B5 ], [ 1, %B6 ], [ 1, %B ]\nret i32 %20\n}", "codegemma": "define internal i32 @twl4030_can_write_to_chip(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\nswitch i32 %1, label %B7 [\ni32 133, label %B1\ni32 129, label %B2\ni32 128, label %B3\ni32 131, label %B4\ni32 130, label %B5\ni32 132, label %B6\n]\n\nB1:\n%2 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 6\n%3 = load i32, ptr %2, align 4\n%4 = icmp ne i32 %3, 0\n%5 = zext i1 %4 to i32\nbr label %B7\n\nB2:\n%6 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 5\n%7 = load i32, ptr %6, align 4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nbr label %B7\n\nB3:\n%10 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 4\n%11 = load i32, ptr %10, align 4\n%12 = icmp ne i32 %11, 0\n%13 = zext i1 %12 to i32\nbr label %B7\n\nB4:\n%14 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 3\n%15 = load i32, ptr %14, align 4\n%16 = icmp ne i32 %15, 0\n%17 = zext i1 %16 to i32\nbr label %B7\n\nB5:\n%18 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 2\n%19 = load i32, ptr %18, align 4\n%20 = icmp ne i32 %19, 0\n%21 = zext i1 %20 to i32\nbr label %B7\n\nB6:\n%22 = getelementptr inbounds %struct.twl4030_priv, ptr %0, i64 0, i32 1\n%23 = load i32, ptr %22, align 4\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %B7, label %B6\n\nB7:\n%25 = phi i32 [ 1, %B6 ], [ 1, %B5 ], [ 1, %B4 ], [ 1, %B3 ], [ 1, %B2 ], [ 1, %B1 ], [ 1, %B ]\nret i32 %25\n}"}, "define dso_local ptr @ParsePrimary(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @ParseSimplePrimary(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\nbr label %7\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @GetToken(ptr noundef %8)\nstore i32 %9, ptr %4, align 4\n%10 = icmp eq i32 %9, 40\nbr i1 %10, label %17, label %11\n\n11:\n%12 = load i32, ptr %4, align 4\n%13 = icmp eq i32 %12, 91\nbr i1 %13, label %17, label %14\n\n14:\n%15 = load i32, ptr %4, align 4\n%16 = icmp eq i32 %15, 46\nbr label %17\n\n17:\n%18 = phi i1 [ true, %11 ], [ true, %7 ], [ %16, %14 ]\nbr i1 %18, label %19, label %30\n\n19:\n%20 = load i32, ptr %4, align 4\nswitch i32 %20, label %29 [\ni32 91, label %21\ni32 40, label %25\n]\n\n21:\n%22 = load ptr, ptr %2, align 8\n%23 = load ptr, ptr %3, align 8\n%24 = call ptr @ParseArrayReference(ptr noundef %22, ptr noundef %23)\nstore ptr %24, ptr %3, align 8\nbr label %29\n\n25:\n%26 = load ptr, ptr %2, align 8\n%27 = load ptr, ptr %3, align 8\n%28 = call ptr @ParseCall(ptr noundef %26, ptr noundef %27)\nstore ptr %28, ptr %3, align 8\nbr label %29\n\n29:\nbr label %7\n\n30:\n%31 = load ptr, ptr %2, align 8\n%32 = load i32, ptr %4, align 4\n%33 = call i32 @SaveToken(ptr noundef %31, i32 noundef %32)\n%34 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %34\n}": {"base_truth": "define dso_local ptr @ParsePrimary(ptr noundef %0) {\nB:\n%1 = tail call ptr @ParseSimplePrimary(ptr noundef %0)\nbr label %B1\n\nB1:\n%2 = phi ptr [ %1, %B ], [ %6, %B5 ]\nbr label %B2\n\nB2:\n%3 = tail call i32 @GetToken(ptr noundef %0)\nswitch i32 %3, label %B6 [\ni32 91, label %B3\ni32 40, label %B4\ni32 46, label %B2\n]\n\nB3:\n%4 = tail call ptr @ParseArrayReference(ptr noundef %0, ptr noundef %2)\nbr label %B5\n\nB4:\n%5 = tail call ptr @ParseCall(ptr noundef %0, ptr noundef %2)\nbr label %B5\n\nB5:\n%6 = phi ptr [ %4, %B3 ], [ %5, %B4 ]\nbr label %B1\n\nB6:\n%7 = tail call i32 @SaveToken(ptr noundef %0, i32 noundef %3)\nret ptr %2\n}", "codellama": "define dso_local ptr @ParsePrimary(ptr noundef %0) {\nB:\n%1 = tail call ptr @ParseSimplePrimary(ptr noundef %0)\nbr label %B1\n\nB1:\n%2 = phi ptr [ %1, %B ], [ %10, %B4 ]\n%3 = tail call i32 @GetToken(ptr noundef %0)\nswitch i32 %3, label %B5 [\ni32 46, label %B4\ni32 91, label %B2\ni32 40, label %B3\n]\n\nB2:\n%4 = tail call ptr @ParseArrayReference(ptr noundef %0, ptr noundef %2)\nbr label %B4\n\nB3:\n%5 = tail call ptr @ParseCall(ptr noundef %0, ptr noundef %2)\nbr label %B4\n\nB4:\n%6 = phi ptr [ %2, %B1 ], [ %5, %B3 ], [ %4, %B2 ]\n%7 = tail call i32 @GetToken(ptr noundef %0)\nswitch i32 %7, label %B5 [\ni32 46, label %B1\ni32 91, label %B2\ni32 40, label %B3\n]\n\nB5:\n%8 = phi i32 [ %3, %B1 ], [ %7, %B4 ]\n%9 = tail call i32 @SaveToken(ptr noundef %0, i32 noundef %8)\nret ptr %6\n}", "codegemma": "define dso_local ptr @ParsePrimary(ptr noundef %0) {\nB:\n%1 = tail call ptr @ParseSimplePrimary(ptr noundef %0)\n%2 = tail call i32 @GetToken(ptr noundef %0)\nswitch i32 %2, label %B4 [\ni32 40, label %B3\ni32 91, label %B3\n]\n\nB1:\n%3 = tail call i32 @GetToken(ptr noundef %0)\nswitch i32 %3, label %B4 [\ni32 40, label %B3\ni32 91, label %B3\n]\n\nB2:\n%4 = tail call i32 @GetToken(ptr noundef %0)\nswitch i32 %4, label %B4 [\ni32 40, label %B3\ni32 91, label %B3\n]\n\nB3:\n%5 = phi ptr [ %1, %B ], [ %1, %B1 ], [ %1, %B2 ]\n%6 = tail call ptr @ParseCall(ptr noundef %0, ptr noundef %5)\nbr label %B4\n\nB4:\n%7 = phi ptr [ %1, %B ], [ %6, %B3 ], [ %1, %B1 ], [ %1, %B2 ], [ %1, %B ]\n%8 = tail call i32 @SaveToken(ptr noundef %0, i32 noundef %2)\nret ptr %7\n}"}, "define dso_local i32 @vector_count(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @vector_count(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @vector_count(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @vector_count(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define internal i32 @bcmgenet_dma_disable(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%5 = load i32, ptr @DESC_INDEX, align 4\n%6 = load i32, ptr @DMA_RING_BUF_EN_SHIFT, align 4\n%7 = add nsw i32 %5, %6\n%8 = shl i32 1, %7\n%9 = load i32, ptr @DMA_EN, align 4\n%10 = or i32 %8, %9\nstore i32 %10, ptr %4, align 4\n%11 = load ptr, ptr %2, align 8\n%12 = load i32, ptr @DMA_CTRL, align 4\n%13 = call i32 @bcmgenet_tdma_readl(ptr noundef %11, i32 noundef %12)\nstore i32 %13, ptr %3, align 4\n%14 = load i32, ptr %4, align 4\n%15 = xor i32 %14, -1\n%16 = load i32, ptr %3, align 4\n%17 = and i32 %16, %15\nstore i32 %17, ptr %3, align 4\n%18 = load ptr, ptr %2, align 8\n%19 = load i32, ptr %3, align 4\n%20 = load i32, ptr @DMA_CTRL, align 4\n%21 = call i32 @bcmgenet_tdma_writel(ptr noundef %18, i32 noundef %19, i32 noundef %20)\n%22 = load ptr, ptr %2, align 8\n%23 = load i32, ptr @DMA_CTRL, align 4\n%24 = call i32 @bcmgenet_rdma_readl(ptr noundef %22, i32 noundef %23)\nstore i32 %24, ptr %3, align 4\n%25 = load i32, ptr %4, align 4\n%26 = xor i32 %25, -1\n%27 = load i32, ptr %3, align 4\n%28 = and i32 %27, %26\nstore i32 %28, ptr %3, align 4\n%29 = load ptr, ptr %2, align 8\n%30 = load i32, ptr %3, align 4\n%31 = load i32, ptr @DMA_CTRL, align 4\n%32 = call i32 @bcmgenet_rdma_writel(ptr noundef %29, i32 noundef %30, i32 noundef %31)\n%33 = load ptr, ptr %2, align 8\n%34 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%35 = call i32 @bcmgenet_umac_writel(ptr noundef %33, i32 noundef 1, i32 noundef %34)\n%36 = call i32 @udelay(i32 noundef 10)\n%37 = load ptr, ptr %2, align 8\n%38 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%39 = call i32 @bcmgenet_umac_writel(ptr noundef %37, i32 noundef 0, i32 noundef %38)\n%40 = load i32, ptr %4, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %40\n}": {"base_truth": "define internal i32 @bcmgenet_dma_disable(ptr noundef %0) {\nB:\n%1 = load i32, ptr @DESC_INDEX, align 4\n%2 = load i32, ptr @DMA_RING_BUF_EN_SHIFT, align 4\n%3 = add nsw i32 %2, %1\n%4 = shl nuw i32 1, %3\n%5 = load i32, ptr @DMA_EN, align 4\n%6 = or i32 %4, %5\n%7 = load i32, ptr @DMA_CTRL, align 4\n%8 = tail call i32 @bcmgenet_tdma_readl(ptr noundef %0, i32 noundef %7)\n%9 = xor i32 %6, -1\n%10 = and i32 %8, %9\n%11 = load i32, ptr @DMA_CTRL, align 4\n%12 = tail call i32 @bcmgenet_tdma_writel(ptr noundef %0, i32 noundef %10, i32 noundef %11)\n%13 = load i32, ptr @DMA_CTRL, align 4\n%14 = tail call i32 @bcmgenet_rdma_readl(ptr noundef %0, i32 noundef %13)\n%15 = and i32 %14, %9\n%16 = load i32, ptr @DMA_CTRL, align 4\n%17 = tail call i32 @bcmgenet_rdma_writel(ptr noundef %0, i32 noundef %15, i32 noundef %16)\n%18 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%19 = tail call i32 @bcmgenet_umac_writel(ptr noundef %0, i32 noundef 1, i32 noundef %18)\n%20 = tail call i32 @udelay(i32 noundef 10)\n%21 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%22 = tail call i32 @bcmgenet_umac_writel(ptr noundef %0, i32 noundef 0, i32 noundef %21)\nret i32 %6\n}", "codellama": "define internal i32 @bcmgenet_dma_disable(ptr noundef %0) {\nB:\n%1 = load i32, ptr @DESC_INDEX, align 4\n%2 = load i32, ptr @DMA_RING_BUF_EN_SHIFT, align 4\n%3 = add nsw i32 %2, %1\n%4 = shl nuw i32 1, %3\n%5 = load i32, ptr @DMA_EN, align 4\n%6 = or i32 %5, %4\n%7 = load i32, ptr @DMA_CTRL, align 4\n%8 = tail call i32 @bcmgenet_tdma_readl(ptr noundef %0, i32 noundef %7)\n%9 = xor i32 %6, -1\n%10 = and i32 %8, %9\n%11 = load i32, ptr @DMA_CTRL, align 4\n%12 = tail call i32 @bcmgenet_tdma_writel(ptr noundef %0, i32 noundef %10, i32 noundef %11)\n%13 = load i32, ptr @DMA_CTRL, align 4\n%14 = tail call i32 @bcmgenet_rdma_readl(ptr noundef %0, i32 noundef %13)\n%15 = and i32 %14, %9\n%16 = load i32, ptr @DMA_CTRL, align 4\n%17 = tail call i32 @bcmgenet_rdma_writel(ptr noundef %0, i32 noundef %15, i32 noundef %16)\n%18 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%19 = tail call i32 @bcmgenet_umac_writel(ptr noundef %0, i32 noundef 1, i32 noundef %18)\n%20 = tail call i32 @udelay(i32 noundef 10)\n%21 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%22 = tail call i32 @bcmgenet_umac_writel(ptr noundef %0, i32 noundef 0, i32 noundef %21)\nret i32 %6\n}", "codegemma": "define internal i32 @bcmgenet_dma_disable(ptr noundef %0) {\nB:\n%1 = load i32, ptr @DESC_INDEX, align 4\n%2 = load i32, ptr @DMA_RING_BUF_EN_SHIFT, align 4\n%3 = add nsw i32 %2, %1\n%4 = shl nuw i32 1, %3\n%5 = load i32, ptr @DMA_EN, align 4\n%6 = or i32 %5, %4\n%7 = load i32, ptr @DMA_CTRL, align 4\n%8 = tail call i32 @bcmgenet_tdma_readl(ptr noundef %0, i32 noundef %7)\n%9 = xor i32 %6, -1\n%10 = and i32 %8, %9\n%11 = load i32, ptr @DMA_CTRL, align 4\n%12 = tail call i32 @bcmgenet_tdma_writel(ptr noundef %0, i32 noundef %10, i32 noundef %11)\n%13 = load i32, ptr @DMA_CTRL, align 4\n%14 = tail call i32 @bcmgenet_rdma_readl(ptr noundef %0, i32 noundef %13)\n%15 = and i32 %14, %9\n%16 = load i32, ptr @DMA_CTRL, align 4\n%17 = tail call i32 @bcmgenet_rdma_writel(ptr noundef %0, i32 noundef %15, i32 noundef %16)\n%18 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%19 = tail call i32 @bcmgenet_umac_writel(ptr noundef %0, i32 noundef 1, i32 noundef %18)\n%20 = tail call i32 @udelay(i32 noundef 10)\n%21 = load i32, ptr @UMAC_TX_FLUSH, align 4\n%22 = tail call i32 @bcmgenet_umac_writel(ptr noundef %0, i32 noundef 0, i32 noundef %21)\nret i32 %6\n}"}, "define dso_local i32 @r3is_separator(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\n%4 = load i32, ptr %2, align 4\nswitch i32 %4, label %6 [\ni32 0, label %5\ni32 9, label %5\ni32 10, label %5\ni32 12, label %5\ni32 13, label %5\ni32 32, label %5\n]\n\n5:\nstore i32 1, ptr %3, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @r3is_separator(i32 noundef %0) {\nB:\nswitch i32 %0, label %B2 [\ni32 0, label %B1\ni32 9, label %B1\ni32 10, label %B1\ni32 12, label %B1\ni32 13, label %B1\ni32 32, label %B1\n]\n\nB1:\nbr label %B2\n\nB2:\n%1 = phi i32 [ 0, %B ], [ 1, %B1 ]\nret i32 %1\n}", "codellama": "define dso_local i32 @r3is_separator(i32 noundef %0) {\nB:\nswitch i32 %0, label %B1 [\ni32 0, label %B2\ni32 9, label %B2\ni32 10, label %B2\ni32 12, label %B2\ni32 13, label %B2\ni32 32, label %B2\n]\n\nB1:\nbr label %B2\n\nB2:\n%1 = phi i32 [ 0, %B1 ], [ 1, %B ], [ 1, %B ], [ 1, %B ], [ 1, %B ], [ 1, %B ], [ 1, %B ]\nret i32 %1\n}", "codegemma": "define dso_local i32 @r3is_separator(i32 noundef %0) {\nB:\nswitch i32 %0, label %B2 [\ni32 0, label %B3\ni32 9, label %B3\ni32 10, label %B3\ni32 12, label %B3\ni32 13, label %B3\ni32 32, label %B3\n]\n\nB1:\nret i32 0\n\nB2:\nbr label %B1\n\nB3:\n%1 = phi i32 [ 1, %B ], [ 0, %B2 ], [ 0, %B2 ], [ 0, %B2 ], [ 0, %B2 ], [ 0, %B2 ], [ 0, %B2 ], [ 0, %B2 ]\nret i32 %1\n}"}, "define dso_local void @SensorReg_Sleep() {\n%1 = call i32 (...) @SensorReg_SaveConfig()\nret void\n}": {"base_truth": "define dso_local void @SensorReg_Sleep() {\nB:\n%0 = tail call i32 (...) @SensorReg_SaveConfig()\nret void\n}", "codellama": "define dso_local void @SensorReg_Sleep() {\nB:\n%0 = tail call i32 (...) @SensorReg_SaveConfig()\nret void\n}", "codegemma": "define dso_local void @SensorReg_Sleep() {\nB:\n%0 = tail call i32 (...) @SensorReg_SaveConfig()\nret void\n}"}, "define dso_local void @skipBlankSymbols(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %4, align 8\n%7 = load i64, ptr %6, align 8\nstore i64 %7, ptr %5, align 8\nbr label %8\n\n8:\n%9 = load ptr, ptr %3, align 8\n%10 = load i64, ptr %5, align 8\n%11 = getelementptr inbounds i8, ptr %9, i64 %10\n%12 = load i8, ptr %11, align 1\n%13 = sext i8 %12 to i32\n%14 = icmp eq i32 %13, 32\nbr i1 %14, label %36, label %15\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = load i64, ptr %5, align 8\n%18 = getelementptr inbounds i8, ptr %16, i64 %17\n%19 = load i8, ptr %18, align 1\n%20 = sext i8 %19 to i32\n%21 = icmp eq i32 %20, 10\nbr i1 %21, label %36, label %22\n\n22:\n%23 = load ptr, ptr %3, align 8\n%24 = load i64, ptr %5, align 8\n%25 = getelementptr inbounds i8, ptr %23, i64 %24\n%26 = load i8, ptr %25, align 1\n%27 = sext i8 %26 to i32\n%28 = icmp eq i32 %27, 13\nbr i1 %28, label %36, label %29\n\n29:\n%30 = load ptr, ptr %3, align 8\n%31 = load i64, ptr %5, align 8\n%32 = getelementptr inbounds i8, ptr %30, i64 %31\n%33 = load i8, ptr %32, align 1\n%34 = sext i8 %33 to i32\n%35 = icmp eq i32 %34, 9\nbr label %36\n\n36:\n%37 = phi i1 [ true, %22 ], [ true, %15 ], [ true, %8 ], [ %35, %29 ]\nbr i1 %37, label %38, label %41\n\n38:\n%39 = load i64, ptr %5, align 8\n%40 = add i64 %39, 1\nstore i64 %40, ptr %5, align 8\nbr label %8\n\n41:\n%42 = load i64, ptr %5, align 8\n%43 = load ptr, ptr %4, align 8\nstore i64 %42, ptr %43, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @skipBlankSymbols(ptr nocapture noundef readonly %0, ptr nocapture noundef %1) {\nB:\n%2 = load i64, ptr %1, align 8\nbr label %B1\n\nB1:\n%3 = phi i64 [ %2, %B ], [ %6, %B2 ]\n%4 = getelementptr inbounds i8, ptr %0, i64 %3\n%5 = load i8, ptr %4, align 1\nswitch i8 %5, label %B3 [\ni8 32, label %B2\ni8 10, label %B2\ni8 13, label %B2\ni8 9, label %B2\n]\n\nB2:\n%6 = add i64 %3, 1\nbr label %B1\n\nB3:\nstore i64 %3, ptr %1, align 8\nret void\n}", "codellama": "define dso_local void @skipBlankSymbols(ptr nocapture noundef readonly %0, ptr nocapture noundef %1) {\nB:\n%2 = load i64, ptr %1, align 8\nbr label %B1\n\nB1:\n%3 = phi i64 [ %2, %B ], [ %8, %B2 ]\n%4 = getelementptr inbounds i8, ptr %0, i64 %3\n%5 = load i8, ptr %4, align 1\nswitch i8 %5, label %B3 [\ni8 32, label %B2\ni8 10, label %B2\ni8 13, label %B2\ni8 9, label %B2\n]\n\nB2:\n%6 = add i64 %3, 1\nbr label %B1\n\nB3:\nstore i64 %3, ptr %1, align 8\nret void\n}", "codegemma": "define dso_local void @skipBlankSymbols(ptr nocapture noundef readonly %0, ptr nocapture noundef %1) {\nB:\n%2 = load i64, ptr %1, align 8\n%3 = getelementptr inbounds i8, ptr %0, i64 %2\n%4 = load i8, ptr %3, align 1\nswitch i8 %4, label %B3 [\ni8 32, label %B1\ni8 13, label %B1\ni8 10, label %B1\n]\n\nB1:\n%5 = phi i64 [ %8, %B1 ], [ %2, %B ]\n%6 = add i64 %5, 1\n%7 = getelementptr inbounds i8, ptr %0, i64 %6\n%8 = load i8, ptr %7, align 1\nswitch i8 %8, label %B3 [\ni8 32, label %B1\ni8 13, label %B1\ni8 10, label %B1\n]\n\nB2:\n%9 = add i64 %11, 1\n%10 = getelementptr inbounds i8, ptr %0, i64 %9\n%11 = load i8, ptr %10, align 1\nswitch i8 %11, label %B3 [\ni8 32, label %B2\ni8 13, label %B2\ni8 10, label %B2\n]\n\nB3:\n%12 = phi i64 [ %2, %B ], [ %6, %B1 ], [ %9, %B2 ]\nstore i64 %12, ptr %1, align 8\nret void\n}"}, "define dso_local void @stor_lookup_next_req_free(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @osapi_free(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @stor_lookup_next_req_free(ptr noundef %0) {\nB:\n%1 = tail call i32 @osapi_free(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @stor_lookup_next_req_free(ptr noundef %0) {\nB:\n%1 = tail call i32 @osapi_free(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @stor_lookup_next_req_free(ptr noundef %0) {\nB:\n%1 = tail call i32 @osapi_free(ptr noundef %0)\nret void\n}"}, "define dso_local ptr @seed_list_get_iterator(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%8 = call ptr @malloc(i32 noundef 8)\nstore ptr %8, ptr %6, align 8\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %10, label %11\n\n10:\nstore ptr null, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %31\n\n11:\n%12 = load i32, ptr %5, align 4\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %14, label %20\n\n14:\n%15 = load ptr, ptr %4, align 8\n%16 = getelementptr inbounds %struct.TYPE_7__, ptr %15, i32 0, i32 1\n%17 = load i32, ptr %16, align 4\n%18 = load ptr, ptr %6, align 8\n%19 = getelementptr inbounds %struct.TYPE_6__, ptr %18, i32 0, i32 1\nstore i32 %17, ptr %19, align 4\nbr label %26\n\n20:\n%21 = load ptr, ptr %4, align 8\n%22 = getelementptr inbounds %struct.TYPE_7__, ptr %21, i32 0, i32 0\n%23 = load i32, ptr %22, align 4\n%24 = load ptr, ptr %6, align 8\n%25 = getelementptr inbounds %struct.TYPE_6__, ptr %24, i32 0, i32 1\nstore i32 %23, ptr %25, align 4\nbr label %26\n\n26:\n%27 = load i32, ptr %5, align 4\n%28 = load ptr, ptr %6, align 8\n%29 = getelementptr inbounds %struct.TYPE_6__, ptr %28, i32 0, i32 0\nstore i32 %27, ptr %29, align 4\n%30 = load ptr, ptr %6, align 8\nstore ptr %30, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %31\n\n31:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%32 = load ptr, ptr %3, align 8\nret ptr %32\n}": {"base_truth": "define dso_local ptr @seed_list_get_iterator(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @malloc(i32 noundef 8)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = icmp eq i32 %1, 0\n%5 = getelementptr inbounds %struct.TYPE_7__, ptr %0, i64 0, i32 1\n%6 = select i1 %4, ptr %5, ptr %0\n%7 = load i32, ptr %6, align 4\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\nstore i32 %7, ptr %8, align 4\nstore i32 %1, ptr %2, align 4\nbr label %B2\n\nB2:\nret ptr %2\n}", "codellama": "define dso_local ptr @seed_list_get_iterator(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @malloc(i32 noundef 8)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = icmp eq i32 %1, 0\n%5 = getelementptr inbounds %struct.TYPE_7__, ptr %0, i64 0, i32 1\n%6 = select i1 %4, ptr %5, ptr %0\n%7 = load i32, ptr %6, align 4\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\nstore i32 %7, ptr %8, align 4\nstore i32 %1, ptr %2, align 4\nbr label %B2\n\nB2:\nret ptr %2\n}", "codegemma": "define dso_local ptr @seed_list_get_iterator(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @malloc(i32 noundef 8)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = icmp eq i32 %1, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\n%6 = getelementptr inbounds %struct.TYPE_7__, ptr %0, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\nstore i32 %7, ptr %5, align 4\nbr label %B3\n\nB3:\n%8 = phi i32 [ 0, %B ], [ %1, %B1 ], [ %7, %B2 ]\nstore i32 %8, ptr %2, align 4\nret ptr %2\n}"}, "define internal i64 @acpi_tb_select_address(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\n%4 = alloca i64, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i64, align 8\n%7 = alloca i64, align 8\nstore ptr %0, ptr %5, align 8\nstore i64 %1, ptr %6, align 8\nstore i64 %2, ptr %7, align 8\n%8 = load i64, ptr %7, align 8\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %12, label %10\n\n10:\n%11 = load i64, ptr %6, align 8\nstore i64 %11, ptr %4, align 8\nbr label %37\n\n12:\n%13 = load i64, ptr %6, align 8\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %35\n\n15:\n%16 = load i64, ptr %7, align 8\n%17 = load i64, ptr %6, align 8\n%18 = icmp ne i64 %16, %17\nbr i1 %18, label %19, label %35\n\n19:\n%20 = load i32, ptr @AE_INFO, align 4\n%21 = load ptr, ptr %5, align 8\n%22 = load i64, ptr %6, align 8\n%23 = load i64, ptr %7, align 8\n%24 = call i32 @ACPI_FORMAT_UINT64(i64 noundef %23)\n%25 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%26 = icmp ne i64 %25, 0\n%27 = zext i1 %26 to i64\n%28 = select i1 %26, i32 32, i32 64\n%29 = call i32 @ACPI_BIOS_WARNING(i32 noundef %28)\n%30 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%31 = icmp ne i64 %30, 0\nbr i1 %31, label %32, label %34\n\n32:\n%33 = load i64, ptr %6, align 8\nstore i64 %33, ptr %4, align 8\nbr label %37\n\n34:\nbr label %35\n\n35:\n%36 = load i64, ptr %7, align 8\nstore i64 %36, ptr %4, align 8\nbr label %37\n\n37:\n%38 = load i64, ptr %4, align 8\nret i64 %38\n}": {"base_truth": "define internal i64 @acpi_tb_select_address(ptr nocapture noundef readnone %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = icmp eq i64 %1, 0\n%5 = icmp eq i64 %2, %1\n%6 = or i1 %4, %5\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = tail call i32 @ACPI_FORMAT_UINT64(i64 noundef %2)\n%8 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%9 = icmp eq i64 %8, 0\n%10 = select i1 %9, i32 64, i32 32\n%11 = tail call i32 @ACPI_BIOS_WARNING(i32 noundef %10)\n%12 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B3, label %B4\n\nB3:\nbr label %B4\n\nB4:\n%14 = phi i64 [ %2, %B3 ], [ %1, %B ], [ %1, %B2 ]\nret i64 %14\n}", "codellama": "define internal i64 @acpi_tb_select_address(ptr nocapture noundef readnone %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\n%4 = icmp eq i64 %1, 0\n%5 = icmp eq i64 %2, %1\n%6 = or i1 %4, %5\nbr i1 %3, label %B3, label %B1\n\nB1:\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = tail call i32 @ACPI_FORMAT_UINT64(i64 noundef %2)\n%8 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%9 = icmp eq i64 %8, 0\n%10 = select i1 %9, i32 64, i32 32\n%11 = tail call i32 @ACPI_BIOS_WARNING(i32 noundef %10)\n%12 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B1, label %B3\n\nB3:\n%14 = phi i64 [ %1, %B ], [ %2, %B1 ], [ %2, %B2 ]\nret i64 %14\n}", "codegemma": "define internal i64 @acpi_tb_select_address(ptr nocapture noundef readnone %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = icmp eq i64 %1, 0\n%5 = icmp eq i64 %2, %1\n%6 = or i1 %4, %5\nbr i1 %6, label %B4, label %B2\n\nB2:\n%7 = load i32, ptr @AE_INFO, align 4\n%8 = tail call i32 @ACPI_FORMAT_UINT64(i64 noundef %2)\n%9 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%10 = icmp eq i64 %9, 0\n%11 = select i1 %10, i32 64, i32 32\n%12 = tail call i32 @ACPI_BIOS_WARNING(i32 noundef %11)\n%13 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = load i64, ptr @acpi_gbl_use32_bit_fadt_addresses, align 8\nbr label %B4\n\nB4:\n%16 = phi i64 [ %15, %B3 ], [ %1, %B1 ], [ 0, %B ], [ %2, %B2 ]\nret i64 %16\n}"}, "define dso_local nofpclass(nan inf) float @pow(float noundef nofpclass(nan inf) %0, i32 noundef %1) {\n%3 = alloca float, align 4\n%4 = alloca i32, align 4\n%5 = alloca float, align 4\n%6 = alloca i32, align 4\nstore float %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%7 = load float, ptr %3, align 4\nstore float %7, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\nstore i32 1, ptr %6, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %6, align 4\n%10 = load i32, ptr %4, align 4\n%11 = icmp slt i32 %9, %10\nbr i1 %11, label %12, label %19\n\n12:\n%13 = load float, ptr %3, align 4\n%14 = load float, ptr %5, align 4\n%15 = fmul fast float %14, %13\nstore float %15, ptr %5, align 4\nbr label %16\n\n16:\n%17 = load i32, ptr %6, align 4\n%18 = add nsw i32 %17, 1\nstore i32 %18, ptr %6, align 4\nbr label %8\n\n19:\n%20 = load float, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret float %20\n}": {"base_truth": "define dso_local nofpclass(nan inf) float @pow(float noundef nofpclass(nan inf) %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %1, 1\nbr i1 %2, label %B1, label %B7\n\nB1:\n%3 = add i32 %1, -1\n%4 = icmp ult i32 %1, 33\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = and i32 %3, -32\n%6 = or i32 %5, 1\n%7 = insertelement <8 x float> <float poison, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>, float %0, i64 0\n%8 = insertelement <8 x float> poison, float %0, i64 0\n%9 = shufflevector <8 x float> %8, <8 x float> poison, <8 x i32> zeroinitializer\n%10 = insertelement <8 x float> poison, float %0, i64 0\n%11 = shufflevector <8 x float> %10, <8 x float> poison, <8 x i32> zeroinitializer\n%12 = insertelement <8 x float> poison, float %0, i64 0\n%13 = shufflevector <8 x float> %12, <8 x float> poison, <8 x i32> zeroinitializer\n%14 = insertelement <8 x float> poison, float %0, i64 0\n%15 = shufflevector <8 x float> %14, <8 x float> poison, <8 x i32> zeroinitializer\nbr label %B3\n\nB3:\n%16 = phi i32 [ 0, %B2 ], [ %25, %B3 ]\n%17 = phi <8 x float> [ %7, %B2 ], [ %21, %B3 ]\n%18 = phi <8 x float> [ <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>, %B2 ], [ %22, %B3 ]\n%19 = phi <8 x float> [ <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>, %B2 ], [ %23, %B3 ]\n%20 = phi <8 x float> [ <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>, %B2 ], [ %24, %B3 ]\n%21 = fmul fast <8 x float> %17, %9\n%22 = fmul fast <8 x float> %18, %11\n%23 = fmul fast <8 x float> %19, %13\n%24 = fmul fast <8 x float> %20, %15\n%25 = add nuw i32 %16, 32\n%26 = icmp eq i32 %25, %5\nbr i1 %26, label %B4, label %B3\n\nB4:\n%27 = fmul fast <8 x float> %22, %21\n%28 = fmul fast <8 x float> %23, %27\n%29 = fmul fast <8 x float> %24, %28\n%30 = tail call fast float @llvm.vector.reduce.fmul.v8f32(float 1.000000e+00, <8 x float> %29)\n%31 = icmp eq i32 %3, %5\nbr i1 %31, label %B7, label %B5\n\nB5:\n%32 = phi i32 [ 1, %B1 ], [ %6, %B4 ]\n%33 = phi float [ %0, %B1 ], [ %30, %B4 ]\nbr label %B6\n\nB6:\n%34 = phi i32 [ %37, %B6 ], [ %32, %B5 ]\n%35 = phi float [ %36, %B6 ], [ %33, %B5 ]\n%36 = fmul fast float %35, %0\n%37 = add nuw nsw i32 %34, 1\n%38 = icmp eq i32 %37, %1\nbr i1 %38, label %B7, label %B6\n\nB7:\n%39 = phi float [ %0, %B ], [ %30, %B4 ], [ %36, %B6 ]\nret float %39\n}", "codellama": "define dso_local nofpclass(nan inf) float @pow(float noundef nofpclass(nan inf) %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %1, 1\nbr i1 %2, label %B1, label %B7\n\nB1:\n%3 = add i32 %1, -1\n%4 = icmp ult i32 %1, 32\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = and i32 %3, -32\n%6 = insertelement <8 x float> poison, float %0, i64 0\n%7 = shufflevector <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n%8 = insertelement <8 x float> poison, float %0, i64 0\n%9 = shufflevector <8 x i32> %7, <8 x i32> %8, <8 x i32> zeroinitializer\n%10 = insertelement <8 x float> poison, float %0, i64 0\n%11 = shufflevector <8 x i32> %7, <8 x i32> %10, <8 x i32> zeroinitializer\n%12 = insertelement <8 x float> poison, float %0, i64 0\n%13 = shufflevector <8 x i32> %7, <8 x i32> %12, <8 x i32> zeroinitializer\n%14 = insertelement <8 x float> poison, float %0, i64 0\n%15 = shufflevector <8 x i32> %7, <8 x i32> %14, <8 x i32> zeroinitializer\nbr label %B3\n\nB3:\n%16 = phi i32 [ 0, %B2 ], [ %29, %B3 ]\n%17 = phi <8 x float> [ %9, %B2 ], [ %25, %B3 ]\n%18 = phi <8 x float> [ %11, %B2 ], [ %26, %B3 ]\n%19 = phi <8 x float> [ %13, %B2 ], [ %27, %B3 ]\n%20 = phi <8 x float> [ %15, %B2 ], [ %28, %B3 ]\n%21 = phi <8 x i32> [ <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>, %B2 ], [ %24, %B3 ]\n%22 = add <8 x i32> %21, <i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8>\n%23 = add <8 x i32> %21, <i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16>\n%24 = add <8 x i32> %21, <i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24>\n%25 = fmul fast <8 x float> %17, %9\n%26 = fmul fast <8 x float> %18, %11\n%27 = fmul fast <8 x float> %19, %13\n%28 = fmul fast <8 x float> %20, %21\n%29 = add nuw i32 %16, 32\n%30 = icmp eq i32 %29, %5\nbr i1 %30, label %B4, label %B3\n\nB4:\n%31 = fmul fast <8 x float> %26, %25\n%32 = fmul fast <8 x float> %27, %31\n%33 = fmul fast <8 x float> %28, %32\n%34 = tail call fast float @llvm.vector.reduce.fmul.v8f32(float -1.000000e+00, <8 x float> %33)\n%35 = icmp eq i32 %3, %5\nbr i1 %35, label %B7, label %B5\n\nB5:\n%36 = phi float [ %0, %B1 ], [ %34, %B4 ]\n%37 = phi i32 [ 0, %B1 ], [ %5, %B4 ]\nbr label %B6\n\nB6:\n%38 = phi float [ %42, %B6 ], [ %36, %B5 ]\n%39 = phi i32 [ %43, %B6 ], [ %37, %B5 ]\n%40 = phi float [ %41, %B6 ], [ 1.000000e+00, %B5 ]\n%41 = fmul fast float %38, %0\n%42 = fmul fast float %41, %40\n%43 = add nuw nsw i32 %39, 1\n%44 = icmp eq i32 %43, %1\nbr i1 %44, label %B7, label %B6\n\nB7:\n%45 = phi float [ 1.000000e+00, %B ], [ %34, %B4 ], [ %42, %B6 ]\nret float %45\n}", "codegemma": "define dso_local nofpclass(nan inf) float @pow(float noundef nofpclass(nan inf) %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %1, 1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi float [ %6, %B1 ], [ %0, %B ]\n%4 = phi i32 [ %7, %B1 ], [ 1, %B ]\n%5 = fmul fast float %3, %0\n%6 = fmul fast float %5, %3\n%7 = add nuw nsw i32 %4, 1\n%8 = icmp eq i32 %7, %1\nbr i1 %8, label %B2, label %B1\n\nB2:\n%9 = phi float [ %0, %B ], [ %6, %B1 ]\nret float %9\n}"}, "define dso_local i32 @ic_transform_body_length(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = icmp ne ptr %4, null\nbr i1 %5, label %8, label %6\n\n6:\n%7 = call i32 @puts(ptr noundef @.str)\nstore i32 0, ptr %2, align 4\nbr label %12\n\n8:\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.ic_transform_body ptr %9, i32 0, i32 0\n%11 = call i32 @ic_pvector_length(ptr noundef %10)\nstore i32 %11, ptr %2, align 4\nbr label %12\n\n12:\n%13 = load i32, ptr %2, align 4\nret i32 %13\n}": {"base_truth": "define dso_local i32 @ic_transform_body_length(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B3\n\nB2:\n%3 = tail call i32 @ic_pvector_length(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%4 = phi i32 [ %3, %B2 ], [ 0, %B1 ]\nret i32 %4\n}", "codellama": "define dso_local i32 @ic_transform_body_length(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B3\n\nB2:\n%3 = tail call i32 @ic_pvector_length(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%4 = phi i32 [ %3, %B2 ], [ 0, %B1 ]\nret i32 %4\n}", "codegemma": "define dso_local i32 @ic_transform_body_length(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B3\n\nB2:\n%3 = tail call i32 @ic_pvector_length(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%4 = phi i32 [ %3, %B2 ], [ 0, %B1 ]\nret i32 %4\n}"}, "define dso_local void @solMD5_Init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\nstore i32 1732584193, ptr %4, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 1\nstore i32 -271733879, ptr %6, align 4\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 2\nstore i32 -1732584194, ptr %8, align 8\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %9, i32 0, i32 3\nstore i32 271733878, ptr %10, align 4\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %11, i32 0, i32 5\nstore i64 0, ptr %12, align 8\n%13 = load ptr, ptr %2, align 8\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %13, i32 0, i32 4\nstore i64 0, ptr %14, align 8\nret void\n}": {"base_truth": "define dso_local void @solMD5_Init(ptr nocapture noundef writeonly %0) {\nB:\nstore <4 x i32> <i32 1732584193, i32 -271733879, i32 -1732584194, i32 271733878>, ptr %0, align 8\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 4\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\nret void\n}", "codellama": "define dso_local void @solMD5_Init(ptr nocapture noundef writeonly %0) {\nB:\nstore <4 x i32> <i32 1732584193, i32 -271733879, i32 -1732584194, i32 271733878>, ptr %0, align 8\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 4\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\nret void\n}", "codegemma": "define dso_local void @solMD5_Init(ptr nocapture noundef writeonly %0) {\nB:\nstore i32 1732584193, ptr %0, align 8\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\nstore i32 -271733879, ptr %1, align 4\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\nstore i32 -1732584194, ptr %2, align 8\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\nstore i32 271733878, ptr %3, align 4\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 4\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %4, i8 0, i64 16, i1 false)\nret void\n}"}, "define dso_local i32 @millisecs() {\n%1 = load i64, ptr @millisecs.Time, align 8\n%2 = add nsw i64 %1, 1\nstore i64 %2, ptr @millisecs.Time, align 8\n%3 = trunc i64 %1 to i32\nret i32 %3\n}": {"base_truth": "define dso_local i32 @millisecs() {\nB:\n%0 = load i64, ptr @millisecs.Time, align 8\n%1 = add nsw i64 %0, 1\nstore i64 %1, ptr @millisecs.Time, align 8\n%2 = trunc i64 %0 to i32\nret i32 %2\n}", "codellama": "define dso_local i32 @millisecs() {\nB:\n%0 = load i64, ptr @millisecs.Time, align 8\n%1 = add nsw i64 %0, 1\nstore i64 %1, ptr @millisecs.Time, align 8\n%2 = trunc i64 %0 to i32\nret i32 %2\n}", "codegemma": "define dso_local i32 @millisecs() {\nB:\n%0 = load i64, ptr @millisecs.Time, align 8\n%1 = add nsw i64 %0, 1\nstore i64 %1, ptr @millisecs.Time, align 8\n%2 = trunc i64 %0 to i32\nret i32 %2\n}"}, "define internal i32 @netwinder_get_fan() {\n%1 = alloca i32, align 4\n%2 = load i32, ptr @system_rev, align 4\n%3 = and i32 %2, 61440\n%4 = icmp eq i32 %3, 16384\nbr i1 %4, label %5, label %7\n\n5:\n%6 = load i32, ptr @FAN_ALWAYS_ON, align 4\nstore i32 %6, ptr %1, align 4\nbr label %18\n\n7:\n%8 = call i32 (...) @nw_gpio_read()\n%9 = load i32, ptr @GPIO_FAN, align 4\n%10 = and i32 %8, %9\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %14\n\n12:\n%13 = load i32, ptr @FAN_ON, align 4\nbr label %16\n\n14:\n%15 = load i32, ptr @FAN_OFF, align 4\nbr label %16\n\n16:\n%17 = phi i32 [ %13, %12 ], [ %15, %14 ]\nstore i32 %17, ptr %1, align 4\nbr label %18\n\n18:\n%19 = load i32, ptr %1, align 4\nret i32 %19\n}": {"base_truth": "define internal i32 @netwinder_get_fan() {\nB:\n%0 = load i32, ptr @system_rev, align 4\n%1 = and i32 %0, 61440\n%2 = icmp eq i32 %1, 16384\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @FAN_ALWAYS_ON, align 4\nbr label %B3\n\nB2:\n%4 = tail call i32 (...) @nw_gpio_read()\n%5 = load i32, ptr @GPIO_FAN, align 4\n%6 = and i32 %5, %4\n%7 = icmp eq i32 %6, 0\n%8 = load i32, ptr @FAN_ON, align 4\n%9 = load i32, ptr @FAN_OFF, align 4\n%10 = select i1 %7, i32 %9, i32 %8\nbr label %B3\n\nB3:\n%11 = phi i32 [ %3, %B1 ], [ %10, %B2 ]\nret i32 %11\n}", "codellama": "define internal i32 @netwinder_get_fan() {\nB:\n%0 = load i32, ptr @system_rev, align 4\n%1 = and i32 %0, 61440\n%2 = icmp eq i32 %1, 16384\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 (...) @nw_gpio_read()\n%4 = load i32, ptr @GPIO_FAN, align 4\n%5 = and i32 %4, %3\n%6 = icmp eq i32 %5, 0\n%7 = load i32, ptr @FAN_ALWAYS_ON, align 4\n%8 = load i32, ptr @FAN_ON, align 4\n%9 = load i32, ptr @FAN_OFF, align 4\n%10 = select i1 %6, i32 %9, i32 %8\nbr label %B2\n\nB2:\n%11 = phi i32 [ %10, %B1 ], [ %7, %B ]\nret i32 %11\n}", "codegemma": "define internal i32 @netwinder_get_fan() {\nB:\n%0 = load i32, ptr @system_rev, align 4\n%1 = and i32 %0, 61440\n%2 = icmp eq i32 %1, 16384\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 (...) @nw_gpio_read()\n%4 = load i32, ptr @GPIO_FAN, align 4\n%5 = and i32 %4, %3\n%6 = icmp eq i32 %5, 0\n%7 = load i32, ptr @FAN_ON, align 4\n%8 = load i32, ptr @FAN_ALWAYS_ON, align 4\n%9 = load i32, ptr @FAN_OFF, align 4\n%10 = select i1 %6, i32 %9, i32 %7\nbr label %B2\n\nB2:\n%11 = phi i32 [ %10, %B1 ], [ @FAN_ALWAYS_ON, %B ]\nret i32 %11\n}"}, "define dso_local i32 @selinux_netlbl_inet_conn_request(ptr noundef %0, i64 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca %struct.netlbl_lsm_secattr, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%9 = load i64, ptr %5, align 8\n%10 = load i64, ptr @PF_INET, align 8\n%11 = icmp ne i64 %9, %10\nbr i1 %11, label %12, label %13\n\n12:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %28\n\n13:\n%14 = call i32 @netlbl_secattr_init(ptr noundef %7)\n%15 = load ptr, ptr %4, align 8\n%16 = getelementptr inbounds %struct.request_sock, ptr %15, i32 0, i32 0\n%17 = load i32, ptr %16, align 4\n%18 = call i32 @security_netlbl_sid_to_secattr(i32 noundef %17, ptr noundef %7)\nstore i32 %18, ptr %6, align 4\n%19 = load i32, ptr %6, align 4\n%20 = icmp ne i32 %19, 0\nbr i1 %20, label %21, label %22\n\n21:\nbr label %25\n\n22:\n%23 = load ptr, ptr %4, align 8\n%24 = call i32 @netlbl_req_setattr(ptr noundef %23, ptr noundef %7)\nstore i32 %24, ptr %6, align 4\nbr label %25\n\n25:\n%26 = call i32 @netlbl_secattr_destroy(ptr noundef %7)\n%27 = load i32, ptr %6, align 4\nstore i32 %27, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %28\n\n28:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%29 = load i32, ptr %3, align 4\nret i32 %29\n}": {"base_truth": "define dso_local i32 @selinux_netlbl_inet_conn_request(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = alloca %struct.netlbl_lsm_secattr, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @PF_INET, align 8\n%4 = icmp eq i64 %3, %1\nbr i1 %4, label %B1, label %B4\n\nB1:\n%5 = call i32 @netlbl_secattr_init(ptr noundef nonnull %2)\n%6 = load i32, ptr %0, align 4\n%7 = call i32 @security_netlbl_sid_to_secattr(i32 noundef %6, ptr noundef nonnull %2)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = call i32 @netlbl_req_setattr(ptr noundef nonnull %0, ptr noundef nonnull %2)\nbr label %B3\n\nB3:\n%10 = phi i32 [ %7, %B1 ], [ %9, %B2 ]\n%11 = call i32 @netlbl_secattr_destroy(ptr noundef nonnull %2)\nbr label %B4\n\nB4:\n%12 = phi i32 [ %10, %B3 ], [ 0, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %12\n}", "codellama": "define dso_local i32 @selinux_netlbl_inet_conn_request(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = alloca %struct.netlbl_lsm_secattr, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @PF_INET, align 8\n%4 = icmp eq i64 %3, %1\nbr i1 %4, label %B1, label %B4\n\nB1:\n%5 = call i32 @netlbl_secattr_init(ptr noundef nonnull %2)\n%6 = load i32, ptr %0, align 4\n%7 = call i32 @security_netlbl_sid_to_secattr(i32 noundef %6, ptr noundef nonnull %2)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = call i32 @netlbl_req_setattr(ptr noundef nonnull %0, ptr noundef nonnull %2)\nbr label %B3\n\nB3:\n%10 = phi i32 [ %7, %B1 ], [ %9, %B2 ]\n%11 = call i32 @netlbl_secattr_destroy(ptr noundef nonnull %2)\nbr label %B4\n\nB4:\n%12 = phi i32 [ %10, %B3 ], [ 0, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %12\n}", "codegemma": "define dso_local i32 @selinux_netlbl_inet_conn_request(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = alloca %struct.netlbl_lsm_secattr, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @PF_INET, align 8\n%4 = icmp eq i64 %3, %1\nbr i1 %4, label %B1, label %B4\n\nB1:\n%5 = call i32 @netlbl_secattr_init(ptr noundef nonnull %2)\n%6 = load i32, ptr %0, align 4\n%7 = call i32 @security_netlbl_sid_to_secattr(i32 noundef %6, ptr noundef nonnull %2)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = call i32 @netlbl_req_setattr(ptr noundef nonnull %0, ptr noundef nonnull %2)\nbr label %B3\n\nB3:\n%10 = call i32 @netlbl_secattr_destroy(ptr noundef nonnull %2)\nbr label %B4\n\nB4:\n%11 = phi i32 [ %9, %B2 ], [ %7, %B3 ], [ 0, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %11\n}"}, "define dso_local void @CNFGClearFrame() {\n%1 = call i32 (...) @CNFGFlushRender()\n%2 = load i32, ptr @CNFGBGColor, align 4\n%3 = call i32 @CNFGClearFrameInternal(i32 noundef %2)\nret void\n}": {"base_truth": "define dso_local void @CNFGClearFrame() {\nB:\n%0 = tail call i32 (...) @CNFGFlushRender()\n%1 = load i32, ptr @CNFGBGColor, align 4\n%2 = tail call i32 @CNFGClearFrameInternal(i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @CNFGClearFrame() {\nB:\n%0 = tail call i32 (...) @CNFGFlushRender()\n%1 = load i32, ptr @CNFGBGColor, align 4\n%2 = tail call i32 @CNFGClearFrameInternal(i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @CNFGClearFrame() {\nB:\n%0 = tail call i32 (...) @CNFGFlushRender()\n%1 = load i32, ptr @CNFGBGColor, align 4\n%2 = tail call i32 @CNFGClearFrameInternal(i32 noundef %1)\nret void\n}"}, "define dso_local void @bfa_itnim_offline(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @offlines, align 4\n%5 = call i32 @bfa_stats(ptr noundef %3, i32 noundef %4)\n%6 = load ptr, ptr %2, align 8\n%7 = load i32, ptr @BFA_ITNIM_SM_OFFLINE, align 4\n%8 = call i32 @bfa_sm_send_event(ptr noundef %6, i32 noundef %7)\nret void\n}": {"base_truth": "define dso_local void @bfa_itnim_offline(ptr noundef %0) {\nB:\n%1 = load i32, ptr @offlines, align 4\n%2 = tail call i32 @bfa_stats(ptr noundef %0, i32 noundef %1)\n%3 = load i32, ptr @BFA_ITNIM_SM_OFFLINE, align 4\n%4 = tail call i32 @bfa_sm_send_event(ptr noundef %0, i32 noundef %3)\nret void\n}", "codellama": "define dso_local void @bfa_itnim_offline(ptr noundef %0) {\nB:\n%1 = load i32, ptr @offlines, align 4\n%2 = tail call i32 @bfa_stats(ptr noundef %0, i32 noundef %1)\n%3 = load i32, ptr @BFA_ITNIM_SM_OFFLINE, align 4\n%4 = tail call i32 @bfa_sm_send_event(ptr noundef %0, i32 noundef %3)\nret void\n}", "codegemma": "define dso_local void @bfa_itnim_offline(ptr noundef %0) {\nB:\n%1 = load i32, ptr @offlines, align 4\n%2 = tail call i32 @bfa_stats(ptr noundef %0, i32 noundef %1)\n%3 = load i32, ptr @BFA_ITNIM_SM_OFFLINE, align 4\n%4 = tail call i32 @bfa_sm_send_event(ptr noundef %0, i32 noundef %3)\nret void\n}"}, "define dso_local ptr @DIBackingStoreGetRsrcForkLength() {\n%1 = load i64, ptr @verbose, align 8\n%2 = icmp ne i64 %1, 0\nbr i1 %2, label %3, label %5\n\n3:\n%4 = call i32 @puts(ptr noundef @.str)\nbr label %5\n\n5:\nret ptr null\n}": {"base_truth": "define dso_local noalias ptr @DIBackingStoreGetRsrcForkLength() {\nB:\n%0 = load i64, ptr @verbose, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B2\n\nB2:\nret ptr null\n}", "codellama": "define dso_local noalias ptr @DIBackingStoreGetRsrcForkLength() {\nB:\n%0 = load i64, ptr @verbose, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B2\n\nB2:\nret ptr null\n}", "codegemma": "define dso_local noalias ptr @DIBackingStoreGetRsrcForkLength() {\nB:\n%0 = load i64, ptr @verbose, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B2\n\nB2:\nret ptr null\n}"}, "define dso_local i32 @taos_affected_rows(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load ptr, ptr %3, align 8\nstore ptr %6, ptr %4, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %15, label %9\n\n9:\n%10 = load ptr, ptr %4, align 8\n%11 = getelementptr inbounds %struct.TYPE_6__, ptr %10, i32 0, i32 1\n%12 = load ptr, ptr %11, align 8\n%13 = load ptr, ptr %4, align 8\n%14 = icmp ne ptr %12, %13\nbr i1 %14, label %15, label %16\n\n15:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %23\n\n16:\n%17 = load ptr, ptr %4, align 8\n%18 = getelementptr inbounds %struct.TYPE_6__, ptr %17, i32 0, i32 0\n%19 = load ptr, ptr %18, align 8\n%20 = getelementptr inbounds %struct.TYPE_5__, ptr %19, i32 0, i32 0\n%21 = getelementptr inbounds %struct.TYPE_4__, ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\nstore i32 %22, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %23\n\n23:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%24 = load i32, ptr %2, align 4\nret i32 %24\n}": {"base_truth": "define dso_local i32 @taos_affected_rows(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, %0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = load ptr, ptr %0, align 8\n%6 = load i32, ptr %5, align 4\nbr label %B3\n\nB3:\n%7 = phi i32 [ %6, %B2 ], [ 0, %B1 ], [ 0, %B ]\nret i32 %7\n}", "codellama": "define dso_local i32 @taos_affected_rows(ptr noundef readonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, %0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = load ptr, ptr %0, align 8\n%6 = load i32, ptr %5, align 4\nbr label %B3\n\nB3:\n%7 = phi i32 [ %6, %B2 ], [ 0, %B1 ], [ 0, %B ]\nret i32 %7\n}", "codegemma": "define dso_local i32 @taos_affected_rows(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, %0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = load ptr, ptr %0, align 8\n%6 = load i32, ptr %5, align 4\nbr label %B3\n\nB3:\n%7 = phi i32 [ %6, %B2 ], [ 0, %B1 ], [ 0, %B ]\nret i32 %7\n}"}, "define dso_local i32 @e1000_setup_led_generic(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = call i32 @DEBUGFUNC(ptr noundef @.str)\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.e1000_hw, ptr %7, i32 0, i32 0\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %8, i32 0, i32 2\n%10 = getelementptr inbounds %struct.TYPE_4__, ptr %9, i32 0, i32 0\n%11 = load i64, ptr %10, align 8\n%12 = inttoptr i64 %11 to ptr\n%13 = icmp ne ptr %12, @e1000_setup_led_generic\nbr i1 %13, label %14, label %17\n\n14:\n%15 = load i32, ptr @E1000_ERR_CONFIG, align 4\n%16 = sub nsw i32 0, %15\nstore i32 %16, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %67\n\n17:\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.e1000_hw, ptr %18, i32 0, i32 1\n%20 = getelementptr inbounds %struct.TYPE_5__, ptr %19, i32 0, i32 0\n%21 = load i64, ptr %20, align 8\n%22 = load i64, ptr @e1000_media_type_fiber, align 8\n%23 = icmp eq i64 %21, %22\nbr i1 %23, label %24, label %49\n\n24:\n%25 = load ptr, ptr %3, align 8\n%26 = load i32, ptr @E1000_LEDCTL, align 4\n%27 = call i32 @E1000_READ_REG(ptr noundef %25, i32 noundef %26)\nstore i32 %27, ptr %4, align 4\n%28 = load i32, ptr %4, align 4\n%29 = load ptr, ptr %3, align 8\n%30 = getelementptr inbounds %struct.e1000_hw, ptr %29, i32 0, i32 0\n%31 = getelementptr inbounds %struct.TYPE_6__, ptr %30, i32 0, i32 0\nstore i32 %28, ptr %31, align 8\n%32 = load i32, ptr @E1000_LEDCTL_LED0_IVRT, align 4\n%33 = load i32, ptr @E1000_LEDCTL_LED0_BLINK, align 4\n%34 = or i32 %32, %33\n%35 = load i32, ptr @E1000_LEDCTL_LED0_MODE_MASK, align 4\n%36 = or i32 %34, %35\n%37 = xor i32 %36, -1\n%38 = load i32, ptr %4, align 4\n%39 = and i32 %38, %37\nstore i32 %39, ptr %4, align 4\n%40 = load i32, ptr @E1000_LEDCTL_MODE_LED_OFF, align 4\n%41 = load i32, ptr @E1000_LEDCTL_LED0_MODE_SHIFT, align 4\n%42 = shl i32 %40, %41\n%43 = load i32, ptr %4, align 4\n%44 = or i32 %43, %42\nstore i32 %44, ptr %4, align 4\n%45 = load ptr, ptr %3, align 8\n%46 = load i32, ptr @E1000_LEDCTL, align 4\n%47 = load i32, ptr %4, align 4\n%48 = call i32 @E1000_WRITE_REG(ptr noundef %45, i32 noundef %46, i32 noundef %47)\nbr label %65\n\n49:\n%50 = load ptr, ptr %3, align 8\n%51 = getelementptr inbounds %struct.e1000_hw, ptr %50, i32 0, i32 1\n%52 = getelementptr inbounds %struct.TYPE_5__, ptr %51, i32 0, i32 0\n%53 = load i64, ptr %52, align 8\n%54 = load i64, ptr @e1000_media_type_copper, align 8\n%55 = icmp eq i64 %53, %54\nbr i1 %55, label %56, label %64\n\n56:\n%57 = load ptr, ptr %3, align 8\n%58 = load i32, ptr @E1000_LEDCTL, align 4\n%59 = load ptr, ptr %3, align 8\n%60 = getelementptr inbounds %struct.e1000_hw, ptr %59, i32 0, i32 0\n%61 = getelementptr inbounds %struct.TYPE_6__, ptr %60, i32 0, i32 1\n%62 = load i32, ptr %61, align 4\n%63 = call i32 @E1000_WRITE_REG(ptr noundef %57, i32 noundef %58, i32 noundef %62)\nbr label %64\n\n64:\nbr label %65\n\n65:\n%66 = load i32, ptr @E1000_SUCCESS, align 4\nstore i32 %66, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %67\n\n67:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%68 = load i32, ptr %2, align 4\nret i32 %68\n}": {"base_truth": "define dso_local i32 @e1000_setup_led_generic(ptr noundef %0) {\nB:\n%1 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%2 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 2\n%3 = load i64, ptr %2, align 8\n%4 = inttoptr i64 %3 to ptr\n%5 = icmp eq ptr %4, @e1000_setup_led_generic\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = load i32, ptr @E1000_ERR_CONFIG, align 4\n%7 = sub nsw i32 0, %6\nbr label %B8\n\nB2:\n%8 = getelementptr inbounds %struct.e1000_hw, ptr %0, i64 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = load i64, ptr @e1000_media_type_fiber, align 8\n%11 = icmp eq i64 %9, %10\nbr i1 %11, label %B3, label %B4\n\nB3:\n%12 = load i32, ptr @E1000_LEDCTL, align 4\n%13 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %12)\nstore i32 %13, ptr %0, align 8\n%14 = load i32, ptr @E1000_LEDCTL_LED0_IVRT, align 4\n%15 = load i32, ptr @E1000_LEDCTL_LED0_BLINK, align 4\n%16 = or i32 %15, %14\n%17 = load i32, ptr @E1000_LEDCTL_LED0_MODE_MASK, align 4\n%18 = or i32 %16, %17\n%19 = xor i32 %18, -1\n%20 = and i32 %13, %19\n%21 = load i32, ptr @E1000_LEDCTL_MODE_LED_OFF, align 4\n%22 = load i32, ptr @E1000_LEDCTL_LED0_MODE_SHIFT, align 4\n%23 = shl i32 %21, %22\n%24 = or i32 %23, %20\nbr label %B6\n\nB4:\n%25 = load i64, ptr @e1000_media_type_copper, align 8\n%26 = icmp eq i64 %9, %25\nbr i1 %26, label %B5, label %B7\n\nB5:\n%27 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%28 = load i32, ptr %27, align 4\nbr label %B6\n\nB6:\n%29 = phi i32 [ %28, %B5 ], [ %24, %B3 ]\n%30 = load i32, ptr @E1000_LEDCTL, align 4\n%31 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %30, i32 noundef %29)\nbr label %B7\n\nB7:\n%32 = load i32, ptr @E1000_SUCCESS, align 4\nbr label %B8\n\nB8:\n%33 = phi i32 [ %7, %B1 ], [ %32, %B7 ]\nret i32 %33\n}", "codellama": "define dso_local i32 @e1000_setup_led_generic(ptr noundef %0) {\nB:\n%1 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%2 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 2\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @E1000_ERR_CONFIG, align 4\n%6 = sub nsw i32 0, %5\nbr label %B5\n\nB2:\n%7 = getelementptr inbounds %struct.e1000_hw, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = load i64, ptr @e1000_media_type_fiber, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %B3, label %B4\n\nB3:\n%11 = load i32, ptr @E1000_LEDCTL, align 4\n%12 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %11)\nstore i32 %12, ptr %0, align 8\n%13 = load i32, ptr @E1000_LEDCTL_LED0_IVRT, align 4\n%14 = load i32, ptr @E1000_LEDCTL_LED0_BLINK, align 4\n%15 = or i32 %14, %13\n%16 = load i32, ptr @E1000_LEDCTL_LED0_MODE_MASK, align 4\n%17 = or i32 %15, %16\n%18 = xor i32 %17, -1\n%19 = and i32 %12, %18\n%20 = load i32, ptr @E1000_LEDCTL_MODE_LED_OFF, align 4\n%21 = load i32, ptr @E1000_LEDCTL_LED0_MODE_SHIFT, align 4\n%22 = shl i32 %20, %21\n%23 = or i32 %22, %19\n%24 = load i32, ptr @E1000_LEDCTL, align 4\n%25 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %24, i3</s>", "codegemma": "define dso_local i32 @e1000_setup_led_generic(ptr noundef %0) {\nB:\n%1 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%2 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 2\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @E1000_ERR_CONFIG, align 4\n%6 = sub nsw i32 0, %5\nbr label %B6\n\nB2:\n%7 = getelementptr inbounds %struct.e1000_hw, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = load i64, ptr @e1000_media_type_fiber, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %B3, label %B4\n\nB3:\n%11 = load i32, ptr @E1000_LEDCTL, align 4\n%12 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %11)\n%13 = load i32, ptr @E1000_LEDCTL_LED0_IVRT, align 4\n%14 = load i32, ptr @E1000_LEDCTL_LED0_BLINK, align 4\n%15 = or i32 %14, %13\n%16 = load i32, ptr @E1000_LEDCTL_LED0_MODE_MASK, align 4\n%17 = or i32 %15, %16\n%18 = xor i32 %17, -1\n%19 = and i32 %12, %18\n%20 = load i32, ptr @E1000_LEDCTL_MODE_LED_OFF, align 4\n%21 = load i32, ptr @E1000_LEDCTL_LED0_MODE_SHIFT, align 4\n%22 = shl i32 %20, %21\n%23 = or i32 %22, %19\n%24 = load i32, ptr @E1000_LEDCTL, align 4\n%25 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %24, i32 noundef %23)\nbr label %B6\n\nB4:\n%26 = load i64, ptr @e1000_media_type_copper, align 8\n%27 = icmp eq i64 %8, %26\nbr i1 %27, label %B5<eos>"}, "define internal i32 @tmpfs_sync(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr @MNT_SUSPEND, align 4\n%7 = icmp eq i32 %5, %6\nbr i1 %7, label %8, label %20\n\n8:\n%9 = load ptr, ptr %3, align 8\n%10 = call i32 @MNT_ILOCK(ptr noundef %9)\n%11 = load i32, ptr @MNTK_SUSPEND2, align 4\n%12 = load i32, ptr @MNTK_SUSPENDED, align 4\n%13 = or i32 %11, %12\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.mount ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 4\n%17 = or i32 %16, %13\nstore i32 %17, ptr %15, align 4\n%18 = load ptr, ptr %3, align 8\n%19 = call i32 @MNT_IUNLOCK(ptr noundef %18)\nbr label %28\n\n20:\n%21 = load i32, ptr %4, align 4\n%22 = load i32, ptr @MNT_LAZY, align 4\n%23 = icmp eq i32 %21, %22\nbr i1 %23, label %24, label %27\n\n24:\n%25 = load ptr, ptr %3, align 8\n%26 = call i32 @tmpfs_update_mtime(ptr noundef %25, i32 noundef 1)\nbr label %27\n\n27:\nbr label %28\n\n28:\nret i32 0\n}": {"base_truth": "define internal i32 @tmpfs_sync(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MNT_SUSPEND, align 4\n%3 = icmp eq i32 %2, %1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @MNT_ILOCK(ptr noundef %0)\n%5 = load i32, ptr @MNTK_SUSPEND2, align 4\n%6 = load i32, ptr @MNTK_SUSPENDED, align 4\n%7 = or i32 %6, %5\n%8 = load i32, ptr %0, align 4\n%9 = or i32 %7, %8\nstore i32 %9, ptr %0, align 4\n%10 = tail call i32 @MNT_IUNLOCK(ptr noundef nonnull %0)\nbr label %B4\n\nB2:\n%11 = load i32, ptr @MNT_LAZY, align 4\n%12 = icmp eq i32 %11, %1\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = tail call i32 @tmpfs_update_mtime(ptr noundef %0, i32 noundef 1)\nbr label %B4\n\nB4:\nret i32 0\n}", "codellama": "define internal i32 @tmpfs_sync(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MNT_SUSPEND, align 4\n%3 = icmp eq i32 %2, %1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @MNT_ILOCK(ptr noundef %0)\n%5 = load i32, ptr @MNTK_SUSPEND2, align 4\n%6 = load i32, ptr @MNTK_SUSPENDED, align 4\n%7 = or i32 %6, %5\n%8 = load i32, ptr %0, align 4\n%9 = or i32 %7, %8\nstore i32 %9, ptr %0, align 4\n%10 = tail call i32 @MNT_IUNLOCK(ptr noundef nonnull %0)\nbr label %B4\n\nB2:\n%11 = load i32, ptr @MNT_LAZY, align 4\n%12 = icmp eq i32 %11, %1\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = tail call i32 @tmpfs_update_mtime(ptr noundef %0, i32 noundef 1)\nbr label %B4\n\nB4:\nret i32 0\n}", "codegemma": "define internal i32 @tmpfs_sync(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MNT_SUSPEND, align 4\n%3 = icmp eq i32 %2, %1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @MNT_ILOCK(ptr noundef %0)\n%5 = load i32, ptr @MNTK_SUSPEND2, align 4\n%6 = load i32, ptr @MNTK_SUSPENDED, align 4\n%7 = or i32 %6, %5\n%8 = load i32, ptr %0, align 4\n%9 = or i32 %7, %8\nstore i32 %9, ptr %0, align 4\n%10 = tail call i32 @MNT_IUNLOCK(ptr noundef nonnull %0)\nbr label %B4\n\nB2:\n%11 = load i32, ptr @MNT_LAZY, align 4\n%12 = icmp eq i32 %11, %1\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = tail call i32 @tmpfs_update_mtime(ptr noundef nonnull %0, i32 noundef 1)\nbr label %B4\n\nB4:\nret i32 0\n}"}, "define internal i64 @xen_feature_show(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca %struct.xen_feature_info align 4\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%7 = load i32, ptr %3, align 4\n%8 = getelementptr inbounds %struct.xen_feature_info ptr %6, i32 0, i32 0\nstore i32 %7, ptr %8, align 4\n%9 = load i32, ptr @XENVER_get_features, align 4\n%10 = call i64 @HYPERVISOR_xen_version(i32 noundef %9, ptr noundef %6)\nstore i64 %10, ptr %5, align 8\n%11 = load i64, ptr %5, align 8\n%12 = icmp ne i64 %11, 0\nbr i1 %12, label %18, label %13\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = getelementptr inbounds %struct.xen_feature_info ptr %6, i32 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = call i64 @sprintf(ptr noundef %14, ptr noundef @.str, i32 noundef %16)\nstore i64 %17, ptr %5, align 8\nbr label %18\n\n18:\n%19 = load i64, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i64 %19\n}": {"base_truth": "define internal i64 @xen_feature_show(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = alloca %struct.xen_feature_info, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr @XENVER_get_features, align 4\n%4 = call i64 @HYPERVISOR_xen_version(i32 noundef %3, ptr noundef nonnull %2)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = getelementptr inbounds %struct.xen_feature_info, ptr %2, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\n%8 = call i64 @sprintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = phi i64 [ %4, %B ], [ %8, %B1 ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret i64 %9\n}", "codellama": "define internal i64 @xen_feature_show(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = alloca %struct.xen_feature_info, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr @XENVER_get_features, align 4\n%4 = call i64 @HYPERVISOR_xen_version(i32 noundef %3, ptr noundef nonnull %2)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = getelementptr inbounds %struct.xen_feature_info, ptr %2, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\n%8 = call i64 @sprintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = phi i64 [ %4, %B ], [ %8, %B1 ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret i64 %9\n}", "codegemma": "define internal i64 @xen_feature_show(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = alloca %struct.xen_feature_info, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr @XENVER_get_features, align 4\n%4 = call i64 @HYPERVISOR_xen_version(i32 noundef %3, ptr noundef nonnull %2)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = getelementptr inbounds %struct.xen_feature_info, ptr %2, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\n%8 = call i64 @sprintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = phi i64 [ %4, %B ], [ %8, %B1 ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret i64 %9\n}"}, "define dso_local i64 @MP4CreateTrackReader(i64 noundef %0, ptr noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%10 = load i64, ptr @MP4NoErr, align 8\nstore i64 %10, ptr %5, align 8\n%11 = load i64, ptr %3, align 8\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %16, label %13\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = icmp eq ptr %14, null\nbr i1 %15, label %16, label %18\n\n16:\n%17 = load i64, ptr @MP4BadParamErr, align 8\nstore i64 %17, ptr %5, align 8\nbr label %57\n\n18:\n%19 = load i64, ptr %3, align 8\n%20 = call i64 @MP4GetTrackMovie(i64 noundef %19, ptr noundef %6)\nstore i64 %20, ptr %5, align 8\n%21 = load i64, ptr %5, align 8\n%22 = icmp ne i64 %21, 0\nbr i1 %22, label %23, label %24\n\n23:\nbr label %57\n\n24:\n%25 = load i64, ptr %3, align 8\n%26 = call i64 @MP4GetTrackMedia(i64 noundef %25, ptr noundef %7)\nstore i64 %26, ptr %5, align 8\n%27 = load i64, ptr %5, align 8\n%28 = icmp ne i64 %27, 0\nbr i1 %28, label %29, label %30\n\n29:\nbr label %57\n\n30:\n%31 = load i32, ptr %7, align 4\n%32 = call i64 @MP4GetMediaHandlerDescription(i32 noundef %31, ptr noundef %8, i32 noundef 0)\nstore i64 %32, ptr %5, align 8\n%33 = load i64, ptr %5, align 8\n%34 = icmp ne i64 %33, 0\nbr i1 %34, label %35, label %36\n\n35:\nbr label %57\n\n36:\n%37 = load i32, ptr %8, align 4\nswitch i32 %37, label %46 [\ni32 128, label %38\n]\n\n38:\n%39 = load i32, ptr %6, align 4\n%40 = load i64, ptr %3, align 8\n%41 = call i64 @MP4CreateODTrackReader(i32 noundef %39, i64 noundef %40, ptr noundef %9)\nstore i64 %41, ptr %5, align 8\n%42 = load i64, ptr %5, align 8\n%43 = icmp ne i64 %42, 0\nbr i1 %43, label %44, label %45\n\n44:\nbr label %57\n\n45:\nbr label %54\n\n46:\n%47 = load i32, ptr %6, align 4\n%48 = load i64, ptr %3, align 8\n%49 = call i64 @MP4CreateOrdinaryTrackReader(i32 noundef %47, i64 noundef %48, ptr noundef %9)\nstore i64 %49, ptr %5, align 8\n%50 = load i64, ptr %5, align 8\n%51 = icmp ne i64 %50, 0\nbr i1 %51, label %52, label %53\n\n52:\nbr label %57\n\n53:\nbr label %54\n\n54:\n%55 = load i64, ptr %9, align 8\n%56 = load ptr, ptr %4, align 8\nstore i64 %55, ptr %56, align 8\nbr label %57\n\n57:\n%58 = load i64, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i64 %58\n}": {"base_truth": "define dso_local i64 @MP4CreateTrackReader(i64 noundef %0, ptr noundef writeonly %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)\n%6 = icmp eq i64 %0, 0\n%7 = icmp eq ptr %1, null\n%8 = or i1 %6, %7\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = load i64, ptr @MP4BadParamErr, align 8\nbr label %B9\n\nB2:\n%10 = call i64 @MP4GetTrackMovie(i64 noundef %0, ptr noundef nonnull %2)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B3, label %B9\n\nB3:\n%12 = call i64 @MP4GetTrackMedia(i64 noundef %0, ptr noundef nonnull %3)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B4, label %B9\n\nB4:\n%14 = load i32, ptr %3, align 4\n%15 = call i64 @MP4GetMediaHandlerDescription(i32 noundef %14, ptr noundef nonnull %4, i32 noundef 0)\n%16 = icmp eq i64 %15, 0\nbr i1 %16, label %B5, label %B9\n\nB5:\n%17 = load i32, ptr %4, align 4\n%18 = icmp eq i32 %17, 128\n%19 = load i32, ptr %2, align 4\nbr i1 %18, label %B6, label %B7\n\nB6:\n%20 = call i64 @MP4CreateODTrackReader(i32 noundef %19, i64 noundef %0, ptr noundef nonnull %5)\n%21 = icmp eq i64 %20, 0\nbr i1 %21, label %B8, label %B9\n\nB7:\n%22 = call i64 @MP4CreateOrdinaryTrackReader(i32 noundef %19, i64 noundef %0, ptr noundef nonnull %5)\n%23 = icmp eq i64 %22, 0\nbr i1 %23, label %B8, label %B9\n\nB8:\n%24 = load i64, ptr %5, align 8\nstore i64 %24, ptr %1, align 8\nbr label %B9\n\nB9:\n%25 = phi i64 [ %9, %B1 ], [ %10, %B2 ], [ %12, %B3 ], [ %15, %B4 ], [ %20, %B6 ], [ 0, %B8 ], [ %22, %B7 ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i64 %25\n}", "codellama": "define dso_local i64 @MP4CreateTrackReader(i64 noundef %0, ptr noundef writeonly %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)\n%6 = icmp eq i64 %0, 0\n%7 = icmp eq ptr %1, null\n%8 = or i1 %6, %7\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = load i64, ptr @MP4BadParamErr, align 8\nbr label %B10\n\nB2:\n%10 = call i64 @MP4GetTrackMovie(i64 noundef %0, ptr noundef nonnull %2)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B3, label %B10\n\nB3:\n%12 = call i64 @MP4GetTrackMedia(i64 noundef %0, ptr noundef nonnull %3)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B4, label %B10\n\nB4:\n%14 = load i32, ptr %3, align 4\n%15 = call i64 @MP4GetMediaHandlerDescription(i32 noundef %14, ptr noundef nonnull %4, i32 noundef 0)\n%16 = icmp eq i64 %15, 0\nbr i1 %16, label %B5, label %B10\n\nB5:\n%17 = load i32, ptr %4, align 4\n%18 = icmp eq i32 %17, 128\nbr i1 %18, label %B6, label %B7\n\nB6:\n%19 = load i32, ptr %2, align 4\n%20 = call i64 @MP4CreateODTrackReader(i32 noundef %19, i64 noundef %0, ptr noundef nonnull %5)\n%21 = icmp eq i64 %20, 0\nbr i1 %21, label %B9, label %B10\n\nB7:\n%22 = load i32, ptr %2, align 4\n%23 = call i64 @MP4CreateOrdinaryTrackReader(i32 noundef %22, i64 noundef %0, ptr noundef nonnull %5)\n%24 = icmp eq i64 %23, 0\nbr i1 %24, label %B8, label %B10\n\nB8:\n%25 = load i64, ptr %5, align 8\nstore i64 %25, ptr %1, align 8\nbr label %B9\n\nB9:\n%26 = phi i64 [ %20, %B6 ], [ %23, %B8 ], [ %15, %B7 ]\nbr label %B10\n\nB10:\n%27 = phi i64 [ %9, %B1 ], [ %10, %B2 ], [ %12, %B3 ], [ %15, %B4 ], [ %26, %B9 ], [ 0, %B7 ], [ 0, %B8 ], [</s>", "codegemma": "define dso_local i64 @MP4CreateTrackReader(i64 noundef %0, ptr noundef writeonly %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)\n%5 = load i64, ptr @MP4NoErr, align 8\n%6 = icmp eq i64 %0, 0\n%7 = icmp eq ptr %1, null\n%8 = or i1 %6, %7\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = load i64, ptr @MP4BadParamErr, align 8\nbr label %B10\n\nB2:\n%10 = call i64 @MP4GetTrackMovie(i64 noundef %0, ptr noundef nonnull %2)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B3, label %B10\n\nB3:\n%12 = call i64 @MP4GetTrackMedia(i64 noundef %0, ptr noundef nonnull %3)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B4, label %B10\n\nB4:\n%14 = load i32, ptr %3, align 4\n%15 = call i64 @MP4GetMediaHandlerDescription(i32 noundef %14, ptr noundef nonnull %3, i32 noundef 0)\n%16 = icmp eq i64 %15, 0\nbr i1 %16, label %B5, label %B10\n\nB5:\n%17 = load i32, ptr %2, align 4\n%18 = icmp eq i32 %17, 128\nbr i1 %18, label %B6, label %B7\n\nB6:\n%19 = call i64 @MP4CreateODTrackReader(i32 noundef %17, i64 noundef %0, ptr noundef nonnull %4)\n%20 = icmp eq i64 %19, 0\nbr i1 %20, label %B8, label %B10\n\nB7:\n%21 = call i64 @MP4CreateOrdinaryTrackReader(i32 noundef %17, i64 noundef %0, ptr noundef nonnull %4)\n%22 = icmp eq i64 %21, 0\nbr i1 %22, label %B8, label %B10\n\nB8:\n%23 = load i64, ptr %4, align 8\nstore i64 %23, ptr %1, align 8\nbr label %B10\n\nB9:\n%24 = load i64, ptr @MP4NoErr, align 8\nbr label %B10\n\nB10:\n%25 = phi i64 [ %9, %B1 ], [ %10, %B2 ], [ %12, %B3 ], [ %15, %B4 ], [ %19, %B6 ], [ %21, %B7 ], [ %24, %B9 ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i64 %25\n}"}, "define internal void @pxamci_stop_clock(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.pxamci_host ptr %5, i32 0, i32 1\n%7 = load i64, ptr %6, align 8\n%8 = load i64, ptr @MMC_STAT, align 8\n%9 = add nsw i64 %7, %8\n%10 = call i32 @readl(i64 noundef %9)\n%11 = load i32, ptr @STAT_CLK_EN, align 4\n%12 = and i32 %10, %11\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %14, label %52\n\n14:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore i64 10000, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%15 = load i32, ptr @STOP_CLOCK, align 4\n%16 = load ptr, ptr %2, align 8\n%17 = getelementptr inbounds %struct.pxamci_host ptr %16, i32 0, i32 1\n%18 = load i64, ptr %17, align 8\n%19 = load i64, ptr @MMC_STRPCL, align 8\n%20 = add nsw i64 %18, %19\n%21 = call i32 @writel(i32 noundef %15, i64 noundef %20)\nbr label %22\n\n22:\n%23 = load ptr, ptr %2, align 8\n%24 = getelementptr inbounds %struct.pxamci_host ptr %23, i32 0, i32 1\n%25 = load i64, ptr %24, align 8\n%26 = load i64, ptr @MMC_STAT, align 8\n%27 = add nsw i64 %25, %26\n%28 = call i32 @readl(i64 noundef %27)\nstore i32 %28, ptr %4, align 4\n%29 = load i32, ptr %4, align 4\n%30 = load i32, ptr @STAT_CLK_EN, align 4\n%31 = and i32 %29, %30\n%32 = icmp ne i32 %31, 0\nbr i1 %32, label %34, label %33\n\n33:\nbr label %40\n\n34:\n%35 = call i32 @udelay(i32 noundef 1)\nbr label %36\n\n36:\n%37 = load i64, ptr %3, align 8\n%38 = add i64 %37, -1\nstore i64 %38, ptr %3, align 8\n%39 = icmp ne i64 %37, 0\nbr i1 %39, label %22, label %40\n\n40:\n%41 = load i32, ptr %4, align 4\n%42 = load i32, ptr @STAT_CLK_EN, align 4\n%43 = and i32 %41, %42\n%44 = icmp ne i32 %43, 0\nbr i1 %44, label %45, label %51\n\n45:\n%46 = load ptr, ptr %2, align 8\n%47 = getelementptr inbounds %struct.pxamci_host ptr %46, i32 0, i32 0\n%48 = load i32, ptr %47, align 8\n%49 = call i32 @mmc_dev(i32 noundef %48)\n%50 = call i32 @dev_err(i32 noundef %49, ptr noundef @.str)\nbr label %51\n\n51:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nbr label %52\n\n52:\nret void\n}": {"base_truth": "define internal void @pxamci_stop_clock(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.pxamci_host, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = load i64, ptr @MMC_STAT, align 8\n%4 = add nsw i64 %3, %2\n%5 = tail call i32 @readl(i64 noundef %4)\n%6 = load i32, ptr @STAT_CLK_EN, align 4\n%7 = and i32 %6, %5\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B6, label %B1\n\nB1:\n%9 = load i32, ptr @STOP_CLOCK, align 4\n%10 = load i64, ptr %1, align 8\n%11 = load i64, ptr @MMC_STRPCL, align 8\n%12 = add nsw i64 %11, %10\n%13 = tail call i32 @writel(i32 noundef %9, i64 noundef %12)\nbr label %B2\n\nB2:\n%14 = phi i64 [ 10000, %B1 ], [ %23, %B3 ]\n%15 = load i64, ptr %1, align 8\n%16 = load i64, ptr @MMC_STAT, align 8\n%17 = add nsw i64 %16, %15\n%18 = tail call i32 @readl(i64 noundef %17)\n%19 = load i32, ptr @STAT_CLK_EN, align 4\n%20 = and i32 %19, %18\n%21 = icmp eq i32 %20, 0\nbr i1 %21, label %B6, label %B3\n\nB3:\n%22 = tail call i32 @udelay(i32 noundef 1)\n%23 = add nsw i64 %14, -1\n%24 = icmp eq i64 %14, 0\nbr i1 %24, label %B4, label %B2\n\nB4:\n%25 = load i32, ptr @STAT_CLK_EN, align 4\n%26 = and i32 %25, %18\n%27 = icmp eq i32 %26, 0\nbr i1 %27, label %B6, label %B5\n\nB5:\n%28 = load i32, ptr %0, align 8\n%29 = tail call i32 @mmc_dev(i32 noundef %28)\n%30 = tail call i32 @dev_err(i32 noundef %29, ptr noundef nonnull @.str)\nbr label %B6\n\nB6:\nret void\n}", "codellama": "define internal void @pxamci_stop_clock(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.pxamci_host, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = load i64, ptr @MMC_STAT, align 8\n%4 = add nsw i64 %3, %2\n%5 = tail call i32 @readl(i64 noundef %4)\n%6 = load i32, ptr @STAT_CLK_EN, align 4\n%7 = and i32 %6, %5\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B6, label %B1\n\nB1:\n%9 = load i32, ptr @STOP_CLOCK, align 4\n%10 = load i64, ptr %1, align 8\n%11 = load i64, ptr @MMC_STRPCL, align 8\n%12 = add nsw i64 %11, %10\n%13 = tail call i32 @writel(i32 noundef %9, i64 noundef %12)\n%14 = load i64, ptr %1, align 8\n%15 = load i64, ptr @MMC_STAT, align 8\n%16 = add nsw i64 %15, %14\n%17 = tail call i32 @readl(i64 noundef %16)\n%18 = load i32, ptr @STAT_CLK_EN, align 4\n%19 = and i32 %18, %17\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B5, label %B2\n\nB2:\n%21 = phi i64 [ %23, %B3 ], [ 10000, %B1 ]\n%22 = tail call i32 @udelay(i32 noundef 1)\n%23 = add nsw i64 %21, -1\n%24 = icmp eq i64 %21, 0\nbr i1 %24, label %B4, label %B3\n\nB3:\n%25 = load i64, ptr %1, align 8\n%26 = load i64, ptr @MMC_STAT, align 8\n%27 = add nsw i64 %26, %25\n%28 = tail call i32 @readl(i64 noundef %27)\n%29 = load i32, ptr @STAT_CLK_EN, align 4\n%30 = and i32 %29, %28\n%31 = icmp eq i32 %30, 0\nbr i1 %31, label %B5, label %B2\n\nB4:\n%32 = load i32, ptr %0, align 8\n%33 = tail call i32 @mmc_dev(i32 noundef %32)\n%34 = tail call i32 @dev_err(i32 noundef %33, ptr noundef nonnull @.str)\nbr label %B6\n\nB5:\n%35 = phi i32 [ %17, %B1 ], [ %28, %B3 ]\n%36 = load i32, ptr @STAT_CLK_EN, align 4\n%37 = and i32 %36, %35\n%38 = icmp eq i32 %37, 0\nbr i1 %38, label %B6, label %B4\n\nB6:\nret void\n}", "codegemma": "define internal void @pxamci_stop_clock(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.pxamci_host, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = load i64, ptr @MMC_STAT, align 8\n%4 = add nsw i64 %3, %2\n%5 = tail call i32 @readl(i64 noundef %4)\n%6 = load i32, ptr @STAT_CLK_EN, align 4\n%7 = and i32 %6, %5\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B5, label %B1\n\nB1:\n%9 = load i32, ptr @STOP_CLOCK, align 4\n%10 = load i64, ptr %1, align 8\n%11 = load i64, ptr @MMC_STRPCL, align 8\n%12 = add nsw i64 %11, %10\n%13 = tail call i32 @writel(i32 noundef %9, i64 noundef %12)\n%14 = load i64, ptr %1, align 8\n%15 = load i64, ptr @MMC_STAT, align 8\n%16 = add nsw i64 %15, %14\n%17 = tail call i32 @readl(i64 noundef %16)\n%18 = load i32, ptr @STAT_CLK_EN, align 4\n%19 = and i32 %18, %17\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B3, label %B2\n\nB2:\n%21 = phi i64 [ %23, %B2 ], [ 10000, %B1 ]\n%22 = tail call i32 @udelay(i32 noundef 1)\n%23 = add i64 %21, -1\n%24 = icmp eq i64 %23, 0\nbr i1 %24, label %B3, label %B2\n\nB3:\n%25 = load i32, ptr @STAT_CLK_EN, align 4\n%26 = and i32 %25, %17\n%27 = icmp eq i32 %26, 0\nbr i1 %27, label %B5, label %B4\n\nB4:\n%28 = load i32, ptr %0, align 8\n%29 = tail call i32 @mmc_dev(i32 noundef %28)\n%30 = tail call i32 @dev_err(i32 noundef %29, ptr noundef nonnull @.str)\nbr label %B5\n\nB5:\nret void\n}"}, "define internal i32 @FileAccess(i64 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i64 %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load i32, ptr @LOG, align 4\n%7 = load i64, ptr %3, align 8\n%8 = load ptr, ptr @VfdCache, align 8\n%9 = load i64, ptr %3, align 8\n%10 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i64 %9\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %10, i32 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = call i32 @elog(i32 noundef %6, ptr noundef @.str, i64 noundef %7, i32 noundef %12)\n%14 = call i32 @DO_DB(i32 noundef %13)\n%15 = load i64, ptr %3, align 8\n%16 = call i64 @FileIsNotOpen(i64 noundef %15)\n%17 = icmp ne i64 %16, 0\nbr i1 %17, label %18, label %26\n\n18:\n%19 = load i64, ptr %3, align 8\n%20 = call i32 @LruInsert(i64 noundef %19)\nstore i32 %20, ptr %4, align 4\n%21 = load i32, ptr %4, align 4\n%22 = icmp ne i32 %21, 0\nbr i1 %22, label %23, label %25\n\n23:\n%24 = load i32, ptr %4, align 4\nstore i32 %24, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %40\n\n25:\nbr label %39\n\n26:\n%27 = load ptr, ptr @VfdCache, align 8\n%28 = getelementptr inbounds %struct.TYPE_2__, ptr %27, i64 0\n%29 = getelementptr inbounds %struct.TYPE_2__, ptr %28, i32 0, i32 0\n%30 = load i64, ptr %29, align 8\n%31 = load i64, ptr %3, align 8\n%32 = icmp ne i64 %30, %31\nbr i1 %32, label %33, label %38\n\n33:\n%34 = load i64, ptr %3, align 8\n%35 = call i32 @Delete(i64 noundef %34)\n%36 = load i64, ptr %3, align 8\n%37 = call i32 @Insert(i64 noundef %36)\nbr label %38\n\n38:\nbr label %39\n\n39:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %40\n\n40:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%41 = load i32, ptr %2, align 4\nret i32 %41\n}": {"base_truth": "define internal i32 @FileAccess(i64 noundef %0) {\nB:\n%1 = load i32, ptr @LOG, align 4\n%2 = load ptr, ptr @VfdCache, align 8\n%3 = getelementptr inbounds %struct.TYPE_2__, ptr %2, i64 %0, i32 1\n%4 = load i32, ptr %3, align 8\n%5 = tail call i32 @elog(i32 noundef %1, ptr noundef nonnull @.str, i64 noundef %0, i32 noundef %4)\n%6 = tail call i32 @DO_DB(i32 noundef %5)\n%7 = tail call i64 @FileIsNotOpen(i64 noundef %0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B2, label %B1\n\nB1:\n%9 = tail call i32 @LruInsert(i64 noundef %0)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B5\n\nB2:\n%11 = load ptr, ptr @VfdCache, align 8\n%12 = load i64, ptr %11, align 8\n%13 = icmp eq i64 %12, %0\nbr i1 %13, label %B4, label %B3\n\nB3:\n%14 = tail call i32 @Delete(i64 noundef %0)\n%15 = tail call i32 @Insert(i64 noundef %0)\nbr label %B4\n\nB4:\nbr label %B5\n\nB5:\n%16 = phi i32 [ 0, %B4 ], [ %9, %B1 ]\nret i32 %16\n}", "codellama": "define internal i32 @FileAccess(i64 noundef %0) {\nB:\n%1 = load i32, ptr @LOG, align 4\n%2 = load ptr, ptr @VfdCache, align 8\n%3 = getelementptr inbounds %struct.TYPE_2__, ptr %2, i64 %0, i32 1\n%4 = load i32, ptr %3, align 8\n%5 = tail call i32 @elog(i32 noundef %1, ptr noundef nonnull @.str, i64 noundef %0, i32 noundef %4)\n%6 = tail call i32 @DO_DB(i32 noundef %5)\n%7 = tail call i64 @FileIsNotOpen(i64 noundef %0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B3, label %B1\n\nB1:\n%9 = tail call i32 @LruInsert(i64 noundef %0)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B5\n\nB2:\n%11 = load ptr, ptr @VfdCache, align 8\nbr label %B3\n\nB3:\n%12 = phi ptr [ %11, %B2 ], [ %2, %B ]\n%13 = load i64, ptr %12, align 8\n%14 = icmp eq i64 %13, %0\nbr i1 %14, label %B4, label %B2\n\nB4:\n%15 = tail call i32 @Delete(i64 noundef %0)\n%16 = tail call i32 @Insert(i64 noundef %0)\nbr label %B3\n\nB5:\nbr label %B4\n}", "codegemma": "define internal i32 @FileAccess(i64 noundef %0) {\nB:\n%1 = load i32, ptr @LOG, align 4\n%2 = load ptr, ptr @VfdCache, align 8\n%3 = getelementptr inbounds %struct.TYPE_2__, ptr %2, i64 %0, i32 1\n%4 = load i32, ptr %3, align 8\n%5 = tail call i32 @elog(i32 noundef %1, ptr noundef nonnull @.str, i64 noundef %0, i32 noundef %4)\n%6 = tail call i32 @DO_DB(i32 noundef %5)\n%7 = tail call i64 @FileIsNotOpen(i64 noundef %0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B3, label %B1\n\nB1:\n%9 = tail call i32 @LruInsert(i64 noundef %0)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B5\n\nB2:\n%11 = tail call i32 @Delete(i64 noundef %0)\nbr label %B3\n\nB3:\n%12 = phi i32 [ %9, %B1 ], [ 0, %B2 ]\nbr label %B5\n\nB4:\n%13 = tail call i32 @Insert(i64 noundef %0)\nbr label %B5\n\nB5:\n%14 = phi i32 [ 0, %B4 ], [ %12, %B3 ], [ 0, %B2 ]\nret i32 %14\n}"}, "define internal ptr @port_build_peer_abort_msg(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i64, align 8\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.port ptr %8, i32 0, i32 0\n%10 = getelementptr inbounds %struct.TYPE_2__, ptr %9, i32 0, i32 2\n%11 = call i64 @msg_importance(ptr noundef %10)\nstore i64 %11, ptr %6, align 8\n%12 = load ptr, ptr %4, align 8\n%13 = getelementptr inbounds %struct.port ptr %12, i32 0, i32 0\n%14 = getelementptr inbounds %struct.TYPE_2__, ptr %13, i32 0, i32 1\n%15 = load i32, ptr %14, align 4\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %18, label %17\n\n17:\nstore ptr null, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %41\n\n18:\n%19 = load i64, ptr %6, align 8\n%20 = load i64, ptr @TIPC_CRITICAL_IMPORTANCE, align 8\n%21 = icmp slt i64 %19, %20\nbr i1 %21, label %22, label %25\n\n22:\n%23 = load i64, ptr %6, align 8\n%24 = add nsw i64 %23, 1\nstore i64 %24, ptr %6, align 8\nbr label %25\n\n25:\n%26 = load ptr, ptr %4, align 8\n%27 = call i32 @port_peerport(ptr noundef %26)\n%28 = load ptr, ptr %4, align 8\n%29 = call i32 @port_peernode(ptr noundef %28)\n%30 = load ptr, ptr %4, align 8\n%31 = getelementptr inbounds %struct.port ptr %30, i32 0, i32 0\n%32 = getelementptr inbounds %struct.TYPE_2__, ptr %31, i32 0, i32 0\n%33 = load i32, ptr %32, align 4\n%34 = load i32, ptr @tipc_own_addr, align 4\n%35 = load i64, ptr %6, align 8\n%36 = load i32, ptr @TIPC_CONN_MSG, align 4\n%37 = load i64, ptr %5, align 8\n%38 = load ptr, ptr %4, align 8\n%39 = call i32 @port_out_seqno(ptr noundef %38)\n%40 = call ptr @port_build_proto_msg(i32 noundef %27, i32 noundef %29, i32 noundef %33, i32 noundef %34, i64 noundef %35, i32 noundef %36, i64 noundef %37, i32 noundef %39, i32 noundef 0)\nstore ptr %40, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %41\n\n41:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%42 = load ptr, ptr %3, align 8\nret ptr %42\n}": {"base_truth": "define internal ptr @port_build_peer_abort_msg(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 2\n%3 = tail call i64 @msg_importance(ptr noundef nonnull %2)\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = load i64, ptr @TIPC_CRITICAL_IMPORTANCE, align 8\n%8 = icmp slt i64 %3, %7\n%9 = zext i1 %8 to i64\n%10 = add nsw i64 %3, %9\n%11 = tail call i32 @port_peerport(ptr noundef nonnull %0)\n%12 = tail call i32 @port_peernode(ptr noundef nonnull %0)\n%13 = load i32, ptr %0, align 4\n%14 = load i32, ptr @tipc_own_addr, align 4\n%15 = load i32, ptr @TIPC_CONN_MSG, align 4\n%16 = tail call i32 @port_out_seqno(ptr noundef nonnull %0)\n%17 = tail call ptr @port_build_proto_msg(i32 noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i64 noundef %10, i32 noundef %15, i64 noundef %1, i32 noundef %16, i32 noundef 0)\nbr label %B2\n\nB2:\n%18 = phi ptr [ %17, %B1 ], [ null, %B ]\nret ptr %18\n}", "codellama": "define internal ptr @port_build_peer_abort_msg(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 2\n%3 = tail call i64 @msg_importance(ptr noundef nonnull %2)\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = load i64, ptr @TIPC_CRITICAL_IMPORTANCE, align 8\n%8 = icmp slt i64 %3, %7\n%9 = add nsw i64 %3, 1\n%10 = select i1 %8, i64 %9, i64 %3\n%11 = tail call i32 @port_peerport(ptr noundef %0)\n%12 = tail call i32 @port_peernode(ptr noundef %0)\n%13 = load i32, ptr %0, align 4\n%14 = load i32, ptr @tipc_own_addr, align 4\n%15 = load i32, ptr @TIPC_CONN_MSG, align 4\n%16 = tail call i32 @port_out_seqno(ptr noundef nonnull %0)\n%17 = tail call ptr @port_build_proto_msg(i32 noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i64 noundef %10, i32 noundef %15, i64 noundef %1, i32 noundef %16, i32 noundef 0)\nbr label %B2\n\nB2:\n%18 = phi ptr [ %17, %B1 ], [ null, %B ]\nret ptr %18\n}", "codegemma": "define internal ptr @port_build_peer_abort_msg(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 2\n%3 = tail call i64 @msg_importance(ptr noundef nonnull %2)\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = load i64, ptr @TIPC_CRITICAL_IMPORTANCE, align 8\n%8 = icmp slt i64 %3, %7\n%9 = zext i1 %8 to i64\n%10 = add nsw i64 %9, %3\n%11 = tail call i32 @port_peerport(ptr noundef %0)\n%12 = tail call i32 @port_peernode(ptr noundef %0)\n%13 = load i32, ptr %0, align 4\n%14 = load i32, ptr @tipc_own_addr, align 4\n%15 = load i32, ptr @TIPC_CONN_MSG, align 4\n%16 = tail call i32 @port_out_seqno(ptr noundef nonnull %0)\n%17 = tail call ptr @port_build_proto_msg(i32 noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i64 noundef %10, i32 noundef %15, i64 noundef %1, i32 noundef %16, i32 noundef 0)\nbr label %B2\n\nB2:\n%18 = phi ptr [ %17, %B1 ], [ null, %B ]\nret ptr %18\n}"}, "define dso_local void @turnRight(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = call i32 @motor(i32 noundef 3, i32 noundef 75)\n%4 = call i32 @motor(i32 noundef 1, i32 noundef -90)\n%5 = load i32, ptr %2, align 4\n%6 = call i32 @msleep(i32 noundef %5)\n%7 = call i32 @off(i32 noundef 1)\n%8 = call i32 @off(i32 noundef 3)\nret void\n}": {"base_truth": "define dso_local void @turnRight(i32 noundef %0) {\nB:\n%1 = tail call i32 @motor(i32 noundef 3, i32 noundef 75)\n%2 = tail call i32 @motor(i32 noundef 1, i32 noundef -90)\n%3 = tail call i32 @msleep(i32 noundef %0)\n%4 = tail call i32 @off(i32 noundef 1)\n%5 = tail call i32 @off(i32 noundef 3)\nret void\n}", "codellama": "define dso_local void @turnRight(i32 noundef %0) {\nB:\n%1 = tail call i32 @motor(i32 noundef 3, i32 noundef 75)\n%2 = tail call i32 @motor(i32 noundef 1, i32 noundef -90)\n%3 = tail call i32 @msleep(i32 noundef %0)\n%4 = tail call i32 @off(i32 noundef 1)\n%5 = tail call i32 @off(i32 noundef 3)\nret void\n}", "codegemma": "define dso_local void @turnRight(i32 noundef %0) {\nB:\n%1 = tail call i32 @motor(i32 noundef 3, i32 noundef 75)\n%2 = tail call i32 @motor(i32 noundef 1, i32 noundef -90)\n%3 = tail call i32 @msleep(i32 noundef %0)\n%4 = tail call i32 @off(i32 noundef 1)\n%5 = tail call i32 @off(i32 noundef 3)\nret void\n}"}, "define dso_local void @info_print(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 2\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\n%12 = load ptr, ptr %4, align 8\n%13 = getelementptr inbounds %struct.TYPE_3__, ptr %12, i32 0, i32 0\n%14 = call i32 @_info_print(i32 noundef %5, i32 noundef %8, i32 noundef %11, ptr noundef %13)\nret void\n}": {"base_truth": "define dso_local void @info_print(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @_info_print(i32 noundef %0, i32 noundef %3, i32 noundef %5, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @info_print(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @_info_print(i32 noundef %0, i32 noundef %3, i32 noundef %5, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @info_print(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @_info_print(i32 noundef %0, i32 noundef %3, i32 noundef %5, ptr noundef %1)\nret void\n}"}, "define dso_local void @TPIUDecoderZeroStats(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TPIUDecoder ptr %3, i32 0, i32 0\n%5 = call i32 @memset(ptr noundef %4, i32 noundef 0, i32 noundef 4)\nret void\n}": {"base_truth": "define dso_local void @TPIUDecoderZeroStats(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret void\n}", "codellama": "define dso_local void @TPIUDecoderZeroStats(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret void\n}", "codegemma": "define dso_local void @TPIUDecoderZeroStats(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret void\n}"}, "define dso_local nofpclass(nan inf) double @kahan_sum_compensation(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load double, ptr %4, align 8\nret double %5\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @kahan_sum_compensation(ptr nocapture noundef readonly %0) {\nB:\n%1 = load double, ptr %0, align 8\nret double %1\n}", "codellama": "define dso_local nofpclass(nan inf) double @kahan_sum_compensation(ptr nocapture noundef readonly %0) {\nB:\n%1 = load double, ptr %0, align 8\nret double %1\n}", "codegemma": "define dso_local nofpclass(nan inf) double @kahan_sum_compensation(ptr nocapture noundef readonly %0) {\nB:\n%1 = load double, ptr %0, align 8\nret double %1\n}"}, "define internal i32 @da8xx_usb0_clk48_enable(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%7 = load ptr, ptr %2, align 8\n%8 = call ptr @to_da8xx_usb0_clk48(ptr noundef %7)\nstore ptr %8, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.da8xx_usb0_clk48 ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = call i32 @clk_enable(i32 noundef %11)\n%13 = load i32, ptr @CFGCHIP2_RESET, align 4\n%14 = load i32, ptr @CFGCHIP2_PHYPWRDN, align 4\n%15 = or i32 %13, %14\n%16 = load i32, ptr @CFGCHIP2_PHY_PLLON, align 4\n%17 = or i32 %15, %16\nstore i32 %17, ptr %4, align 4\n%18 = load i32, ptr @CFGCHIP2_PHY_PLLON, align 4\nstore i32 %18, ptr %5, align 4\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.da8xx_usb0_clk48 ptr %19, i32 0, i32 1\n%21 = load i32, ptr %20, align 4\n%22 = call i32 @CFGCHIP(i32 noundef 2)\n%23 = load i32, ptr %4, align 4\n%24 = load i32, ptr %5, align 4\n%25 = call i32 @regmap_write_bits(i32 noundef %21, i32 noundef %22, i32 noundef %23, i32 noundef %24)\n%26 = load ptr, ptr %3, align 8\n%27 = getelementptr inbounds %struct.da8xx_usb0_clk48 ptr %26, i32 0, i32 1\n%28 = load i32, ptr %27, align 4\n%29 = call i32 @CFGCHIP(i32 noundef 2)\n%30 = load i32, ptr %5, align 4\n%31 = load i32, ptr %5, align 4\n%32 = load i32, ptr @CFGCHIP2_PHYCLKGD, align 4\n%33 = and i32 %31, %32\n%34 = call i32 @regmap_read_poll_timeout(i32 noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %33, i32 noundef 0, i32 noundef 500000)\nstore i32 %34, ptr %6, align 4\n%35 = load ptr, ptr %3, align 8\n%36 = getelementptr inbounds %struct.da8xx_usb0_clk48 ptr %35, i32 0, i32 0\n%37 = load i32, ptr %36, align 4\n%38 = call i32 @clk_disable(i32 noundef %37)\n%39 = load i32, ptr %6, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %39\n}": {"base_truth": "define internal i32 @da8xx_usb0_clk48_enable(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_da8xx_usb0_clk48(ptr noundef %0)\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @clk_enable(i32 noundef %2)\n%4 = load i32, ptr @CFGCHIP2_RESET, align 4\n%5 = load i32, ptr @CFGCHIP2_PHYPWRDN, align 4\n%6 = or i32 %5, %4\n%7 = load i32, ptr @CFGCHIP2_PHY_PLLON, align 4\n%8 = or i32 %6, %7\n%9 = getelementptr inbounds %struct.da8xx_usb0_clk48, ptr %1, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @CFGCHIP(i32 noundef 2)\n%12 = tail call i32 @regmap_write_bits(i32 noundef %10, i32 noundef %11, i32 noundef %8, i32 noundef %7)\n%13 = load i32, ptr %9, align 4\n%14 = tail call i32 @CFGCHIP(i32 noundef 2)\n%15 = load i32, ptr @CFGCHIP2_PHYCLKGD, align 4\n%16 = and i32 %15, %7\n%17 = tail call i32 @regmap_read_poll_timeout(i32 noundef %13, i32 noundef %14, i32 noundef %7, i32 noundef %16, i32 noundef 0, i32 noundef 500000)\n%18 = load i32, ptr %1, align 4\n%19 = tail call i32 @clk_disable(i32 noundef %18)\nret i32 %17\n}", "codellama": "define internal i32 @da8xx_usb0_clk48_enable(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_da8xx_usb0_clk48(ptr noundef %0)\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @clk_enable(i32 noundef %2)\n%4 = load i32, ptr @CFGCHIP2_RESET, align 4\n%5 = load i32, ptr @CFGCHIP2_PHYPWRDN, align 4\n%6 = or i32 %5, %4\n%7 = load i32, ptr @CFGCHIP2_PHY_PLLON, align 4\n%8 = or i32 %6, %7\n%9 = getelementptr inbounds %struct.da8xx_usb0_clk48, ptr %1, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @CFGCHIP(i32 noundef 2)\n%12 = tail call i32 @regmap_write_bits(i32 noundef %10, i32 noundef %11, i32 noundef %8, i32 noundef %7)\n%13 = load i32, ptr %9, align 4\n%14 = tail call i32 @CFGCHIP(i32 noundef 2)\n%15 = load i32, ptr @CFGCHIP2_PHYCLKGD, align 4\n%16 = and i32 %15, %7\n%17 = tail call i32 @regmap_read_poll_timeout(i32 noundef %13, i32 noundef %14, i32 noundef %7, i32 noundef %16, i32 noundef 0, i32 noundef 500000)\n%18 = load i32, ptr %1, align 4\n%19 = tail call i32 @clk_disable(i32 noundef %18)\nret i32 %17\n}", "codegemma": "define internal i32 @da8xx_usb0_clk48_enable(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_da8xx_usb0_clk48(ptr noundef %0)\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @clk_enable(i32 noundef %2)\n%4 = load i32, ptr @CFGCHIP2_RESET, align 4\n%5 = load i32, ptr @CFGCHIP2_PHYPWRDN, align 4\n%6 = or i32 %5, %4\n%7 = load i32, ptr @CFGCHIP2_PHY_PLLON, align 4\n%8 = or i32 %6, %7\n%9 = getelementptr inbounds %struct.da8xx_usb0_clk48, ptr %1, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @CFGCHIP(i32 noundef 2)\n%12 = tail call i32 @regmap_write_bits(i32 noundef %10, i32 noundef %11, i32 noundef %8, i32 noundef %7)\n%13 = load i32, ptr %9, align 4\n%14 = tail call i32 @CFGCHIP(i32 noundef 2)\n%15 = load i32, ptr @CFGCHIP2_PHYCLKGD, align 4\n%16 = and i32 %15, %7\n%17 = tail call i32 @regmap_read_poll_timeout(i32 noundef %13, i32 noundef %14, i32 noundef %7, i32 noundef %16, i32 noundef 0, i32 noundef 500000)\n%18 = load i32, ptr %1, align 4\n%19 = tail call i32 @clk_disable(i32 noundef %18)\nret i32 %17\n}"}, "define dso_local void @free_internal_person(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr null, %3\nbr i1 %4, label %5, label %8\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = call i32 @free(ptr noundef %6)\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @free_internal_person(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @free_internal_person(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @free_internal_person(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i64 @pcode_VarIterationPostIncDoWhileLoop(i64 noundef %0) {\n%2 = alloca i64, align 8\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore i64 0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\nstore i64 0, ptr %4, align 8\nbr label %5\n\n5:\n%6 = load i64, ptr %4, align 8\n%7 = add nsw i64 %6, 5\nstore i64 %7, ptr %4, align 8\nbr label %8\n\n8:\n%9 = load i64, ptr %3, align 8\n%10 = add nsw i64 %9, 1\nstore i64 %10, ptr %3, align 8\n%11 = load i64, ptr %2, align 8\n%12 = icmp slt i64 %9, %11\nbr i1 %12, label %5, label %13\n\n13:\n%14 = load i64, ptr %4, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i64 %14\n}": {"base_truth": "define dso_local i64 @pcode_VarIterationPostIncDoWhileLoop(i64 noundef %0) {\nB:\n%1 = tail call i64 @llvm.smax.i64(i64 %0, i64 0)\n%2 = mul i64 %1, 5\n%3 = add i64 %2, 5\nret i64 %3\n}", "codellama": "define dso_local i64 @pcode_VarIterationPostIncDoWhileLoop(i64 noundef %0) {\nB:\n%1 = tail call i64 @llvm.smax.i64(i64 %0, i64 0)\n%2 = mul i64 %1, 5\n%3 = add i64 %2, 5\nret i64 %3\n}", "codegemma": "define dso_local i64 @pcode_VarIterationPostIncDoWhileLoop(i64 noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i64 [ 0, %B ], [ %3, %B1 ]\n%2 = phi i64 [ 0, %B ], [ %5, %B1 ]\n%3 = add nuw nsw i64 %1, 1\n%4 = icmp eq i64 %3, %0\n%5 = add nuw nsw i64 %2, 5\n%6 = select i1 %4, i64 %5, i64 0\nbr label %B1\n\nB2:\nret i64 %6\n}"}, "define dso_local nofpclass(nan inf) float @decay(float noundef nofpclass(nan inf) %0) {\n%2 = alloca float, align 4\n%3 = alloca float, align 4\nstore float %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load float, ptr %2, align 4\nstore float %4, ptr %3, align 4\n%5 = load float, ptr %2, align 4\n%6 = fcmp fast oge float %5, 0.000000e+00\nbr i1 %6, label %7, label %17\n\n7:\n%8 = load i64, ptr @DECAY, align 8\n%9 = sitofp i64 %8 to float\n%10 = load float, ptr %2, align 4\n%11 = fsub fast float %10, %9\nstore float %11, ptr %2, align 4\n%12 = load float, ptr %2, align 4\n%13 = fcmp fast olt float %12, 0.000000e+00\nbr i1 %13, label %14, label %16\n\n14:\n%15 = call fast nofpclass(nan inf) float (...) @random_dir()\nstore float %15, ptr %2, align 4\nbr label %16\n\n16:\nbr label %27\n\n17:\n%18 = load i64, ptr @DECAY, align 8\n%19 = sitofp i64 %18 to float\n%20 = load float, ptr %2, align 4\n%21 = fadd fast float %20, %19\nstore float %21, ptr %2, align 4\n%22 = load float, ptr %2, align 4\n%23 = fcmp fast ogt float %22, 0.000000e+00\nbr i1 %23, label %24, label %26\n\n24:\n%25 = call fast nofpclass(nan inf) float (...) @random_dir()\nstore float %25, ptr %2, align 4\nbr label %26\n\n26:\nbr label %27\n\n27:\n%28 = load float, ptr %2, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret float %28\n}": {"base_truth": "define dso_local nofpclass(nan inf) float @decay(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fcmp fast ult float %0, 0.000000e+00\n%2 = load i64, ptr @DECAY, align 8\n%3 = sitofp i64 %2 to float\nbr i1 %1, label %B2, label %B1\n\nB1:\n%4 = fsub fast float %0, %3\n%5 = fcmp fast olt float %4, 0.000000e+00\nbr i1 %5, label %B3, label %B4\n\nB2:\n%6 = fadd fast float %3, %0\n%7 = fcmp fast ogt float %6, 0.000000e+00\nbr i1 %7, label %B3, label %B4\n\nB3:\n%8 = tail call fast nofpclass(nan inf) float (...) @random_dir()\nbr label %B4\n\nB4:\n%9 = phi float [ %4, %B1 ], [ %6, %B2 ], [ %8, %B3 ]\nret float %9\n}", "codellama": "define dso_local nofpclass(nan inf) float @decay(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fcmp fast ult float %0, 0.000000e+00\n%2 = load i64, ptr @DECAY, align 8\n%3 = sitofp i64 %2 to float\nbr i1 %1, label %B3, label %B1\n\nB1:\n%4 = fsub fast float %0, %3\n%5 = fcmp fast olt float %4, 0.000000e+00\nbr i1 %5, label %B2, label %B5\n\nB2:\n%6 = tail call fast nofpclass(nan inf) float (...) @random_dir()\nbr label %B5\n\nB3:\n%7 = fadd fast float %3, %0\n%8 = fcmp fast ogt float %7, 0.000000e+00\nbr i1 %8, label %B4, label %B5\n\nB4:\n%9 = tail call fast nofpclass(nan inf) float (...) @random_dir()\nbr label %B5\n\nB5:\n%10 = phi float [ %6, %B2 ], [ %9, %B4 ], [ %7, %B3 ], [ %0, %B1 ]\nret float %10\n}", "codegemma": "define dso_local nofpclass(nan inf) float @decay(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fcmp fast ult float %0, 0.000000e+00\n%2 = load i64, ptr @DECAY, align 8\n%3 = sitofp i64 %2 to float\nbr i1 %1, label %B2, label %B1\n\nB1:\n%4 = fsub fast float %0, %3\n%5 = fcmp fast olt float %4, 0.000000e+00\nbr i1 %5, label %B3, label %B4\n\nB2:\n%6 = fadd fast float %3, %0\n%7 = fcmp fast ogt float %6, 0.000000e+00\nbr i1 %7, label %B3, label %B4\n\nB3:\n%8 = tail call fast nofpclass(nan inf) float (...) @random_dir()\nbr label %B4\n\nB4:\n%9 = phi float [ %8, %B3 ], [ %4, %B1 ], [ %6, %B2 ]\nret float %9\n}"}, "define dso_local void @ooaofooa_TE_VAL_R2040_Unlink(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 0\nstore i64 0, ptr %6, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.TYPE_5__, ptr %7, i32 0, i32 0\nstore i64 0, ptr %8, align 8\nret void\n}": {"base_truth": "define dso_local void @ooaofooa_TE_VAL_R2040_Unlink(ptr nocapture noundef writeonly %0, ptr nocapture noundef writeonly %1) {\nB:\nstore i64 0, ptr %1, align 8\nstore i64 0, ptr %0, align 8\nret void\n}", "codellama": "define dso_local void @ooaofooa_TE_VAL_R2040_Unlink(ptr nocapture noundef writeonly %0, ptr nocapture noundef writeonly %1) {\nB:\nstore i64 0, ptr %1, align 8\nstore i64 0, ptr %0, align 8\nret void\n}", "codegemma": "define dso_local void @ooaofooa_TE_VAL_R2040_Unlink(ptr nocapture noundef writeonly %0, ptr nocapture noundef writeonly %1) {\nB:\nstore i64 0, ptr %1, align 8\nstore i64 0, ptr %0, align 8\nret void\n}"}, "define dso_local i32 @cJSON_ToBooleanOpt(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load ptr, ptr %4, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %10, label %8\n\n8:\n%9 = load i32, ptr %5, align 4\nstore i32 %9, ptr %3, align 4\nbr label %26\n\n10:\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\nswitch i32 %13, label %24 [\ni32 0, label %14\ni32 1, label %15\ni32 2, label %16\ni32 3, label %17\ni32 4, label %23\ni32 5, label %23\ni32 6, label %23\n]\n\n14:\nstore i32 0, ptr %3, align 4\nbr label %26\n\n15:\nstore i32 1, ptr %3, align 4\nbr label %26\n\n16:\nstore i32 0, ptr %3, align 4\nbr label %26\n\n17:\n%18 = load ptr, ptr %4, align 8\n%19 = getelementptr inbounds %struct.TYPE_3__, ptr %18, i32 0, i32 1\n%20 = load i32, ptr %19, align 4\n%21 = icmp ne i32 %20, 0\n%22 = zext i1 %21 to i32\nstore i32 %22, ptr %3, align 4\nbr label %26\n\n23:\nbr label %24\n\n24:\n%25 = load i32, ptr %5, align 4\nstore i32 %25, ptr %3, align 4\nbr label %26\n\n26:\n%27 = load i32, ptr %3, align 4\nret i32 %27\n}": {"base_truth": "define dso_local i32 @cJSON_ToBooleanOpt(ptr noundef readonly %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B5, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\nswitch i32 %3, label %B4 [\ni32 0, label %B5\ni32 1, label %B2\ni32 2, label %B5\ni32 3, label %B3\n]\n\nB2:\nbr label %B5\n\nB3:\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp ne i32 %5, 0\n%7 = zext i1 %6 to i32\nbr label %B5\n\nB4:\nbr label %B5\n\nB5:\n%8 = phi i32 [ %1, %B4 ], [ %7, %B3 ], [ 1, %B2 ], [ %1, %B ], [ 0, %B1 ], [ 0, %B1 ]\nret i32 %8\n}", "codellama": "define dso_local i32 @cJSON_ToBooleanOpt(ptr noundef readonly %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\nswitch i32 %3, label %B4 [\ni32 1, label %B2\ni32 2, label %B3\ni32 4, label %B4\ni32 5, label %B4\ni32 6, label %B4\n]\n\nB2:\nbr label %B4\n\nB3:\nbr label %B4\n\nB4:\n%4 = phi i32 [ 0, %B3 ], [ 1, %B2 ], [ %1, %B ], [ %1, %B1 ], [ %1, %B1 ], [ %1, %B1 ], [ %1, %B1 ]\nret i32 %4\n}", "codegemma": "define dso_local i32 @cJSON_ToBooleanOpt(ptr noundef readonly %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\nswitch i32 %3, label %B4 [\ni32 0, label %B4\ni32 1, label %B3\ni32 2, label %B4\ni32 3, label %B2\n]\n\nB2:\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp ne i32 %5, 0\n%7 = zext i1 %6 to i32\nbr label %B4\n\nB3:\nbr label %B4\n\nB4:\n%8 = phi i32 [ %7, %B2 ], [ %1, %B1 ], [ %1, %B ], [ %1, %B1 ], [ %1, %B1 ], [ %1, %B1 ]\nret i32 %8\n}"}, "define dso_local i32 @R_ScaleFromGlobalAngle(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%8 = load i32, ptr %2, align 4\n%9 = load i32, ptr @viewangle, align 4\n%10 = sub nsw i32 %8, %9\n%11 = add nsw i32 1073741824, %10\nstore i32 %11, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%12 = load i32, ptr %2, align 4\n%13 = load i32, ptr @rw_normalangle, align 4\n%14 = sub nsw i32 %12, %13\n%15 = add nsw i32 1073741824, %14\nstore i32 %15, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%16 = load i32, ptr @rw_distance, align 4\n%17 = load ptr, ptr @finesine, align 8\n%18 = load i32, ptr %3, align 4\n%19 = ashr i32 %18, 19\n%20 = sext i32 %19 to i64\n%21 = getelementptr inbounds i32, ptr %17, i64 %20\n%22 = load i32, ptr %21, align 4\n%23 = call i32 @FixedMul(i32 noundef %16, i32 noundef %22)\nstore i32 %23, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%24 = load i32, ptr @projection, align 4\n%25 = load ptr, ptr @finesine, align 8\n%26 = load i32, ptr %4, align 4\n%27 = ashr i32 %26, 19\n%28 = sext i32 %27 to i64\n%29 = getelementptr inbounds i32, ptr %25, i64 %28\n%30 = load i32, ptr %29, align 4\n%31 = load i32, ptr @detailshift, align 4\n%32 = shl i32 %30, %31\n%33 = call i32 @FixedMul(i32 noundef %24, i32 noundef %32)\nstore i32 %33, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%34 = load i32, ptr %5, align 4\n%35 = load i32, ptr %6, align 4\n%36 = ashr i32 %35, 16\n%37 = icmp sgt i32 %34, %36\nbr i1 %37, label %38, label %51\n\n38:\n%39 = load i32, ptr %6, align 4\n%40 = load i32, ptr %5, align 4\n%41 = call i32 @FixedDiv(i32 noundef %39, i32 noundef %40)\nstore i32 %41, ptr %7, align 4\n%42 = load i32, ptr %7, align 4\n%43 = icmp sgt i32 %42, 16777216\nbr i1 %43, label %44, label %45\n\n44:\nstore i32 16777216, ptr %7, align 4\nbr label %50\n\n45:\n%46 = load i32, ptr %7, align 4\n%47 = icmp slt i32 %46, 256\nbr i1 %47, label %48, label %49\n\n48:\nstore i32 256, ptr %7, align 4\nbr label %49\n\n49:\nbr label %50\n\n50:\nbr label %53\n\n51:\n%52 = load i32, ptr @max_rwscale, align 4\nstore i32 %52, ptr %7, align 4\nbr label %53\n\n53:\n%54 = load i32, ptr %7, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %54\n}": {"base_truth": "define dso_local i32 @R_ScaleFromGlobalAngle(i32 noundef %0) {\nB:\n%1 = load i32, ptr @viewangle, align 4\n%2 = add i32 %0, 1073741824\n%3 = sub i32 %2, %1\n%4 = load i32, ptr @rw_normalangle, align 4\n%5 = sub i32 %2, %4\n%6 = load i32, ptr @rw_distance, align 4\n%7 = load ptr, ptr @finesine, align 8\n%8 = ashr i32 %3, 19\n%9 = sext i32 %8 to i64\n%10 = getelementptr inbounds i32, ptr %7, i64 %9\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @FixedMul(i32 noundef %6, i32 noundef %11)\n%13 = load i32, ptr @projection, align 4\n%14 = load ptr, ptr @finesine, align 8\n%15 = ashr i32 %5, 19\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds i32, ptr %14, i64 %16\n%18 = load i32, ptr %17, align 4\n%19 = load i32, ptr @detailshift, align 4\n%20 = shl i32 %18, %19\n%21 = tail call i32 @FixedMul(i32 noundef %13, i32 noundef %20)\n%22 = ashr i32 %21, 16\n%23 = icmp sgt i32 %12, %22\nbr i1 %23, label %B1, label %B2\n\nB1:\n%24 = tail call i32 @FixedDiv(i32 noundef %21, i32 noundef %12)\n%25 = tail call i32 @llvm.smax.i32(i32 %24, i32 256)\n%26 = tail call i32 @llvm.smin.i32(i32 %25, i32 16777216)\nbr label %B3\n\nB2:\n%27 = load i32, ptr @max_rwscale, align 4\nbr label %B3\n\nB3:\n%28 = phi i32 [ %27, %B2 ], [ %26, %B1 ]\nret i32 %28\n}", "codellama": "define dso_local i32 @R_ScaleFromGlobalAngle(i32 noundef %0) {\nB:\n%1 = load i32, ptr @viewangle, align 4\n%2 = add i32 %0, 1073741824\n%3 = sub i32 %2, %1\n%4 = load i32, ptr @rw_normalangle, align 4\n%5 = add i32 %3, 1073741824\n%6 = sub i32 %5, %4\n%7 = load i32, ptr @rw_distance, align 4\n%8 = load ptr, ptr @finesine, align 8\n%9 = ashr i32 %3, 19\n%10 = sext i32 %9 to i64\n%11 = getelementptr inbounds i32, ptr %8, i64 %10\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @FixedMul(i32 noundef %7, i32 noundef %12)\n%14 = load i32, ptr @projection, align 4\n%15 = load ptr, ptr @finesine, align 8\n%16 = ashr i32 %6, 19\n%17 = sext i32 %16 to i64\n%18 = getelementptr inbounds i32, ptr %15, i64 %17\n%19 = load i32, ptr %18, align 4\n%20 = load i32, ptr @detailshift, align 4\n%21 = shl i32 %19, %20\n%22 = tail call i32 @FixedMul(i32 noundef %14, i32 noundef %21)\n%23 = ashr i32 %22, 16\n%24 = icmp sgt i32 %13, %23\nbr i1 %24, label %B1, label %B2\n\nB1:\n%25 = tail call i32 @FixedDiv(i32 noundef %22, i32 noundef %13)\n%26 = tail call i32 @llvm.smin.i32(i32 %25, i32 16777216)\n%27 = tail call i32 @llvm.smax.i32(i32 %26, i32 256)\nbr label %B2\n\nB2:\n%28 = phi i32 [ %27, %B1 ], [ %22, %B ]\n%29 = load i32, ptr @max_rwscale, align 4\n%30 = tail call i32 @llvm.smax.i32(i32 %28, i32 %29)\nret i32 %30\n}", "codegemma": "define dso_local i32 @R_ScaleFromGlobalAngle(i32 noundef %0) {\nB:\n%1 = load i32, ptr @viewangle, align 4\n%2 = sub nsw i32 %0, %1\n%3 = add nsw i32 %2, 1073741824\n%4 = load i32, ptr @rw_normalangle, align 4\n%5 = sub nsw i32 %0, %4\n%6 = add nsw i32 %5, 1073741824\n%7 = load i32, ptr @rw_distance, align 4\n%8 = load ptr, ptr @finesine, align 8\n%9 = ashr i32 %3, 19\n%10 = sext i32 %9 to i64\n%11 = getelementptr inbounds i32, ptr %8, i64 %10\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @FixedMul(i32 noundef %7, i32 noundef %12)\n%14 = load i32, ptr @projection, align 4\n%15 = load ptr, ptr @finesine, align 8\n%16 = ashr i32 %6, 19\n%17 = sext i32 %16 to i64\n%18 = getelementptr inbounds i32, ptr %15, i64 %17\n%19 = load i32, ptr %18, align 4\n%20 = load i32, ptr @detailshift, align 4\n%21 = shl i32 %19, %20\n%22 = tail call i32 @FixedMul(i32 noundef %14, i32 noundef %21)\n%23 = ashr i32 %22, 16\n%24 = icmp sgt i32 %13, %23\nbr i1 %24, label %B1, label %B3\n\nB1:\n%25 = tail call i32 @FixedDiv(i32 noundef %22, i32 noundef %13)\n%26 = icmp sgt i32 %25, 16777216\nbr i1 %26, label %B4, label %B2\n\nB2:\n%27 = icmp slt i32 %25, 256\n%28 = select i1 %27, i32 256, i32 %25\nbr label %B4\n\nB3:\n%29 = load i32, ptr @max_rwscale, align 4\nbr label %B4\n\nB4:\n%30 = phi i32 [ %29, %B3 ], [ %28, %B2 ], [ 16777216, %B1 ]\nret i32 %30\n}"}, "define dso_local ptr @IkeBuildCertPayload(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca %struct.TYPE_7__, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%7 = load ptr, ptr %3, align 8\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %9, label %10\n\n9:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %25\n\n10:\n%11 = call i32 @Zero(ptr noundef %4, i32 noundef 4)\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.TYPE_6__, ptr %12, i32 0, i32 1\n%14 = load i32, ptr %13, align 4\n%15 = getelementptr inbounds %struct.TYPE_7__, ptr %4, i32 0, i32 0\nstore i32 %14, ptr %15, align 4\n%16 = call ptr (...) @NewBuf()\nstore ptr %16, ptr %5, align 8\n%17 = load ptr, ptr %5, align 8\n%18 = call i32 @WriteBuf(ptr noundef %17, ptr noundef %4, i32 noundef 4)\n%19 = load ptr, ptr %5, align 8\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.TYPE_6__, ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = call i32 @WriteBufBuf(ptr noundef %19, i32 noundef %22)\n%24 = load ptr, ptr %5, align 8\nstore ptr %24, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %25\n\n25:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%26 = load ptr, ptr %2, align 8\nret ptr %26\n}": {"base_truth": "define dso_local ptr @IkeBuildCertPayload(ptr noundef readonly %0) {\nB:\n%1 = alloca %struct.TYPE_7__, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = call i32 @Zero(ptr noundef nonnull %1, i32 noundef 4)\n%4 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\nstore i32 %5, ptr %1, align 4\n%6 = call ptr (...) @NewBuf()\n%7 = call i32 @WriteBuf(ptr noundef %6, ptr noundef nonnull %1, i32 noundef 4)\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @WriteBufBuf(ptr noundef %6, i32 noundef %8)\nbr label %B2\n\nB2:\n%10 = phi ptr [ %6, %B1 ], [ null, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret ptr %10\n}", "codellama": "define dso_local ptr @IkeBuildCertPayload(ptr noundef readonly %0) {\nB:\n%1 = alloca %struct.TYPE_7__, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\nstore i32 %4, ptr %1, align 4\n%5 = tail call ptr (...) @NewBuf()\n%6 = call i32 @WriteBuf(ptr noundef %5, ptr noundef nonnull %1, i32 noundef 4)\n%7 = load i32, ptr %0, align 4\n%8 = call i32 @WriteBufBuf(ptr noundef %5, i32 noundef %7)\nbr label %B2\n\nB2:\n%9 = phi ptr [ %5, %B1 ], [ null, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret ptr %9\n}", "codegemma": "define dso_local ptr @IkeBuildCertPayload(ptr noundef readonly %0) {\nB:\n%1 = alloca %struct.TYPE_7__, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = call i32 @Zero(ptr noundef nonnull %1, i32 noundef 4)\n%4 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\nstore i32 %5, ptr %1, align 4\n%6 = call ptr (...) @NewBuf()\n%7 = call i32 @WriteBuf(ptr noundef %6, ptr noundef nonnull %1, i32 noundef 4)\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @WriteBufBuf(ptr noundef %6, i32 noundef %8)\nbr label %B2\n\nB2:\n%10 = phi ptr [ %6, %B1 ], [ null, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret ptr %10\n}"}, "define dso_local void @g(i64 %0) {\n%2 = alloca %struct.s align 4\nstore i64 %0, ptr %2, align 4\n%3 = getelementptr inbounds %struct.s ptr %2, i32 0, i32 0\n%4 = load i32, ptr %3, align 4\n%5 = icmp ne i32 %4, 5\nbr i1 %5, label %10, label %6\n\n6:\n%7 = getelementptr inbounds %struct.s ptr %2, i32 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = icmp ne i32 %8, 4\nbr i1 %9, label %10, label %12\n\n10:\n%11 = call i32 (...) @abort()\nunreachable\n\n12:\nret void\n}": {"base_truth": "define dso_local void @g(i64 %0) {\nB:\n%1 = icmp eq i64 %0, 17179869189\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 (...) @abort()\nunreachable\n\nB2:\nret void\n}", "codellama": "define dso_local void @g(i64 %0) {\nB:\n%1 = and i64 %0, 4294967295\n%2 = icmp eq i64 %1, 21474836484\n%3 = icmp eq i64 %0, 17179869184\n%4 = select i1 %2, i1 true, i1 %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 (...) @abort()\nunreachable\n\nB2:\nret void\n}", "codegemma": "define dso_local void @g(i64 %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = and i32 %1, 4294967295\n%3 = icmp eq i32 %2, 5\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 (...) @abort()\nunreachable\n\nB2:\nret void\n}"}, "define dso_local i32 @is_worker_here(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\n%8 = load ptr, ptr %5, align 8\n%9 = load i32, ptr %6, align 4\n%10 = load i32, ptr %7, align 4\n%11 = call i64 @get_worker_city(ptr noundef %8, i32 noundef %9, i32 noundef %10)\n%12 = load i64, ptr @C_TILE_WORKER, align 8\n%13 = icmp ne i64 %11, %12\nbr i1 %13, label %14, label %15\n\n14:\nstore i32 0, ptr %4, align 4\nbr label %44\n\n15:\n%16 = load i32, ptr %6, align 4\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %18, label %22\n\n18:\n%19 = load i32, ptr %7, align 4\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %21, label %22\n\n21:\nstore i32 0, ptr %4, align 4\nbr label %44\n\n22:\n%23 = load i32, ptr %6, align 4\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %25, label %29\n\n25:\n%26 = load i32, ptr %7, align 4\n%27 = icmp eq i32 %26, 4\nbr i1 %27, label %28, label %29\n\n28:\nstore i32 0, ptr %4, align 4\nbr label %44\n\n29:\n%30 = load i32, ptr %6, align 4\n%31 = icmp eq i32 %30, 4\nbr i1 %31, label %32, label %36\n\n32:\n%33 = load i32, ptr %7, align 4\n%34 = icmp eq i32 %33, 0\nbr i1 %34, label %35, label %36\n\n35:\nstore i32 0, ptr %4, align 4\nbr label %44\n\n36:\n%37 = load i32, ptr %6, align 4\n%38 = icmp eq i32 %37, 4\nbr i1 %38, label %39, label %43\n\n39:\n%40 = load i32, ptr %7, align 4\n%41 = icmp eq i32 %40, 4\nbr i1 %41, label %42, label %43\n\n42:\nstore i32 0, ptr %4, align 4\nbr label %44\n\n43:\nstore i32 1, ptr %4, align 4\nbr label %44\n\n44:\n%45 = load i32, ptr %4, align 4\nret i32 %45\n}": {"base_truth": "define dso_local i32 @is_worker_here(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i64 @get_worker_city(ptr noundef %0, i32 noundef %1, i32 noundef %2)\n%4 = load i64, ptr @C_TILE_WORKER, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B4\n\nB1:\n%6 = icmp eq i32 %2, 0\n%7 = or i32 %2, %1\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B2\n\nB2:\n%9 = icmp eq i32 %1, 0\n%10 = icmp eq i32 %2, 4\n%11 = and i1 %9, %10\nbr i1 %11, label %B4, label %B3\n\nB3:\n%12 = icmp eq i32 %1, 4\n%13 = xor i1 %10, %6\n%14 = and i1 %12, %13\n%15 = xor i1 %14, true\n%16 = zext i1 %15 to i32\nbr label %B4\n\nB4:\n%17 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ %16, %B3 ]\nret i32 %17\n}", "codellama": "define dso_local i32 @is_worker_here(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i64 @get_worker_city(ptr noundef %0, i32 noundef %1, i32 noundef %2)\n%4 = load i64, ptr @C_TILE_WORKER, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B5\n\nB1:\n%6 = icmp eq i32 %1, 0\n%7 = icmp eq i32 %2, 0\n%8 = and i1 %6, %7\nbr i1 %8, label %B5, label %B2\n\nB2:\n%9 = icmp eq i32 %1, 0\n%10 = icmp eq i32 %2, 4\n%11 = and i1 %9, %10\nbr i1 %11, label %B5, label %B3\n\nB3:\n%12 = icmp eq i32 %1, 4\n%13 = icmp eq i32 %2, 0\n%14 = and i1 %12, %13\nbr i1 %14, label %B5, label %B4\n\nB4:\n%15 = icmp eq i32 %1, 4\n%16 = icmp eq i32 %2, 4\n%17 = and i1 %15, %16\n%18 = icmp ne i32 %1, 4\n%19 = and i1 %18, %17\n%20 = zext i1 %19 to i32\nbr label %B5\n\nB5:\n%21 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 0, %B2 ], [ 0, %B3 ], [ %20, %B4 ]\nret i32 %21\n}", "codegemma": "define dso_local i32 @is_worker_here(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i64 @get_worker_city(ptr noundef %0, i32 noundef %1, i32 noundef %2)\n%4 = load i64, ptr @C_TILE_WORKER, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = icmp eq i32 %1, 0\n%7 = icmp eq i32 %2, 0\n%8 = or i1 %6, %7\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = icmp eq i32 %1, 4\n%10 = icmp eq i32 %2, 4\n%11 = or i1 %9, %10\n%12 = or i1 %9, %7\n%13 = or i1 %12, %10\n%14 = or i1 %13, %7\n%15 = or i1 %14, %11\n%16 = zext i1 %15 to i32\nbr label %B3\n\nB3:\n%17 = phi i32 [ 0, %B ], [ 0, %B1 ], [ %16, %B2 ]\nret i32 %17\n}"}, "define internal void @scan_set_error_return(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = icmp ne i32 %5, 0\nbr i1 %6, label %7, label %11\n\n7:\n%8 = load ptr, ptr %4, align 8\n%9 = load i32, ptr @SCAN_ERROR_EOF, align 4\n%10 = call i32 @ZVAL_LONG(ptr noundef %8, i32 noundef %9)\nbr label %14\n\n11:\n%12 = load ptr, ptr %4, align 8\n%13 = call i32 @convert_to_null(ptr noundef %12)\nbr label %14\n\n14:\nret void\n}": {"base_truth": "define internal void @scan_set_error_return(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq i32 %0, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @SCAN_ERROR_EOF, align 4\n%4 = tail call i32 @ZVAL_LONG(ptr noundef %1, i32 noundef %3)\nbr label %B3\n\nB2:\n%5 = tail call i32 @convert_to_null(ptr noundef %1)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @scan_set_error_return(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq i32 %0, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @SCAN_ERROR_EOF, align 4\n%4 = tail call i32 @ZVAL_LONG(ptr noundef %1, i32 noundef %3)\nbr label %B3\n\nB2:\n%5 = tail call i32 @convert_to_null(ptr noundef %1)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @scan_set_error_return(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq i32 %0, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @SCAN_ERROR_EOF, align 4\n%4 = tail call i32 @ZVAL_LONG(ptr noundef %1, i32 noundef %3)\nbr label %B3\n\nB2:\n%5 = tail call i32 @convert_to_null(ptr noundef %1)\nbr label %B3\n\nB3:\nret void\n}"}, "define internal void @devcgroup_destroy(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %4, align 8\n%7 = call ptr @cgroup_to_devcgroup(ptr noundef %6)\nstore ptr %7, ptr %5, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = call i32 @dev_exception_clean(ptr noundef %8)\n%10 = load ptr, ptr %5, align 8\n%11 = call i32 @kfree(ptr noundef %10)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret void\n}": {"base_truth": "define internal void @devcgroup_destroy(ptr nocapture noundef readnone %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @cgroup_to_devcgroup(ptr noundef %1)\n%3 = tail call i32 @dev_exception_clean(ptr noundef %2)\n%4 = tail call i32 @kfree(ptr noundef %2)\nret void\n}", "codellama": "define internal void @devcgroup_destroy(ptr nocapture noundef readnone %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @cgroup_to_devcgroup(ptr noundef %1)\n%3 = tail call i32 @dev_exception_clean(ptr noundef %2)\n%4 = tail call i32 @kfree(ptr noundef %2)\nret void\n}", "codegemma": "define internal void @devcgroup_destroy(ptr nocapture noundef readnone %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @cgroup_to_devcgroup(ptr noundef %1)\n%3 = tail call i32 @dev_exception_clean(ptr noundef %2)\n%4 = tail call i32 @kfree(ptr noundef %2)\nret void\n}"}, "define internal void @check_http_protocol(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr @seaf, align 8\n%4 = getelementptr inbounds %struct.TYPE_8__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.TYPE_7__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = load i32, ptr @FALSE, align 4\n%10 = load i32, ptr @check_http_protocol_done, align 4\n%11 = load ptr, ptr %2, align 8\n%12 = call i64 @http_tx_manager_check_protocol_version(i32 noundef %5, i32 noundef %8, i32 noundef %9, i32 noundef %10, ptr noundef %11)\n%13 = icmp slt i64 %12, 0\nbr i1 %13, label %14, label %18\n\n14:\n%15 = load ptr, ptr %2, align 8\n%16 = load i32, ptr @SYNC_ERROR_ID_NOT_ENOUGH_MEMORY, align 4\n%17 = call i32 @transition_to_error(ptr noundef %15, i32 noundef %16)\nbr label %22\n\n18:\n%19 = load ptr, ptr %2, align 8\n%20 = load i32, ptr @CLONE_STATE_CHECK_SERVER, align 4\n%21 = call i32 @transition_state(ptr noundef %19, i32 noundef %20)\nbr label %22\n\n22:\nret void\n}": {"base_truth": "define internal void @check_http_protocol(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @seaf, align 8\n%2 = load i32, ptr %1, align 4\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @check_http_protocol_done, align 4\n%6 = tail call i64 @http_tx_manager_check_protocol_version(i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef nonnull %0)\n%7 = icmp slt i64 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr @SYNC_ERROR_ID_NOT_ENOUGH_MEMORY, align 4\n%9 = tail call i32 @transition_to_error(ptr noundef nonnull %0, i32 noundef %8)\nbr label %B3\n\nB2:\n%10 = load i32, ptr @CLONE_STATE_CHECK_SERVER, align 4\n%11 = tail call i32 @transition_state(ptr noundef nonnull %0, i32 noundef %10)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @check_http_protocol(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @seaf, align 8\n%2 = load i32, ptr %1, align 4\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @check_http_protocol_done, align 4\n%6 = tail call i64 @http_tx_manager_check_protocol_version(i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef nonnull %0)\n%7 = icmp slt i64 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr @SYNC_ERROR_ID_NOT_ENOUGH_MEMORY, align 4\n%9 = tail call i32 @transition_to_error(ptr noundef nonnull %0, i32 noundef %8)\nbr label %B3\n\nB2:\n%10 = load i32, ptr @CLONE_STATE_CHECK_SERVER, align 4\n%11 = tail call i32 @transition_state(ptr noundef nonnull %0, i32 noundef %10)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @check_http_protocol(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @seaf, align 8\n%2 = load i32, ptr %1, align 4\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @check_http_protocol_done, align 4\n%6 = tail call i64 @http_tx_manager_check_protocol_version(i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef nonnull %0)\n%7 = icmp slt i64 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr @SYNC_ERROR_ID_NOT_ENOUGH_MEMORY, align 4\n%9 = tail call i32 @transition_to_error(ptr noundef nonnull %0, i32 noundef %8)\nbr label %B3\n\nB2:\n%10 = load i32, ptr @CLONE_STATE_CHECK_SERVER, align 4\n%11 = tail call i32 @transition_state(ptr noundef nonnull %0, i32 noundef %10)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local void @memset_good3() {\n%1 = alloca [10 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr %1)\n%2 = getelementptr inbounds [10 x i32], ptr %1, i64 0, i64 0\n%3 = call i32 @memset(ptr noundef %2, i32 noundef 0, i32 noundef 20)\ncall void @llvm.lifetime.end.p0(i64 40, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @memset_good3() {\nB:\n%0 = alloca [10 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\n%1 = call i32 @memset(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 20)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @memset_good3() {\nB:\n%0 = alloca [10 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\n%1 = call i32 @memset(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 20)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @memset_good3() {\nB:\n%0 = alloca [10 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\n%1 = call i32 @memset(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 20)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret void\n}"}, "define dso_local void @print(i32 %0, ptr %1) {\n%3 = alloca %struct.TYPE_7__, align 8\n%4 = alloca i32, align 4\n%5 = getelementptr inbounds { i32, ptr }, ptr %3, i32 0, i32 0\nstore i32 %0, ptr %5, align 8\n%6 = getelementptr inbounds { i32, ptr }, ptr %3, i32 0, i32 1\nstore ptr %1, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 1, ptr %4, align 4\nbr label %7\n\n7:\n%8 = load i32, ptr %4, align 4\n%9 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i32 0, i32 0\n%10 = load i32, ptr %9, align 8\n%11 = icmp sle i32 %8, %10\nbr i1 %11, label %12, label %40\n\n12:\n%13 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i32 0, i32 1\n%14 = load ptr, ptr %13, align 8\n%15 = load i32, ptr %4, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %14, i64 %16\n%18 = getelementptr inbounds %struct.TYPE_6__, ptr %17, i32 0, i32 1\n%19 = getelementptr inbounds %struct.TYPE_5__, ptr %18, i32 0, i32 0\n%20 = load i32, ptr %19, align 4\n%21 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i32 0, i32 1\n%22 = load ptr, ptr %21, align 8\n%23 = load i32, ptr %4, align 4\n%24 = sext i32 %23 to i64\n%25 = getelementptr inbounds %struct.TYPE_6__, ptr %22, i64 %24\n%26 = getelementptr inbounds %struct.TYPE_6__, ptr %25, i32 0, i32 1\n%27 = getelementptr inbounds %struct.TYPE_5__, ptr %26, i32 0, i32 1\n%28 = load i32, ptr %27, align 4\n%29 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i32 0, i32 1\n%30 = load ptr, ptr %29, align 8\n%31 = load i32, ptr %4, align 4\n%32 = sext i32 %31 to i64\n%33 = getelementptr inbounds %struct.TYPE_6__, ptr %30, i64 %32\n%34 = getelementptr inbounds %struct.TYPE_6__, ptr %33, i32 0, i32 0\n%35 = load i32, ptr %34, align 4\n%36 = call i32 @printf(ptr noundef @.str, i32 noundef %20, i32 noundef %28, i32 noundef %35)\nbr label %37\n\n37:\n%38 = load i32, ptr %4, align 4\n%39 = add nsw i32 %38, 1\nstore i32 %39, ptr %4, align 4\nbr label %7\n\n40:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\nret void\n}": {"base_truth": "define dso_local void @print(i32 %0, ptr nocapture readonly %1) {\nB:\n%2 = icmp slt i32 %0, 1\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = add nuw i32 %0, 1\n%4 = zext i32 %3 to i64\nbr label %B2\n\nB2:\n%5 = phi i64 [ 1, %B1 ], [ %13, %B2 ]\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 %5\n%7 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 %5, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 %5, i32 1, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr %6, align 4\n%12 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %8, i32 noundef %10, i32 noundef %11)\n%13 = add nuw nsw i64 %5, 1\n%14 = icmp eq i64 %13, %4\nbr i1 %14, label %B3, label %B2\n\nB3:\nret void\n}", "codellama": "define dso_local void @print(i32 %0, ptr nocapture readonly %1) {\nB:\n%2 = icmp slt i32 %0, 1\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1, i32 1\n%4 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1, i32 1\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%7 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%11 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%12 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%13 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%14 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%15 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%16 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%18 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%19 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%20 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%21 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%22 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%23 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%24 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%25 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%26 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%27 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%28 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%29 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%30 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%31 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%32 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%33 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%34 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%35 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%36 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%37 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%38 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%39 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%40 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%41 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%42 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%43 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%44 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%45 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%46 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%47 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%48 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%49 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%50 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%51 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%52 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%53 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 1\n%54 = getelementptr inbounds</s>", "codegemma": "define dso_local void @print(i32 %0, ptr nocapture readonly %1) {\nB:\n%2 = icmp slt i32 %0, 1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi i64 [ %11, %B1 ], [ 1, %B ]\n%4 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 %3\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 %3, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = load i32, ptr %4, align 4\n%8 = load i32, ptr %5, align 4\n%9 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %6, i32 noundef %8, i32 noundef %7)\n%10 = add nuw nsw i64 %3, 1\n%11 = icmp eq i64 %10, %0\nbr i1 %11, label %B2, label %B1\n\nB2:\nret void\n}"}, "define dso_local void @put_flags_aout(i64 noundef %0) {\n%2 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\n%3 = load i32, ptr @header_aout, align 4\n%4 = load i64, ptr %2, align 8\n%5 = and i64 %4, -9\n%6 = call i32 @N_SET_FLAGS(i32 noundef %3, i64 noundef %5)\nret void\n}": {"base_truth": "define dso_local void @put_flags_aout(i64 noundef %0) {\nB:\n%1 = load i32, ptr @header_aout, align 4\n%2 = and i64 %0, -9\n%3 = tail call i32 @N_SET_FLAGS(i32 noundef %1, i64 noundef %2)\nret void\n}", "codellama": "define dso_local void @put_flags_aout(i64 noundef %0) {\nB:\n%1 = load i32, ptr @header_aout, align 4\n%2 = and i64 %0, -9\n%3 = tail call i32 @N_SET_FLAGS(i32 noundef %1, i64 noundef %2)\nret void\n}", "codegemma": "define dso_local void @put_flags_aout(i64 noundef %0) {\nB:\n%1 = load i32, ptr @header_aout, align 4\n%2 = and i64 %0, -9\n%3 = tail call i32 @N_SET_FLAGS(i32 noundef %1, i64 noundef %2)\nret void\n}"}, "define internal ptr @udl_cmd_buf_alloc_locked(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\nbr label %6\n\n6:\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.udl_softc ptr %7, i32 0, i32 0\n%9 = call ptr @TAILQ_FIRST(ptr noundef %8)\nstore ptr %9, ptr %5, align 8\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %11, label %22\n\n11:\n%12 = load i32, ptr %4, align 4\n%13 = load i32, ptr @M_WAITOK, align 4\n%14 = icmp ne i32 %12, %13\nbr i1 %14, label %15, label %16\n\n15:\nbr label %22\n\n16:\n%17 = load ptr, ptr %3, align 8\n%18 = getelementptr inbounds %struct.udl_softc ptr %17, i32 0, i32 2\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.udl_softc ptr %19, i32 0, i32 1\n%21 = call i32 @cv_wait(ptr noundef %18, ptr noundef %20)\nbr label %6\n\n22:\n%23 = load ptr, ptr %5, align 8\n%24 = icmp ne ptr %23, null\nbr i1 %24, label %25, label %33\n\n25:\n%26 = load ptr, ptr %3, align 8\n%27 = getelementptr inbounds %struct.udl_softc ptr %26, i32 0, i32 0\n%28 = load ptr, ptr %5, align 8\n%29 = load i32, ptr @entry, align 4\n%30 = call i32 @TAILQ_REMOVE(ptr noundef %27, ptr noundef %28, i32 noundef %29)\n%31 = load ptr, ptr %5, align 8\n%32 = getelementptr inbounds %struct.udl_cmd_buf ptr %31, i32 0, i32 0\nstore i64 0, ptr %32, align 8\nbr label %33\n\n33:\n%34 = load ptr, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret ptr %34\n}": {"base_truth": "define internal ptr @udl_cmd_buf_alloc_locked(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @TAILQ_FIRST(ptr noundef %0)\n%3 = icmp eq ptr %2, null\n%4 = load i32, ptr @M_WAITOK, align 4\n%5 = icmp eq i32 %4, %1\n%6 = select i1 %3, i1 %5, i1 false\nbr i1 %6, label %B1, label %B3\n\nB1:\n%7 = getelementptr inbounds %struct.udl_softc, ptr %0, i64 0, i32 2\n%8 = getelementptr inbounds %struct.udl_softc, ptr %0, i64 0, i32 1\nbr label %B2\n\nB2:\n%9 = tail call i32 @cv_wait(ptr noundef nonnull %7, ptr noundef nonnull %8)\n%10 = tail call ptr @TAILQ_FIRST(ptr noundef %0)\n%11 = icmp eq ptr %10, null\n%12 = load i32, ptr @M_WAITOK, align 4\n%13 = icmp eq i32 %12, %1\n%14 = select i1 %11, i1 %13, i1 false\nbr i1 %14, label %B2, label %B3\n\nB3:\n%15 = phi ptr [ %2, %B ], [ %10, %B2 ]\n%16 = phi i1 [ %3, %B ], [ %11, %B2 ]\nbr i1 %16, label %B5, label %B4\n\nB4:\n%17 = load i32, ptr @entry, align 4\n%18 = tail call i32 @TAILQ_REMOVE(ptr noundef %0, ptr noundef nonnull %15, i32 noundef %17)\nstore i64 0, ptr %15, align 8\nbr label %B5\n\nB5:\nret ptr %15\n}", "codellama": "define internal ptr @udl_cmd_buf_alloc_locked(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @TAILQ_FIRST(ptr noundef %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = icmp eq i32 %1, %1\nbr i1 %4, label %B3, label %B2\n\nB2:\n%5 = getelementptr inbounds %struct.udl_softc, ptr %0, i64 0, i32 2\n%6 = getelementptr inbounds %struct.udl_softc, ptr %0, i64 0, i32 1\n%7 = tail call i32 @cv_wait(ptr noundef nonnull %5, ptr noundef nonnull %6)\n%8 = tail call ptr @TAILQ_FIRST(ptr noundef %0)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B1, label %B4\n\nB3:\n%10 = load i32, ptr @entry, align 4\n%11 = tail call i32 @TAILQ_REMOVE(ptr noundef %0, ptr noundef null, i32 noundef %10)\nbr label %B4\n\nB4:\n%12 = phi ptr [ null, %B3 ], [ %2, %B ], [ %8, %B2 ]\nret ptr %12\n}", "codegemma": "define internal ptr @udl_cmd_buf_alloc_locked(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @TAILQ_FIRST(ptr noundef %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B1, label %B3\n\nB1:\n%4 = load i32, ptr @M_WAITOK, align 4\n%5 = icmp eq i32 %4, %1\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = getelementptr inbounds %struct.udl_softc, ptr %0, i64 0, i32 2\n%7 = getelementptr inbounds %struct.udl_softc, ptr %0, i64 0, i32 1\n%8 = tail call i32 @cv_wait(ptr noundef nonnull %6, ptr noundef nonnull %7)\n%9 = tail call ptr @TAILQ_FIRST(ptr noundef %0)\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %B3, label %B4\n\nB3:\nbr label %B5\n\nB4:\n%11 = load i32, ptr @entry, align 4\n%12 = tail call i32 @TAILQ_REMOVE(ptr noundef %0, ptr noundef nonnull %9, i32 noundef %11)\nstore i64 0, ptr %9, align 8\nbr label %B5\n\nB5:\n%13 = phi ptr [ %2, %B3 ], [ %9, %B4 ]\nret ptr %13\n}"}, "define dso_local void @reset_fd_limit() {\nstore i64 0, ptr @fd_limit, align 8\nret void\n}": {"base_truth": "define dso_local void @reset_fd_limit() {\nB:\nstore i64 0, ptr @fd_limit, align 8\nret void\n}", "codellama": "define dso_local void @reset_fd_limit() {\nB:\nstore i64 0, ptr @fd_limit, align 8\nret void\n}", "codegemma": "define dso_local void @reset_fd_limit() {\nB:\nstore i64 0, ptr @fd_limit, align 8\nret void\n}"}, "define internal ptr @create_bounce_buffer(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\n%12 = alloca ptr, align 8\n%13 = alloca ptr, align 8\n%14 = alloca i32, align 4\n%15 = alloca i32, align 4\nstore ptr %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %12)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %13)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %14)\n%16 = load i32, ptr %9, align 4\n%17 = load i32, ptr @WRITE_TYPE, align 4\n%18 = icmp eq i32 %16, %17\nbr i1 %18, label %19, label %20\n\n19:\nbr label %22\n\n20:\n%21 = load i32, ptr @PAGE_SIZE, align 4\nbr label %22\n\n22:\n%23 = phi i32 [ 0, %19 ], [ %21, %20 ]\nstore i32 %23, ptr %14, align 4\n%24 = load i32, ptr %8, align 4\n%25 = load i32, ptr @PAGE_SIZE, align 4\n%26 = call i32 @ALIGN(i32 noundef %24, i32 noundef %25)\n%27 = load i32, ptr @PAGE_SHIFT, align 4\n%28 = ashr i32 %26, %27\nstore i32 %28, ptr %11, align 4\n%29 = load i32, ptr %11, align 4\n%30 = load i32, ptr @GFP_ATOMIC, align 4\n%31 = call ptr @kcalloc(i32 noundef %29, i32 noundef 4, i32 noundef %30)\nstore ptr %31, ptr %12, align 8\n%32 = load ptr, ptr %12, align 8\n%33 = icmp ne ptr %32, null\nbr i1 %33, label %35, label %34\n\n34:\nstore ptr null, ptr %5, align 8\nstore i32 1, ptr %15, align 4\nbr label %66\n\n35:\n%36 = load ptr, ptr %12, align 8\n%37 = load i32, ptr %11, align 4\n%38 = call i32 @sg_init_table(ptr noundef %36, i32 noundef %37)\nstore i32 0, ptr %10, align 4\nbr label %39\n\n39:\n%40 = load i32, ptr %10, align 4\n%41 = load i32, ptr %11, align 4\n%42 = icmp slt i32 %40, %41\nbr i1 %42, label %43, label %60\n\n43:\n%44 = load i32, ptr @GFP_ATOMIC, align 4\n%45 = call ptr @alloc_page(i32 noundef %44)\nstore ptr %45, ptr %13, align 8\n%46 = load ptr, ptr %13, align 8\n%47 = icmp ne ptr %46, null\nbr i1 %47, label %49, label %48\n\n48:\nbr label %62\n\n49:\n%50 = load ptr, ptr %12, align 8\n%51 = load i32, ptr %10, align 4\n%52 = sext i32 %51 to i64\n%53 = getelementptr inbounds %struct.scatterlist, ptr %50, i64 %52\n%54 = load ptr, ptr %13, align 8\n%55 = load i32, ptr %14, align 4\n%56 = call i32 @sg_set_page(ptr noundef %53, ptr noundef %54, i32 noundef %55, i32 noundef 0)\nbr label %57\n\n57:\n%58 = load i32, ptr %10, align 4\n%59 = add nsw i32 %58, 1\nstore i32 %59, ptr %10, align 4\nbr label %39\n\n60:\n%61 = load ptr, ptr %12, align 8\nstore ptr %61, ptr %5, align 8\nstore i32 1, ptr %15, align 4\nbr label %66\n\n62:\n%63 = load ptr, ptr %12, align 8\n%64 = load i32, ptr %11, align 4\n%65 = call i32 @destroy_bounce_buffer(ptr noundef %63, i32 noundef %64)\nstore ptr null, ptr %5, align 8\nstore i32 1, ptr %15, align 4\nbr label %66\n\n66:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %14)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %13)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %12)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\n%67 = load ptr, ptr %5, align 8\nret ptr %67\n}": {"base_truth": "define internal ptr @create_bounce_buffer(ptr nocapture noundef readnone %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr @WRITE_TYPE, align 4\n%5 = icmp eq i32 %4, %3\n%6 = load i32, ptr @PAGE_SIZE, align 4\n%7 = select i1 %5, i32 0, i32 %6\n%8 = tail call i32 @ALIGN(i32 noundef %2, i32 noundef %6)\n%9 = load i32, ptr @PAGE_SHIFT, align 4\n%10 = ashr i32 %8, %9\n%11 = load i32, ptr @GFP_ATOMIC, align 4\n%12 = tail call ptr @kcalloc(i32 noundef %10, i32 noundef 4, i32 noundef %11)\n%13 = icmp eq ptr %12, null\nbr i1 %13, label %B6, label %B1\n\nB1:\n%14 = tail call i32 @sg_init_table(ptr noundef nonnull %12, i32 noundef %10)\n%15 = icmp sgt i32 %10, 0\nbr i1 %15, label %B2, label %B6\n\nB2:\n%16 = zext i32 %10 to i64\nbr label %B3\n\nB3:\n%17 = phi i64 [ 0, %B2 ], [ %23, %B4 ]\n%18 = load i32, ptr @GFP_ATOMIC, align 4\n%19 = tail call ptr @alloc_page(i32 noundef %18)\n%20 = icmp eq ptr %19, null\nbr i1 %20, label %B5, label %B4\n\nB4:\n%21 = getelementptr inbounds %struct.scatterlist, ptr %12, i64 %17\n%22 = tail call i32 @sg_set_page(ptr noundef nonnull %21, ptr noundef nonnull %19, i32 noundef %7, i32 noundef 0)\n%23 = add nuw nsw i64 %17, 1\n%24 = icmp eq i64 %23, %16\nbr i1 %24, label %B6, label %B3\n\nB5:\n%25 = tail call i32 @destroy_bounce_buffer(ptr noundef nonnull %12, i32 noundef %10)\nbr label %B6\n\nB6:\n%26 = phi ptr [ null, %B5 ], [ null, %B ], [ %12, %B1 ], [ %12, %B4 ]\nret ptr %26\n}", "codellama": "define internal ptr @create_bounce_buffer(ptr nocapture noundef readnone %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr @WRITE_TYPE, align 4\n%5 = icmp eq i32 %4, %3\n%6 = load i32, ptr @PAGE_SIZE, align 4\n%7 = select i1 %5, i32 0, i32 %6\n%8 = tail call i32 @ALIGN(i32 noundef %2, i32 noundef %6)\n%9 = load i32, ptr @PAGE_SHIFT, align 4\n%10 = ashr i32 %8, %9\n%11 = load i32, ptr @GFP_ATOMIC, align 4\n%12 = tail call ptr @kcalloc(i32 noundef %10, i32 noundef 4, i32 noundef %11)\n%13 = icmp eq ptr %12, null\nbr i1 %13, label %B5, label %B1\n\nB1:\n%14 = tail call i32 @sg_init_table(ptr noundef nonnull %12, i32 noundef %10)\n%15 = icmp sgt i32 %10, 0\nbr i1 %15, label %B2, label %B5\n\nB2:\n%16 = zext i32 %10 to i64\nbr label %B3\n\nB3:\n%17 = phi i64 [ 0, %B2 ], [ %23, %B4 ]\n%18 = load i32, ptr @GFP_ATOMIC, align 4\n%19 = tail call ptr @alloc_page(i32 noundef %18)\n%20 = icmp eq ptr %19, null\nbr i1 %20, label %B5, label %B4\n\nB4:\n%21 = getelementptr inbounds %struct.scatterlist, ptr %12, i64 %17\n%22 = tail call i32 @sg_set_page(ptr noundef %21, ptr noundef nonnull %19, i32 noundef %7, i32 noundef 0)\n%23 = add nuw nsw i64 %17, 1\n%24 = icmp eq i64 %23, %16\nbr i1 %24, label %B5, label %B3\n\nB5:\n%25 = phi ptr [ null, %B ], [ %12, %B1 ], [ null, %B3 ], [ %12, %B4 ]\n%26 = tail call i32 @destroy_bounce_buffer(ptr noundef %25, i32 noundef %10)\nret ptr %25\n}", "codegemma": "define internal ptr @create_bounce_buffer(ptr nocapture noundef readnone %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr @WRITE_TYPE, align 4\n%5 = icmp eq i32 %4, %3\n%6 = load i32, ptr @PAGE_SIZE, align 4\n%7 = select i1 %5, i32 0, i32 %6\n%8 = tail call i32 @ALIGN(i32 noundef %2, i32 noundef %6)\n%9 = load i32, ptr @PAGE_SHIFT, align 4\n%10 = ashr i32 %8, %9\n%11 = tail call ptr @kcalloc(i32 noundef %10, i32 noundef 4, i32 noundef 0)\n%12 = icmp eq ptr %11, null\nbr i1 %12, label %B5, label %B1\n\nB1:\n%13 = tail call i32 @sg_init_table(ptr noundef nonnull %11, i32 noundef %10)\n%14 = icmp sgt i32 %10, 0\nbr i1 %14, label %B2, label %B5\n\nB2:\n%15 = phi i64 [ %21, %B4 ], [ 0, %B1 ]\n%16 = load i32, ptr @GFP_ATOMIC, align 4\n%17 = tail call ptr @alloc_page(i32 noundef %16)\n%18 = icmp eq ptr %17, null\nbr i1 %18, label %B4, label %B3\n\nB3:\n%19 = getelementptr inbounds %struct.scatterlist, ptr %11, i64 %15\n%20 = tail call i32 @sg_set_page(ptr noundef %19, ptr noundef nonnull %17, i32 noundef %7, i32 noundef 0)\nbr label %B4\n\nB4:\n%21 = add nuw nsw i64 %15, 1\n%22 = icmp eq i64 %21, %10\nbr i1 %22, label %B5, label %B2\n\nB5:\n%23 = phi ptr [ null, %B ], [ %11, %B1 ], [ null, %B4 ]\nret ptr %23\n}"}, "define dso_local i32 @btsnd_hcic_exit_per_inq() {\n%1 = alloca i32, align 4\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%6 = call ptr @HCI_GET_CMD_BUF(i64 noundef %5)\nstore ptr %6, ptr %2, align 8\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %8, label %10\n\n8:\n%9 = load i32, ptr @FALSE, align 4\nstore i32 %9, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %30\n\n10:\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds %struct.TYPE_4__, ptr %11, i64 1\nstore ptr %12, ptr %3, align 8\n%13 = load i64, ptr @HCIC_PREAMBLE_SIZE, align 8\n%14 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%15 = add nsw i64 %13, %14\n%16 = load ptr, ptr %2, align 8\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %16, i32 0, i32 1\nstore i64 %15, ptr %17, align 8\n%18 = load ptr, ptr %2, align 8\n%19 = getelementptr inbounds %struct.TYPE_4__, ptr %18, i32 0, i32 0\nstore i64 0, ptr %19, align 8\n%20 = load ptr, ptr %3, align 8\n%21 = load i32, ptr @HCI_EXIT_PERIODIC_INQUIRY_MODE, align 4\n%22 = call i32 @UINT16_TO_STREAM(ptr noundef %20, i32 noundef %21)\n%23 = load ptr, ptr %3, align 8\n%24 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%25 = call i32 @UINT8_TO_STREAM(ptr noundef %23, i64 noundef %24)\n%26 = load i32, ptr @LOCAL_BR_EDR_CONTROLLER_ID, align 4\n%27 = load ptr, ptr %2, align 8\n%28 = call i32 @btu_hcif_send_cmd(i32 noundef %26, ptr noundef %27)\n%29 = load i32, ptr @TRUE, align 4\nstore i32 %29, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\n%31 = load i32, ptr %1, align 4\nret i32 %31\n}": {"base_truth": "define dso_local i32 @btsnd_hcic_exit_per_inq() {\nB:\n%0 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%1 = tail call ptr @HCI_GET_CMD_BUF(i64 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 1\n%4 = load i64, ptr @HCIC_PREAMBLE_SIZE, align 8\n%5 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%6 = add nsw i64 %5, %4\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 1\nstore i64 %6, ptr %7, align 8\nstore i64 0, ptr %1, align 8\n%8 = load i32, ptr @HCI_EXIT_PERIODIC_INQUIRY_MODE, align 4\n%9 = tail call i32 @UINT16_TO_STREAM(ptr noundef nonnull %3, i32 noundef %8)\n%10 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%11 = tail call i32 @UINT8_TO_STREAM(ptr noundef nonnull %3, i64 noundef %10)\n%12 = load i32, ptr @LOCAL_BR_EDR_CONTROLLER_ID, align 4\n%13 = tail call i32 @btu_hcif_send_cmd(i32 noundef %12, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%14 = phi ptr [ @TRUE, %B1 ], [ @FALSE, %B ]\n%15 = load i32, ptr %14, align 4\nret i32 %15\n}", "codellama": "define dso_local i32 @btsnd_hcic_exit_per_inq() {\nB:\n%0 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%1 = tail call ptr @HCI_GET_CMD_BUF(i64 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 1\n%4 = load i64, ptr @HCIC_PREAMBLE_SIZE, align 8\n%5 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%6 = add nsw i64 %5, %4\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 1\nstore i64 %6, ptr %7, align 8\nstore i64 0, ptr %1, align 8\n%8 = load i32, ptr @HCI_EXIT_PERIODIC_INQUIRY_MODE, align 4\n%9 = tail call i32 @UINT16_TO_STREAM(ptr noundef nonnull %3, i32 noundef %8)\n%10 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%11 = tail call i32 @UINT8_TO_STREAM(ptr noundef nonnull %3, i64 noundef %10)\n%12 = load i32, ptr @LOCAL_BR_EDR_CONTROLLER_ID, align 4\n%13 = tail call i32 @btu_hcif_send_cmd(i32 noundef %12, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%14 = phi ptr [ @TRUE, %B1 ], [ @FALSE, %B ]\n%15 = load i32, ptr %14, align 4\nret i32 %15\n}", "codegemma": "define dso_local i32 @btsnd_hcic_exit_per_inq() {\nB:\n%0 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%1 = tail call ptr @HCI_GET_CMD_BUF(i64 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 1\n%4 = load i64, ptr @HCIC_PREAMBLE_SIZE, align 8\n%5 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%6 = add nsw i64 %5, %4\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 1\nstore i64 %6, ptr %7, align 8\nstore i64 0, ptr %1, align 8\n%8 = load i32, ptr @HCI_EXIT_PERIODIC_INQUIRY_MODE, align 4\n%9 = tail call i32 @UINT16_TO_STREAM(ptr noundef nonnull %3, i32 noundef %8)\n%10 = load i64, ptr @HCIC_PARAM_SIZE_EXIT_PER_INQ, align 8\n%11 = tail call i32 @UINT8_TO_STREAM(ptr noundef nonnull %3, i64 noundef %10)\n%12 = load i32, ptr @LOCAL_BR_EDR_CONTROLLER_ID, align 4\n%13 = tail call i32 @btu_hcif_send_cmd(i32 noundef %12, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%14 = phi ptr [ @TRUE, %B1 ], [ @FALSE, %B ]\n%15 = load i32, ptr %14, align 4\nret i32 %15\n}"}, "define dso_local void @dflush() {\n%1 = call i32 (...) @errflush()\nret void\n}": {"base_truth": "define dso_local void @dflush() {\nB:\n%0 = tail call i32 (...) @errflush()\nret void\n}", "codellama": "define dso_local void @dflush() {\nB:\n%0 = tail call i32 (...) @errflush()\nret void\n}", "codegemma": "define dso_local void @dflush() {\nB:\n%0 = tail call i32 (...) @errflush()\nret void\n}"}, "define dso_local i32 @maxv(i32 %0, ptr %1) {\n%3 = alloca %struct.TYPE_3__, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca double, align 8\n%7 = getelementptr inbounds { i32, ptr }, ptr %3, i32 0, i32 0\nstore i32 %0, ptr %7, align 8\n%8 = getelementptr inbounds { i32, ptr }, ptr %3, i32 0, i32 1\nstore ptr %1, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 -1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%9 = load double, ptr @SHRT_MIN, align 8\nstore double %9, ptr %6, align 8\nstore i32 0, ptr %4, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %4, align 4\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%13 = load i32, ptr %12, align 8\n%14 = icmp slt i32 %11, %13\nbr i1 %14, label %15, label %36\n\n15:\n%16 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 1\n%17 = load ptr, ptr %16, align 8\n%18 = load i32, ptr %4, align 4\n%19 = sext i32 %18 to i64\n%20 = getelementptr inbounds double, ptr %17, i64 %19\n%21 = load double, ptr %20, align 8\n%22 = load double, ptr %6, align 8\n%23 = fcmp fast ogt double %21, %22\nbr i1 %23, label %24, label %32\n\n24:\n%25 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 1\n%26 = load ptr, ptr %25, align 8\n%27 = load i32, ptr %4, align 4\n%28 = sext i32 %27 to i64\n%29 = getelementptr inbounds double, ptr %26, i64 %28\n%30 = load double, ptr %29, align 8\nstore double %30, ptr %6, align 8\n%31 = load i32, ptr %4, align 4\nstore i32 %31, ptr %5, align 4\nbr label %32\n\n32:\nbr label %33\n\n33:\n%34 = load i32, ptr %4, align 4\n%35 = add nsw i32 %34, 1\nstore i32 %35, ptr %4, align 4\nbr label %10\n\n36:\n%37 = load i32, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\nret i32 %37\n}": {"base_truth": "define dso_local i32 @maxv(i32 %0, ptr nocapture readonly %1) {\nB:\n%2 = icmp sgt i32 %0, 0\nbr i1 %2, label %B1, label %B6\n\nB1:\n%3 = load double, ptr @SHRT_MIN, align 8\n%4 = zext i32 %0 to i64\n%5 = and i64 %4, 7\n%6 = icmp ult i32 %0, 8\nbr i1 %6, label %B4, label %B2\n\nB2:\n%7 = and i64 %4, 4294967288\nbr label %B3\n\nB3:\n%8 = phi i64 [ 0, %B2 ], [ %67, %B3 ]\n%9 = phi double [ %3, %B2 ], [ %66, %B3 ]\n%10 = phi i32 [ -1, %B2 ], [ %65, %B3 ]\n%11 = phi i64 [ 0, %B2 ], [ %68, %B3 ]\n%12 = getelementptr inbounds double, ptr %1, i64 %8\n%13 = load double, ptr %12, align 8\n%14 = fcmp fast ogt double %13, %9\n%15 = trunc i64 %8 to i32\n%16 = select i1 %14, i32 %15, i32 %10\n%17 = select i1 %14, double %13, double %9\n%18 = or i64 %8, 1\n%19 = getelementptr inbounds double, ptr %1, i64 %18\n%20 = load double, ptr %19, align 8\n%21 = fcmp fast ogt double %20, %17\n%22 = trunc i64 %18 to i32\n%23 = select i1 %21, i32 %22, i32 %16\n%24 = select i1 %21, double %20, double %17\n%25 = or i64 %8, 2\n%26 = getelementptr inbounds double, ptr %1, i64 %25\n%27 = load double, ptr %26, align 8\n%28 = fcmp fast ogt double %27, %24\n%29 = trunc i64 %25 to i32\n%30 = select i1 %28, i32 %29, i32 %23\n%31 = select i1 %28, double %27, double %24\n%32 = or i64 %8, 3\n%33 = getelementptr inbounds double, ptr %1, i64 %32\n%34 = load double, ptr %33, align 8\n%35 = fcmp fast ogt double %34, %31\n%36 = trunc i64 %32 to i32\n%37 = select i1 %35, i32 %36, i32 %30\n%38 = select i1 %35, double %34, double %31\n%39 = or i64 %8, 4\n%40 = getelementptr inbounds double, ptr %1, i64 %39\n%41 = load double, ptr %40, align 8\n%42 = fcmp fast ogt double %41, %38\n%43 = trunc i64 %39 to i32\n%44 = select i1 %42, i32 %43, i32 %37\n%45 = select i1 %42, double %41, double %38\n%46 = or i64 %8, 5\n%47 = getelementptr inbounds double, ptr %1, i64 %46\n%48 = load double, ptr %47, align 8\n%49 = fcmp fast ogt double %48, %45\n%50 = trunc i64 %46 to i32\n%51 = select i1 %49, i32 %50, i32 %44\n%52 = select i1 %49, double %48, double %45\n%53 = or i64 %8, 6\n%54 = getelementptr inbounds double, ptr %1, i64 %53\n%55 = load double, ptr %54, align 8\n%56 = fcmp fast ogt double %55, %52\n%57 = trunc i64 %53 to i32\n%58 = select i1 %56, i32 %57, i32 %51\n%59 = select i1 %56, double %55, double %52\n%60 = or i64 %8, 7\n%61 = getelementptr inbounds double, ptr %1, i64 %60\n%62 = load double, ptr %61, align 8\n%63 = fcmp fast ogt double %62, %59\n%64 = trunc i64 %60 to i32\n%65 = select i1 %63, i32 %64, i32 %58\n%66 = select i1 %63, double %62, double %59\n%67 = add nuw nsw i64 %8, 8\n%68 = add i64 %11, 8\n%69 = icmp eq i64 %68, %7\nbr i1 %69, label %B4, label %B3\n\nB4:\n%70 = phi i32 [ undef, %B1 ], [ %65, %B3 ]\n%71 = phi i64 [ 0, %B1 ], [ %67, %B3 ]\n%72 = phi double [ %3, %B1 ], [ %66, %B3 ]\n%73 = phi i32 [ -1, %B1 ], [ %65, %B3 ]\n%74 = icmp eq i64 %5, 0\nbr i1 %74, label %B6, label %B5\n\nB5:\n%75 = phi i64 [ %85, %B5 ], [ %71, %B4 ]\n%76 = phi double [ %84, %B5 ], [ %72, %B4 ]\n%77 = phi i32 [ %83, %B5 ], [ %73, %B4 ]\n%78 = phi i64 [ %86, %B5 ], [ 0, %B4 ]\n%79 = getelementptr inbounds double, ptr %1, i64 %75\n%80 = load double, ptr %79, align 8\n%81 = fcmp fast ogt double %80, %76\n%82 = trunc i64 %75 to i32\n%83 = select i1 %81, i32 %82, i32 %77\n%84 = select i1 %81, double %80, double %76\n%85 = add nuw nsw i64 %75, 1\n%86 = add i64 %78, 1\n%87 = icmp eq i64 %86, %5\nbr i1 %87, label %B6, label %B5\n\nB6:\n%88 = phi i32 [ -1, %B ], [ %70, %B4 ], [ %83, %B5 ]\nret i32 %88\n}", "codellama": "define dso_local i32 @maxv(i32 %0, ptr nocapture readonly %1) {\nB:\n%2 = icmp sgt i32 %0, 0\nbr i1 %2, label %B1, label %B5\n\nB1:\n%3 = load double, ptr @SHRT_MIN, align 8\n%4 = zext i32 %0 to i64\nbr label %B2\n\nB2:\n%5 = phi i64 [ 0, %B1 ], [ %12, %B4 ]\n%6 = phi double [ %3, %B1 ], [ %10, %B4 ]\n%7 = phi i32 [ -1, %B1 ], [ %11, %B4 ]\n%8 = getelementptr inbounds double, ptr %1, i64 %5\n%9 = load double, ptr %8, align 8\n%10 = fcmp fast ogt double %9, %6\n%11 = trunc i64 %5 to i32\n%12 = add nuw nsw i64 %5, 1\n%13 = icmp eq i64 %12, %4\nbr i1 %10, label %B3, label %B4\n\nB3:\n%14 = select i1 %10, i32 %7, i32 %11\nbr label %B5\n\nB4:\n%15 = fcmp fast ogt double %9, %6\n%16 = select i1 %15, i32 %11, i32 %7\n%17 = select i1 %15, double %9, double %6\nbr label %B2\n\nB5:\n%18 = phi i32 [ -1, %B ], [ %14, %B3 ], [ %7, %B4 ]\nret i32 %18\n}", "codegemma": "define dso_local i32 @maxv(i32 %0, ptr nocapture readonly %1) {\nB:\n%2 = icmp sgt i32 %0, 0\nbr i1 %2, label %B1, label %B3\n\nB1:\n%3 = load double, ptr @SHRT_MIN, align 8\n%4 = zext i32 %0 to i64\nbr label %B2\n\nB2:\n%5 = phi i64 [ 0, %B1 ], [ %11, %B2 ]\n%6 = phi double [ %3, %B1 ], [ %10, %B2 ]\n%7 = phi i32 [ -1, %B1 ], [ %9, %B2 ]\n%8 = getelementptr inbounds double, ptr %1, i64 %5\n%9 = load double, ptr %8, align 8\n%10 = fcmp fast ogt double %9, %6\n%11 = select i1 %10, i64 %5, i64 %7\n%12 = icmp eq i64 %11, %4\nbr i1 %12, label %B3, label %B2\n\nB3:\n%13 = phi i32 [ -1, %B ], [ %9, %B2 ]\nret i32 %13\n}"}, "define dso_local i32 @xmlCopyProp(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @xmlCopyPropInternal(ptr noundef null, i32 noundef %5, i32 noundef %6)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @xmlCopyProp(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @xmlCopyPropInternal(ptr noundef null, i32 noundef %0, i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @xmlCopyProp(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @xmlCopyPropInternal(ptr noundef null, i32 noundef %0, i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @xmlCopyProp(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @xmlCopyPropInternal(ptr noundef null, i32 noundef %0, i32 noundef %1)\nret i32 %2\n}"}, "define dso_local i32 @rtl92s_phy_mac_config(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%7 = load ptr, ptr %2, align 8\n%8 = call ptr @rtl_priv(ptr noundef %7)\nstore ptr %8, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%9 = load i32, ptr @MAC_2T_ARRAYLENGTH, align 4\nstore i32 %9, ptr %5, align 4\n%10 = load ptr, ptr @rtl8192semac_2t_array, align 8\nstore ptr %10, ptr %6, align 8\nstore i32 0, ptr %4, align 4\nbr label %11\n\n11:\n%12 = load i32, ptr %4, align 4\n%13 = load i32, ptr %5, align 4\n%14 = icmp slt i32 %12, %13\nbr i1 %14, label %15, label %32\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = load ptr, ptr %6, align 8\n%18 = load i32, ptr %4, align 4\n%19 = sext i32 %18 to i64\n%20 = getelementptr inbounds i32, ptr %17, i64 %19\n%21 = load i32, ptr %20, align 4\n%22 = load ptr, ptr %6, align 8\n%23 = load i32, ptr %4, align 4\n%24 = add nsw i32 %23, 1\n%25 = sext i32 %24 to i64\n%26 = getelementptr inbounds i32, ptr %22, i64 %25\n%27 = load i32, ptr %26, align 4\n%28 = call i32 @rtl_write_byte(ptr noundef %16, i32 noundef %21, i32 noundef %27)\nbr label %29\n\n29:\n%30 = load i32, ptr %4, align 4\n%31 = add nsw i32 %30, 2\nstore i32 %31, ptr %4, align 4\nbr label %11\n\n32:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 1\n}": {"base_truth": "define dso_local i32 @rtl92s_phy_mac_config(ptr noundef %0) {\nB:\n%1 = tail call ptr @rtl_priv(ptr noundef %0)\n%2 = load i32, ptr @MAC_2T_ARRAYLENGTH, align 4\n%3 = load ptr, ptr @rtl8192semac_2t_array, align 8\n%4 = icmp sgt i32 %2, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = phi i64 [ %12, %B1 ], [ 0, %B ]\n%6 = getelementptr inbounds i32, ptr %3, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = or i64 %5, 1\n%9 = getelementptr inbounds i32, ptr %3, i64 %8\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %7, i32 noundef %10)\n%12 = add nuw i64 %5, 2\n%13 = trunc i64 %12 to i32\n%14 = icmp sgt i32 %2, %13\nbr i1 %14, label %B1, label %B2\n\nB2:\nret i32 1\n}", "codellama": "define dso_local i32 @rtl92s_phy_mac_config(ptr noundef %0) {\nB:\n%1 = tail call ptr @rtl_priv(ptr noundef %0)\n%2 = load i32, ptr @MAC_2T_ARRAYLENGTH, align 4\n%3 = load ptr, ptr @rtl8192semac_2t_array, align 8\n%4 = icmp sgt i32 %2, 0\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = zext i32 %2 to i64\nbr label %B2\n\nB2:\n%6 = phi i64 [ 0, %B1 ], [ %15, %B2 ]\n%7 = getelementptr inbounds i32, ptr %3, i64 %6\n%8 = load i32, ptr %7, align 4\n%9 = or i64 %6, 1\n%10 = getelementptr inbounds i32, ptr %3, i64 %9\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %8, i32 noundef %11)\n%13 = add nuw nsw i64 %6, 2\n%14 = icmp ult i64 %13, %5\n%15 = add nuw nsw i64 %6, 2\nbr i1 %14, label %B2, label %B3\n\nB3:\nret i32 1\n}", "codegemma": "define dso_local i32 @rtl92s_phy_mac_config(ptr noundef %0) {\nB:\n%1 = tail call ptr @rtl_priv(ptr noundef %0)\n%2 = load i32, ptr @MAC_2T_ARRAYLENGTH, align 4\n%3 = load ptr, ptr @rtl8192semac_2t_array, align 8\n%4 = icmp sgt i32 %2, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = phi i64 [ %10, %B1 ], [ 0, %B ]\n%6 = getelementptr inbounds i32, ptr %3, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = add nuw nsw i64 %5, 1\n%9 = getelementptr inbounds i32, ptr %3, i64 %8\n%10 = add nuw nsw i64 %5, 2\n%11 = load i32, ptr %9, align 4\n%12 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %7, i32 noundef %11)\n%13 = icmp eq i64 %10, %2\nbr i1 %13, label %B2, label %B1\n\nB2:\nret i32 1\n}"}, "define internal ptr @ListItem(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i64, align 8\n%7 = alloca i64, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\n%12 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%13 = load ptr, ptr %5, align 8\n%14 = call i64 @PyInt_Check(ptr noundef %13)\n%15 = icmp ne i64 %14, 0\nbr i1 %15, label %16, label %22\n\n16:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%17 = load ptr, ptr %5, align 8\n%18 = call i64 @PyInt_AsLong(ptr noundef %17)\nstore i64 %18, ptr %6, align 8\n%19 = load ptr, ptr %4, align 8\n%20 = load i64, ptr %6, align 8\n%21 = call ptr @ListIndex(ptr noundef %19, i64 noundef %20)\nstore ptr %21, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\nbr label %53\n\n22:\n%23 = load ptr, ptr %5, align 8\n%24 = call i64 @PyLong_Check(ptr noundef %23)\n%25 = icmp ne i64 %24, 0\nbr i1 %25, label %26, label %32\n\n26:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%27 = load ptr, ptr %5, align 8\n%28 = call i64 @PyLong_AsLong(ptr noundef %27)\nstore i64 %28, ptr %7, align 8\n%29 = load ptr, ptr %4, align 8\n%30 = load i64, ptr %7, align 8\n%31 = call ptr @ListIndex(ptr noundef %29, i64 noundef %30)\nstore ptr %31, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nbr label %53\n\n32:\n%33 = load ptr, ptr %5, align 8\n%34 = call i64 @PySlice_Check(ptr noundef %33)\n%35 = icmp ne i64 %34, 0\nbr i1 %35, label %36, label %50\n\n36:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\n%37 = load ptr, ptr %5, align 8\n%38 = load ptr, ptr %4, align 8\n%39 = call i32 @ListLength(ptr noundef %38)\n%40 = call i64 @PySlice_GetIndicesEx(ptr noundef %37, i32 noundef %39, ptr noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef %11)\n%41 = icmp slt i64 %40, 0\nbr i1 %41, label %42, label %43\n\n42:\nstore ptr null, ptr %3, align 8\nstore i32 1, ptr %12, align 4\nbr label %49\n\n43:\n%44 = load ptr, ptr %4, align 8\n%45 = load i32, ptr %8, align 4\n%46 = load i32, ptr %10, align 4\n%47 = load i32, ptr %11, align 4\n%48 = call ptr @ListSlice(ptr noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef %47)\nstore ptr %48, ptr %3, align 8\nstore i32 1, ptr %12, align 4\nbr label %49\n\n49:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\nbr label %53\n\n50:\n%51 = load ptr, ptr %5, align 8\n%52 = call i32 @RAISE_INVALID_INDEX_TYPE(ptr noundef %51)\nstore ptr null, ptr %3, align 8\nbr label %53\n\n53:\n%54 = load ptr, ptr %3, align 8\nret ptr %54\n}": {"base_truth": "define internal ptr @ListItem(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = tail call i64 @PyInt_Check(ptr noundef %1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = tail call i64 @PyInt_AsLong(ptr noundef %1)\n%9 = tail call ptr @ListIndex(ptr noundef %0, i64 noundef %8)\nbr label %B9\n\nB2:\n%10 = tail call i64 @PyLong_Check(ptr noundef %1)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B4, label %B3\n\nB3:\n%12 = tail call i64 @PyLong_AsLong(ptr noundef %1)\n%13 = tail call ptr @ListIndex(ptr noundef %0, i64 noundef %12)\nbr label %B9\n\nB4:\n%14 = tail call i64 @PySlice_Check(ptr noundef %1)\n%15 = icmp eq i64 %14, 0\nbr i1 %15, label %B8, label %B5\n\nB5:\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)\n%16 = tail call i32 @ListLength(ptr noundef %0)\n%17 = call i64 @PySlice_GetIndicesEx(ptr noundef %1, i32 noundef %16, ptr noundef nonnull %2, ptr noundef nonnull %3, ptr noundef nonnull %4, ptr noundef nonnull %5)\n%18 = icmp slt i64 %17, 0\nbr i1 %18, label %B7, label %B6\n\nB6:\n%19 = load i32, ptr %2, align 4\n%20 = load i32, ptr %4, align 4\n%21 = load i32, ptr %5, align 4\n%22 = call ptr @ListSlice(ptr noundef %0, i32 noundef %19, i32 noundef %20, i32 noundef %21)\nbr label %B7\n\nB7:\n%23 = phi ptr [ %22, %B6 ], [ null, %B5 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nbr label %B9\n\nB8:\n%24 = tail call i32 @RAISE_INVALID_INDEX_TYPE(ptr noundef %1)\nbr label %B9\n\nB9:\n%25 = phi ptr [ %9, %B1 ], [ %13, %B3 ], [ %23, %B7 ], [ null, %B8 ]\nret ptr %25\n}", "codellama": "define internal ptr @ListItem(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = tail call i64 @PyInt_Check(ptr noundef %1)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = tail call i64 @PyInt_AsLong(ptr noundef %1)\n%8 = tail call ptr @ListIndex(ptr noundef %0, i64 noundef %7)\nbr label %B9\n\nB2:\n%9 = tail call i64 @PyLong_Check(ptr noundef %1)\n%10 = icmp eq i64 %9, 0\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i64 @PyLong_AsLong(ptr noundef %1)\n%12 = tail call ptr @ListIndex(ptr noundef %0, i64 noundef %11)\nbr label %B9\n\nB4:\n%13 = tail call i64 @PySlice_Check(ptr noundef %1)\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %B8, label %B5\n\nB5:\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)\n%15 = tail call i32 @ListLength(ptr noundef %0)\n%16 = call i64 @PySlice_GetIndicesEx(ptr noundef %1, i32 noundef %15, ptr noundef nonnull %2, ptr noundef nonnull %3, ptr noundef nonnull %4, ptr noundef nonnull %5)\n%17 = icmp slt i64 %16, 0\nbr i1 %17, label %B7, label %B6\n\nB6:\n%18 = load i32, ptr %2, align 4\n%19 = load i32, ptr %4, align 4\n%20 = load i32, ptr %5, align 4\n%21 = call ptr @ListSlice(ptr noundef %0, i32 noundef %18, i32 noundef %19, i32 noundef %20)\nbr label %B7\n\nB7:\n%22 = phi ptr [ %21, %B6 ], [ null, %B5 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nbr label %B9\n\nB8:\n%23 = tail call i32 @RAISE_INVALID_INDEX_TYPE(ptr noundef %1)\nbr label %B9\n\nB9:\n%24 = phi ptr [ %8, %B1 ], [ %12, %B3 ], [ null, %B8 ], [ %22, %B7 ]\nret ptr %24\n}", "codegemma": "define internal ptr @ListItem(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = alloca i64, align 8\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = tail call i64 @PyInt_Check(ptr noundef %1)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = tail call i64 @PyInt_AsLong(ptr noundef %1)\n%11 = tail call ptr @ListIndex(ptr noundef %0, i64 noundef %10)\nbr label %B10\n\nB2:\n%12 = tail call i64 @PyLong_Check(ptr noundef %1)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %B4, label %B3\n\nB3:\n%14 = tail call i64 @PyLong_AsLong(ptr noundef %1)\n%15 = tail call ptr @ListIndex(ptr noundef %0, i64 noundef %14)\nbr label %B10\n\nB4:\n%16 = tail call i64 @PySlice_Check(ptr noundef %1)\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B8, label %B5\n\nB5:\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)\n%18 = tail call i32 @ListLength(ptr noundef %0)\n%19 = call i64 @PySlice_GetIndicesEx(ptr noundef %1, i32 noundef %18, ptr noundef nonnull %2, ptr noundef nonnull %3, ptr noundef nonnull %4, ptr noundef nonnull %7)\n%20 = icmp slt i64 %19, 0\nbr i1 %20, label %B7, label %B6\n\nB6:\n%21 = load i32, ptr %2, align 8\n%22 = load i32, ptr %4, align 4\n%23 = load i32, ptr %7, align 4\n%24 = call ptr @ListSlice(ptr noundef %0, i32 noundef %21, i32 noundef %22, i32 noundef %23)\nbr label %B7\n\nB7:\n%25 = phi ptr [ %24, %B6 ], [ null, %B5 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nbr label %B10\n\nB8:\n%26 = call i32 @RAISE_INVALID_INDEX_TYPE(ptr noundef %1)\nbr label %B10\n\nB9:\n%27 = call i32 @RAISE_INVALID_INDEX_TYPE(ptr noundef %1)\nbr label %B10\n\nB10:\n%28 = phi ptr [ %15<eos>"}, "define internal void @msdc_set_buswidth(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.msdc_host ptr %6, i32 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = load i64, ptr @SDC_CFG, align 8\n%10 = add nsw i64 %8, %9\n%11 = call i32 @readl(i64 noundef %10)\nstore i32 %11, ptr %5, align 4\n%12 = load i32, ptr @SDC_CFG_BUSWIDTH, align 4\n%13 = xor i32 %12, -1\n%14 = load i32, ptr %5, align 4\n%15 = and i32 %14, %13\nstore i32 %15, ptr %5, align 4\n%16 = load i32, ptr %4, align 4\nswitch i32 %16, label %17 [\ni32 130, label %18\ni32 129, label %23\ni32 128, label %28\n]\n\n17:\nbr label %18\n\n18:\n%19 = load i32, ptr @MSDC_BUS_1BITS, align 4\n%20 = shl i32 %19, 16\n%21 = load i32, ptr %5, align 4\n%22 = or i32 %21, %20\nstore i32 %22, ptr %5, align 4\nbr label %33\n\n23:\n%24 = load i32, ptr @MSDC_BUS_4BITS, align 4\n%25 = shl i32 %24, 16\n%26 = load i32, ptr %5, align 4\n%27 = or i32 %26, %25\nstore i32 %27, ptr %5, align 4\nbr label %33\n\n28:\n%29 = load i32, ptr @MSDC_BUS_8BITS, align 4\n%30 = shl i32 %29, 16\n%31 = load i32, ptr %5, align 4\n%32 = or i32 %31, %30\nstore i32 %32, ptr %5, align 4\nbr label %33\n\n33:\n%34 = load i32, ptr %5, align 4\n%35 = load ptr, ptr %3, align 8\n%36 = getelementptr inbounds %struct.msdc_host ptr %35, i32 0, i32 1\n%37 = load i64, ptr %36, align 8\n%38 = load i64, ptr @SDC_CFG, align 8\n%39 = add nsw i64 %37, %38\n%40 = call i32 @writel(i32 noundef %34, i64 noundef %39)\n%41 = load ptr, ptr %3, align 8\n%42 = getelementptr inbounds %struct.msdc_host ptr %41, i32 0, i32 0\n%43 = load i32, ptr %42, align 8\n%44 = load i32, ptr %4, align 4\n%45 = call i32 @dev_dbg(i32 noundef %43, ptr noundef @.str, i32 noundef %44)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @msdc_set_buswidth(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.msdc_host, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = load i64, ptr @SDC_CFG, align 8\n%5 = add nsw i64 %4, %3\n%6 = tail call i32 @readl(i64 noundef %5)\n%7 = load i32, ptr @SDC_CFG_BUSWIDTH, align 4\n%8 = icmp eq i32 %1, 129\n%9 = icmp eq i32 %1, 128\n%10 = xor i32 %7, -1\n%11 = and i32 %6, %10\n%12 = load i32, ptr @MSDC_BUS_8BITS, align 4\n%13 = load i32, ptr @MSDC_BUS_4BITS, align 4\n%14 = load i32, ptr @MSDC_BUS_1BITS, align 4\n%15 = select i1 %8, i32 %13, i32 %14\n%16 = select i1 %9, i32 %12, i32 %15\n%17 = shl i32 %16, 16\n%18 = or i32 %17, %11\n%19 = load i64, ptr %2, align 8\n%20 = load i64, ptr @SDC_CFG, align 8\n%21 = add nsw i64 %20, %19\n%22 = tail call i32 @writel(i32 noundef %18, i64 noundef %21)\n%23 = load i32, ptr %0, align 8\n%24 = tail call i32 @dev_dbg(i32 noundef %23, ptr noundef nonnull @.str, i32 noundef %1)\nret void\n}", "codellama": "define internal void @msdc_set_buswidth(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.msdc_host, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = load i64, ptr @SDC_CFG, align 8\n%5 = add nsw i64 %4, %3\n%6 = tail call i32 @readl(i64 noundef %5)\n%7 = load i32, ptr @SDC_CFG_BUSWIDTH, align 4\n%8 = xor i32 %7, -1\n%9 = and i32 %6, %8\nswitch i32 %1, label %B4 [\ni32 130, label %B1\ni32 129, label %B2\ni32 128, label %B3\n]\n\nB1:\n%10 = load i32, ptr @MSDC_BUS_1BITS, align 4\n%11 = shl i32 %10, 16\nbr label %B4\n\nB2:\n%12 = load i32, ptr @MSDC_BUS_4BITS, align 4\n%13 = shl i32 %12, 16\nbr label %B4\n\nB3:\n%14 = load i32, ptr @MSDC_BUS_8BITS, align 4\n%15 = shl i32 %14, 16\nbr label %B4\n\nB4:\n%16 = phi i32 [ %9, %B ], [ %9, %B3 ], [ %9, %B2 ], [ %15, %B1 ]\n%17 = phi i32 [ 0, %B ], [ %13, %B2 ], [ %11, %B1 ], [ %15, %B3 ]\n%18 = or i32 %16, %17\n%19 = load i64, ptr %2, align 8\n%20 = load i64, ptr @SDC_CFG, align 8\n%21 = add nsw i64 %20, %19\n%22 = tail call i32 @writel(i32 noundef %18, i64 noundef %21)\n%23 = load i32, ptr %0, align 8\n%24 = tail call i32 @dev_dbg(i32 noundef %23, ptr noundef nonnull @.str, i32 noundef %1)\nret void\n}", "codegemma": "define internal void @msdc_set_buswidth(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.msdc_host, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = load i64, ptr @SDC_CFG, align 8\n%5 = add nsw i64 %4, %3\n%6 = tail call i32 @readl(i64 noundef %5)\n%7 = load i32, ptr @SDC_CFG_BUSWIDTH, align 4\n%8 = xor i32 %7, -1\n%9 = and i32 %6, %8\n%10 = add i32 %1, -128\n%11 = icmp ult i32 %10, 3\nbr i1 %11, label %B1, label %B2\n\nB1:\n%12 = sext i32 %10 to i64\n%13 = getelementptr inbounds [3 x i32], ptr @switch.table.msdc_set_buswidth, i64 0, i64 %12\n%14 = load i32, ptr %13, align 4\n%15 = shl i32 %14, 16\n%16 = or i32 %15, %9\nbr label %B2\n\nB2:\n%17 = phi i32 [ %16, %B1 ], [ %9, %B ]\n%18 = load i64, ptr %2, align 8\n%19 = load i64, ptr @SDC_CFG, align 8\n%20 = add nsw i64 %19, %18\n%21 = tail call i32 @writel(i32 noundef %17, i64 noundef %20)\n%22 = load i32, ptr %0, align 8\n%23 = tail call i32 @dev_dbg(i32 noundef %22, ptr noundef nonnull @.str, i32 noundef %1)\nret void\n}"}, "define dso_local i32 @is_piece(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %4, align 4\n%8 = icmp slt i32 %7, 19\nbr i1 %8, label %9, label %23\n\n9:\n%10 = load ptr, ptr %3, align 8\n%11 = load ptr, ptr @g_blockdefine, align 8\n%12 = load i32, ptr %4, align 4\n%13 = sext i32 %12 to i64\n%14 = getelementptr inbounds i32, ptr %11, i64 %13\n%15 = load i32, ptr %14, align 4\n%16 = call i32 @ft_strcmp(ptr noundef %10, i32 noundef %15)\n%17 = icmp ne i32 %16, 0\nbr i1 %17, label %20, label %18\n\n18:\n%19 = load i32, ptr %4, align 4\nstore i32 %19, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n20:\n%21 = load i32, ptr %4, align 4\n%22 = add nsw i32 %21, 1\nstore i32 %22, ptr %4, align 4\nbr label %6\n\n23:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n24:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%25 = load i32, ptr %2, align 4\nret i32 %25\n}": {"base_truth": "define dso_local i32 @is_piece(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @g_blockdefine, align 8\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B19, label %B1\n\nB1:\n%5 = load ptr, ptr @g_blockdefine, align 8\n%6 = getelementptr inbounds i32, ptr %5, i64 1\n%7 = load i32, ptr %6, align 4\n%8 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %7)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B19, label %B2\n\nB2:\n%10 = load ptr, ptr @g_blockdefine, align 8\n%11 = getelementptr inbounds i32, ptr %10, i64 2\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %12)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B19, label %B3\n\nB3:\n%15 = load ptr, ptr @g_blockdefine, align 8\n%16 = getelementptr inbounds i32, ptr %15, i64 3\n%17 = load i32, ptr %16, align 4\n%18 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %17)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B19, label %B4\n\nB4:\n%20 = load ptr, ptr @g_blockdefine, align 8\n%21 = getelementptr inbounds i32, ptr %20, i64 4\n%22 = load i32, ptr %21, align 4\n%23 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %22)\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %B19, label %B5\n\nB5:\n%25 = load ptr, ptr @g_blockdefine, align 8\n%26 = getelementptr inbounds i32, ptr %25, i64 5\n%27 = load i32, ptr %26, align 4\n%28 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %27)\n%29 = icmp eq i32 %28, 0\nbr i1 %29, label %B19, label %B6\n\nB6:\n%30 = load ptr, ptr @g_blockdefine, align 8\n%31 = getelementptr inbounds i32, ptr %30, i64 6\n%32 = load i32, ptr %31, align 4\n%33 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %32)\n%34 = icmp eq i32 %33, 0\nbr i1 %34, label %B19, label %B7\n\nB7:\n%35 = load ptr, ptr @g_blockdefine, align 8\n%36 = getelementptr inbounds i32, ptr %35, i64 7\n%37 = load i32, ptr %36, align 4\n%38 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %37)\n%39 = icmp eq i32 %38, 0\nbr i1 %39, label %B19, label %B8\n\nB8:\n%40 = load ptr, ptr @g_blockdefine, align 8\n%41 = getelementptr inbounds i32, ptr %40, i64 8\n%42 = load i32, ptr %41, align 4\n%43 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %42)\n%44 = icmp eq i32 %43, 0\nbr i1 %44, label %B19, label %B9\n\nB9:\n%45 = load ptr, ptr @g_blockdefine, align 8\n%46 = getelementptr inbounds i32, ptr %45, i64 9\n%47 = load i32, ptr %46, align 4\n%48 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %47)\n%49 = icmp eq i32 %48, 0\nbr i1 %49, label %B19, label %B10\n\nB10:\n%50 = load ptr, ptr @g_blockdefine, align 8\n%51 = getelementptr inbounds i32, ptr %50, i64 10\n%52 = load i32, ptr %51, align 4\n%53 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %52)\n%54 = icmp eq i32 %53, 0\nbr i1 %54, label %B19, label %B11\n\nB11:\n%55 = load ptr, ptr @g_blockdefine, align 8\n%56 = getelementptr inbounds i32, ptr %55, i64 11\n%57 = load i32, ptr %56, align 4\n%58 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %57)\n%59 = icmp eq i32 %58, 0\nbr i1 %59, label %B19, label %B12\n\nB12:\n%60 = load ptr, ptr @g_blockdefine, align 8\n%61 = getelementptr inbounds i32, ptr %60, i64 12\n%62 = load i32, ptr %61, align 4\n%63 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %62)\n%64 = icmp eq i32 %63, 0\nbr i1 %64, label %B19, label %B13\n\nB13:\n%65 = load ptr, ptr @g_blockdefine, align 8\n%66 = getelementptr inbounds i32, ptr %65, i64 13\n%67 = load i32, ptr %66, align 4\n%68 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %67)\n%69 = icmp eq i32 %68, 0\nbr i1 %69, label %B19, label %B14\n\nB14:\n%70 = load ptr, ptr @g_blockdefine, align 8\n%71 = getelementptr inbounds i32, ptr %70, i64 14\n%72 = load i32, ptr %71, align 4\n%73 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %72)\n%74 = icmp eq i32 %73, 0\nbr i1 %74, label %B19, label %B15\n\nB15:\n%75 = load ptr, ptr @g_blockdefine, align 8\n%76 = getelementptr inbounds i32, ptr %75, i64 15\n%77 = load i32, ptr %76, align 4\n%78 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %77)\n%79 = icmp eq i32 %78, 0\nbr i1 %79, label %B19, label %B16\n\nB16:\n%80 = load ptr, ptr @g_blockdefine, align 8\n%81 = getelementptr inbounds i32, ptr %80, i64 16\n%82 = load i32, ptr %81, align 4\n%83 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %82)\n%84 = icmp eq i32 %83, 0\nbr i1 %84, label %B19, label %B17\n\nB17:\n%85 = load ptr, ptr @g_blockdefine, align 8\n%86 = getelementptr inbounds i32, ptr %85, i64 17\n%87 = load i32, ptr %86, align 4\n%88 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %87)\n%89 = icmp eq i32 %88, 0\nbr i1 %89, label %B19, label %B18\n\nB18:\n%90 = load ptr, ptr @g_blockdefine, align 8\n%91 = getelementptr inbounds i32, ptr %90, i64 18\n%92 = load i32, ptr %91, align 4\n%93 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %92)\n%94 = icmp eq i32 %93, 0\nbr i1 %94, label %B19, label %B20\n\nB19:\n%95 = phi i32 [ 0, %B ], [ 1, %B1 ], [ 2, %B2 ], [ 3, %B3 ], [ 4, %B4 ], [ 5, %B5 ], [ 6, %B6 ], [ 7, %B7 ], [ 8, %B8 ], [ 9, %B9 ], [ 10, %B10 ], [ 11, %B11 ], [ 12, %B12 ], [ 13, %B13 ], [ 14, %B14 ], [ 15, %B15 ], [ 16, %B16 ], [ 17, %B17 ], [ 18, %B18 ]\nbr label %B20\n\nB20:\n%96 = phi i32 [ %95, %B19 ], [ -1, %B18 ]\nret i32 %96\n}", "codellama": "define dso_local i32 @is_piece(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @g_blockdefine, align 8\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B19, label %B1\n\nB1:\n%5 = getelementptr inbounds i32, ptr %1, i64 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B19, label %B2\n\nB2:\n%9 = getelementptr inbounds i32, ptr %1, i64 2\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %10)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B19, label %B3\n\nB3:\n%13 = getelementptr inbounds i32, ptr %1, i64 3\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %14)\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B19, label %B4\n\nB4:\n%17 = getelementptr inbounds i32, ptr %1, i64 4\n%18 = load i32, ptr %17, align 4\n%19 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %18)\n%20 = icmp eq i32 %19, 0\nbr i1 %20, label %B19, label %B5\n\nB5:\n%21 = getelementptr inbounds i32, ptr %1, i64 5\n%22 = load i32, ptr %21, align 4\n%23 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %22)\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %B19, label %B6\n\nB6:\n%25 = getelementptr inbounds i32, ptr %1, i64 6\n%26 = load i32, ptr %25, align 4\n%27 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %26)\n%28 = icmp eq i32 %27, 0\nbr i1 %28, label %B19, label %B7\n\nB7:\n%29 = getelementptr inbounds i32, ptr %1, i64 7\n%30 = load i32, ptr %29, align 4\n%31 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %30)\n%32 = icmp eq i32 %31, 0\nbr i1 %32, label %B19, label %B8\n\nB8:\n%33 = getelementptr inbounds i32, ptr %1, i64 8\n%34 = load i32, ptr %33, align 4\n%35 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %34)\n%36 = icmp eq i32 %35, 0\nbr i1 %36, label %B19, label %B9\n\nB9:\n%37 = getelementptr inbounds i32, ptr %1, i64 9\n%38 = load i32, ptr %37, align 4\n%39 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %38)\n%40 = icmp eq i32 %39, 0\nbr i1 %40, label %B19, label %B10\n\nB10:\n%41 = getelementptr inbounds i32, ptr %1, i64 10\n%42 = load i32, ptr %41, align 4\n%43 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %42)\n%44 = icmp eq i32 %43, 0\nbr i1 %44, label %B19, label %B11\n\nB11:\n%45 = getelementptr inbounds i32, ptr %1, i64 11\n%46 = load i32, ptr %45, align 4\n%47 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %46)\n%48 = icmp eq i32 %47, 0\nbr i1 %48, label %B19, label %B12\n\nB12:\n%49 = getelementptr inbounds i32, ptr %1, i64 12\n%50 = load i32, ptr %49, align 4\n%51 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %50)\n%52 = icmp eq i32 %51, 0\nbr i1 %52, label %B19, label %B13\n\nB13:\n%53 = getelementptr inbounds i32, ptr %1, i64 13\n%54 = load i32, ptr %53, align 4\n%55 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %54)\n%56 = icmp eq i32 %55, 0\nbr i1 %56, label %B19, label %B14\n\nB14:\n%57 = getelementptr inbounds i32, ptr %1, i64 14\n%58 = load i32, ptr %57, align 4\n%59 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %58)\n%60 = icmp eq i32 %59, 0\nbr i1 %60, label %B19, label %B15\n\nB15:\n%61 = getelementptr inbounds i32, ptr %1, i64 15\n%62 = load i32, ptr %61, align 4\n%63 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %62)\n%64 = icmp eq i32 %63, 0\nbr i1 %64, label %B19, label %B16\n\nB16:\n%65 = getelementptr inbounds i32, ptr %1, i64 16\n%66 = load i32, ptr</s>", "codegemma": "define dso_local i32 @is_piece(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @g_blockdefine, align 8\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = phi i64 [ %6, %B2 ], [ 0, %B ]\n%6 = add nuw nsw i64 %5, 1\n%7 = icmp eq i64 %6, 19\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = load ptr, ptr @g_blockdefine, align 8\n%9 = getelementptr inbounds i32, ptr %8, i64 %6\n%10 = load i32, ptr %9, align 4\n%11 = tail call i32 @ft_strcmp(ptr noundef %0, i32 noundef %10)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B1\n\nB3:\n%13 = phi i32 [ -1, %B1 ], [ -1, %B ], [ %6, %B2 ]\nret i32 %13\n}"}, "define dso_local void @_jit_getarg_s(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %6, align 8\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %7, i32 0, i32 0\n%9 = load i64, ptr %8, align 8\n%10 = load i64, ptr @jit_code_arg, align 8\n%11 = icmp eq i64 %9, %10\n%12 = zext i1 %11 to i32\n%13 = call i32 @assert(i32 noundef %12)\n%14 = load i32, ptr @getarg_s, align 4\n%15 = load i32, ptr %5, align 4\n%16 = load ptr, ptr %6, align 8\n%17 = call i32 @jit_inc_synth_wp(i32 noundef %14, i32 noundef %15, ptr noundef %16)\n%18 = load ptr, ptr %6, align 8\n%19 = getelementptr inbounds %struct.TYPE_6__, ptr %18, i32 0, i32 1\n%20 = getelementptr inbounds %struct.TYPE_5__, ptr %19, i32 0, i32 0\n%21 = load i32, ptr %20, align 8\n%22 = icmp sge i32 %21, 0\nbr i1 %22, label %23, label %39\n\n23:\n%24 = load ptr, ptr %6, align 8\n%25 = getelementptr inbounds %struct.TYPE_6__, ptr %24, i32 0, i32 1\n%26 = getelementptr inbounds %struct.TYPE_5__, ptr %25, i32 0, i32 0\n%27 = load i32, ptr %26, align 8\n%28 = icmp slt i32 %27, 8\nbr i1 %28, label %29, label %39\n\n29:\n%30 = load i32, ptr %5, align 4\n%31 = load i64, ptr @JIT_RA0, align 8\n%32 = load ptr, ptr %6, align 8\n%33 = getelementptr inbounds %struct.TYPE_6__, ptr %32, i32 0, i32 1\n%34 = getelementptr inbounds %struct.TYPE_5__, ptr %33, i32 0, i32 0\n%35 = load i32, ptr %34, align 8\n%36 = sext i32 %35 to i64\n%37 = sub nsw i64 %31, %36\n%38 = call i32 @jit_extr_s(i32 noundef %30, i64 noundef %37)\nbr label %47\n\n39:\n%40 = load i32, ptr %5, align 4\n%41 = load i32, ptr @JIT_FP, align 4\n%42 = load ptr, ptr %6, align 8\n%43 = getelementptr inbounds %struct.TYPE_6__, ptr %42, i32 0, i32 1\n%44 = getelementptr inbounds %struct.TYPE_5__, ptr %43, i32 0, i32 0\n%45 = load i32, ptr %44, align 8\n%46 = call i32 @jit_ldxi_s(i32 noundef %40, i32 noundef %41, i32 noundef %45)\nbr label %47\n\n47:\n%48 = call i32 (...) @jit_dec_synth()\nret void\n}": {"base_truth": "define dso_local void @_jit_getarg_s(ptr nocapture noundef readnone %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = load i64, ptr %2, align 8\n%4 = load i64, ptr @jit_code_arg, align 8\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @assert(i32 noundef %6)\n%8 = load i32, ptr @getarg_s, align 4\n%9 = tail call i32 @jit_inc_synth_wp(i32 noundef %8, i32 noundef %1, ptr noundef nonnull %2)\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\n%11 = load i32, ptr %10, align 8\n%12 = icmp ult i32 %11, 8\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = load i64, ptr @JIT_RA0, align 8\n%14 = zext i32 %11 to i64\n%15 = sub nsw i64 %13, %14\n%16 = tail call i32 @jit_extr_s(i32 noundef %1, i64 noundef %15)\nbr label %B3\n\nB2:\n%17 = load i32, ptr @JIT_FP, align 4\n%18 = tail call i32 @jit_ldxi_s(i32 noundef %1, i32 noundef %17, i32 noundef %11)\nbr label %B3\n\nB3:\n%19 = tail call i32 (...) @jit_dec_synth()\nret void\n}", "codellama": "define dso_local void @_jit_getarg_s(ptr nocapture noundef readnone %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = load i64, ptr %2, align 8\n%4 = load i64, ptr @jit_code_arg, align 8\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @assert(i32 noundef %6)\n%8 = load i32, ptr @getarg_s, align 4\n%9 = tail call i32 @jit_inc_synth_wp(i32 noundef %8, i32 noundef %1, ptr noundef nonnull %2)\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\n%11 = load i32, ptr %10, align 8\n%12 = icmp ult i32 %11, 8\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = load i64, ptr @JIT_RA0, align 8\n%14 = zext i32 %11 to i64\n%15 = sub nsw i64 %13, %14\n%16 = tail call i32 @jit_extr_s(i32 noundef %1, i64 noundef %15)\nbr label %B3\n\nB2:\n%17 = load i32, ptr @JIT_FP, align 4\n%18 = tail call i32 @jit_ldxi_s(i32 noundef %1, i32 noundef %17, i32 noundef %11)\nbr label %B3\n\nB3:\n%19 = tail call i32 (...) @jit_dec_synth()\nret void\n}", "codegemma": "define dso_local void @_jit_getarg_s(ptr nocapture noundef readnone %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = load i64, ptr %2, align 8\n%4 = load i64, ptr @jit_code_arg, align 8\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @assert(i32 noundef %6)\n%8 = load i32, ptr @getarg_s, align 4\n%9 = tail call i32 @jit_inc_synth_wp(i32 noundef %8, i32 noundef %1, ptr noundef nonnull %2)\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\n%11 = load i32, ptr %10, align 8\n%12 = icmp ult i32 %11, 8\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = load i64, ptr @JIT_RA0, align 8\n%14 = zext i32 %11 to i64\n%15 = sub nsw i64 %13, %14\n%16 = tail call i32 @jit_extr_s(i32 noundef %1, i64 noundef %15)\nbr label %B3\n\nB2:\n%17 = load i32, ptr @JIT_FP, align 4\n%18 = tail call i32 @jit_ldxi_s(i32 noundef %1, i32 noundef %17, i32 noundef %11)\nbr label %B3\n\nB3:\n%19 = tail call i32 (...) @jit_dec_synth()\nret void\n}"}, "define dso_local i32 @etnaviv_cmdbuf_suballoc_map(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore ptr %2, ptr %7, align 8\nstore i32 %3, ptr %8, align 4\n%9 = load ptr, ptr %6, align 8\n%10 = load ptr, ptr %7, align 8\n%11 = load i32, ptr %8, align 4\n%12 = load ptr, ptr %5, align 8\n%13 = getelementptr inbounds %struct.etnaviv_cmdbuf_suballoc ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 4\n%15 = load i32, ptr @SUBALLOC_SIZE, align 4\n%16 = call i32 @etnaviv_iommu_get_suballoc_va(ptr noundef %9, ptr noundef %10, i32 noundef %11, i32 noundef %14, i32 noundef %15)\nret i32 %16\n}": {"base_truth": "define dso_local i32 @etnaviv_cmdbuf_suballoc_map(ptr nocapture noundef readonly %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @SUBALLOC_SIZE, align 4\n%6 = tail call i32 @etnaviv_iommu_get_suballoc_va(ptr noundef %1, ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\nret i32 %6\n}", "codellama": "define dso_local i32 @etnaviv_cmdbuf_suballoc_map(ptr nocapture noundef readonly %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @SUBALLOC_SIZE, align 4\n%6 = tail call i32 @etnaviv_iommu_get_suballoc_va(ptr noundef %1, ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\nret i32 %6\n}", "codegemma": "define dso_local i32 @etnaviv_cmdbuf_suballoc_map(ptr nocapture noundef readonly %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @SUBALLOC_SIZE, align 4\n%6 = tail call i32 @etnaviv_iommu_get_suballoc_va(ptr noundef %1, ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\nret i32 %6\n}"}, "define dso_local void @function_with_loop_1() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 1, ptr %1, align 4\nbr label %2\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = icmp slt i32 %3, 100\nbr i1 %4, label %5, label %15\n\n5:\nbr label %6\n\n6:\n%7 = load i32, ptr %1, align 4\n%8 = icmp slt i32 %7, 50\nbr i1 %8, label %9, label %12\n\n9:\n%10 = load i32, ptr %1, align 4\n%11 = add nsw i32 %10, 1\nstore i32 %11, ptr %1, align 4\nbr label %6\n\n12:\n%13 = load i32, ptr %1, align 4\n%14 = add nsw i32 %13, 1\nstore i32 %14, ptr %1, align 4\nbr label %2\n\n15:\n%16 = load i32, ptr %1, align 4\n%17 = call i32 @print(i32 noundef %16)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @function_with_loop_1() {\nB:\n%0 = tail call i32 @print(i32 noundef 100)\nret void\n}", "codellama": "define dso_local void @function_with_loop_1() {\nB:\n%0 = tail call i32 @print(i32 noundef 100)\nret void\n}", "codegemma": "define dso_local void @function_with_loop_1() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 1, %B ], [ %2, %B2 ]\n%1 = icmp slt i32 %0, 50\nbr i1 %1, label %B2, label %B3\n\nB2:\n%2 = add nuw nsw i32 %0, 1\n%3 = icmp eq i32 %2, 50\nbr i1 %3, label %B3, label %B1\n\nB3:\n%4 = add nuw nsw i32 %0, 1\n%5 = tail call i32 @print(i32 noundef %4)\nret void\n}"}, "define dso_local nofpclass(nan inf) double @f4_sum_pre_int_int_int_int_union_i8_int(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\nstore i32 %0, ptr %6, align 4\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\nstore i32 %4, ptr %10, align 4\n%11 = load i32, ptr %6, align 4\n%12 = sitofp i32 %11 to double\n%13 = load i32, ptr %7, align 4\n%14 = sitofp i32 %13 to double\n%15 = fadd fast double %12, %14\n%16 = load i32, ptr %8, align 4\n%17 = sitofp i32 %16 to double\n%18 = fadd fast double %15, %17\n%19 = load i32, ptr %9, align 4\n%20 = sitofp i32 %19 to double\n%21 = fadd fast double %18, %20\n%22 = load i32, ptr %10, align 4\n%23 = call fast nofpclass(nan inf) double @_f4_sum_union_i8_int(i32 noundef %22)\n%24 = fadd fast double %21, %23\nret double %24\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @f4_sum_pre_int_int_int_int_union_i8_int(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = sitofp i32 %0 to double\n%6 = sitofp i32 %1 to double\n%7 = fadd fast double %6, %5\n%8 = sitofp i32 %2 to double\n%9 = fadd fast double %7, %8\n%10 = sitofp i32 %3 to double\n%11 = fadd fast double %9, %10\n%12 = tail call fast nofpclass(nan inf) double @_f4_sum_union_i8_int(i32 noundef %4)\n%13 = fadd fast double %11, %12\nret double %13\n}", "codellama": "define dso_local nofpclass(nan inf) double @f4_sum_pre_int_int_int_int_union_i8_int(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = sitofp i32 %0 to double\n%6 = sitofp i32 %1 to double\n%7 = fadd fast double %6, %5\n%8 = sitofp i32 %2 to double\n%9 = fadd fast double %7, %8\n%10 = sitofp i32 %3 to double\n%11 = fadd fast double %9, %10\n%12 = tail call fast nofpclass(nan inf) double @_f4_sum_union_i8_int(i32 noundef %4)\n%13 = fadd fast double %11, %12\nret double %13\n}", "codegemma": "define dso_local nofpclass(nan inf) double @f4_sum_pre_int_int_int_int_union_i8_int(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = sitofp i32 %0 to double\n%6 = sitofp i32 %1 to double\n%7 = fadd fast double %6, %5\n%8 = sitofp i32 %2 to double\n%9 = fadd fast double %7, %8\n%10 = sitofp i32 %3 to double\n%11 = fadd fast double %9, %10\n%12 = tail call fast nofpclass(nan inf) double @_f4_sum_union_i8_int(i32 noundef %4)\n%13 = fadd fast double %11, %12\nret double %13\n}"}, "define dso_local i64 @strlen(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore i64 0, ptr %3, align 8\nbr label %4\n\n4:\n%5 = load ptr, ptr %2, align 8\n%6 = load i64, ptr %3, align 8\n%7 = add i64 %6, 1\nstore i64 %7, ptr %3, align 8\n%8 = getelementptr inbounds i8, ptr %5, i64 %6\n%9 = load i8, ptr %8, align 1\n%10 = sext i8 %9 to i32\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %13\n\n12:\nbr label %4\n\n13:\n%14 = load i64, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i64 %14\n}": {"base_truth": "define dso_local i64 @strlen(ptr nocapture noundef readonly %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i64 [ 0, %B ], [ %2, %B1 ]\n%2 = add i64 %1, 1\n%3 = getelementptr inbounds i8, ptr %0, i64 %1\n%4 = load i8, ptr %3, align 1\n%5 = icmp eq i8 %4, 0\nbr i1 %5, label %B2, label %B1\n\nB2:\nret i64 %2\n}", "codellama": "define dso_local i64 @strlen(ptr nocapture noundef readonly %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i64 [ 0, %B ], [ %5, %B1 ]\n%2 = getelementptr inbounds i8, ptr %0, i64 %1\n%3 = load i8, ptr %2, align 1\n%4 = icmp eq i8 %3, 0\n%5 = add i64 %1, 1\nbr i1 %4, label %B2, label %B1\n\nB2:\nret i64 %1\n}", "codegemma": "define dso_local i64 @strlen(ptr nocapture noundef readonly %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i64 [ 0, %B ], [ %5, %B1 ]\n%2 = getelementptr inbounds i8, ptr %0, i64 %1\n%3 = load i8, ptr %2, align 1\n%4 = icmp eq i8 %3, 0\n%5 = add i64 %1, 1\nbr i1 %4, label %B2, label %B1\n\nB2:\nret i64 %1\n}"}, "define dso_local i32 @parse_align_bits(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @eval_expression(ptr noundef %6, ptr noundef %4)\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %13, label %9\n\n9:\n%10 = load i32, ptr %4, align 4\n%11 = srem i32 %10, 8\n%12 = icmp ne i32 %11, 0\nbr i1 %12, label %13, label %16\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = call i32 @print_error(ptr noundef @.str, ptr noundef %14)\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %22\n\n16:\n%17 = load i32, ptr %4, align 4\n%18 = sdiv i32 %17, 8\nstore i32 %18, ptr %4, align 4\n%19 = load ptr, ptr %3, align 8\n%20 = load i32, ptr %4, align 4\n%21 = call i32 @parse_align(ptr noundef %19, i32 noundef %20)\nstore i32 %21, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %22\n\n22:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%23 = load i32, ptr %2, align 4\nret i32 %23\n}": {"base_truth": "define dso_local i32 @parse_align_bits(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @eval_expression(ptr noundef %0, ptr noundef nonnull %1)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr %1, align 4\n%5 = and i32 %4, 7\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = call i32 @print_error(ptr noundef nonnull @.str, ptr noundef %0)\nbr label %B4\n\nB3:\n%8 = sdiv i32 %4, 8\nstore i32 %8, ptr %1, align 4\n%9 = call i32 @parse_align(ptr noundef %0, i32 noundef %8)\nbr label %B4\n\nB4:\n%10 = phi i32 [ -1, %B2 ], [ %9, %B3 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %10\n}", "codellama": "define dso_local i32 @parse_align_bits(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @eval_expression(ptr noundef %0, ptr noundef nonnull %1)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr %1, align 4\n%5 = and i32 %4, 7\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = call i32 @print_error(ptr noundef nonnull @.str, ptr noundef %0)\nbr label %B4\n\nB3:\n%8 = sdiv i32 %4, 8\nstore i32 %8, ptr %1, align 4\n%9 = call i32 @parse_align(ptr noundef %0, i32 noundef %8)\nbr label %B4\n\nB4:\n%10 = phi i32 [ -1, %B2 ], [ %9, %B3 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %10\n}", "codegemma": "define dso_local i32 @parse_align_bits(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @eval_expression(ptr noundef %0, ptr noundef nonnull %1)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr %1, align 4\n%5 = srem i32 %4, 8\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = call i32 @print_error(ptr noundef nonnull @.str, ptr noundef %0)\nbr label %B4\n\nB3:\n%8 = sdiv i32 %4, 8\nstore i32 %8, ptr %1, align 4\n%9 = call i32 @parse_align(ptr noundef %0, i32 noundef %8)\nbr label %B4\n\nB4:\n%10 = phi i32 [ -1, %B2 ], [ %9, %B3 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %10\n}"}, "define internal void @display_disable(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%6 = load ptr, ptr %2, align 8\n%7 = call ptr @to_xen_drm_pipeline(ptr noundef %6)\nstore ptr %7, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.drm_simple_display_pipe ptr %8, i32 0, i32 0\n%10 = getelementptr inbounds %struct.TYPE_2__, ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = call i64 @drm_dev_enter(i32 noundef %11, ptr noundef %5)\n%13 = icmp ne i64 %12, 0\nbr i1 %13, label %14, label %20\n\n14:\n%15 = load ptr, ptr %3, align 8\n%16 = call i32 @xen_drm_front_fb_to_cookie(ptr noundef null)\n%17 = call i32 @xen_drm_front_mode_set(ptr noundef %15, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef %16)\nstore i32 %17, ptr %4, align 4\n%18 = load i32, ptr %5, align 4\n%19 = call i32 @drm_dev_exit(i32 noundef %18)\nbr label %20\n\n20:\n%21 = load i32, ptr %4, align 4\n%22 = icmp ne i32 %21, 0\nbr i1 %22, label %23, label %26\n\n23:\n%24 = load i32, ptr %4, align 4\n%25 = call i32 @DRM_ERROR(ptr noundef @.str, i32 noundef %24)\nbr label %26\n\n26:\n%27 = load ptr, ptr %3, align 8\n%28 = getelementptr inbounds %struct.xen_drm_front_drm_pipeline ptr %27, i32 0, i32 0\nstore i32 1, ptr %28, align 4\n%29 = load ptr, ptr %3, align 8\n%30 = call i32 @send_pending_event(ptr noundef %29)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @display_disable(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = tail call ptr @to_xen_drm_pipeline(ptr noundef %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = call i64 @drm_dev_enter(i32 noundef %3, ptr noundef nonnull %1)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = call i32 @xen_drm_front_fb_to_cookie(ptr noundef null)\n%7 = call i32 @xen_drm_front_mode_set(ptr noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef %6)\n%8 = load i32, ptr %1, align 4\n%9 = call i32 @drm_dev_exit(i32 noundef %8)\n%10 = icmp eq i32 %7, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = call i32 @DRM_ERROR(ptr noundef nonnull @.str, i32 noundef %7)\nbr label %B3\n\nB3:\nstore i32 1, ptr %2, align 4\n%12 = call i32 @send_pending_event(ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codellama": "define internal void @display_disable(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = tail call ptr @to_xen_drm_pipeline(ptr noundef %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = call i64 @drm_dev_enter(i32 noundef %3, ptr noundef nonnull %1)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = call i32 @xen_drm_front_fb_to_cookie(ptr noundef null)\n%7 = call i32 @xen_drm_front_mode_set(ptr noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef %6)\n%8 = load i32, ptr %1, align 4\n%9 = call i32 @drm_dev_exit(i32 noundef %8)\n%10 = icmp eq i32 %7, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = phi i32 [ %7, %B1 ], [ 0, %B ]\n%12 = call i32 @DRM_ERROR(ptr noundef nonnull @.str, i32 noundef %11)\nbr label %B3\n\nB3:\nstore i32 1, ptr %2, align 4\n%13 = call i32 @send_pending_event(ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codegemma": "define internal void @display_disable(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = tail call ptr @to_xen_drm_pipeline(ptr noundef %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\n%3 = load i32, ptr %0, align 4\n%4 = call i64 @drm_dev_enter(i32 noundef %3, ptr noundef nonnull %1)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = call i32 @xen_drm_front_fb_to_cookie(ptr noundef null)\n%7 = call i32 @xen_drm_front_mode_set(ptr noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef %6)\n%8 = load i32, ptr %1, align 4\n%9 = call i32 @drm_dev_exit(i32 noundef %8)\nbr label %B2\n\nB2:\n%10 = phi i32 [ %7, %B1 ], [ 0, %B ]\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B4, label %B3\n\nB3:\n%12 = call i32 @DRM_ERROR(ptr noundef nonnull @.str, i32 noundef %10)\nbr label %B4\n\nB4:\nstore i32 1, ptr %2, align 4\n%13 = call i32 @send_pending_event(ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}"}, "define dso_local void @C67_STW_SP_A0(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @C67_asm(ptr noundef @.str, i32 noundef %3, i32 noundef 0, i32 noundef 0)\nret void\n}": {"base_truth": "define dso_local void @C67_STW_SP_A0(i32 noundef %0) {\nB:\n%1 = tail call i32 @C67_asm(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef 0, i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @C67_STW_SP_A0(i32 noundef %0) {\nB:\n%1 = tail call i32 @C67_asm(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef 0, i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @C67_STW_SP_A0(i32 noundef %0) {\nB:\n%1 = tail call i32 @C67_asm(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef 0, i32 noundef 0)\nret void\n}"}, "define dso_local void @wait_for_reply() {\nbr label %1\n\n1:\n%2 = load i64, ptr @reply, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %4, label %6\n\n4:\n%5 = call i32 @sleep(i32 noundef 0)\nbr label %1\n\n6:\nstore i64 0, ptr @reply, align 8\nret void\n}": {"base_truth": "define dso_local void @wait_for_reply() {\nB:\n%0 = load i64, ptr @reply, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 @sleep(i32 noundef 0)\n%3 = load i64, ptr @reply, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB2:\nstore i64 0, ptr @reply, align 8\nret void\n}", "codellama": "define dso_local void @wait_for_reply() {\nB:\n%0 = load i64, ptr @reply, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 @sleep(i32 noundef 0)\n%3 = load i64, ptr @reply, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB2:\nstore i64 0, ptr @reply, align 8\nret void\n}", "codegemma": "define dso_local void @wait_for_reply() {\nB:\n%0 = load i64, ptr @reply, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = tail call i32 @sleep(i32 noundef 0)\n%3 = load i64, ptr @reply, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB2:\nstore i64 0, ptr @reply, align 8\nret void\n}"}, "define internal void @write_footer(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @avio_printf(i32 noundef %5, ptr noundef @.str)\nret void\n}": {"base_truth": "define internal void @write_footer(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @avio_printf(i32 noundef %1, ptr noundef nonnull @.str)\nret void\n}", "codellama": "define internal void @write_footer(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @avio_printf(i32 noundef %1, ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define internal void @write_footer(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @avio_printf(i32 noundef %1, ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local void @td_removed_print(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = call ptr @hbuf_new(i32 noundef 128)\nstore ptr %4, ptr %3, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr @white, align 4\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @hbuf_str(ptr noundef %7)\n%9 = call i32 @hbuf_sprintf(ptr noundef %5, ptr noundef @.str, i32 noundef %6, ptr noundef @.str.1, i32 noundef %8)\n%10 = load ptr, ptr %3, align 8\n%11 = call i32 @hbuf_println(ptr noundef %10)\n%12 = load ptr, ptr %3, align 8\n%13 = call i32 @hbuf_free(ptr noundef %12)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @td_removed_print(ptr noundef %0) {\nB:\n%1 = tail call ptr @hbuf_new(i32 noundef 128)\n%2 = load i32, ptr @white, align 4\n%3 = tail call i32 @hbuf_str(ptr noundef %0)\n%4 = tail call i32 @hbuf_sprintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %2, ptr noundef nonnull @.str.1, i32 noundef %3)\n%5 = tail call i32 @hbuf_println(ptr noundef %1)\n%6 = tail call i32 @hbuf_free(ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @td_removed_print(ptr noundef %0) {\nB:\n%1 = tail call ptr @hbuf_new(i32 noundef 128)\n%2 = load i32, ptr @white, align 4\n%3 = tail call i32 @hbuf_str(ptr noundef %0)\n%4 = tail call i32 @hbuf_sprintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %2, ptr noundef nonnull @.str.1, i32 noundef %3)\n%5 = tail call i32 @hbuf_println(ptr noundef %1)\n%6 = tail call i32 @hbuf_free(ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @td_removed_print(ptr noundef %0) {\nB:\n%1 = tail call ptr @hbuf_new(i32 noundef 128)\n%2 = load i32, ptr @white, align 4\n%3 = tail call i32 @hbuf_str(ptr noundef %0)\n%4 = tail call i32 @hbuf_sprintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %2, ptr noundef nonnull @.str.1, i32 noundef %3)\n%5 = tail call i32 @hbuf_println(ptr noundef %1)\n%6 = tail call i32 @hbuf_free(ptr noundef %1)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\n%2 = call i32 @printf(ptr noundef @.str, i32 noundef 3)\n%3 = call i32 @printf(ptr noundef @.str.1, i32 noundef 3)\n%4 = call i32 @printf(ptr noundef @.str.2, i32 noundef 3)\n%5 = call i32 @printf(ptr noundef @.str.3, i32 noundef 3)\n%6 = call i32 @printf(ptr noundef @.str.4, i32 noundef 3)\n%7 = call i32 @printf(ptr noundef @.str.5, i32 noundef 3)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 3)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef 3)\n%2 = tail call i32 @printf(ptr noundef nonnull @.str.2, i32 noundef 3)\n%3 = tail call i32 @printf(ptr noundef nonnull @.str.3, i32 noundef 3)\n%4 = tail call i32 @printf(ptr noundef nonnull @.str.4, i32 noundef 3)\n%5 = tail call i32 @printf(ptr noundef nonnull @.str.5, i32 noundef 3)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 3)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef 3)\n%2 = tail call i32 @printf(ptr noundef nonnull @.str.2, i32 noundef 3)\n%3 = tail call i32 @printf(ptr noundef nonnull @.str.3, i32 noundef 3)\n%4 = tail call i32 @printf(ptr noundef nonnull @.str.4, i32 noundef 3)\n%5 = tail call i32 @printf(ptr noundef nonnull @.str.5, i32 noundef 3)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 3)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef 3)\n%2 = tail call i32 @printf(ptr noundef nonnull @.str.2, i32 noundef 3)\n%3 = tail call i32 @printf(ptr noundef nonnull @.str.3, i32 noundef 3)\n%4 = tail call i32 @printf(ptr noundef nonnull @.str.4, i32 noundef 3)\n%5 = tail call i32 @printf(ptr noundef nonnull @.str.5, i32 noundef 3)\nret i32 0\n}"}, "define internal i32 @bond_clone_destroy(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = call i32 (...) @bond_lock()\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @ifnet_softc(ptr noundef %7)\nstore ptr %8, ptr %4, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = icmp eq ptr %9, null\nbr i1 %10, label %16, label %11\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = call i64 @ifnet_type(ptr noundef %12)\n%14 = load i64, ptr @IFT_IEEE8023ADLAG, align 8\n%15 = icmp ne i64 %13, %14\nbr i1 %15, label %16, label %18\n\n16:\n%17 = call i32 (...) @bond_unlock()\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %30\n\n18:\n%19 = load ptr, ptr %4, align 8\n%20 = call i64 @ifbond_flags_if_detaching(ptr noundef %19)\n%21 = icmp ne i64 %20, 0\nbr i1 %21, label %22, label %24\n\n22:\n%23 = call i32 (...) @bond_unlock()\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %30\n\n24:\n%25 = load ptr, ptr %4, align 8\n%26 = call i32 @bond_remove(ptr noundef %25)\n%27 = call i32 (...) @bond_unlock()\n%28 = load ptr, ptr %3, align 8\n%29 = call i32 @bond_if_detach(ptr noundef %28)\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%31 = load i32, ptr %2, align 4\nret i32 %31\n}": {"base_truth": "define internal i32 @bond_clone_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @bond_lock()\n%2 = tail call ptr @ifnet_softc(ptr noundef %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i64 @ifnet_type(ptr noundef %0)\n%5 = load i64, ptr @IFT_IEEE8023ADLAG, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = tail call i32 (...) @bond_unlock()\nbr label %B6\n\nB3:\n%8 = tail call i64 @ifbond_flags_if_detaching(ptr noundef nonnull %2)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B5, label %B4\n\nB4:\n%10 = tail call i32 (...) @bond_unlock()\nbr label %B6\n\nB5:\n%11 = tail call i32 @bond_remove(ptr noundef nonnull %2)\n%12 = tail call i32 (...) @bond_unlock()\n%13 = tail call i32 @bond_if_detach(ptr noundef %0)\nbr label %B6\n\nB6:\nret i32 0\n}", "codellama": "define internal i32 @bond_clone_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @bond_lock()\n%2 = tail call ptr @ifnet_softc(ptr noundef %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i64 @ifnet_type(ptr noundef %0)\n%5 = load i64, ptr @IFT_IEEE8023ADLAG, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B2, label %B3\n\nB2:\n%7 = tail call i64 @ifbond_flags_if_detaching(ptr noundef nonnull %2)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 @bond_remove(ptr noundef %2)\nbr label %B4\n\nB4:\n%10 = tail call i32 (...) @bond_unlock()\n%11 = tail call i32 @bond_if_detach(ptr noundef %0)\nret i32 0\n}", "codegemma": "define internal i32 @bond_clone_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @bond_lock()\n%2 = tail call ptr @ifnet_softc(ptr noundef %0)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = tail call i64 @ifnet_type(ptr noundef %0)\n%5 = load i64, ptr @IFT_IEEE8023ADLAG, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B2, label %B3\n\nB2:\n%7 = tail call i64 @ifbond_flags_if_detaching(ptr noundef nonnull %2)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 (...) @bond_unlock()\nbr label %B5\n\nB4:\n%10 = tail call i32 @bond_remove(ptr noundef %0)\n%11 = tail call i32 (...) @bond_unlock()\n%12 = tail call i32 @bond_if_detach(ptr noundef %0)\nbr label %B5\n\nB5:\nret i32 0\n}"}, "define internal void @sdl_serialize_type_ref(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i64, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\nstore i64 %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%8 = load i64, ptr %4, align 8\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %23\n\n10:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%11 = load ptr, ptr %5, align 8\n%12 = call ptr @zend_hash_str_find(ptr noundef %11, ptr noundef %4, i32 noundef 8)\nstore ptr %12, ptr %7, align 8\n%13 = icmp ne ptr %12, null\nbr i1 %13, label %14, label %19\n\n14:\n%15 = load ptr, ptr %7, align 8\n%16 = call i32 @Z_LVAL_P(ptr noundef %15)\n%17 = load ptr, ptr %6, align 8\n%18 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef %16, ptr noundef %17)\nbr label %22\n\n19:\n%20 = load ptr, ptr %6, align 8\n%21 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %20)\nbr label %22\n\n22:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nbr label %26\n\n23:\n%24 = load ptr, ptr %6, align 8\n%25 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %24)\nbr label %26\n\n26:\nret void\n}": {"base_truth": "define internal void @sdl_serialize_type_ref(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\n%4 = icmp eq i64 %0, 0\nbr i1 %4, label %B4, label %B1\n\nB1:\n%5 = call ptr @zend_hash_str_find(ptr noundef %1, ptr noundef nonnull %3, i32 noundef 8)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = call i32 @Z_LVAL_P(ptr noundef nonnull %5)\n%8 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef %7, ptr noundef %2)\nbr label %B5\n\nB3:\n%9 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %2)\nbr label %B5\n\nB4:\n%10 = tail call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %2)\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define internal void @sdl_serialize_type_ref(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\n%4 = icmp eq i64 %0, 0\nbr i1 %4, label %B4, label %B1\n\nB1:\n%5 = call ptr @zend_hash_str_find(ptr noundef %1, ptr noundef nonnull %3, i32 noundef 8)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = call i32 @Z_LVAL_P(ptr noundef nonnull %5)\n%8 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef %7, ptr noundef %2)\nbr label %B5\n\nB3:\n%9 = call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %2)\nbr label %B5\n\nB4:\n%10 = tail call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %2)\nbr label %B5\n\nB5:\nret void\n}", "codegemma": "define internal void @sdl_serialize_type_ref(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i64 %0, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = tail call ptr @zend_hash_str_find(ptr noundef %1, ptr noundef %0, i32 noundef 8)\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = tail call i32 @Z_LVAL_P(ptr noundef nonnull %4)\n%7 = tail call i32 @WSDL_CACHE_PUT_INT(i32 noundef %6, ptr noundef %2)\nbr label %B4\n\nB3:\n%8 = tail call i32 @WSDL_CACHE_PUT_INT(i32 noundef 0, ptr noundef %2)\nbr label %B4\n\nB4:\nret void\n}"}, "define dso_local void @test_group_end(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %9, label %7\n\n7:\n%8 = call i32 @fail(ptr noundef @.str)\nbr label %9\n\n9:\n%10 = load ptr, ptr %2, align 8\n%11 = call i32 @context_report_group(ptr noundef %10)\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.TYPE_4__, ptr %12, i32 0, i32 0\nstore i64 0, ptr %13, align 8\nret void\n}": {"base_truth": "define dso_local void @test_group_end(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @fail(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%4 = tail call i32 @context_report_group(ptr noundef nonnull %0)\nstore i64 0, ptr %0, align 8\nret void\n}", "codellama": "define dso_local void @test_group_end(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @fail(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%4 = tail call i32 @context_report_group(ptr noundef nonnull %0)\nstore i64 0, ptr %0, align 8\nret void\n}", "codegemma": "define dso_local void @test_group_end(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @fail(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%4 = tail call i32 @context_report_group(ptr noundef nonnull %0)\nstore i64 0, ptr %0, align 8\nret void\n}"}, "define dso_local signext i8 @peek_byte() {\n%1 = load i32, ptr @pc, align 4\n%2 = call signext i8 @get_mem8(i32 noundef %1)\nret i8 %2\n}": {"base_truth": "define dso_local signext i8 @peek_byte() {\nB:\n%0 = load i32, ptr @pc, align 4\n%1 = tail call signext i8 @get_mem8(i32 noundef %0)\nret i8 %1\n}", "codellama": "define dso_local signext i8 @peek_byte() {\nB:\n%0 = load i32, ptr @pc, align 4\n%1 = tail call signext i8 @get_mem8(i32 noundef %0)\nret i8 %1\n}", "codegemma": "define dso_local signext i8 @peek_byte() {\nB:\n%0 = load i32, ptr @pc, align 4\n%1 = tail call signext i8 @get_mem8(i32 noundef %0)\nret i8 %1\n}"}, "define dso_local void @init_8259A() {\n%1 = call i32 @out_byte(i32 noundef 32, i32 noundef 17)\n%2 = call i32 @out_byte(i32 noundef 160, i32 noundef 17)\n%3 = call i32 @out_byte(i32 noundef 33, i32 noundef 32)\n%4 = call i32 @out_byte(i32 noundef 161, i32 noundef 40)\n%5 = call i32 @out_byte(i32 noundef 33, i32 noundef 4)\n%6 = call i32 @out_byte(i32 noundef 161, i32 noundef 2)\n%7 = call i32 @out_byte(i32 noundef 33, i32 noundef 1)\n%8 = call i32 @out_byte(i32 noundef 161, i32 noundef 1)\n%9 = call i32 @out_byte(i32 noundef 33, i32 noundef 255)\n%10 = call i32 @out_byte(i32 noundef 161, i32 noundef 255)\nret void\n}": {"base_truth": "define dso_local void @init_8259A() {\nB:\n%0 = tail call i32 @out_byte(i32 noundef 32, i32 noundef 17)\n%1 = tail call i32 @out_byte(i32 noundef 160, i32 noundef 17)\n%2 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 32)\n%3 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 40)\n%4 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 4)\n%5 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 2)\n%6 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 1)\n%7 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 1)\n%8 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 255)\n%9 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 255)\nret void\n}", "codellama": "define dso_local void @init_8259A() {\nB:\n%0 = tail call i32 @out_byte(i32 noundef 32, i32 noundef 17)\n%1 = tail call i32 @out_byte(i32 noundef 160, i32 noundef 17)\n%2 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 32)\n%3 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 40)\n%4 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 4)\n%5 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 2)\n%6 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 1)\n%7 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 1)\n%8 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 255)\n%9 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 255)\nret void\n}", "codegemma": "define dso_local void @init_8259A() {\nB:\n%0 = tail call i32 @out_byte(i32 noundef 32, i32 noundef 17)\n%1 = tail call i32 @out_byte(i32 noundef 160, i32 noundef 17)\n%2 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 32)\n%3 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 40)\n%4 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 4)\n%5 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 2)\n%6 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 1)\n%7 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 1)\n%8 = tail call i32 @out_byte(i32 noundef 33, i32 noundef 255)\n%9 = tail call i32 @out_byte(i32 noundef 161, i32 noundef 255)\nret void\n}"}, "define internal void @init_amd_gh(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 @MSR_AMD64_MCx_MASK(i32 noundef 4)\n%4 = call i32 @msr_set_bit(i32 noundef %3, i32 noundef 10)\n%5 = load i32, ptr @MSR_AMD64_BU_CFG2, align 4\n%6 = call i32 @msr_clear_bit(i32 noundef %5, i32 noundef 24)\n%7 = load ptr, ptr %2, align 8\n%8 = load i32, ptr @amd_erratum_383, align 4\n%9 = call i64 @cpu_has_amd_erratum(ptr noundef %7, i32 noundef %8)\n%10 = icmp ne i64 %9, 0\nbr i1 %10, label %11, label %15\n\n11:\n%12 = load ptr, ptr %2, align 8\n%13 = load i32, ptr @X86_BUG_AMD_TLB_MMATCH, align 4\n%14 = call i32 @set_cpu_bug(ptr noundef %12, i32 noundef %13)\nbr label %15\n\n15:\nret void\n}": {"base_truth": "define internal void @init_amd_gh(ptr noundef %0) {\nB:\n%1 = tail call i32 @MSR_AMD64_MCx_MASK(i32 noundef 4)\n%2 = tail call i32 @msr_set_bit(i32 noundef %1, i32 noundef 10)\n%3 = load i32, ptr @MSR_AMD64_BU_CFG2, align 4\n%4 = tail call i32 @msr_clear_bit(i32 noundef %3, i32 noundef 24)\n%5 = load i32, ptr @amd_erratum_383, align 4\n%6 = tail call i64 @cpu_has_amd_erratum(ptr noundef %0, i32 noundef %5)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @X86_BUG_AMD_TLB_MMATCH, align 4\n%9 = tail call i32 @set_cpu_bug(ptr noundef %0, i32 noundef %8)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @init_amd_gh(ptr noundef %0) {\nB:\n%1 = tail call i32 @MSR_AMD64_MCx_MASK(i32 noundef 4)\n%2 = tail call i32 @msr_set_bit(i32 noundef %1, i32 noundef 10)\n%3 = load i32, ptr @MSR_AMD64_BU_CFG2, align 4\n%4 = tail call i32 @msr_clear_bit(i32 noundef %3, i32 noundef 24)\n%5 = load i32, ptr @amd_erratum_383, align 4\n%6 = tail call i64 @cpu_has_amd_erratum(ptr noundef %0, i32 noundef %5)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @X86_BUG_AMD_TLB_MMATCH, align 4\n%9 = tail call i32 @set_cpu_bug(ptr noundef %0, i32 noundef %8)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @init_amd_gh(ptr noundef %0) {\nB:\n%1 = tail call i32 @MSR_AMD64_MCx_MASK(i32 noundef 4)\n%2 = tail call i32 @msr_set_bit(i32 noundef %1, i32 noundef 10)\n%3 = load i32, ptr @MSR_AMD64_BU_CFG2, align 4\n%4 = tail call i32 @msr_clear_bit(i32 noundef %3, i32 noundef 24)\n%5 = load i32, ptr @amd_erratum_383, align 4\n%6 = tail call i64 @cpu_has_amd_erratum(ptr noundef %0, i32 noundef %5)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @X86_BUG_AMD_TLB_MMATCH, align 4\n%9 = tail call i32 @set_cpu_bug(ptr noundef %0, i32 noundef %8)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @ERR_load_STORE_strings() {\n%1 = load ptr, ptr @STORE_str_functs, align 8\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %2, i32 0, i32 0\n%4 = load i32, ptr %3, align 4\n%5 = call ptr @ERR_func_error_string(i32 noundef %4)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %7, label %12\n\n7:\n%8 = load ptr, ptr @STORE_str_functs, align 8\n%9 = call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %8)\n%10 = load ptr, ptr @STORE_str_reasons, align 8\n%11 = call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %10)\nbr label %12\n\n12:\nret void\n}": {"base_truth": "define dso_local void @ERR_load_STORE_strings() {\nB:\n%0 = load ptr, ptr @STORE_str_functs, align 8\n%1 = load i32, ptr %0, align 4\n%2 = tail call ptr @ERR_func_error_string(i32 noundef %1)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load ptr, ptr @STORE_str_functs, align 8\n%5 = tail call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %4)\n%6 = load ptr, ptr @STORE_str_reasons, align 8\n%7 = tail call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %6)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @ERR_load_STORE_strings() {\nB:\n%0 = load ptr, ptr @STORE_str_functs, align 8\n%1 = load i32, ptr %0, align 4\n%2 = tail call ptr @ERR_func_error_string(i32 noundef %1)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load ptr, ptr @STORE_str_functs, align 8\n%5 = tail call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %4)\n%6 = load ptr, ptr @STORE_str_reasons, align 8\n%7 = tail call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %6)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @ERR_load_STORE_strings() {\nB:\n%0 = load ptr, ptr @STORE_str_functs, align 8\n%1 = load i32, ptr %0, align 4\n%2 = tail call ptr @ERR_func_error_string(i32 noundef %1)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load ptr, ptr @STORE_str_functs, align 8\n%5 = tail call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %4)\n%6 = load ptr, ptr @STORE_str_reasons, align 8\n%7 = tail call i32 @ERR_load_strings(i32 noundef 0, ptr noundef %6)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @ps3_repository_read_stor_dev_region(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5) {\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca ptr, align 8\n%12 = alloca ptr, align 8\n%13 = alloca ptr, align 8\n%14 = alloca i32, align 4\n%15 = alloca i32, align 4\nstore i32 %0, ptr %8, align 4\nstore i32 %1, ptr %9, align 4\nstore i32 %2, ptr %10, align 4\nstore ptr %3, ptr %11, align 8\nstore ptr %4, ptr %12, align 8\nstore ptr %5, ptr %13, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %14)\n%16 = load i32, ptr %8, align 4\n%17 = load i32, ptr %9, align 4\n%18 = load i32, ptr %10, align 4\n%19 = load ptr, ptr %11, align 8\n%20 = call i32 @ps3_repository_read_stor_dev_region_id(i32 noundef %16, i32 noundef %17, i32 noundef %18, ptr noundef %19)\nstore i32 %20, ptr %14, align 4\n%21 = load i32, ptr %14, align 4\n%22 = icmp ne i32 %21, 0\nbr i1 %22, label %23, label %25\n\n23:\n%24 = load i32, ptr %14, align 4\nstore i32 %24, ptr %7, align 4\nstore i32 1, ptr %15, align 4\nbr label %42\n\n25:\n%26 = load i32, ptr %8, align 4\n%27 = load i32, ptr %9, align 4\n%28 = load i32, ptr %10, align 4\n%29 = load ptr, ptr %12, align 8\n%30 = call i32 @ps3_repository_read_stor_dev_region_start(i32 noundef %26, i32 noundef %27, i32 noundef %28, ptr noundef %29)\nstore i32 %30, ptr %14, align 4\n%31 = load i32, ptr %14, align 4\n%32 = icmp ne i32 %31, 0\nbr i1 %32, label %33, label %35\n\n33:\n%34 = load i32, ptr %14, align 4\nstore i32 %34, ptr %7, align 4\nstore i32 1, ptr %15, align 4\nbr label %42\n\n35:\n%36 = load i32, ptr %8, align 4\n%37 = load i32, ptr %9, align 4\n%38 = load i32, ptr %10, align 4\n%39 = load ptr, ptr %13, align 8\n%40 = call i32 @ps3_repository_read_stor_dev_region_size(i32 noundef %36, i32 noundef %37, i32 noundef %38, ptr noundef %39)\nstore i32 %40, ptr %14, align 4\n%41 = load i32, ptr %14, align 4\nstore i32 %41, ptr %7, align 4\nstore i32 1, ptr %15, align 4\nbr label %42\n\n42:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %14)\n%43 = load i32, ptr %7, align 4\nret i32 %43\n}": {"base_truth": "define dso_local i32 @ps3_repository_read_stor_dev_region(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5) {\nB:\n%6 = tail call i32 @ps3_repository_read_stor_dev_region_id(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B3\n\nB1:\n%8 = tail call i32 @ps3_repository_read_stor_dev_region_start(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %4)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = tail call i32 @ps3_repository_read_stor_dev_region_size(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %5)\nbr label %B3\n\nB3:\n%11 = phi i32 [ %10, %B2 ], [ %6, %B ], [ %8, %B1 ]\nret i32 %11\n}", "codellama": "define dso_local i32 @ps3_repository_read_stor_dev_region(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5) {\nB:\n%6 = tail call i32 @ps3_repository_read_stor_dev_region_id(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B3\n\nB1:\n%8 = tail call i32 @ps3_repository_read_stor_dev_region_start(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %4)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = tail call i32 @ps3_repository_read_stor_dev_region_size(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %5)\nbr label %B3\n\nB3:\n%11 = phi i32 [ %10, %B2 ], [ %6, %B ], [ %8, %B1 ]\nret i32 %11\n}", "codegemma": "define dso_local i32 @ps3_repository_read_stor_dev_region(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5) {\nB:\n%6 = tail call i32 @ps3_repository_read_stor_dev_region_id(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B1, label %B3\n\nB1:\n%8 = tail call i32 @ps3_repository_read_stor_dev_region_start(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %4)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = tail call i32 @ps3_repository_read_stor_dev_region_size(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %5)\nbr label %B3\n\nB3:\n%11 = phi i32 [ %10, %B2 ], [ %6, %B ], [ %8, %B1 ]\nret i32 %11\n}"}, "define dso_local nofpclass(nan inf) float @BackEaseIn(float noundef nofpclass(nan inf) %0) {\n%2 = alloca float, align 4\nstore float %0, ptr %2, align 4\n%3 = load float, ptr %2, align 4\n%4 = load float, ptr %2, align 4\n%5 = fmul fast float %3, %4\n%6 = load float, ptr %2, align 4\n%7 = fmul fast float %5, %6\n%8 = load float, ptr %2, align 4\n%9 = load float, ptr %2, align 4\n%10 = fpext float %9 to double\n%11 = fmul fast double %10, 0x400921FB54442D18\n%12 = fptrunc double %11 to float\n%13 = call fast nofpclass(nan inf) float @sin(float noundef nofpclass(nan inf) %12)\n%14 = fmul fast float %8, %13\n%15 = fsub fast float %7, %14\nret float %15\n}": {"base_truth": "define dso_local nofpclass(nan inf) float @BackEaseIn(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fmul fast float %0, %0\n%2 = fpext float %0 to double\n%3 = fmul fast double %2, 0x400921FB54442D18\n%4 = fptrunc double %3 to float\n%5 = tail call fast nofpclass(nan inf) float @sin(float noundef nofpclass(nan inf) %4)\n%6 = fsub fast float %1, %5\n%7 = fmul fast float %6, %0\nret float %7\n}", "codellama": "define dso_local nofpclass(nan inf) float @BackEaseIn(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fmul fast float %0, %0\n%2 = fmul fast float %1, %0\n%3 = fpext float %0 to double\n%4 = fmul fast double %3, 0x400921FB54442D18\n%5 = fptrunc double %4 to float\n%6 = tail call fast nofpclass(nan inf) float @sin(float noundef nofpclass(nan inf) %5)\n%7 = fmul fast float %6, %0\n%8 = fsub fast float %2, %7\nret float %8\n}", "codegemma": "define dso_local nofpclass(nan inf) float @BackEaseIn(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fmul fast float %0, %0\n%2 = fmul fast float %1, %0\n%3 = fpext float %0 to double\n%4 = fmul fast double %3, 0x400921FB54442D18\n%5 = fptrunc double %4 to float\n%6 = tail call fast nofpclass(nan inf) float @sin(float noundef nofpclass(nan inf) %5)\n%7 = fmul fast float %6, %0\n%8 = fsub fast float %1, %7\nret float %8\n}"}, "define dso_local i32 @pgp_set_unicode_mode(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = icmp ne i32 %5, 0\n%7 = zext i1 %6 to i64\n%8 = select i1 %6, i32 1, i32 0\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %9, i32 0, i32 0\nstore i32 %8, ptr %10, align 4\nret i32 0\n}": {"base_truth": "define dso_local i32 @pgp_set_unicode_mode(ptr nocapture noundef writeonly %0, i32 noundef %1) {\nB:\n%2 = icmp ne i32 %1, 0\n%3 = zext i1 %2 to i32\nstore i32 %3, ptr %0, align 4\nret i32 0\n}", "codellama": "define dso_local i32 @pgp_set_unicode_mode(ptr nocapture noundef writeonly %0, i32 noundef %1) {\nB:\n%2 = icmp ne i32 %1, 0\n%3 = zext i1 %2 to i32\nstore i32 %3, ptr %0, align 4\nret i32 0\n}", "codegemma": "define dso_local i32 @pgp_set_unicode_mode(ptr nocapture noundef writeonly %0, i32 noundef %1) {\nB:\n%2 = icmp ne i32 %1, 0\n%3 = zext i1 %2 to i32\nstore i32 %3, ptr %0, align 4\nret i32 0\n}"}, "define dso_local i32 @match(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%8 = load ptr, ptr %3, align 8\n%9 = call ptr (...) @StateList_new()\n%10 = call ptr @init_list(ptr noundef %8, ptr noundef %9)\nstore ptr %10, ptr %5, align 8\n%11 = call ptr (...) @StateList_new()\nstore ptr %11, ptr %6, align 8\nbr label %12\n\n12:\n%13 = load ptr, ptr %4, align 8\n%14 = load i8, ptr %13, align 1\n%15 = icmp ne i8 %14, 0\nbr i1 %15, label %16, label %28\n\n16:\n%17 = load ptr, ptr %4, align 8\n%18 = load i8, ptr %17, align 1\n%19 = load ptr, ptr %5, align 8\n%20 = load ptr, ptr %6, align 8\n%21 = call i32 @step(i8 noundef signext %18, ptr noundef %19, ptr noundef %20)\n%22 = load ptr, ptr %5, align 8\nstore ptr %22, ptr %7, align 8\n%23 = load ptr, ptr %6, align 8\nstore ptr %23, ptr %5, align 8\n%24 = load ptr, ptr %7, align 8\nstore ptr %24, ptr %6, align 8\nbr label %25\n\n25:\n%26 = load ptr, ptr %4, align 8\n%27 = getelementptr inbounds i8, ptr %26, i32 1\nstore ptr %27, ptr %4, align 8\nbr label %12\n\n28:\n%29 = load ptr, ptr %5, align 8\n%30 = call i32 @is_match(ptr noundef %29)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 %30\n}": {"base_truth": "define dso_local i32 @match(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = tail call ptr (...) @StateList_new()\n%3 = tail call ptr @init_list(ptr noundef %0, ptr noundef %2)\n%4 = tail call ptr (...) @StateList_new()\n%5 = load i8, ptr %1, align 1\n%6 = icmp eq i8 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = phi i8 [ %13, %B1 ], [ %5, %B ]\n%8 = phi ptr [ %12, %B1 ], [ %1, %B ]\n%9 = phi ptr [ %10, %B1 ], [ %4, %B ]\n%10 = phi ptr [ %9, %B1 ], [ %3, %B ]\n%11 = tail call i32 @step(i8 noundef signext %7, ptr noundef %10, ptr noundef %9)\n%12 = getelementptr inbounds i8, ptr %8, i64 1\n%13 = load i8, ptr %12, align 1\n%14 = icmp eq i8 %13, 0\nbr i1 %14, label %B2, label %B1\n\nB2:\n%15 = phi ptr [ %3, %B ], [ %9, %B1 ]\n%16 = tail call i32 @is_match(ptr noundef %15)\nret i32 %16\n}", "codellama": "define dso_local i32 @match(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = tail call ptr (...) @StateList_new()\n%3 = tail call ptr @init_list(ptr noundef %0, ptr noundef %2)\n%4 = tail call ptr (...) @StateList_new()\n%5 = load i8, ptr %1, align 1\n%6 = icmp eq i8 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = phi ptr [ %11, %B1 ], [ %4, %B ]\n%8 = phi ptr [ %10, %B1 ], [ %3, %B ]\n%9 = phi ptr [ %12, %B1 ], [ %1, %B ]\n%10 = tail call i32 @step(i8 noundef signext %5, ptr noundef %8, ptr noundef %7)\n%11 = tail call ptr @StateList_new()\n%12 = getelementptr inbounds i8, ptr %9, i64 1\n%13 = load i8, ptr %12, align 1\n%14 = icmp eq i8 %13, 0\nbr i1 %14, label %B2, label %B1\n\nB2:\n%15 = phi ptr [ %3, %B ], [ %8, %B1 ]\n%16 = phi ptr [ %4, %B ], [ %11, %B1 ]\n%17 = tail call i32 @is_match(ptr noundef %15)\nret i32 %17\n}", "codegemma": "define dso_local i32 @match(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = tail call ptr (...) @StateList_new()\n%3 = tail call ptr @init_list(ptr noundef %0, ptr noundef %2)\n%4 = tail call ptr (...) @StateList_new()\n%5 = load i8, ptr %1, align 1\n%6 = icmp eq i8 %5, 0\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = phi i8 [ %11, %B1 ], [ %5, %B ]\n%8 = phi ptr [ %10, %B1 ], [ %4, %B ]\n%9 = phi ptr [ %9, %B1 ], [ %2, %B ]\n%10 = tail call i32 @step(i8 noundef signext %7, ptr noundef %9, ptr noundef %8)\n%11 = load i8, ptr %1, align 1\n%12 = icmp eq i8 %11, 0\nbr i1 %12, label %B2, label %B1\n\nB2:\n%13 = phi ptr [ %3, %B ], [ %4, %B1 ]\n%14 = tail call i32 @is_match(ptr noundef %13)\nret i32 %14\n}"}, "define dso_local void @special_fdivpl() {\n%1 = call i32 @emit_1_or_2_operandsl_vartext(ptr noundef @.str, ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @special_fdivpl() {\nB:\n%0 = tail call i32 @emit_1_or_2_operandsl_vartext(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @special_fdivpl() {\nB:\n%0 = tail call i32 @emit_1_or_2_operandsl_vartext(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @special_fdivpl() {\nB:\n%0 = tail call i32 @emit_1_or_2_operandsl_vartext(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}"}, "define internal void @flushing_binlog_check() {\n%1 = call i32 (...) @compute_uncommitted_log_bytes()\n%2 = load i32, ptr @ULOG_BUFFER_SIZE, align 4\n%3 = ashr i32 %2, 1\n%4 = icmp sgt i32 %1, %3\nbr i1 %4, label %5, label %7\n\n5:\n%6 = call i32 @flush_binlog_forced(i32 noundef 0)\nbr label %7\n\n7:\nret void\n}": {"base_truth": "define internal void @flushing_binlog_check() {\nB:\n%0 = tail call i32 (...) @compute_uncommitted_log_bytes()\n%1 = load i32, ptr @ULOG_BUFFER_SIZE, align 4\n%2 = ashr i32 %1, 1\n%3 = icmp sgt i32 %0, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @flush_binlog_forced(i32 noundef 0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @flushing_binlog_check() {\nB:\n%0 = tail call i32 (...) @compute_uncommitted_log_bytes()\n%1 = load i32, ptr @ULOG_BUFFER_SIZE, align 4\n%2 = ashr i32 %1, 1\n%3 = icmp sgt i32 %0, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @flush_binlog_forced(i32 noundef 0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @flushing_binlog_check() {\nB:\n%0 = tail call i32 (...) @compute_uncommitted_log_bytes()\n%1 = load i32, ptr @ULOG_BUFFER_SIZE, align 4\n%2 = ashr i32 %1, 1\n%3 = icmp sgt i32 %0, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @flush_binlog_forced(i32 noundef 0)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal zeroext i16 @keymap_kip1000(i32 noundef %0) {\n%2 = alloca i16, align 2\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\nswitch i32 %4, label %37 [\ni32 130, label %5\ni32 20, label %7\ni32 18, label %9\ni32 17, label %11\ni32 36, label %13\ni32 34, label %15\ni32 33, label %17\ni32 68, label %19\ni32 66, label %21\ni32 65, label %23\ni32 129, label %25\ni32 132, label %27\ni32 136, label %29\ni32 72, label %31\ni32 40, label %33\ni32 24, label %35\n]\n\n5:\n%6 = load i16, ptr @KEY_NUMERIC_0, align 2\nstore i16 %6, ptr %2, align 2\nbr label %40\n\n7:\n%8 = load i16, ptr @KEY_NUMERIC_1, align 2\nstore i16 %8, ptr %2, align 2\nbr label %40\n\n9:\n%10 = load i16, ptr @KEY_NUMERIC_2, align 2\nstore i16 %10, ptr %2, align 2\nbr label %40\n\n11:\n%12 = load i16, ptr @KEY_NUMERIC_3, align 2\nstore i16 %12, ptr %2, align 2\nbr label %40\n\n13:\n%14 = load i16, ptr @KEY_NUMERIC_4, align 2\nstore i16 %14, ptr %2, align 2\nbr label %40\n\n15:\n%16 = load i16, ptr @KEY_NUMERIC_5, align 2\nstore i16 %16, ptr %2, align 2\nbr label %40\n\n17:\n%18 = load i16, ptr @KEY_NUMERIC_6, align 2\nstore i16 %18, ptr %2, align 2\nbr label %40\n\n19:\n%20 = load i16, ptr @KEY_NUMERIC_7, align 2\nstore i16 %20, ptr %2, align 2\nbr label %40\n\n21:\n%22 = load i16, ptr @KEY_NUMERIC_8, align 2\nstore i16 %22, ptr %2, align 2\nbr label %40\n\n23:\n%24 = load i16, ptr @KEY_NUMERIC_9, align 2\nstore i16 %24, ptr %2, align 2\nbr label %40\n\n25:\n%26 = load i16, ptr @KEY_NUMERIC_POUND, align 2\nstore i16 %26, ptr %2, align 2\nbr label %40\n\n27:\n%28 = load i16, ptr @KEY_NUMERIC_STAR, align 2\nstore i16 %28, ptr %2, align 2\nbr label %40\n\n29:\n%30 = load i16, ptr @KEY_ENTER, align 2\nstore i16 %30, ptr %2, align 2\nbr label %40\n\n31:\n%32 = load i16, ptr @KEY_ESC, align 2\nstore i16 %32, ptr %2, align 2\nbr label %40\n\n33:\n%34 = load i16, ptr @KEY_LEFT, align 2\nstore i16 %34, ptr %2, align 2\nbr label %40\n\n35:\n%36 = load i16, ptr @KEY_RIGHT, align 2\nstore i16 %36, ptr %2, align 2\nbr label %40\n\n37:\n%38 = load i32, ptr %3, align 4\n%39 = call zeroext i16 @special_keymap(i32 noundef %38)\nstore i16 %39, ptr %2, align 2\nbr label %40\n\n40:\n%41 = load i16, ptr %2, align 2\nret i16 %41\n}": {"base_truth": "define internal zeroext i16 @keymap_kip1000(i32 noundef %0) {\nB:\nswitch i32 %0, label %B17 [\ni32 130, label %B1\ni32 20, label %B2\ni32 18, label %B3\ni32 17, label %B4\ni32 36, label %B5\ni32 34, label %B6\ni32 33, label %B7\ni32 68, label %B8\ni32 66, label %B9\ni32 65, label %B10\ni32 129, label %B11\ni32 132, label %B12\ni32 136, label %B13\ni32 72, label %B14\ni32 40, label %B15\ni32 24, label %B16\n]\n\nB1:\n%1 = load i16, ptr @KEY_NUMERIC_0, align 2\nbr label %B18\n\nB2:\n%2 = load i16, ptr @KEY_NUMERIC_1, align 2\nbr label %B18\n\nB3:\n%3 = load i16, ptr @KEY_NUMERIC_2, align 2\nbr label %B18\n\nB4:\n%4 = load i16, ptr @KEY_NUMERIC_3, align 2\nbr label %B18\n\nB5:\n%5 = load i16, ptr @KEY_NUMERIC_4, align 2\nbr label %B18\n\nB6:\n%6 = load i16, ptr @KEY_NUMERIC_5, align 2\nbr label %B18\n\nB7:\n%7 = load i16, ptr @KEY_NUMERIC_6, align 2\nbr label %B18\n\nB8:\n%8 = load i16, ptr @KEY_NUMERIC_7, align 2\nbr label %B18\n\nB9:\n%9 = load i16, ptr @KEY_NUMERIC_8, align 2\nbr label %B18\n\nB10:\n%10 = load i16, ptr @KEY_NUMERIC_9, align 2\nbr label %B18\n\nB11:\n%11 = load i16, ptr @KEY_NUMERIC_POUND, align 2\nbr label %B18\n\nB12:\n%12 = load i16, ptr @KEY_NUMERIC_STAR, align 2\nbr label %B18\n\nB13:\n%13 = load i16, ptr @KEY_ENTER, align 2\nbr label %B18\n\nB14:\n%14 = load i16, ptr @KEY_ESC, align 2\nbr label %B18\n\nB15:\n%15 = load i16, ptr @KEY_LEFT, align 2\nbr label %B18\n\nB16:\n%16 = load i16, ptr @KEY_RIGHT, align 2\nbr label %B18\n\nB17:\n%17 = tail call zeroext i16 @special_keymap(i32 noundef %0)\nbr label %B18\n\nB18:\n%18 = phi i16 [ %17, %B17 ], [ %16, %B16 ], [ %15, %B15 ], [ %14, %B14 ], [ %13, %B13 ], [ %12, %B12 ], [ %11, %B11 ], [ %10, %B10 ], [ %9, %B9 ], [ %8, %B8 ], [ %7, %B7 ], [ %6, %B6 ], [ %5, %B5 ], [ %4, %B4 ], [ %3, %B3 ], [ %2, %B2 ], [ %1, %B1 ]\nret i16 %18\n}", "codellama": "define internal zeroext i16 @keymap_kip1000(i32 noundef %0) {\nB:\nswitch i32 %0, label %B13 [\ni32 130, label %B12\ni32 20, label %B1\ni32 18, label %B2\ni32 17, label %B3\ni32 36, label %B4\ni32 34, label %B5\ni32 33, label %B6\ni32 68, label %B7\ni32 66, label %B8\ni32 65, label %B9\ni32 129, label %B10\ni32 132, label %B11\ni32 136, label %B12\ni32 72, label %B14\ni32 40, label %B15\ni32 24, label %B16\n]\n\nB1:\nbr label %B12\n\nB2:\nbr label %B12\n\nB3:\nbr label %B12\n\nB4:\nbr label %B12\n\nB5:\nbr label %B12\n\nB6:\nbr label %B12\n\nB7:\nbr label %B12\n\nB8:\nbr label %B12\n\nB9:\nbr label %B12\n\nB10:\nbr label %B12\n\nB11:\nbr label %B12\n\nB12:\n%1 = phi ptr [ @KEY_ENTER, %B11 ], [ @KEY_ESC, %B10 ], [ @KEY_RIGHT, %B9 ], [ @KEY_RIGHT, %B8 ], [ @KEY_RIGHT, %B7 ], [ @KEY_RIGHT, %B6 ], [ @KEY_RIGHT, %B5 ], [ @KEY_RIGHT, %B4 ], [ @KEY_RIGHT, %B3 ], [ @KEY_RIGHT, %B2 ], [ @KEY_RIGHT, %B1 ], [ @KEY_NUMERIC_POUND, %B10 ], [ @KEY_NUMERIC_STAR, %B9 ], [ @KEY_NUMERIC_6, %B8 ], [ @KEY_NUMERIC_5, %B7 ], [ @KEY_NUMERIC_4, %B6 ], [ @KEY_NUMERIC_3, %B5 ], [ @KEY_NUMERIC_2, %B4 ], [ @KEY_NUMERIC_1, %B3 ], [ @KEY_NUMERIC_0, %B2 ], [ @KEY_NUMERIC_0, %B ]\n%2 = load i16, ptr %1, align 2\nbr label %B14\n\nB13:\n%3 = tail call zeroext i16 @special_keymap(i32 noundef %0)\nbr label %B14\n\nB14:\n%4 = phi i16 [ %3, %B13 ], [ %2, %B12 ], [ 0, %B ]\nret i16 %4\n}", "codegemma": "define internal zeroext i16 @keymap_kip1000(i32 noundef %0) {\nB:\n%1 = add i32 %0, -129\n%2 = icmp ult i32 %1, 14\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call zeroext i16 @special_keymap(i32 noundef %0)\nbr label %B3\n\nB2:\n%4 = sext i32 %1 to i64\n%5 = getelementptr inbounds [14 x ptr], ptr @switch.table.keymap_kip1000, i64 0, i64 %4\n%6 = load ptr, ptr %5, align 8\n%7 = load i16, ptr %6, align 2\nbr label %B3\n\nB3:\n%8 = phi i16 [ %3, %B1 ], [ %7, %B2 ]\nret i16 %8\n}"}, "define dso_local void @test_shr() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\nbr label %2\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = icmp slt i32 %3, 64\nbr i1 %4, label %5, label %11\n\n5:\n%6 = load i32, ptr %1, align 4\n%7 = call i32 @exec_shr(i32 noundef 565001524, i32 noundef 305419896, i32 noundef %6)\nbr label %8\n\n8:\n%9 = load i32, ptr %1, align 4\n%10 = add nsw i32 %9, 1\nstore i32 %10, ptr %1, align 4\nbr label %2\n\n11:\nstore i32 0, ptr %1, align 4\nbr label %12\n\n12:\n%13 = load i32, ptr %1, align 4\n%14 = icmp slt i32 %13, 64\nbr i1 %14, label %15, label %21\n\n15:\n%16 = load i32, ptr %1, align 4\n%17 = call i32 @exec_shr(i32 noundef -2126564319, i32 noundef -2110499208, i32 noundef %16)\nbr label %18\n\n18:\n%19 = load i32, ptr %1, align 4\n%20 = add nsw i32 %19, 1\nstore i32 %20, ptr %1, align 4\nbr label %12\n\n21:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @test_shr() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 0, %B ], [ %2, %B1 ]\n%1 = tail call i32 @exec_shr(i32 noundef 565001524, i32 noundef 305419896, i32 noundef %0)\n%2 = add nuw nsw i32 %0, 1\n%3 = icmp eq i32 %2, 64\nbr i1 %3, label %B2, label %B1\n\nB2:\n%4 = phi i32 [ %6, %B2 ], [ 0, %B1 ]\n%5 = tail call i32 @exec_shr(i32 noundef -2126564319, i32 noundef -2110499208, i32 noundef %4)\n%6 = add nuw nsw i32 %4, 1\n%7 = icmp eq i32 %6, 64\nbr i1 %7, label %B3, label %B2\n\nB3:\nret void\n}", "codellama": "define dso_local void @test_shr() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 0, %B ], [ %3, %B1 ]\n%1 = tail call i32 @exec_shr(i32 noundef 565001524, i32 noundef 305419896, i32 noundef %0)\n%2 = add nuw nsw i32 %0, 1\n%3 = icmp eq i32 %2, 64\nbr i1 %3, label %B2, label %B1\n\nB2:\n%4 = phi i32 [ %7, %B2 ], [ 0, %B1 ]\n%5 = tail call i32 @exec_shr(i32 noundef -2126564319, i32 noundef -2110499208, i32 noundef %4)\n%6 = add nuw nsw i32 %4, 1\n%7 = icmp eq i32 %6, 64\nbr i1 %7, label %B3, label %B2\n\nB3:\nret void\n}", "codegemma": "define dso_local void @test_shr() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 0, %B ], [ %2, %B1 ]\n%1 = tail call i32 @exec_shr(i32 noundef 565001524, i32 noundef 305419896, i32 noundef %0)\n%2 = add nuw nsw i32 %0, 1\n%3 = icmp eq i32 %2, 64\nbr i1 %3, label %B2, label %B1\n\nB2:\nbr label %B3\n\nB3:\n%4 = phi i32 [ 0, %B2 ], [ %6, %B3 ]\n%5 = tail call i32 @exec_shr(i32 noundef -2126564319, i32 noundef -2110499208, i32 noundef %4)\n%6 = add nuw nsw i32 %4, 1\n%7 = icmp eq i32 %6, 64\nbr i1 %7, label %B4, label %B3\n\nB4:\nret void\n}"}, "define dso_local void @msg_error_undefined_io() {\n%1 = call i32 @printf(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @msg_error_undefined_io() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @msg_error_undefined_io() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @msg_error_undefined_io() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local i32 @gcp_get_leng() {\n%1 = load i32, ptr @gcp_leng, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @gcp_get_leng() {\nB:\n%0 = load i32, ptr @gcp_leng, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @gcp_get_leng() {\nB:\n%0 = load i32, ptr @gcp_leng, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @gcp_get_leng() {\nB:\n%0 = load i32, ptr @gcp_leng, align 4\nret i32 %0\n}"}, "define dso_local void @isEQ(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %3, align 8\n%6 = load i64, ptr %4, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %8, label %12\n\n8:\n%9 = load i64, ptr %3, align 8\n%10 = load i64, ptr %4, align 8\n%11 = call i32 @printf(ptr noundef @.str, i64 noundef %9, i64 noundef %10)\nbr label %16\n\n12:\n%13 = load i64, ptr %3, align 8\n%14 = load i64, ptr %4, align 8\n%15 = call i32 @printf(ptr noundef @.str.1, i64 noundef %13, i64 noundef %14)\nbr label %16\n\n16:\nret void\n}": {"base_truth": "define dso_local void @isEQ(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @printf(ptr noundef nonnull @.str, i64 noundef %0, i64 noundef %0)\nbr label %B3\n\nB2:\n%4 = tail call i32 @printf(ptr noundef nonnull @.str.1, i64 noundef %0, i64 noundef %1)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @isEQ(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @printf(ptr noundef nonnull @.str, i64 noundef %0, i64 noundef %0)\nbr label %B3\n\nB2:\n%4 = tail call i32 @printf(ptr noundef nonnull @.str.1, i64 noundef %0, i64 noundef %1)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @isEQ(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = icmp eq i64 %0, %1\n%3 = select i1 %2, ptr @.str, ptr @.str.1\n%4 = tail call i32 @printf(ptr noundef nonnull %3, i64 noundef %0, i64 noundef %1)\nret void\n}"}, "define dso_local i32 @pattern_rotate_270(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @pattern_rotate_90(i32 noundef %3)\n%5 = call i32 @pattern_rotate_90(i32 noundef %4)\n%6 = call i32 @pattern_rotate_90(i32 noundef %5)\nret i32 %6\n}": {"base_truth": "define dso_local i32 @pattern_rotate_270(i32 noundef %0) {\nB:\n%1 = tail call i32 @pattern_rotate_90(i32 noundef %0)\n%2 = tail call i32 @pattern_rotate_90(i32 noundef %1)\n%3 = tail call i32 @pattern_rotate_90(i32 noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @pattern_rotate_270(i32 noundef %0) {\nB:\n%1 = tail call i32 @pattern_rotate_90(i32 noundef %0)\n%2 = tail call i32 @pattern_rotate_90(i32 noundef %1)\n%3 = tail call i32 @pattern_rotate_90(i32 noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @pattern_rotate_270(i32 noundef %0) {\nB:\n%1 = tail call i32 @pattern_rotate_90(i32 noundef %0)\n%2 = tail call i32 @pattern_rotate_90(i32 noundef %1)\n%3 = tail call i32 @pattern_rotate_90(i32 noundef %2)\nret i32 %3\n}"}, "define internal i32 @hpsa_skip_device(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore ptr %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\n%11 = load ptr, ptr %6, align 8\n%12 = call i32 @MASKED_DEVICE(ptr noundef %11)\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %15, label %14\n\n14:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n15:\n%16 = load ptr, ptr %7, align 8\n%17 = getelementptr inbounds %struct.ext_report_lun_entry ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\nstore i32 %18, ptr %8, align 4\n%19 = load ptr, ptr %7, align 8\n%20 = getelementptr inbounds %struct.ext_report_lun_entry ptr %19, i32 0, i32 1\n%21 = load i32, ptr %20, align 4\nstore i32 %21, ptr %9, align 4\n%22 = load i32, ptr %8, align 4\n%23 = load i32, ptr @RPL_DEV_FLAG_NON_DISK, align 4\n%24 = and i32 %22, %23\n%25 = icmp ne i32 %24, 0\nbr i1 %25, label %26, label %32\n\n26:\n%27 = load i32, ptr %9, align 4\n%28 = load i32, ptr @BMIC_DEVICE_TYPE_ENCLOSURE, align 4\n%29 = icmp eq i32 %27, %28\nbr i1 %29, label %30, label %31\n\n30:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n31:\nstore i32 1, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n32:\n%33 = load i32, ptr %8, align 4\n%34 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED, align 4\n%35 = and i32 %33, %34\n%36 = icmp ne i32 %35, 0\nbr i1 %36, label %38, label %37\n\n37:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n38:\n%39 = load i32, ptr %8, align 4\n%40 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK, align 4\n%41 = and i32 %39, %40\n%42 = icmp ne i32 %41, 0\nbr i1 %42, label %43, label %44\n\n43:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n44:\n%45 = load ptr, ptr %5, align 8\n%46 = load ptr, ptr %6, align 8\n%47 = call i64 @hpsa_is_disk_spare(ptr noundef %45, ptr noundef %46)\n%48 = icmp ne i64 %47, 0\nbr i1 %48, label %49, label %50\n\n49:\nstore i32 1, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n50:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %51\n\n51:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\n%52 = load i32, ptr %4, align 4\nret i32 %52\n}": {"base_truth": "define internal i32 @hpsa_skip_device(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = tail call i32 @MASKED_DEVICE(ptr noundef %1)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B6, label %B1\n\nB1:\n%5 = load i32, ptr %2, align 4\n%6 = load i32, ptr @RPL_DEV_FLAG_NON_DISK, align 4\n%7 = and i32 %6, %5\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = getelementptr inbounds %struct.ext_report_lun_entry, ptr %2, i64 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr @BMIC_DEVICE_TYPE_ENCLOSURE, align 4\n%12 = icmp ne i32 %10, %11\nbr label %B6\n\nB3:\n%13 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED, align 4\n%14 = and i32 %13, %5\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B6, label %B4\n\nB4:\n%16 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK, align 4\n%17 = and i32 %16, %5\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B5, label %B6\n\nB5:\n%19 = tail call i64 @hpsa_is_disk_spare(ptr noundef %0, ptr noundef %1)\n%20 = icmp ne i64 %19, 0\nbr label %B6\n\nB6:\n%21 = phi i1 [ false, %B ], [ %12, %B2 ], [ false, %B3 ], [ false, %B4 ], [ %20, %B5 ]\n%22 = zext i1 %21 to i32\nret i32 %22\n}", "codellama": "define internal i32 @hpsa_skip_device(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = tail call i32 @MASKED_DEVICE(ptr noundef %1)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B5, label %B1\n\nB1:\n%5 = load i32, ptr %2, align 4\n%6 = getelementptr inbounds %struct.ext_report_lun_entry, ptr %2, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr @RPL_DEV_FLAG_NON_DISK, align 4\n%9 = and i32 %8, %5\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = load i32, ptr @BMIC_DEVICE_TYPE_ENCLOSURE, align 4\n%12 = icmp ne i32 %7, %11\n%13 = zext i1 %12 to i32\nbr label %B5\n\nB3:\n%14 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED, align 4\n%15 = and i32 %14, %5\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B5, label %B4\n\nB4:\n%17 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK, align 4\n%18 = and i32 %17, %5\n%19 = icmp eq i32 %18, 0\n%20 = tail call i64 @hpsa_is_disk_spare(ptr noundef %0, ptr noundef %1)\n%21 = icmp eq i64 %20, 0\n%22 = select i1 %19, i1 %21, i1 false\n%23 = zext i1 %22 to i32\nbr label %B5\n\nB5:\n%24 = phi i32 [ 0, %B ], [ %13, %B2 ], [ 0, %B3 ], [ %23, %B4 ]\nret i32 %24\n}", "codegemma": "define internal i32 @hpsa_skip_device(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = tail call i32 @MASKED_DEVICE(ptr noundef %1)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B5, label %B1\n\nB1:\n%5 = load i32, ptr %2, align 4\n%6 = getelementptr inbounds %struct.ext_report_lun_entry, ptr %2, i64 0, i32 1\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr @RPL_DEV_FLAG_NON_DISK, align 4\n%9 = and i32 %8, %5\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = load i32, ptr @BMIC_DEVICE_TYPE_ENCLOSURE, align 4\n%12 = icmp eq i32 %7, %11\nbr i1 %12, label %B5, label %B4\n\nB3:\n%13 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED, align 4\n%14 = and i32 %13, %5\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B5, label %B4\n\nB4:\n%16 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK, align 4\n%17 = and i32 %16, %5\n%18 = icmp eq i32 %17, 0\nbr i1 %18, label %B6, label %B5\n\nB5:\n%19 = tail call i64 @hpsa_is_disk_spare(ptr noundef %0, ptr noundef %1)\n%20 = icmp ne i64 %19, 0\n%21 = zext i1 %20 to i32\nbr label %B5\n\nB6:\n%22 = tail call i32 @MASKED_DEVICE(ptr noundef %1)\n%23 = icmp eq i32 %22, 0\nbr i1 %23, label %B5, label %B7\n\nB7:\n%24 = load i32, ptr %2, align 4\n%25 = getelementptr inbounds %struct.ext_report_lun_entry, ptr %2, i64 0, i32 1\n%26 = load i32, ptr %25, align 4\n%27 = load i32, ptr @RPL_DEV_FLAG_NON_DISK, align 4\n%28 = and i32 %27, %24\n%29 = icmp eq i32 %28, 0\nbr i1 %29, label %B3, label %B8\n\nB8:\n%30 = load i32, ptr @BMIC_DEVICE_TYPE_ENCLOSURE, align 4\n%31 = icmp eq i32 %26, %30\nbr i1 %31, label %B5, label %B9\n\nB9:\n%32 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED, align 4\n%33 = and i32 %32, %24\n%34 = icmp eq i32 %33, 0\nbr i1 %34, label %B5, label %B10\n\nB10:\n%35 = load i32, ptr @RPL_DEV_FLAG_UNCONFIG_DISK, align 4\n%36 = and i32 %35, %24\n%37 = icmp eq i32 %36, 0\nbr i1 %37, label %B6, label %B5\n\nB11:\n%38 = tail call i64 @hpsa_is_disk_spare(ptr noundef %0, ptr noundef %1)\n%39 = icmp ne i64 %38, 0\n%40 = zext i1 %39 to i32\nbr label %B5\n\nB12:\n%41 = tail call i32 @MASKED_DEVICE(ptr noundef %1)\n%42 = icmp eq i32 %41, 0\nbr i1 %42, label %B5, label %B13\n\nB13:\n%43 = load i32, ptr %2, align 4\n%44 = getelementptr inbounds %struct.ext_report_lun_entry, ptr %2, i64 0, i32 1\n%45<eos>"}, "define dso_local nofpclass(nan inf) double @clrngLfsr113RandomU01_cl_float(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = call fast nofpclass(nan inf) double @clrngLfsr113NextState(ptr noundef %4)\n%6 = fmul fast double %5, 0x3DEFFFFFE0842D8F\nret double %6\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @clrngLfsr113RandomU01_cl_float(ptr noundef %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) double @clrngLfsr113NextState(ptr noundef %0)\n%2 = fmul fast double %1, 0x3DEFFFFFE0842D8F\nret double %2\n}", "codellama": "define dso_local nofpclass(nan inf) double @clrngLfsr113RandomU01_cl_float(ptr noundef %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) double @clrngLfsr113NextState(ptr noundef %0)\n%2 = fmul fast double %1, 0x3DEFFFFFE0842D8F\nret double %2\n}", "codegemma": "define dso_local nofpclass(nan inf) double @clrngLfsr113RandomU01_cl_float(ptr noundef %0) {\nB:\n%1 = tail call fast nofpclass(nan inf) double @clrngLfsr113NextState(ptr noundef %0)\n%2 = fmul fast double %1, 0x3DEFFFFFE0842D8F\nret double %2\n}"}, "define internal i32 @sio_cngetc(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca %struct.siocnstate align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%10 = load ptr, ptr %3, align 8\n%11 = icmp ne ptr %10, null\nbr i1 %11, label %12, label %21\n\n12:\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.consdev, ptr %13, i32 0, i32 0\n%15 = load i64, ptr %14, align 8\n%16 = load i64, ptr @siocnunit, align 8\n%17 = icmp eq i64 %15, %16\nbr i1 %17, label %18, label %21\n\n18:\n%19 = load i64, ptr @siocniobase, align 8\nstore i64 %19, ptr %5, align 8\n%20 = load i32, ptr @comdefaultrate, align 4\nstore i32 %20, ptr %8, align 4\nbr label %22\n\n21:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %9, align 4\nbr label %46\n\n22:\n%23 = call i32 (...) @spltty()\nstore i32 %23, ptr %6, align 4\n%24 = load i64, ptr %5, align 8\n%25 = load i32, ptr %8, align 4\n%26 = call i32 @siocnopen(ptr noundef %7, i64 noundef %24, i32 noundef %25)\n%27 = load i64, ptr %5, align 8\n%28 = load i64, ptr @com_lsr, align 8\n%29 = add nsw i64 %27, %28\n%30 = call i32 @inb(i64 noundef %29)\n%31 = load i32, ptr @LSR_RXRDY, align 4\n%32 = and i32 %30, %31\n%33 = icmp ne i32 %32, 0\nbr i1 %33, label %34, label %39\n\n34:\n%35 = load i64, ptr %5, align 8\n%36 = load i64, ptr @com_data, align 8\n%37 = add nsw i64 %35, %36\n%38 = call i32 @inb(i64 noundef %37)\nstore i32 %38, ptr %4, align 4\nbr label %40\n\n39:\nstore i32 -1, ptr %4, align 4\nbr label %40\n\n40:\n%41 = load i64, ptr %5, align 8\n%42 = call i32 @siocnclose(ptr noundef %7, i64 noundef %41)\n%43 = load i32, ptr %6, align 4\n%44 = call i32 @splx(i32 noundef %43)\n%45 = load i32, ptr %4, align 4\nstore i32 %45, ptr %2, align 4\nstore i32 1, ptr %9, align 4\nbr label %46\n\n46:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%47 = load i32, ptr %2, align 4\nret i32 %47\n}": {"base_truth": "define internal i32 @sio_cngetc(ptr noundef readonly %0) {\nB:\n%1 = alloca %struct.siocnstate, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B5, label %B1\n\nB1:\n%3 = load i64, ptr %0, align 8\n%4 = load i64, ptr @siocnunit, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B2, label %B5\n\nB2:\n%6 = load i64, ptr @siocniobase, align 8\n%7 = load i32, ptr @comdefaultrate, align 4\n%8 = tail call i32 (...) @spltty()\n%9 = call i32 @siocnopen(ptr noundef nonnull %1, i64 noundef %6, i32 noundef %7)\n%10 = load i64, ptr @com_lsr, align 8\n%11 = add nsw i64 %10, %6\n%12 = call i32 @inb(i64 noundef %11)\n%13 = load i32, ptr @LSR_RXRDY, align 4\n%14 = and i32 %13, %12\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B4, label %B3\n\nB3:\n%16 = load i64, ptr @com_data, align 8\n%17 = add nsw i64 %16, %6\n%18 = call i32 @inb(i64 noundef %17)\nbr label %B4\n\nB4:\n%19 = phi i32 [ %18, %B3 ], [ -1, %B2 ]\n%20 = call i32 @siocnclose(ptr noundef nonnull %1, i64 noundef %6)\n%21 = call i32 @splx(i32 noundef %8)\nbr label %B5\n\nB5:\n%22 = phi i32 [ %19, %B4 ], [ -1, %B1 ], [ -1, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %22\n}", "codellama": "define internal i32 @sio_cngetc(ptr noundef readonly %0) {\nB:\n%1 = alloca %struct.siocnstate, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B5, label %B1\n\nB1:\n%3 = load i64, ptr %0, align 8\n%4 = load i64, ptr @siocnunit, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B2, label %B5\n\nB2:\n%6 = load i64, ptr @siocniobase, align 8\n%7 = load i32, ptr @comdefaultrate, align 4\n%8 = tail call i32 (...) @spltty()\n%9 = call i32 @siocnopen(ptr noundef nonnull %1, i64 noundef %6, i32 noundef %7)\n%10 = load i64, ptr @com_lsr, align 8\n%11 = add nsw i64 %10, %6\n%12 = call i32 @inb(i64 noundef %11)\n%13 = load i32, ptr @LSR_RXRDY, align 4\n%14 = and i32 %13, %12\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B4, label %B3\n\nB3:\n%16 = load i64, ptr @com_data, align 8\n%17 = add nsw i64 %16, %6\n%18 = call i32 @inb(i64 noundef %17)\nbr label %B4\n\nB4:\n%19 = phi i32 [ %18, %B3 ], [ -1, %B2 ]\n%20 = call i32 @siocnclose(ptr noundef nonnull %1, i64 noundef %6)\n%21 = call i32 @splx(i32 noundef %8)\nbr label %B5\n\nB5:\n%22 = phi i32 [ %19, %B4 ], [ -1, %B1 ], [ -1, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %22\n}", "codegemma": "define internal i32 @sio_cngetc(ptr noundef readonly %0) {\nB:\n%1 = alloca %struct.siocnstate, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = load i64, ptr %0, align 8\n%4 = load i64, ptr @siocnunit, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B2, label %B4\n\nB2:\n%6 = load i64, ptr @siocniobase, align 8\n%7 = load i32, ptr @comdefaultrate, align 4\n%8 = call i32 @siocnopen(ptr noundef nonnull %1, i64 noundef %6, i32 noundef %7)\n%9 = load i64, ptr @com_lsr, align 8\n%10 = add nsw i64 %9, %6\n%11 = call i32 @inb(i64 noundef %10)\n%12 = load i32, ptr @LSR_RXRDY, align 4\n%13 = and i32 %12, %11\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = load i64, ptr @com_data, align 8\n%16 = add nsw i64 %15, %6\n%17 = call i32 @inb(i64 noundef %16)\nbr label %B4\n\nB4:\n%18 = phi i32 [ %17, %B3 ], [ -1, %B1 ], [ -1, %B ], [ -1, %B2 ]\n%19 = call i32 @splx(i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %18\n}"}, "define dso_local i32 @bar() {\n%1 = load i32, ptr @RESULT, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @bar() {\nB:\n%0 = load i32, ptr @RESULT, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @bar() {\nB:\n%0 = load i32, ptr @RESULT, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @bar() {\nB:\n%0 = load i32, ptr @RESULT, align 4\nret i32 %0\n}"}, "define dso_local i32 @alarm_status(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.t_map ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 8\n%7 = icmp sgt i32 %6, 80\nbr i1 %7, label %8, label %13\n\n8:\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.t_map ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\nswitch i32 %11, label %12 [\n]\n\n12:\nbr label %57\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.t_map ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 8\n%17 = icmp sgt i32 %16, 60\nbr i1 %17, label %18, label %22\n\n18:\n%19 = call i32 @COLOR_PAIR(i32 noundef 6)\n%20 = load i32, ptr @A_BOLD, align 4\n%21 = or i32 %19, %20\nstore i32 %21, ptr %2, align 4\nbr label %59\n\n22:\n%23 = load ptr, ptr %3, align 8\n%24 = getelementptr inbounds %struct.t_map ptr %23, i32 0, i32 2\n%25 = load i32, ptr %24, align 8\n%26 = icmp eq i32 %25, 1\nbr i1 %26, label %27, label %29\n\n27:\n%28 = call i32 @COLOR_PAIR(i32 noundef 5)\nstore i32 %28, ptr %2, align 4\nbr label %59\n\n29:\n%30 = load ptr, ptr %3, align 8\n%31 = getelementptr inbounds %struct.t_map ptr %30, i32 0, i32 2\n%32 = load i32, ptr %31, align 8\n%33 = icmp eq i32 %32, 2\nbr i1 %33, label %34, label %38\n\n34:\n%35 = call i32 @COLOR_PAIR(i32 noundef 5)\n%36 = load i32, ptr @A_REVERSE, align 4\n%37 = or i32 %35, %36\nstore i32 %37, ptr %2, align 4\nbr label %59\n\n38:\n%39 = load ptr, ptr %3, align 8\n%40 = getelementptr inbounds %struct.t_map ptr %39, i32 0, i32 4\n%41 = load i64, ptr %40, align 8\n%42 = icmp ne i64 %41, 0\nbr i1 %42, label %43, label %45\n\n43:\n%44 = call i32 @COLOR_PAIR(i32 noundef 6)\nstore i32 %44, ptr %2, align 4\nbr label %59\n\n45:\n%46 = load ptr, ptr %3, align 8\n%47 = getelementptr inbounds %struct.t_map ptr %46, i32 0, i32 3\n%48 = load i64, ptr %47, align 8\n%49 = icmp eq i64 %48, 0\nbr i1 %49, label %50, label %52\n\n50:\n%51 = call i32 @COLOR_PAIR(i32 noundef 4)\nstore i32 %51, ptr %2, align 4\nbr label %59\n\n52:\nbr label %53\n\n53:\nbr label %54\n\n54:\nbr label %55\n\n55:\nbr label %56\n\n56:\nbr label %57\n\n57:\n%58 = call i32 @COLOR_PAIR(i32 noundef 1)\nstore i32 %58, ptr %2, align 4\nbr label %59\n\n59:\n%60 = load i32, ptr %2, align 4\nret i32 %60\n}": {"base_truth": "define dso_local i32 @alarm_status(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp sgt i32 %1, 80\nbr i1 %2, label %B10, label %B1\n\nB1:\n%3 = icmp sgt i32 %1, 60\nbr i1 %3, label %B2, label %B3\n\nB2:\n%4 = tail call i32 @COLOR_PAIR(i32 noundef 6)\n%5 = load i32, ptr @A_BOLD, align 4\n%6 = or i32 %5, %4\nbr label %B11\n\nB3:\n%7 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 2\n%8 = load i32, ptr %7, align 8\nswitch i32 %8, label %B6 [\ni32 1, label %B4\ni32 2, label %B5\n]\n\nB4:\n%9 = tail call i32 @COLOR_PAIR(i32 noundef 5)\nbr label %B11\n\nB5:\n%10 = tail call i32 @COLOR_PAIR(i32 noundef 5)\n%11 = load i32, ptr @A_REVERSE, align 4\n%12 = or i32 %11, %10\nbr label %B11\n\nB6:\n%13 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 4\n%14 = load i64, ptr %13, align 8\n%15 = icmp eq i64 %14, 0\nbr i1 %15, label %B8, label %B7\n\nB7:\n%16 = tail call i32 @COLOR_PAIR(i32 noundef 6)\nbr label %B11\n\nB8:\n%17 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 3\n%18 = load i64, ptr %17, align 8\n%19 = icmp eq i64 %18, 0\nbr i1 %19, label %B9, label %B10\n\nB9:\n%20 = tail call i32 @COLOR_PAIR(i32 noundef 4)\nbr label %B11\n\nB10:\n%21 = tail call i32 @COLOR_PAIR(i32 noundef 1)\nbr label %B11\n\nB11:\n%22 = phi i32 [ %21, %B10 ], [ %6, %B2 ], [ %9, %B4 ], [ %12, %B5 ], [ %16, %B7 ], [ %20, %B9 ]\nret i32 %22\n}", "codellama": "define dso_local i32 @alarm_status(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp sgt i32 %1, 80\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @COLOR_PAIR(i32 noundef 6)\n%4 = load i32, ptr @A_BOLD, align 4\n%5 = or i32 %4, %3\nbr label %B10\n\nB2:\n%6 = icmp sgt i32 %1, 60\nbr i1 %6, label %B3, label %B4\n\nB3:\n%7 = tail call i32 @COLOR_PAIR(i32 noundef 6)\nbr label %B10\n\nB4:\n%8 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 2\n%9 = load i32, ptr %8, align 8\nswitch i32 %9, label %B9 [\ni32 1, label %B5\ni32 2, label %B6\n]\n\nB5:\n%10 = tail call i32 @COLOR_PAIR(i32 noundef 5)\nbr label %B10\n\nB6:\n%11 = tail call i32 @COLOR_PAIR(i32 noundef 5)\n%12 = load i32, ptr @A_REVERSE, align 4\n%13 = or i32 %12, %11\nbr label %B10\n\nB7:\n%14 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 4\n%15 = load i64, ptr %14, align 8\n%16 = icmp eq i64 %15, 0\nbr i1 %16, label %B8, label %B10\n\nB8:\n%17 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 3\n%18 = load i64, ptr %17, align 8\n%19 = icmp eq i64 %18, 0\n%20 = select i1 %19, i32 4, i32 1\nbr label %B10\n\nB9:\n%21 = tail call i32 @COLOR_PAIR(i32 noundef 1)\nbr label %B10\n\nB10:\n%22 = phi i32 [ %5, %B1 ], [ %7, %B3 ], [ %10, %B5 ], [ %13, %B6 ], [ %21, %B9 ], [ %14, %B7 ], [ %20, %B8 ]\nret i32 %22\n}", "codegemma": "define dso_local i32 @alarm_status(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp sgt i32 %1, 80\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\nbr label %B11\n\nB2:\n%5 = icmp sgt i32 %1, 60\nbr i1 %5, label %B3, label %B4\n\nB3:\n%6 = tail call i32 @COLOR_PAIR(i32 noundef 6)\n%7 = load i32, ptr @A_BOLD, align 4\n%8 = or i32 %7, %6\nbr label %B11\n\nB4:\n%9 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 2\n%10 = load i32, ptr %9, align 8\nswitch i32 %10, label %B6 [\ni32 1, label %B5\ni32 2, label %B6\n]\n\nB5:\n%11 = tail call i32 @COLOR_PAIR(i32 noundef 5)\nbr label %B11\n\nB6:\n%12 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 4\n%13 = load i64, ptr %12, align 8\n%14 = icmp eq i64 %13, 0\nbr i1 %14, label %B7, label %B11\n\nB7:\n%15 = getelementptr inbounds %struct.t_map, ptr %0, i64 0, i32 3\n%16 = load i64, ptr %15, align 8\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B8, label %B11\n\nB8:\n%18 = tail call i32 @COLOR_PAIR(i32 noundef 4)\nbr label %B11\n\nB9:\n%19 = tail call i32 @COLOR_PAIR(i32 noundef 6)\nbr label %B11\n\nB10:\n%20 = tail call i32 @COLOR_PAIR(i32 noundef 1)\nbr label %B11\n\nB11:\n%21 = phi i32 [ %4, %B1 ], [ %11, %B5 ], [ %18, %B8 ], [ %19, %B9 ], [ %10, %B4 ], [ %10, %B6 ], [ %20, %B10 ]\nret i32 %21\n}"}, "define dso_local i32 @dps_set_resp_syntax(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4) {\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca ptr, align 8\n%11 = alloca ptr, align 8\nstore i32 %0, ptr %7, align 4\nstore i32 %1, ptr %8, align 4\nstore i32 %2, ptr %9, align 4\nstore ptr %3, ptr %10, align 8\nstore ptr %4, ptr %11, align 8\n%12 = load ptr, ptr %11, align 8\n%13 = icmp ne ptr %12, null\nbr i1 %13, label %14, label %60\n\n14:\n%15 = load ptr, ptr %11, align 8\n%16 = getelementptr inbounds %struct.TYPE_4__, ptr %15, i32 0, i32 0\nstore i32 0, ptr %16, align 8\n%17 = load ptr, ptr %11, align 8\n%18 = getelementptr inbounds %struct.TYPE_4__, ptr %17, i32 0, i32 4\nstore i64 0, ptr %18, align 8\n%19 = load ptr, ptr %11, align 8\n%20 = getelementptr inbounds %struct.TYPE_4__, ptr %19, i32 0, i32 3\nstore i64 0, ptr %20, align 8\n%21 = load ptr, ptr %11, align 8\n%22 = getelementptr inbounds %struct.TYPE_4__, ptr %21, i32 0, i32 2\nstore i64 0, ptr %22, align 8\n%23 = load i32, ptr %7, align 4\n%24 = icmp sgt i32 %23, 32\nbr i1 %24, label %33, label %25\n\n25:\n%26 = load ptr, ptr @DpsUserIdTable, align 8\n%27 = load i32, ptr %7, align 4\n%28 = sext i32 %27 to i64\n%29 = getelementptr inbounds %struct.TYPE_5__, ptr %26, i64 %28\n%30 = getelementptr inbounds %struct.TYPE_5__, ptr %29, i32 0, i32 0\n%31 = load i32, ptr %30, align 4\n%32 = icmp ne i32 %31, 255\nbr i1 %32, label %33, label %38\n\n33:\n%34 = load ptr, ptr %11, align 8\n%35 = getelementptr inbounds %struct.TYPE_4__, ptr %34, i32 0, i32 0\nstore i32 4, ptr %35, align 8\n%36 = load ptr, ptr %11, align 8\n%37 = getelementptr inbounds %struct.TYPE_4__, ptr %36, i32 0, i32 1\nstore i32 131074, ptr %37, align 4\nbr label %56\n\n38:\n%39 = load ptr, ptr %10, align 8\n%40 = icmp ne ptr %39, null\nbr i1 %40, label %46, label %41\n\n41:\n%42 = load ptr, ptr %11, align 8\n%43 = getelementptr inbounds %struct.TYPE_4__, ptr %42, i32 0, i32 0\nstore i32 4, ptr %43, align 8\n%44 = load ptr, ptr %11, align 8\n%45 = getelementptr inbounds %struct.TYPE_4__, ptr %44, i32 0, i32 1\nstore i32 196616, ptr %45, align 4\nbr label %55\n\n46:\n%47 = load i32, ptr %9, align 4\n%48 = icmp ne i32 %47, 2\nbr i1 %48, label %49, label %54\n\n49:\n%50 = load ptr, ptr %11, align 8\n%51 = getelementptr inbounds %struct.TYPE_4__, ptr %50, i32 0, i32 0\nstore i32 4, ptr %51, align 8\n%52 = load ptr, ptr %11, align 8\n%53 = getelementptr inbounds %struct.TYPE_4__, ptr %52, i32 0, i32 1\nstore i32 131080, ptr %53, align 4\nbr label %54\n\n54:\nbr label %55\n\n55:\nbr label %56\n\n56:\n%57 = load ptr, ptr %11, align 8\n%58 = getelementptr inbounds %struct.TYPE_4__, ptr %57, i32 0, i32 0\n%59 = load i32, ptr %58, align 8\nstore i32 %59, ptr %6, align 4\nbr label %61\n\n60:\nstore i32 4, ptr %6, align 4\nbr label %61\n\n61:\n%62 = load i32, ptr %6, align 4\nret i32 %62\n}": {"base_truth": "define dso_local i32 @dps_set_resp_syntax(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef readnone %3, ptr noundef writeonly %4) {\nB:\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B8, label %B1\n\nB1:\nstore i32 0, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 2\n%7 = icmp sgt i32 %0, 32\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %6, i8 0, i64 24, i1 false)\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = load ptr, ptr @DpsUserIdTable, align 8\n%9 = sext i32 %0 to i64\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %8, i64 %9\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, 255\nbr i1 %12, label %B4, label %B3\n\nB3:\nstore i32 4, ptr %4, align 8\n%13 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 131074, ptr %13, align 4\nbr label %B8\n\nB4:\n%14 = icmp eq ptr %3, null\nbr i1 %14, label %B5, label %B6\n\nB5:\nstore i32 4, ptr %4, align 8\n%15 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 196616, ptr %15, align 4\nbr label %B8\n\nB6:\n%16 = icmp eq i32 %2, 2\nbr i1 %16, label %B8, label %B7\n\nB7:\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 4, ptr %4, align 8\nstore i32 131080, ptr %17, align 4\nbr label %B8\n\nB8:\n%18 = phi i32 [ 4, %B ], [ 4, %B5 ], [ 4, %B7 ], [ 0, %B6 ], [ 4, %B3 ]\nret i32 %18\n}", "codellama": "define dso_local i32 @dps_set_resp_syntax(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef readnone %3, ptr noundef writeonly %4) {\nB:\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B8, label %B1\n\nB1:\nstore i32 0, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 2\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %6, i8 0, i64 24, i1 false)\n%7 = icmp sgt i32 %0, 32\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = load ptr, ptr @DpsUserIdTable, align 8\n%9 = sext i32 %0 to i64\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %8, i64 %9\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, 255\nbr i1 %12, label %B4, label %B3\n\nB3:\nstore i32 4, ptr %4, align 8\n%13 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 131074, ptr %13, align 4\nbr label %B7\n\nB4:\n%14 = icmp eq ptr %3, null\nbr i1 %14, label %B5, label %B6\n\nB5:\nstore i32 4, ptr %4, align 8\n%15 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 196616, ptr %15, align 4\nbr label %B7\n\nB6:\n%16 = icmp eq i32 %2, 2\n%17 = select i1 %16, i32 4, i32 4\nstore i32 %17, ptr %4, align 8\n%18 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 131080, ptr %18, align 4\nbr label %B7\n\nB7:\n%19 = phi i32 [ 4, %B3 ], [ 4, %B5 ], [ %17, %B6 ]\nret i32 %19\n\nB8:\nret i32 4\n}", "codegemma": "define dso_local i32 @dps_set_resp_syntax(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef readnone %3, ptr noundef writeonly %4) {\nB:\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B5, label %B1\n\nB1:\nstore i32 0, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 3\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 2\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %6, i8 0, i64 24, i1 false)\n%8 = icmp sgt i32 %0, 32\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = load ptr, ptr @DpsUserIdTable, align 8\n%10 = sext i32 %0 to i64\n%11 = getelementptr inbounds %struct.TYPE_5__, ptr %9, i64 %10\n%12 = load i32, ptr %11, align 4\n%13 = icmp eq i32 %12, 255\nbr i1 %13, label %B4, label %B3\n\nB3:\nstore i32 4, ptr %4, align 8\n%14 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 131074, ptr %14, align 4\nbr label %B5\n\nB4:\n%15 = icmp eq ptr %3, null\nbr i1 %15, label %B5, label %B6\n\nB5:\n%16 = phi i32 [ 4, %B3 ], [ 4, %B4 ], [ 4, %B ]\nbr label %B6\n\nB6:\n%17 = phi i32 [ 196616, %B4 ], [ %16, %B5 ]\n%18 = icmp eq i32 %2, 2\nbr i1 %18, label %B8, label %B7\n\nB7:\n%19 = phi i32 [ 131080, %B6 ], [ 131074, %B3 ]\n%20 = phi i32 [ 4, %B6 ], [ 4, %B3 ]\nstore i32 %20, ptr %4, align 8\n%21 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i64 0, i32 1\nstore i32 %19, ptr %21, align 4\nbr label %B8\n\nB8:\n%22 = phi i32 [ %17, %B6 ], [ %20, %B7 ]\nret i32 %22\n}"}, "define dso_local void @chip16_shutdown() {\n%1 = call i32 (...) @snd_stop()\nret void\n}": {"base_truth": "define dso_local void @chip16_shutdown() {\nB:\n%0 = tail call i32 (...) @snd_stop()\nret void\n}", "codellama": "define dso_local void @chip16_shutdown() {\nB:\n%0 = tail call i32 (...) @snd_stop()\nret void\n}", "codegemma": "define dso_local void @chip16_shutdown() {\nB:\n%0 = tail call i32 (...) @snd_stop()\nret void\n}"}, "define dso_local i64 @h2h_cmp_sentence_lowlevel(ptr noundef %0, ptr noundef %1, i64 noundef %2) {\n%4 = alloca i64, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i64, align 8\n%8 = alloca i64, align 8\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i64 %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\nstore i64 0, ptr %8, align 8\nbr label %10\n\n10:\n%11 = load i64, ptr %8, align 8\n%12 = load i64, ptr %7, align 8\n%13 = icmp ult i64 %11, %12\nbr i1 %13, label %14, label %41\n\n14:\n%15 = load ptr, ptr %5, align 8\n%16 = load i64, ptr %8, align 8\n%17 = getelementptr inbounds i64, ptr %15, i64 %16\n%18 = load i64, ptr %17, align 8\n%19 = load ptr, ptr %6, align 8\n%20 = load i64, ptr %8, align 8\n%21 = getelementptr inbounds i64, ptr %19, i64 %20\n%22 = load i64, ptr %21, align 8\n%23 = icmp ne i64 %18, %22\nbr i1 %23, label %24, label %37\n\n24:\n%25 = load ptr, ptr %5, align 8\n%26 = load i64, ptr %8, align 8\n%27 = getelementptr inbounds i64, ptr %25, i64 %26\n%28 = load i64, ptr %27, align 8\n%29 = load ptr, ptr %6, align 8\n%30 = load i64, ptr %8, align 8\n%31 = getelementptr inbounds i64, ptr %29, i64 %30\n%32 = load i64, ptr %31, align 8\n%33 = icmp ugt i64 %28, %32\n%34 = zext i1 %33 to i64\n%35 = select i1 %33, i32 1, i32 -1\n%36 = sext i32 %35 to i64\nstore i64 %36, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %42\n\n37:\nbr label %38\n\n38:\n%39 = load i64, ptr %8, align 8\n%40 = add i64 %39, 1\nstore i64 %40, ptr %8, align 8\nbr label %10\n\n41:\nstore i64 0, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %42\n\n42:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\n%43 = load i64, ptr %4, align 8\nret i64 %43\n}": {"base_truth": "define dso_local i64 @h2h_cmp_sentence_lowlevel(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B4, label %B2\n\nB1:\n%4 = add nuw i64 %6, 1\n%5 = icmp eq i64 %4, %2\nbr i1 %5, label %B4, label %B2\n\nB2:\n%6 = phi i64 [ %4, %B1 ], [ 0, %B ]\n%7 = getelementptr inbounds i64, ptr %0, i64 %6\n%8 = load i64, ptr %7, align 8\n%9 = getelementptr inbounds i64, ptr %1, i64 %6\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %8, %10\nbr i1 %11, label %B1, label %B3\n\nB3:\n%12 = icmp ugt i64 %8, %10\n%13 = select i1 %12, i64 1, i64 -1\nbr label %B4\n\nB4:\n%14 = phi i64 [ %13, %B3 ], [ 0, %B ], [ 0, %B1 ]\nret i64 %14\n}", "codellama": "define dso_local i64 @h2h_cmp_sentence_lowlevel(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B4, label %B2\n\nB1:\n%4 = add nuw i64 %6, 1\n%5 = icmp eq i64 %4, %2\nbr i1 %5, label %B4, label %B2\n\nB2:\n%6 = phi i64 [ %4, %B1 ], [ 0, %B ]\n%7 = getelementptr inbounds i64, ptr %0, i64 %6\n%8 = load i64, ptr %7, align 8\n%9 = getelementptr inbounds i64, ptr %1, i64 %6\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %8, %10\nbr i1 %11, label %B1, label %B3\n\nB3:\n%12 = icmp ugt i64 %8, %10\n%13 = select i1 %12, i64 1, i64 -1\nbr label %B4\n\nB4:\n%14 = phi i64 [ %13, %B3 ], [ 0, %B ], [ 0, %B1 ]\nret i64 %14\n}", "codegemma": "define dso_local i64 @h2h_cmp_sentence_lowlevel(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = phi i64 [ %11, %B3 ], [ 0, %B ]\n%5 = getelementptr inbounds i64, ptr %0, i64 %4\n%6 = load i64, ptr %5, align 8\n%7 = getelementptr inbounds i64, ptr %1, i64 %4\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %6, %8\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = icmp ugt i64 %6, %8\n%11 = select i1 %10, i64 1, i64 -1\nbr label %B4\n\nB3:\n%12 = add nuw i64 %4, 1\n%13 = icmp eq i64 %12, %2\nbr i1 %13, label %B4, label %B1\n\nB4:\n%14 = phi i64 [ %11, %B2 ], [ 0, %B ], [ 0, %B3 ]\nret i64 %14\n}"}, "define dso_local void @l2c_link_segments_xmitted(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_9__, ptr %7, i64 1\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.TYPE_9__, ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = sext i32 %11 to i64\n%13 = getelementptr inbounds i32, ptr %8, i64 %12\nstore ptr %13, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%14 = load i32, ptr %4, align 4\n%15 = load ptr, ptr %3, align 8\n%16 = call i32 @STREAM_TO_UINT16(i32 noundef %14, ptr noundef %15)\n%17 = load i32, ptr %4, align 4\n%18 = call i32 @HCID_GET_HANDLE(i32 noundef %17)\nstore i32 %18, ptr %4, align 4\n%19 = load i32, ptr %4, align 4\n%20 = call ptr @l2cu_find_lcb_by_handle(i32 noundef %19)\nstore ptr %20, ptr %5, align 8\n%21 = icmp eq ptr %20, null\nbr i1 %21, label %22, label %27\n\n22:\n%23 = load i32, ptr %4, align 4\n%24 = call i32 @L2CAP_TRACE_WARNING(ptr noundef @.str, i32 noundef %23)\n%25 = load ptr, ptr %2, align 8\n%26 = call i32 @osi_free(ptr noundef %25)\nstore i32 1, ptr %6, align 4\nbr label %48\n\n27:\n%28 = load ptr, ptr %5, align 8\n%29 = getelementptr inbounds %struct.TYPE_8__, ptr %28, i32 0, i32 0\n%30 = load i64, ptr %29, align 8\n%31 = load i64, ptr @LST_CONNECTED, align 8\n%32 = icmp eq i64 %30, %31\nbr i1 %32, label %33, label %44\n\n33:\n%34 = load ptr, ptr %5, align 8\n%35 = getelementptr inbounds %struct.TYPE_8__, ptr %34, i32 0, i32 2\n%36 = load i32, ptr %35, align 4\n%37 = load ptr, ptr %2, align 8\n%38 = call i32 @list_prepend(i32 noundef %36, ptr noundef %37)\n%39 = load i32, ptr @FALSE, align 4\n%40 = load ptr, ptr %5, align 8\n%41 = getelementptr inbounds %struct.TYPE_8__, ptr %40, i32 0, i32 1\nstore i32 %39, ptr %41, align 8\n%42 = load ptr, ptr %5, align 8\n%43 = call i32 @l2c_link_check_send_pkts(ptr noundef %42, ptr noundef null, ptr noundef null)\nbr label %47\n\n44:\n%45 = load ptr, ptr %2, align 8\n%46 = call i32 @osi_free(ptr noundef %45)\nbr label %47\n\n47:\nstore i32 0, ptr %6, align 4\nbr label %48\n\n48:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\n%49 = load i32, ptr %6, align 4\nswitch i32 %49, label %51 [\ni32 0, label %50\ni32 1, label %50\n]\n\n50:\nret void\n\n51:\nunreachable\n}": {"base_truth": "define dso_local void @l2c_link_segments_xmitted(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_9__, ptr %0, i64 1\n%2 = load i32, ptr %0, align 4\n%3 = sext i32 %2 to i64\n%4 = getelementptr inbounds i32, ptr %1, i64 %3\n%5 = tail call i32 @STREAM_TO_UINT16(i32 noundef undef, ptr noundef nonnull %4)\n%6 = tail call i32 @HCID_GET_HANDLE(i32 noundef undef)\n%7 = tail call ptr @l2cu_find_lcb_by_handle(i32 noundef %6)\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = tail call i32 @L2CAP_TRACE_WARNING(ptr noundef nonnull @.str, i32 noundef %6)\n%10 = tail call i32 @osi_free(ptr noundef nonnull %0)\nbr label %B5\n\nB2:\n%11 = load i64, ptr %7, align 8\n%12 = load i64, ptr @LST_CONNECTED, align 8\n%13 = icmp eq i64 %11, %12\nbr i1 %13, label %B3, label %B4\n\nB3:\n%14 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i64 0, i32 2\n%15 = load i32, ptr %14, align 4\n%16 = tail call i32 @list_prepend(i32 noundef %15, ptr noundef nonnull %0)\n%17 = load i32, ptr @FALSE, align 4\n%18 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i64 0, i32 1\nstore i32 %17, ptr %18, align 8\n%19 = tail call i32 @l2c_link_check_send_pkts(ptr noundef nonnull %7, ptr noundef null, ptr noundef null)\nbr label %B5\n\nB4:\n%20 = tail call i32 @osi_free(ptr noundef nonnull %0)\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define dso_local void @l2c_link_segments_xmitted(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_9__, ptr %0, i64 1\n%2 = load i32, ptr %0, align 4\n%3 = sext i32 %2 to i64\n%4 = getelementptr inbounds i32, ptr %1, i64 %3\n%5 = tail call i32 @STREAM_TO_UINT16(i32 noundef undef, ptr noundef nonnull %4)\n%6 = tail call i32 @HCID_GET_HANDLE(i32 noundef undef)\n%7 = tail call ptr @l2cu_find_lcb_by_handle(i32 noundef %6)\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = tail call i32 @L2CAP_TRACE_WARNING(ptr noundef nonnull @.str, i32 noundef %6)\nbr label %B4\n\nB2:\n%10 = load i64, ptr %7, align 8\n%11 = load i64, ptr @LST_CONNECTED, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i64 0, i32 2\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @list_prepend(i32 noundef %14, ptr noundef nonnull %0)\n%16 = load i32, ptr @FALSE, align 4\n%17 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i64 0, i32 1\nstore i32 %16, ptr %17, align 8\n%18 = tail call i32 @l2c_link_check_send_pkts(ptr noundef nonnull %7, ptr noundef null, ptr noundef null)\nbr label %B5\n\nB4:\n%19 = tail call i32 @osi_free(ptr noundef nonnull %0)\nbr label %B5\n\nB5:\nret void\n}", "codegemma": "define dso_local void @l2c_link_segments_xmitted(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_9__, ptr %0, i64 1\n%2 = load i32, ptr %0, align 4\n%3 = sext i32 %2 to i64\n%4 = getelementptr inbounds i32, ptr %1, i64 %3\n%5 = tail call i32 @STREAM_TO_UINT16(i32 noundef undef, ptr noundef %4)\n%6 = tail call i32 @HCID_GET_HANDLE(i32 noundef undef)\n%7 = tail call ptr @l2cu_find_lcb_by_handle(i32 noundef %6)\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = tail call i32 @L2CAP_TRACE_WARNING(ptr noundef nonnull @.str, i32 noundef %6)\nbr label %B5\n\nB2:\n%10 = load i64, ptr %7, align 8\n%11 = load i64, ptr @LST_CONNECTED, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i64 0, i32 2\n%14 = load i32, ptr %13, align 4\n%15 = tail call i32 @list_prepend(i32 noundef %14, ptr noundef nonnull %0)\n%16 = load i32, ptr @FALSE, align 4\n%17 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i64 0, i32 1\nstore i32 %16, ptr %17, align 8\n%18 = tail call i32 @l2c_link_check_send_pkts(ptr noundef nonnull %7, ptr noundef null, ptr noundef null)\nbr label %B5\n\nB4:\n%19 = tail call i32 @osi_free(ptr noundef nonnull %0)\nbr label %B5\n\nB5:\nret void\n}"}, "define internal i32 @nfqnl_put_packet_info(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\nstore i32 0, ptr %7, align 4\n%8 = load ptr, ptr %5, align 8\n%9 = getelementptr inbounds %struct.sk_buff, ptr %8, i32 0, i32 0\n%10 = load i64, ptr %9, align 8\n%11 = load i64, ptr @CHECKSUM_PARTIAL, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %13, label %15\n\n13:\n%14 = load i32, ptr @NFQA_SKB_CSUMNOTREADY, align 4\nstore i32 %14, ptr %7, align 4\nbr label %21\n\n15:\n%16 = load i32, ptr %6, align 4\n%17 = icmp ne i32 %16, 0\nbr i1 %17, label %18, label %20\n\n18:\n%19 = load i32, ptr @NFQA_SKB_CSUM_NOTVERIFIED, align 4\nstore i32 %19, ptr %7, align 4\nbr label %20\n\n20:\nbr label %21\n\n21:\n%22 = load ptr, ptr %5, align 8\n%23 = call i64 @skb_is_gso(ptr noundef %22)\n%24 = icmp ne i64 %23, 0\nbr i1 %24, label %25, label %29\n\n25:\n%26 = load i32, ptr @NFQA_SKB_GSO, align 4\n%27 = load i32, ptr %7, align 4\n%28 = or i32 %27, %26\nstore i32 %28, ptr %7, align 4\nbr label %29\n\n29:\n%30 = load i32, ptr %7, align 4\n%31 = icmp ne i32 %30, 0\nbr i1 %31, label %32, label %38\n\n32:\n%33 = load ptr, ptr %4, align 8\n%34 = load i32, ptr @NFQA_SKB_INFO, align 4\n%35 = load i32, ptr %7, align 4\n%36 = call i32 @htonl(i32 noundef %35)\n%37 = call i32 @nla_put_be32(ptr noundef %33, i32 noundef %34, i32 noundef %36)\nbr label %39\n\n38:\nbr label %39\n\n39:\n%40 = phi i32 [ %37, %32 ], [ 0, %38 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret i32 %40\n}": {"base_truth": "define internal i32 @nfqnl_put_packet_info(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr %1, align 8\n%4 = load i64, ptr @CHECKSUM_PARTIAL, align 8\n%5 = icmp eq i64 %3, %4\n%6 = load i32, ptr @NFQA_SKB_CSUMNOTREADY, align 4\n%7 = icmp eq i32 %2, 0\n%8 = load i32, ptr @NFQA_SKB_CSUM_NOTVERIFIED, align 4\n%9 = select i1 %7, i32 0, i32 %8\n%10 = select i1 %5, i32 %6, i32 %9\n%11 = tail call i64 @skb_is_gso(ptr noundef nonnull %1)\n%12 = icmp eq i64 %11, 0\n%13 = load i32, ptr @NFQA_SKB_GSO, align 4\n%14 = select i1 %12, i32 0, i32 %13\n%15 = or i32 %14, %10\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B2, label %B1\n\nB1:\n%17 = load i32, ptr @NFQA_SKB_INFO, align 4\n%18 = tail call i32 @htonl(i32 noundef %15)\n%19 = tail call i32 @nla_put_be32(ptr noundef %0, i32 noundef %17, i32 noundef %18)\nbr label %B2\n\nB2:\n%20 = phi i32 [ %19, %B1 ], [ 0, %B ]\nret i32 %20\n}", "codellama": "define internal i32 @nfqnl_put_packet_info(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr %1, align 8\n%4 = load i64, ptr @CHECKSUM_PARTIAL, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = load i32, ptr @NFQA_SKB_CSUMNOTREADY, align 4\nbr label %B3\n\nB2:\n%7 = icmp eq i32 %2, 0\n%8 = load i32, ptr @NFQA_SKB_CSUM_NOTVERIFIED, align 4\n%9 = select i1 %7, i32 0, i32 %8\nbr label %B3\n\nB3:\n%10 = phi i32 [ %6, %B1 ], [ %9, %B2 ]\n%11 = tail call i64 @skb_is_gso(ptr noundef nonnull %1)\n%12 = icmp eq i64 %11, 0\n%13 = load i32, ptr @NFQA_SKB_GSO, align 4\n%14 = select i1 %12, i32 0, i32 %13\n%15 = or i32 %14, %10\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B5, label %B4\n\nB4:\n%17 = load i32, ptr @NFQA_SKB_INFO, align 4\n%18 = tail call i32 @htonl(i32 noundef %15)\n%19 = tail call i32 @nla_put_be32(ptr noundef %0, i32 noundef %17, i32 noundef %18)\nbr label %B5\n\nB5:\n%20 = phi i32 [ %19, %B4 ], [ 0, %B3 ]\nret i32 %20\n}", "codegemma": "define internal i32 @nfqnl_put_packet_info(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr %1, align 8\n%4 = load i64, ptr @CHECKSUM_PARTIAL, align 8\n%5 = icmp eq i64 %3, %4\n%6 = load i32, ptr @NFQA_SKB_CSUMNOTREADY, align 4\n%7 = load i32, ptr @NFQA_SKB_CSUM_NOTVERIFIED, align 4\n%8 = select i1 %5, i32 %6, i32 %7\n%9 = tail call i64 @skb_is_gso(ptr noundef nonnull %1)\n%10 = icmp eq i64 %9, 0\n%11 = load i32, ptr @NFQA_SKB_GSO, align 4\n%12 = select i1 %10, i32 0, i32 %11\n%13 = or i32 %12, %8\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B2, label %B1\n\nB1:\n%15 = tail call i32 @htonl(i32 noundef %13)\n%16 = load i32, ptr @NFQA_SKB_INFO, align 4\n%17 = tail call i32 @nla_put_be32(ptr noundef %0, i32 noundef %16, i32 noundef %15)\nbr label %B2\n\nB2:\n%18 = phi i32 [ %17, %B1 ], [ 0, %B ]\nret i32 %18\n}"}, "define dso_local ptr @r81tmp_string() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i32, ptr @fBC72tmp_string, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %4, label %13\n\n4:\nstore i32 1, ptr @fBC72tmp_string, align 4\n%5 = call i64 @se_malloc(i32 noundef 4)\n%6 = inttoptr i64 %5 to ptr\nstore ptr %6, ptr %1, align 8\n%7 = load i32, ptr @M7, align 4\n%8 = load ptr, ptr %1, align 8\nstore i32 %7, ptr %8, align 4\n%9 = load ptr, ptr %1, align 8\n%10 = call i32 @INT32_C(i32 noundef 512)\n%11 = call i32 @r7make(ptr noundef %9, i32 noundef %10)\n%12 = load ptr, ptr %1, align 8\nstore ptr %12, ptr @oBC72tmp_string, align 8\nbr label %13\n\n13:\n%14 = load ptr, ptr @oBC72tmp_string, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %14\n}": {"base_truth": "define dso_local ptr @r81tmp_string() {\nB:\n%0 = load i32, ptr @fBC72tmp_string, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC72tmp_string, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC72tmp_string, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M7, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @INT32_C(i32 noundef 512)\n%7 = tail call i32 @r7make(ptr noundef nonnull %4, i32 noundef %6)\nstore ptr %4, ptr @oBC72tmp_string, align 8\nbr label %B3\n\nB3:\n%8 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %8\n}", "codellama": "define dso_local ptr @r81tmp_string() {\nB:\n%0 = load i32, ptr @fBC72tmp_string, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC72tmp_string, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC72tmp_string, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M7, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @INT32_C(i32 noundef 512)\n%7 = tail call i32 @r7make(ptr noundef nonnull %4, i32 noundef %6)\nstore ptr %4, ptr @oBC72tmp_string, align 8\nbr label %B3\n\nB3:\n%8 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %8\n}", "codegemma": "define dso_local ptr @r81tmp_string() {\nB:\n%0 = load i32, ptr @fBC72tmp_string, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC72tmp_string, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC72tmp_string, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M7, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @INT32_C(i32 noundef 512)\n%7 = tail call i32 @r7make(ptr noundef nonnull %4, i32 noundef %6)\nstore ptr %4, ptr @oBC72tmp_string, align 8\nbr label %B3\n\nB3:\n%8 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %8\n}"}, "define dso_local i32 @iSeries_get_irq() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = load i32, ptr @NO_IRQ_IGNORE, align 4\nstore i32 %2, ptr %1, align 4\n%3 = call i64 (...) @hvlpevent_is_pending()\n%4 = icmp ne i64 %3, 0\nbr i1 %4, label %5, label %7\n\n5:\n%6 = call i32 (...) @process_hvlpevents()\nbr label %7\n\n7:\n%8 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %8\n}": {"base_truth": "define dso_local i32 @iSeries_get_irq() {\nB:\n%0 = load i32, ptr @NO_IRQ_IGNORE, align 4\n%1 = tail call i64 (...) @hvlpevent_is_pending()\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 (...) @process_hvlpevents()\nbr label %B2\n\nB2:\nret i32 %0\n}", "codellama": "define dso_local i32 @iSeries_get_irq() {\nB:\n%0 = load i32, ptr @NO_IRQ_IGNORE, align 4\n%1 = tail call i64 (...) @hvlpevent_is_pending()\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 (...) @process_hvlpevents()\nbr label %B2\n\nB2:\nret i32 %0\n}", "codegemma": "define dso_local i32 @iSeries_get_irq() {\nB:\n%0 = load i32, ptr @NO_IRQ_IGNORE, align 4\n%1 = tail call i64 (...) @hvlpevent_is_pending()\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 (...) @process_hvlpevents()\nbr label %B2\n\nB2:\nret i32 %0\n}"}, "define dso_local i32 @spi_block_erase_21(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = call i32 @spi_write_cmd(ptr noundef %7, i32 noundef 33, i32 noundef 1, i32 noundef %8, ptr noundef null, i32 noundef 0, i32 noundef 10000)\nret i32 %9\n}": {"base_truth": "define dso_local i32 @spi_block_erase_21(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @spi_write_cmd(ptr noundef %0, i32 noundef 33, i32 noundef 1, i32 noundef %1, ptr noundef null, i32 noundef 0, i32 noundef 10000)\nret i32 %3\n}", "codellama": "define dso_local i32 @spi_block_erase_21(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @spi_write_cmd(ptr noundef %0, i32 noundef 33, i32 noundef 1, i32 noundef %1, ptr noundef null, i32 noundef 0, i32 noundef 10000)\nret i32 %3\n}", "codegemma": "define dso_local i32 @spi_block_erase_21(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @spi_write_cmd(ptr noundef %0, i32 noundef 33, i32 noundef 1, i32 noundef %1, ptr noundef null, i32 noundef 0, i32 noundef 10000)\nret i32 %3\n}"}, "define dso_local void @uv__init_detect_system_wakeup() {\n%1 = call i32 (...) @uv__register_system_resume_callback()\nret void\n}": {"base_truth": "define dso_local void @uv__init_detect_system_wakeup() {\nB:\n%0 = tail call i32 (...) @uv__register_system_resume_callback()\nret void\n}", "codellama": "define dso_local void @uv__init_detect_system_wakeup() {\nB:\n%0 = tail call i32 (...) @uv__register_system_resume_callback()\nret void\n}", "codegemma": "define dso_local void @uv__init_detect_system_wakeup() {\nB:\n%0 = tail call i32 (...) @uv__register_system_resume_callback()\nret void\n}"}, "define dso_local void @DwSetBP(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @hi(i32 noundef %3)\n%5 = call i32 (...) @AddrFlag()\n%6 = or i32 %4, %5\n%7 = load i32, ptr %2, align 4\n%8 = call i32 @lo(i32 noundef %7)\n%9 = call i32 @Bytes(i32 noundef 209, i32 noundef %6, i32 noundef %8)\n%10 = call i32 @DwSend(i32 noundef %9)\nret void\n}": {"base_truth": "define dso_local void @DwSetBP(i32 noundef %0) {\nB:\n%1 = tail call i32 @hi(i32 noundef %0)\n%2 = tail call i32 (...) @AddrFlag()\n%3 = or i32 %2, %1\n%4 = tail call i32 @lo(i32 noundef %0)\n%5 = tail call i32 @Bytes(i32 noundef 209, i32 noundef %3, i32 noundef %4)\n%6 = tail call i32 @DwSend(i32 noundef %5)\nret void\n}", "codellama": "define dso_local void @DwSetBP(i32 noundef %0) {\nB:\n%1 = tail call i32 @hi(i32 noundef %0)\n%2 = tail call i32 (...) @AddrFlag()\n%3 = or i32 %2, %1\n%4 = tail call i32 @lo(i32 noundef %0)\n%5 = tail call i32 @Bytes(i32 noundef 209, i32 noundef %3, i32 noundef %4)\n%6 = tail call i32 @DwSend(i32 noundef %5)\nret void\n}", "codegemma": "define dso_local void @DwSetBP(i32 noundef %0) {\nB:\n%1 = tail call i32 @hi(i32 noundef %0)\n%2 = tail call i32 (...) @AddrFlag()\n%3 = or i32 %2, %1\n%4 = tail call i32 @lo(i32 noundef %0)\n%5 = tail call i32 @Bytes(i32 noundef 209, i32 noundef %3, i32 noundef %4)\n%6 = tail call i32 @DwSend(i32 noundef %5)\nret void\n}"}, "define dso_local i32 @setnonblocking(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load i32, ptr %3, align 4\n%7 = load i32, ptr @F_GETFL, align 4\n%8 = call i32 @fcntl(i32 noundef %6, i32 noundef %7, i32 noundef 0)\nstore i32 %8, ptr %4, align 4\n%9 = icmp eq i32 %8, -1\nbr i1 %9, label %10, label %12\n\n10:\n%11 = call i32 @perror(ptr noundef @.str)\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n12:\n%13 = load i32, ptr %4, align 4\n%14 = load i32, ptr @O_NONBLOCK, align 4\n%15 = or i32 %13, %14\nstore i32 %15, ptr %4, align 4\n%16 = load i32, ptr %3, align 4\n%17 = load i32, ptr @F_SETFL, align 4\n%18 = load i32, ptr %4, align 4\n%19 = call i32 @fcntl(i32 noundef %16, i32 noundef %17, i32 noundef %18)\nstore i32 %19, ptr %4, align 4\n%20 = icmp eq i32 %19, -1\nbr i1 %20, label %21, label %23\n\n21:\n%22 = call i32 @perror(ptr noundef @.str)\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n23:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %24\n\n24:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%25 = load i32, ptr %2, align 4\nret i32 %25\n}": {"base_truth": "define dso_local i32 @setnonblocking(i32 noundef %0) {\nB:\n%1 = load i32, ptr @F_GETFL, align 4\n%2 = tail call i32 @fcntl(i32 noundef %0, i32 noundef %1, i32 noundef 0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @O_NONBLOCK, align 4\n%5 = or i32 %4, %2\n%6 = load i32, ptr @F_SETFL, align 4\n%7 = tail call i32 @fcntl(i32 noundef %0, i32 noundef %6, i32 noundef %5)\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = tail call i32 @perror(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\n%10 = phi i32 [ 0, %B1 ], [ -1, %B2 ]\nret i32 %10\n}", "codellama": "define dso_local i32 @setnonblocking(i32 noundef %0) {\nB:\n%1 = load i32, ptr @F_GETFL, align 4\n%2 = tail call i32 @fcntl(i32 noundef %0, i32 noundef %1, i32 noundef 0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @O_NONBLOCK, align 4\n%5 = or i32 %4, %2\n%6 = load i32, ptr @F_SETFL, align 4\n%7 = tail call i32 @fcntl(i32 noundef %0, i32 noundef %6, i32 noundef %5)\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = phi ptr [ @.str, %B ], [ @.str, %B1 ]\n%10 = tail call i32 @perror(ptr noundef nonnull %9)\nbr label %B3\n\nB3:\n%11 = phi i32 [ 0, %B1 ], [ -1, %B2 ]\nret i32 %11\n}", "codegemma": "define dso_local i32 @setnonblocking(i32 noundef %0) {\nB:\n%1 = load i32, ptr @F_GETFL, align 4\n%2 = tail call i32 @fcntl(i32 noundef %0, i32 noundef %1, i32 noundef 0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load i32, ptr @O_NONBLOCK, align 4\n%5 = or i32 %4, %2\n%6 = load i32, ptr @F_SETFL, align 4\n%7 = tail call i32 @fcntl(i32 noundef %0, i32 noundef %6, i32 noundef %5)\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = phi ptr [ @.str, %B ], [ @.str.1, %B1 ]\n%10 = tail call i32 @perror(ptr noundef nonnull %9)\nbr label %B3\n\nB3:\n%11 = phi i32 [ 0, %B1 ], [ -1, %B2 ]\nret i32 %11\n}"}, "define dso_local i64 @fold_build_cleanup_point_expr(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\n%5 = alloca i64, align 8\n%6 = alloca i64, align 8\n%7 = alloca i32, align 4\nstore i64 %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\n%8 = load i64, ptr %5, align 8\n%9 = call i32 @TREE_SIDE_EFFECTS(i64 noundef %8)\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %13, label %11\n\n11:\n%12 = load i64, ptr %5, align 8\nstore i64 %12, ptr %3, align 8\nbr label %46\n\n13:\n%14 = load i64, ptr %5, align 8\n%15 = call i64 @TREE_CODE(i64 noundef %14)\n%16 = load i64, ptr @RETURN_EXPR, align 8\n%17 = icmp eq i64 %15, %16\nbr i1 %17, label %18, label %41\n\n18:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%19 = load i64, ptr %5, align 8\n%20 = call i64 @TREE_OPERAND(i64 noundef %19, i32 noundef 0)\nstore i64 %20, ptr %6, align 8\n%21 = load i64, ptr %6, align 8\n%22 = icmp ne i64 %21, 0\nbr i1 %22, label %23, label %27\n\n23:\n%24 = load i64, ptr %6, align 8\n%25 = call i32 @TREE_SIDE_EFFECTS(i64 noundef %24)\n%26 = icmp ne i32 %25, 0\nbr i1 %26, label %29, label %27\n\n27:\n%28 = load i64, ptr %5, align 8\nstore i64 %28, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %38\n\n29:\n%30 = load i64, ptr %6, align 8\n%31 = call i64 @TREE_OPERAND(i64 noundef %30, i32 noundef 1)\nstore i64 %31, ptr %6, align 8\n%32 = load i64, ptr %6, align 8\n%33 = call i32 @TREE_SIDE_EFFECTS(i64 noundef %32)\n%34 = icmp ne i32 %33, 0\nbr i1 %34, label %37, label %35\n\n35:\n%36 = load i64, ptr %5, align 8\nstore i64 %36, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %38\n\n37:\nstore i32 0, ptr %7, align 4\nbr label %38\n\n38:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%39 = load i32, ptr %7, align 4\nswitch i32 %39, label %48 [\ni32 0, label %40\ni32 1, label %46\n]\n\n40:\nbr label %41\n\n41:\n%42 = load i32, ptr @CLEANUP_POINT_EXPR, align 4\n%43 = load i64, ptr %4, align 8\n%44 = load i64, ptr %5, align 8\n%45 = call i64 @build1(i32 noundef %42, i64 noundef %43, i64 noundef %44)\nstore i64 %45, ptr %3, align 8\nbr label %46\n\n46:\n%47 = load i64, ptr %3, align 8\nret i64 %47\n\n48:\nunreachable\n}": {"base_truth": "define dso_local i64 @fold_build_cleanup_point_expr(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B6, label %B1\n\nB1:\n%4 = tail call i64 @TREE_CODE(i64 noundef %1)\n%5 = load i64, ptr @RETURN_EXPR, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B2, label %B5\n\nB2:\n%7 = tail call i64 @TREE_OPERAND(i64 noundef %1, i32 noundef 0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B6, label %B3\n\nB3:\n%9 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %7)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B6, label %B4\n\nB4:\n%11 = tail call i64 @TREE_OPERAND(i64 noundef %7, i32 noundef 1)\n%12 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B6, label %B5\n\nB5:\n%14 = load i32, ptr @CLEANUP_POINT_EXPR, align 4\n%15 = tail call i64 @build1(i32 noundef %14, i64 noundef %0, i64 noundef %1)\nbr label %B6\n\nB6:\n%16 = phi i64 [ %1, %B4 ], [ %15, %B5 ], [ %1, %B ], [ %1, %B3 ], [ %1, %B2 ]\nret i64 %16\n}", "codellama": "define dso_local i64 @fold_build_cleanup_point_expr(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B6, label %B1\n\nB1:\n%4 = tail call i64 @TREE_CODE(i64 noundef %1)\n%5 = load i64, ptr @RETURN_EXPR, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B2, label %B5\n\nB2:\n%7 = tail call i64 @TREE_OPERAND(i64 noundef %1, i32 noundef 0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B6, label %B3\n\nB3:\n%9 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %7)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B6, label %B4\n\nB4:\n%11 = tail call i64 @TREE_OPERAND(i64 noundef %7, i32 noundef 1)\n%12 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B6, label %B5\n\nB5:\n%14 = load i32, ptr @CLEANUP_POINT_EXPR, align 4\n%15 = tail call i64 @build1(i32 noundef %14, i64 noundef %0, i64 noundef %1)\nbr label %B6\n\nB6:\n%16 = phi i64 [ %1, %B ], [ %1, %B3 ], [ %1, %B2 ], [ %15, %B5 ], [ %1, %B4 ]\nret i64 %16\n}", "codegemma": "define dso_local i64 @fold_build_cleanup_point_expr(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B6, label %B1\n\nB1:\n%4 = tail call i64 @TREE_CODE(i64 noundef %1)\n%5 = load i64, ptr @RETURN_EXPR, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B2, label %B5\n\nB2:\n%7 = tail call i64 @TREE_OPERAND(i64 noundef %1, i32 noundef 0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B6, label %B3\n\nB3:\n%9 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %7)\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B6, label %B4\n\nB4:\n%11 = tail call i64 @TREE_OPERAND(i64 noundef %7, i32 noundef 1)\n%12 = tail call i32 @TREE_SIDE_EFFECTS(i64 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B6, label %B5\n\nB5:\n%14 = load i32, ptr @CLEANUP_POINT_EXPR, align 4\n%15 = tail call i64 @build1(i32 noundef %14, i64 noundef %0, i64 noundef %1)\nbr label %B6\n\nB6:\n%16 = phi i64 [ %15, %B5 ], [ %1, %B ], [ %7, %B2 ], [ %11, %B4 ], [ %1, %B3 ]\nret i64 %16\n}"}, "define dso_local void @printPaddle(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %3, align 4\nbr label %5\n\n5:\n%6 = load i32, ptr %3, align 4\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 8\n%10 = icmp slt i32 %6, %9\nbr i1 %10, label %11, label %39\n\n11:\nstore i32 0, ptr %4, align 4\nbr label %12\n\n12:\n%13 = load i32, ptr %4, align 4\n%14 = load ptr, ptr %2, align 8\n%15 = getelementptr inbounds %struct.TYPE_3__, ptr %14, i32 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = icmp slt i32 %13, %16\nbr i1 %17, label %18, label %35\n\n18:\n%19 = load ptr, ptr %2, align 8\n%20 = getelementptr inbounds %struct.TYPE_3__, ptr %19, i32 0, i32 3\n%21 = load i64, ptr %20, align 8\n%22 = load i32, ptr %4, align 4\n%23 = sext i32 %22 to i64\n%24 = add nsw i64 %21, %23\n%25 = load ptr, ptr %2, align 8\n%26 = getelementptr inbounds %struct.TYPE_3__, ptr %25, i32 0, i32 2\n%27 = load i64, ptr %26, align 8\n%28 = load i32, ptr %3, align 4\n%29 = sext i32 %28 to i64\n%30 = add nsw i64 %27, %29\n%31 = call i32 @mvprintw(i64 noundef %24, i64 noundef %30, ptr noundef @.str)\nbr label %32\n\n32:\n%33 = load i32, ptr %4, align 4\n%34 = add nsw i32 %33, 1\nstore i32 %34, ptr %4, align 4\nbr label %12\n\n35:\nbr label %36\n\n36:\n%37 = load i32, ptr %3, align 4\n%38 = add nsw i32 %37, 1\nstore i32 %38, ptr %3, align 4\nbr label %5\n\n39:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @printPaddle(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B6\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%6 = load i32, ptr %3, align 4\n%7 = icmp sgt i32 %6, 0\nbr i1 %7, label %B2, label %B6\n\nB2:\n%8 = phi i32 [ %23, %B5 ], [ %1, %B1 ]\n%9 = phi i32 [ %24, %B5 ], [ %6, %B1 ]\n%10 = phi i64 [ %25, %B5 ], [ 0, %B1 ]\n%11 = icmp sgt i32 %9, 0\nbr i1 %11, label %B3, label %B5\n\nB3:\n%12 = phi i64 [ %18, %B3 ], [ 0, %B2 ]\n%13 = load i64, ptr %4, align 8\n%14 = add nsw i64 %13, %12\n%15 = load i64, ptr %5, align 8\n%16 = add nsw i64 %15, %10\n%17 = tail call i32 @mvprintw(i64 noundef %14, i64 noundef %16, ptr noundef nonnull @.str)\n%18 = add nuw nsw i64 %12, 1\n%19 = load i32, ptr %3, align 4\n%20 = sext i32 %19 to i64\n%21 = icmp slt i64 %18, %20\nbr i1 %21, label %B3, label %B4\n\nB4:\n%22 = load i32, ptr %0, align 8\nbr label %B5\n\nB5:\n%23 = phi i32 [ %22, %B4 ], [ %8, %B2 ]\n%24 = phi i32 [ %19, %B4 ], [ %9, %B2 ]\n%25 = add nuw nsw i64 %10, 1\n%26 = sext i32 %23 to i64\n%27 = icmp slt i64 %25, %26\nbr i1 %27, label %B2, label %B6\n\nB6:\nret void\n}", "codellama": "define dso_local void @printPaddle(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B5\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\nbr label %B2\n\nB2:\n%6 = phi i64 [ 0, %B1 ], [ %17, %B4 ]\n%7 = load i32, ptr %3, align 4\n%8 = sext i32 %7 to i64\n%9 = icmp sgt i32 %7, 0\nbr i1 %9, label %B3, label %B4\n\nB3:\n%10 = phi i64 [ %14, %B3 ], [ 0, %B2 ]\n%11 = load i64, ptr %4, align 8\n%12 = add nsw i64 %11, %10\n%13 = load i64, ptr %5, align 8\n%14 = add nsw i64 %10, 1\n%15 = icmp eq i64 %14, %8\nbr i1 %15, label %B4, label %B3\n\nB4:\n%16 = phi i64 [ %6, %B2 ], [ %8, %B3 ]\n%17 = add nuw nsw i64 %6, 1\n%18 = icmp eq i64 %17, %1\nbr i1 %18, label %B5, label %B2\n\nB5:\nret void\n}", "codegemma": "define dso_local void @printPaddle(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp sgt i32 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B2, label %B4\n\nB2:\n%6 = phi i64 [ %13, %B3 ], [ 0, %B1 ]\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 3\n%8 = load i64, ptr %7, align 8\n%9 = add nsw i64 %8, %6\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%11 = load i64, ptr %10, align 8\n%12 = add nsw i64 %11, %6\n%13 = add nuw nsw i64 %6, 1\n%14 = tail call i32 @mvprintw(i64 noundef %9, i64 noundef %12, ptr noundef nonnull @.str)\n%15 = load i32, ptr %3, align 4\n%16 = sext i32 %15 to i64\n%17 = icmp slt i64 %13, %16\nbr i1 %17, label %B2, label %B3\n\nB3:\n%18 = load i32, ptr %0, align 8\n%19 = sext i32 %18 to i64\n%20 = icmp slt i64 %13, %19\nbr i1 %20, label %B1, label %B4\n\nB4:\nret void\n}"}, "define dso_local void @glGetTrackMatrixivNV(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\nstore i32 %0, ptr %5, align 4\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore ptr %3, ptr %8, align 8\n%9 = load i32, ptr @NFOSMESA_GLGETTRACKMATRIXIVNV, align 4\n%10 = load i32, ptr @cur_context, align 4\n%11 = call i32 @HostCall_p(i32 noundef %9, i32 noundef %10, ptr noundef %5)\nret void\n}": {"base_truth": "define dso_local void @glGetTrackMatrixivNV(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef readnone %3) {\nB:\n%4 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\n%5 = load i32, ptr @NFOSMESA_GLGETTRACKMATRIXIVNV, align 4\n%6 = load i32, ptr @cur_context, align 4\n%7 = call i32 @HostCall_p(i32 noundef %5, i32 noundef %6, ptr noundef nonnull %4)\nret void\n}", "codellama": "define dso_local void @glGetTrackMatrixivNV(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef readnone %3) {\nB:\n%4 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\n%5 = load i32, ptr @NFOSMESA_GLGETTRACKMATRIXIVNV, align 4\n%6 = load i32, ptr @cur_context, align 4\n%7 = call i32 @HostCall_p(i32 noundef %5, i32 noundef %6, ptr noundef nonnull %4)\nret void\n}", "codegemma": "define dso_local void @glGetTrackMatrixivNV(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef readnone %3) {\nB:\n%4 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\n%5 = load i32, ptr @NFOSMESA_GLGETTRACKMATRIXIVNV, align 4\n%6 = load i32, ptr @cur_context, align 4\n%7 = call i32 @HostCall_p(i32 noundef %5, i32 noundef %6, ptr noundef nonnull %4)\nret void\n}"}, "define dso_local i32 @Px_GetNumInputSources(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\nstore ptr %4, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define dso_local i32 @Px_GetNumInputSources(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @Px_GetNumInputSources(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @Px_GetNumInputSources(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}"}, "define internal i32 @ad799x_read_config(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.ad799x_state ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nswitch i32 %6, label %19 [\ni32 129, label %7\ni32 128, label %7\ni32 132, label %13\ni32 131, label %13\ni32 130, label %13\n]\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.ad799x_state ptr %8, i32 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr @AD7998_CONF_REG, align 4\n%12 = call i32 @i2c_smbus_read_word_swapped(i32 noundef %10, i32 noundef %11)\nstore i32 %12, ptr %2, align 4\nbr label %23\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.ad799x_state ptr %14, i32 0, i32 2\n%16 = load i32, ptr %15, align 4\n%17 = load i32, ptr @AD7998_CONF_REG, align 4\n%18 = call i32 @i2c_smbus_read_byte_data(i32 noundef %16, i32 noundef %17)\nstore i32 %18, ptr %2, align 4\nbr label %23\n\n19:\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.ad799x_state ptr %20, i32 0, i32 1\n%22 = load i32, ptr %21, align 4\nstore i32 %22, ptr %2, align 4\nbr label %23\n\n23:\n%24 = load i32, ptr %2, align 4\nret i32 %24\n}": {"base_truth": "define internal i32 @ad799x_read_config(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B3 [\ni32 129, label %B1\ni32 128, label %B1\ni32 132, label %B2\ni32 131, label %B2\ni32 130, label %B2\n]\n\nB1:\n%2 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @AD7998_CONF_REG, align 4\n%5 = tail call i32 @i2c_smbus_read_word_swapped(i32 noundef %3, i32 noundef %4)\nbr label %B4\n\nB2:\n%6 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 2\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr @AD7998_CONF_REG, align 4\n%9 = tail call i32 @i2c_smbus_read_byte_data(i32 noundef %7, i32 noundef %8)\nbr label %B4\n\nB3:\n%10 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 1\n%11 = load i32, ptr %10, align 4\nbr label %B4\n\nB4:\n%12 = phi i32 [ %11, %B3 ], [ %9, %B2 ], [ %5, %B1 ]\nret i32 %12\n}", "codellama": "define internal i32 @ad799x_read_config(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B3 [\ni32 129, label %B1\ni32 128, label %B1\ni32 132, label %B2\ni32 131, label %B2\ni32 130, label %B2\n]\n\nB1:\n%2 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @AD7998_CONF_REG, align 4\n%5 = tail call i32 @i2c_smbus_read_word_swapped(i32 noundef %3, i32 noundef %4)\nbr label %B4\n\nB2:\n%6 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 2\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr @AD7998_CONF_REG, align 4\n%9 = tail call i32 @i2c_smbus_read_byte_data(i32 noundef %7, i32 noundef %8)\nbr label %B4\n\nB3:\n%10 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 1\n%11 = load i32, ptr %10, align 4\nbr label %B4\n\nB4:\n%12 = phi i32 [ %11, %B3 ], [ %9, %B2 ], [ %5, %B1 ]\nret i32 %12\n}", "codegemma": "define internal i32 @ad799x_read_config(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = add i32 %1, -128\n%3 = icmp ult i32 %2, 5\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 2\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr @AD7998_CONF_REG, align 4\n%7 = tail call i32 @i2c_smbus_read_word_swapped(i32 noundef %5, i32 noundef %6)\nbr label %B3\n\nB2:\n%8 = getelementptr inbounds %struct.ad799x_state, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\nbr label %B3\n\nB3:\n%10 = phi i32 [ %9, %B2 ], [ %7, %B1 ]\nret i32 %10\n}"}, "define dso_local i32 @FunctionCall0Coll(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%6 = load ptr, ptr @fcinfo, align 8\n%7 = call i32 @LOCAL_FCINFO(ptr noundef %6, i32 noundef 0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%8 = load ptr, ptr @fcinfo, align 8\n%9 = load ptr, ptr %3, align 8\n%10 = load i32, ptr %4, align 4\n%11 = getelementptr inbounds %struct.TYPE_9__, ptr %8, i32 0, i32 0\n%12 = load i64, ptr %11, align 8\n%13 = call i32 @InitFunctionCallInfoData(i64 %12, ptr noundef %9, i32 noundef 0, i32 noundef %10, ptr noundef null, ptr noundef null)\n%14 = load ptr, ptr @fcinfo, align 8\n%15 = call i32 @FunctionCallInvoke(ptr noundef %14)\nstore i32 %15, ptr %5, align 4\n%16 = load ptr, ptr @fcinfo, align 8\n%17 = getelementptr inbounds %struct.TYPE_9__, ptr %16, i32 0, i32 0\n%18 = load i64, ptr %17, align 8\n%19 = icmp ne i64 %18, 0\nbr i1 %19, label %20, label %26\n\n20:\n%21 = load i32, ptr @ERROR, align 4\n%22 = load ptr, ptr %3, align 8\n%23 = getelementptr inbounds %struct.TYPE_8__, ptr %22, i32 0, i32 0\n%24 = load i32, ptr %23, align 4\n%25 = call i32 @elog(i32 noundef %21, ptr noundef @.str, i32 noundef %24)\nbr label %26\n\n26:\n%27 = load i32, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %27\n}": {"base_truth": "define dso_local i32 @FunctionCall0Coll(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load ptr, ptr @fcinfo, align 8\n%3 = tail call i32 @LOCAL_FCINFO(ptr noundef %2, i32 noundef 0)\n%4 = load ptr, ptr @fcinfo, align 8\n%5 = load i64, ptr %4, align 8\n%6 = tail call i32 @InitFunctionCallInfoData(i64 %5, ptr noundef %0, i32 noundef 0, i32 noundef %1, ptr noundef null, ptr noundef null)\n%7 = load ptr, ptr @fcinfo, align 8\n%8 = tail call i32 @FunctionCallInvoke(ptr noundef %7)\n%9 = load ptr, ptr @fcinfo, align 8\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB1:\n%12 = load i32, ptr @ERROR, align 4\n%13 = load i32, ptr %0, align 4\n%14 = tail call i32 @elog(i32 noundef %12, ptr noundef nonnull @.str, i32 noundef %13)\nbr label %B2\n\nB2:\nret i32 %8\n}", "codellama": "define dso_local i32 @FunctionCall0Coll(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load ptr, ptr @fcinfo, align 8\n%3 = tail call i32 @LOCAL_FCINFO(ptr noundef %2, i32 noundef 0)\n%4 = load ptr, ptr @fcinfo, align 8\n%5 = load i64, ptr %4, align 8\n%6 = tail call i32 @InitFunctionCallInfoData(i64 %5, ptr noundef %0, i32 noundef 0, i32 noundef %1, ptr noundef null, ptr noundef null)\n%7 = load ptr, ptr @fcinfo, align 8\n%8 = tail call i32 @FunctionCallInvoke(ptr noundef %7)\n%9 = load ptr, ptr @fcinfo, align 8\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB1:\n%12 = load i32, ptr @ERROR, align 4\n%13 = load i32, ptr %0, align 4\n%14 = tail call i32 @elog(i32 noundef %12, ptr noundef nonnull @.str, i32 noundef %13)\nbr label %B2\n\nB2:\nret i32 %8\n}", "codegemma": "define dso_local i32 @FunctionCall0Coll(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load ptr, ptr @fcinfo, align 8\n%3 = tail call i32 @LOCAL_FCINFO(ptr noundef %2, i32 noundef 0)\n%4 = load ptr, ptr @fcinfo, align 8\n%5 = load i64, ptr %4, align 8\n%6 = tail call i32 @InitFunctionCallInfoData(i64 %5, ptr noundef %0, i32 noundef 0, i32 noundef %1, ptr noundef null, ptr noundef null)\n%7 = load ptr, ptr @fcinfo, align 8\n%8 = tail call i32 @FunctionCallInvoke(ptr noundef %7)\n%9 = load ptr, ptr @fcinfo, align 8\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB1:\n%12 = load i32, ptr @ERROR, align 4\n%13 = load i32, ptr %0, align 4\n%14 = tail call i32 @elog(i32 noundef %12, ptr noundef nonnull @.str, i32 noundef %13)\nbr label %B2\n\nB2:\nret i32 %8\n}"}, "define dso_local void @sgIP_Hub_RemoveHardwareInterface(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\nbr label %5\n\n5:\n%6 = load i32, ptr %3, align 4\n%7 = icmp slt i32 %6, 1\nbr i1 %7, label %8, label %20\n\n8:\n%9 = load ptr, ptr @HWInterfaces, align 8\n%10 = load i32, ptr %3, align 4\n%11 = sext i32 %10 to i64\n%12 = getelementptr inbounds %struct.TYPE_4__, ptr %9, i64 %11\n%13 = load ptr, ptr %2, align 8\n%14 = icmp eq ptr %12, %13\nbr i1 %14, label %15, label %16\n\n15:\nbr label %20\n\n16:\nbr label %17\n\n17:\n%18 = load i32, ptr %3, align 4\n%19 = add nsw i32 %18, 1\nstore i32 %19, ptr %3, align 4\nbr label %5\n\n20:\n%21 = load i32, ptr %3, align 4\n%22 = icmp eq i32 %21, 1\nbr i1 %22, label %23, label %24\n\n23:\nstore i32 1, ptr %4, align 4\nbr label %29\n\n24:\n%25 = load ptr, ptr %2, align 8\n%26 = getelementptr inbounds %struct.TYPE_4__, ptr %25, i32 0, i32 0\nstore i64 0, ptr %26, align 8\n%27 = load i32, ptr @NumHWInterfaces, align 4\n%28 = add nsw i32 %27, -1\nstore i32 %28, ptr @NumHWInterfaces, align 4\nstore i32 0, ptr %4, align 4\nbr label %29\n\n29:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\n%30 = load i32, ptr %4, align 4\nswitch i32 %30, label %32 [\ni32 0, label %31\ni32 1, label %31\n]\n\n31:\nret void\n\n32:\nunreachable\n}": {"base_truth": "define dso_local void @sgIP_Hub_RemoveHardwareInterface(ptr noundef writeonly %0) {\nB:\n%1 = load ptr, ptr @HWInterfaces, align 8\n%2 = icmp eq ptr %1, %0\nbr i1 %2, label %B1, label %B2\n\nB1:\nstore i64 0, ptr %0, align 8\n%3 = load i32, ptr @NumHWInterfaces, align 4\n%4 = add nsw i32 %3, -1\nstore i32 %4, ptr @NumHWInterfaces, align 4\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @sgIP_Hub_RemoveHardwareInterface(ptr noundef writeonly %0) {\nB:\n%1 = load ptr, ptr @HWInterfaces, align 8\n%2 = icmp eq ptr %1, %0\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 1\n%4 = icmp eq ptr %3, %0\nbr i1 %4, label %B3, label %B2\n\nB2:\nstore i64 0, ptr %0, align 8\n%5 = load i32, ptr @NumHWInterfaces, align 4\n%6 = add nsw i32 %5, -1\nstore i32 %6, ptr @NumHWInterfaces, align 4\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @sgIP_Hub_RemoveHardwareInterface(ptr noundef %0) {\nB:\n%1 = load ptr, ptr @HWInterfaces, align 8\n%2 = icmp eq ptr %1, %0\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = load i32, ptr @NumHWInterfaces, align 4\n%4 = icmp sgt i32 %3, 1\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = add nsw i32 %3, -1\nstore i32 %5, ptr @NumHWInterfaces, align 4\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local i64 @mach_port_mod_refs(i64 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca i64, align 8\n%6 = alloca i64, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca i64, align 8\n%12 = alloca i32, align 4\nstore i64 %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %11)\n%13 = load i64, ptr %6, align 8\n%14 = load i64, ptr @IS_NULL, align 8\n%15 = icmp eq i64 %13, %14\nbr i1 %15, label %16, label %18\n\n16:\n%17 = load i64, ptr @KERN_INVALID_TASK, align 8\nstore i64 %17, ptr %5, align 8\nstore i32 1, ptr %12, align 4\nbr label %60\n\n18:\n%19 = load i32, ptr %8, align 4\n%20 = load i32, ptr @MACH_PORT_RIGHT_NUMBER, align 4\n%21 = icmp sge i32 %19, %20\nbr i1 %21, label %22, label %24\n\n22:\n%23 = load i64, ptr @KERN_INVALID_VALUE, align 8\nstore i64 %23, ptr %5, align 8\nstore i32 1, ptr %12, align 4\nbr label %60\n\n24:\n%25 = load i32, ptr %7, align 4\n%26 = call i32 @MACH_PORT_VALID(i32 noundef %25)\n%27 = icmp ne i32 %26, 0\nbr i1 %27, label %40, label %28\n\n28:\n%29 = load i32, ptr %8, align 4\n%30 = load i32, ptr @MACH_PORT_RIGHT_SEND, align 4\n%31 = icmp eq i32 %29, %30\nbr i1 %31, label %36, label %32\n\n32:\n%33 = load i32, ptr %8, align 4\n%34 = load i32, ptr @MACH_PORT_RIGHT_SEND_ONCE, align 4\n%35 = icmp eq i32 %33, %34\nbr i1 %35, label %36, label %38\n\n36:\n%37 = load i64, ptr @KERN_SUCCESS, align 8\nstore i64 %37, ptr %5, align 8\nstore i32 1, ptr %12, align 4\nbr label %60\n\n38:\n%39 = load i64, ptr @KERN_INVALID_NAME, align 8\nstore i64 %39, ptr %5, align 8\nstore i32 1, ptr %12, align 4\nbr label %60\n\n40:\n%41 = load i64, ptr %6, align 8\n%42 = load i32, ptr %7, align 4\n%43 = call i64 @ipc_right_lookup_write(i64 noundef %41, i32 noundef %42, ptr noundef %10)\nstore i64 %43, ptr %11, align 8\n%44 = load i64, ptr %11, align 8\n%45 = load i64, ptr @KERN_SUCCESS, align 8\n%46 = icmp ne i64 %44, %45\nbr i1 %46, label %47, label %52\n\n47:\n%48 = load i32, ptr %7, align 4\n%49 = load i32, ptr @kGUARD_EXC_INVALID_NAME, align 4\n%50 = call i32 @mach_port_guard_exception(i32 noundef %48, i32 noundef 0, i32 noundef 0, i32 noundef %49)\n%51 = load i64, ptr %11, align 8\nstore i64 %51, ptr %5, align 8\nstore i32 1, ptr %12, align 4\nbr label %60\n\n52:\n%53 = load i64, ptr %6, align 8\n%54 = load i32, ptr %7, align 4\n%55 = load i32, ptr %10, align 4\n%56 = load i32, ptr %8, align 4\n%57 = load i32, ptr %9, align 4\n%58 = call i64 @ipc_right_delta(i64 noundef %53, i32 noundef %54, i32 noundef %55, i32 noundef %56, i32 noundef %57)\nstore i64 %58, ptr %11, align 8\n%59 = load i64, ptr %11, align 8\nstore i64 %59, ptr %5, align 8\nstore i32 1, ptr %12, align 4\nbr label %60\n\n60:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\n%61 = load i64, ptr %5, align 8\nret i64 %61\n}": {"base_truth": "define dso_local i64 @mach_port_mod_refs(i64 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\n%5 = load i64, ptr @IS_NULL, align 8\n%6 = icmp eq i64 %5, %0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = load i64, ptr @KERN_INVALID_TASK, align 8\nbr label %B11\n\nB2:\n%8 = load i32, ptr @MACH_PORT_RIGHT_NUMBER, align 4\n%9 = icmp sgt i32 %8, %2\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = load i64, ptr @KERN_INVALID_VALUE, align 8\nbr label %B11\n\nB4:\n%11 = tail call i32 @MACH_PORT_VALID(i32 noundef %1)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B5, label %B8\n\nB5:\n%13 = load i32, ptr @MACH_PORT_RIGHT_SEND, align 4\n%14 = icmp eq i32 %13, %2\n%15 = load i32, ptr @MACH_PORT_RIGHT_SEND_ONCE, align 4\n%16 = icmp eq i32 %15, %2\n%17 = select i1 %14, i1 true, i1 %16\nbr i1 %17, label %B6, label %B7\n\nB6:\n%18 = load i64, ptr @KERN_SUCCESS, align 8\nbr label %B11\n\nB7:\n%19 = load i64, ptr @KERN_INVALID_NAME, align 8\nbr label %B11\n\nB8:\n%20 = call i64 @ipc_right_lookup_write(i64 noundef %0, i32 noundef %1, ptr noundef nonnull %4)\n%21 = load i64, ptr @KERN_SUCCESS, align 8\n%22 = icmp eq i64 %20, %21\nbr i1 %22, label %B10, label %B9\n\nB9:\n%23 = load i32, ptr @kGUARD_EXC_INVALID_NAME, align 4\n%24 = call i32 @mach_port_guard_exception(i32 noundef %1, i32 noundef 0, i32 noundef 0, i32 noundef %23)\nbr label %B11\n\nB10:\n%25 = load i32, ptr %4, align 4\n%26 = call i64 @ipc_right_delta(i64 noundef %0, i32 noundef %1, i32 noundef %25, i32 noundef %2, i32 noundef %3)\nbr label %B11\n\nB11:\n%27 = phi i64 [ %7, %B1 ], [ %10, %B3 ], [ %20, %B9 ], [ %26, %B10 ], [ %18, %B6 ], [ %19, %B7 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\nret i64 %27\n}", "codellama": "define dso_local i64 @mach_port_mod_refs(i64 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\n%5 = load i64, ptr @IS_NULL, align 8\n%6 = icmp eq i64 %5, %0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = load i64, ptr @KERN_INVALID_TASK, align 8\nbr label %B10\n\nB2:\n%8 = load i32, ptr @MACH_PORT_RIGHT_NUMBER, align 4\n%9 = icmp sgt i32 %8, %2\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = load i64, ptr @KERN_INVALID_VALUE, align 8\nbr label %B10\n\nB4:\n%11 = tail call i32 @MACH_PORT_VALID(i32 noundef %1)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B5, label %B8\n\nB5:\n%13 = load i32, ptr @MACH_PORT_RIGHT_SEND, align 4\n%14 = icmp eq i32 %13, %2\n%15 = load i32, ptr @MACH_PORT_RIGHT_SEND_ONCE, align 4\n%16 = icmp eq i32 %15, %2\n%17 = select i1 %14, i1 true, i1 %16\nbr i1 %17, label %B6, label %B7\n\nB6:\n%18 = load i64, ptr @KERN_SUCCESS, align 8\nbr label %B10\n\nB7:\n%19 = load i64, ptr @KERN_INVALID_NAME, align 8\nbr label %B10\n\nB8:\n%20 = call i64 @ipc_right_lookup_write(i64 noundef %0, i32 noundef %1, ptr noundef nonnull %4)\n%21 = load i64, ptr @KERN_SUCCESS, align 8\n%22 = icmp eq i64 %20, %21\nbr i1 %22, label %B10, label %B9\n\nB9:\n%23 = load i32, ptr @kGUARD_EXC_INVALID_NAME, align 4\n%24 = call i32 @mach_port_guard_exception(i32 noundef %1, i32 noundef 0, i32 noundef 0, i32 noundef %23)\nbr label %B10\n\nB10:\n%25 = phi i64 [ %7, %B1 ], [ %10, %B3 ], [ %20, %B9 ], [ %20, %B8 ], [ %18, %B6 ], [ %19, %B7 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\nret i</s>", "codegemma": "define dso_local i64 @mach_port_mod_refs(i64 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\n%5 = load i64, ptr @IS_NULL, align 8\n%6 = icmp eq i64 %5, %0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = load i64, ptr @KERN_INVALID_TASK, align 8\nbr label %B10\n\nB2:\n%8 = load i32, ptr @MACH_PORT_RIGHT_NUMBER, align 4\n%9 = icmp sgt i32 %8, %2\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = load i64, ptr @KERN_INVALID_VALUE, align 8\nbr label %B10\n\nB4:\n%11 = tail call i32 @MACH_PORT_VALID(i32 noundef %1)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B5, label %B8\n\nB5:\n%13 = load i32, ptr @MACH_PORT_RIGHT_SEND, align 4\n%14 = icmp eq i32 %13, %2\n%15 = load i32, ptr @MACH_PORT_RIGHT_SEND_ONCE, align 4\n%16 = icmp eq i32 %15, %2\n%17 = select i1 %14, i1 true, i1 %16\nbr i1 %17, label %B6, label %B7\n\nB6:\n%18 = load i64, ptr @KERN_SUCCESS, align 8\nbr label %B10\n\nB7:\n%19 = load i64, ptr @KERN_INVALID_NAME, align 8\nbr label %B10\n\nB8:\n%20 = call i64 @ipc_right_lookup_write(i64 noundef %0, i32 noundef %1, ptr noundef nonnull %4)\n%21 = load i64, ptr @KERN_SUCCESS, align 8\n%22 = icmp eq i64 %20, %21\nbr i1 %22, label %B10, label %B9\n\nB9:\n%23 = load i32, ptr @kGUARD_EXC_INVALID_NAME, align 4\n%24 = call i32 @mach_port_guard_exception(i32 noundef %1, i32 noundef 0, i32 noundef 0, i32 noundef %23)\nbr label %B10\n\nB10:\n%25 = phi i64 [ %7, %B1 ], [ %10, %B3 ], [ %18, %B6 ], [ %19, %B7 ], [ %20, %B9 ], [ %20, %B8 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\nret i64 %25\n}"}, "define dso_local void @clk_disable(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 (...) @clock_lock()\n%4 = load ptr, ptr %2, align 8\n%5 = call i32 @local_clk_unuse(ptr noundef %4)\n%6 = call i32 (...) @clock_unlock()\nret void\n}": {"base_truth": "define dso_local void @clk_disable(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @clock_lock()\n%2 = tail call i32 @local_clk_unuse(ptr noundef %0)\n%3 = tail call i32 (...) @clock_unlock()\nret void\n}", "codellama": "define dso_local void @clk_disable(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @clock_lock()\n%2 = tail call i32 @local_clk_unuse(ptr noundef %0)\n%3 = tail call i32 (...) @clock_unlock()\nret void\n}", "codegemma": "define dso_local void @clk_disable(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @clock_lock()\n%2 = tail call i32 @local_clk_unuse(ptr noundef %0)\n%3 = tail call i32 (...) @clock_unlock()\nret void\n}"}, "define dso_local void @uiFreeImage(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr @TRUE, align 4\n%7 = call i32 @g_ptr_array_free(i32 noundef %5, i32 noundef %6)\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @uiprivFree(ptr noundef %8)\nret void\n}": {"base_truth": "define dso_local void @uiFreeImage(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = load i32, ptr @TRUE, align 4\n%3 = tail call i32 @g_ptr_array_free(i32 noundef %1, i32 noundef %2)\n%4 = tail call i32 @uiprivFree(ptr noundef nonnull %0)\nret void\n}", "codellama": "define dso_local void @uiFreeImage(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = load i32, ptr @TRUE, align 4\n%3 = tail call i32 @g_ptr_array_free(i32 noundef %1, i32 noundef %2)\n%4 = tail call i32 @uiprivFree(ptr noundef nonnull %0)\nret void\n}", "codegemma": "define dso_local void @uiFreeImage(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = load i32, ptr @TRUE, align 4\n%3 = tail call i32 @g_ptr_array_free(i32 noundef %1, i32 noundef %2)\n%4 = tail call i32 @uiprivFree(ptr noundef nonnull %0)\nret void\n}"}, "define dso_local void @DwReset() {\n%1 = call i32 @Bytes(i32 noundef 7)\n%2 = call i32 @DwSend(i32 noundef %1)\n%3 = call i32 (...) @DwSync()\n%4 = call i32 (...) @DwReconnect()\nret void\n}": {"base_truth": "define dso_local void @DwReset() {\nB:\n%0 = tail call i32 @Bytes(i32 noundef 7)\n%1 = tail call i32 @DwSend(i32 noundef %0)\n%2 = tail call i32 (...) @DwSync()\n%3 = tail call i32 (...) @DwReconnect()\nret void\n}", "codellama": "define dso_local void @DwReset() {\nB:\n%0 = tail call i32 @Bytes(i32 noundef 7)\n%1 = tail call i32 @DwSend(i32 noundef %0)\n%2 = tail call i32 (...) @DwSync()\n%3 = tail call i32 (...) @DwReconnect()\nret void\n}", "codegemma": "define dso_local void @DwReset() {\nB:\n%0 = tail call i32 @Bytes(i32 noundef 7)\n%1 = tail call i32 @DwSend(i32 noundef %0)\n%2 = tail call i32 (...) @DwSync()\n%3 = tail call i32 (...) @DwReconnect()\nret void\n}"}, "define dso_local void @hr_session_close(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\nstore ptr %4, ptr %3, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.http_session ptr %5, i32 0, i32 1\n%7 = load i64, ptr %6, align 8\n%8 = icmp ne i64 %7, 0\nbr i1 %8, label %9, label %14\n\n9:\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.http_session ptr %10, i32 0, i32 1\n%12 = load i64, ptr %11, align 8\n%13 = call i32 @free(i64 noundef %12)\nbr label %14\n\n14:\n%15 = load ptr, ptr %3, align 8\n%16 = getelementptr inbounds %struct.http_session ptr %15, i32 0, i32 0\n%17 = load i64, ptr %16, align 8\n%18 = icmp ne i64 %17, 0\nbr i1 %18, label %19, label %24\n\n19:\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.http_session ptr %20, i32 0, i32 0\n%22 = load i64, ptr %21, align 8\n%23 = call i32 @uwsgi_buffer_destroy(i64 noundef %22)\nbr label %24\n\n24:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @hr_session_close(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.http_session, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @free(i64 noundef %2)\nbr label %B2\n\nB2:\n%5 = load i64, ptr %0, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = tail call i32 @uwsgi_buffer_destroy(i64 noundef %5)\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @hr_session_close(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.http_session, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @free(i64 noundef %2)\nbr label %B2\n\nB2:\n%5 = load i64, ptr %0, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = tail call i32 @uwsgi_buffer_destroy(i64 noundef %5)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @hr_session_close(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.http_session, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @free(i64 noundef %2)\nbr label %B2\n\nB2:\n%5 = load i64, ptr %0, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = tail call i32 @uwsgi_buffer_destroy(i64 noundef %5)\nbr label %B4\n\nB4:\nret void\n}"}, "define dso_local i32 @retmeX(i32 %0) {\n%2 = alloca %struct.X align 4\n%3 = alloca %struct.X align 4\n%4 = getelementptr inbounds %struct.X ptr %3, i32 0, i32 0\nstore i32 %0, ptr %4, align 4\ncall void @llvm.memcpy.p0.p0.i64(ptr align 4 %2, ptr align 4 %3, i64 4, i1 false)\n%5 = getelementptr inbounds %struct.X ptr %2, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nret i32 %6\n}": {"base_truth": "define dso_local i32 @retmeX(i32 returned %0) {\nB:\nret i32 %0\n}", "codellama": "define dso_local i32 @retmeX(i32 returned %0) {\nB:\nret i32 %0\n}", "codegemma": "define dso_local i32 @retmeX(i32 returned %0) {\nB:\nret i32 %0\n}"}, "define dso_local void @unget_cpp_token(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %7, label %13\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\n%11 = load ptr, ptr %4, align 8\n%12 = call i32 @list_push(i32 noundef %10, ptr noundef %11)\nbr label %13\n\n13:\nret void\n}": {"base_truth": "define dso_local void @unget_cpp_token(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @list_push(i32 noundef %3, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @unget_cpp_token(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @list_push(i32 noundef %3, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @unget_cpp_token(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @list_push(i32 noundef %3, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i32 @graph_symbol_forks(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.graph_symbol ptr %4, i32 0, i32 2\n%6 = load i32, ptr %5, align 4\n%7 = icmp ne i32 %6, 0\nbr i1 %7, label %9, label %8\n\n8:\nstore i32 0, ptr %2, align 4\nbr label %22\n\n9:\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.graph_symbol ptr %10, i32 0, i32 1\n%12 = load i32, ptr %11, align 4\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %15, label %14\n\n14:\nstore i32 0, ptr %2, align 4\nbr label %22\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = getelementptr inbounds %struct.graph_symbol ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = icmp ne i32 %18, 0\nbr i1 %19, label %21, label %20\n\n20:\nstore i32 0, ptr %2, align 4\nbr label %22\n\n21:\nstore i32 1, ptr %2, align 4\nbr label %22\n\n22:\n%23 = load i32, ptr %2, align 4\nret i32 %23\n}": {"base_truth": "define internal i32 @graph_symbol_forks(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.graph_symbol, ptr %0, i64 0, i32 2\n%2 = load i32, ptr %1, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.graph_symbol, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr %0, align 4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nbr label %B3\n\nB3:\n%10 = phi i32 [ 0, %B ], [ 0, %B1 ], [ %9, %B2 ]\nret i32 %10\n}", "codellama": "define internal i32 @graph_symbol_forks(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.graph_symbol, ptr %0, i64 0, i32 2\n%2 = load i32, ptr %1, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.graph_symbol, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr %0, align 4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nbr label %B3\n\nB3:\n%10 = phi i32 [ 0, %B ], [ 0, %B1 ], [ %9, %B2 ]\nret i32 %10\n}", "codegemma": "define internal i32 @graph_symbol_forks(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.graph_symbol, ptr %0, i64 0, i32 2\n%2 = load i32, ptr %1, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = getelementptr inbounds %struct.graph_symbol, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr %0, align 4\n%8 = icmp ne i32 %7, 0\n%9 = zext i1 %8 to i32\nbr label %B3\n\nB3:\n%10 = phi i32 [ 0, %B ], [ 0, %B1 ], [ %9, %B2 ]\nret i32 %10\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca [5 x double], align 16\n%3 = alloca [5 x double], align 16\n%4 = alloca [5 x double], align 16\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 40, ptr %2)\ncall void @llvm.memset.p0.i64(ptr align 16 %2, i8 0, i64 40, i1 false)\n%5 = getelementptr inbounds [5 x double], ptr %2, i32 0, i32 0\nstore double 1.100000e+00, ptr %5, align 16\n%6 = getelementptr inbounds [5 x double], ptr %2, i32 0, i32 1\nstore double 2.200000e+00, ptr %6, align 8\n%7 = getelementptr inbounds [5 x double], ptr %2, i32 0, i32 2\nstore double 3.300000e+00, ptr %7, align 16\n%8 = getelementptr inbounds [5 x double], ptr %2, i32 0, i32 3\nstore double 4.400000e+00, ptr %8, align 8\n%9 = getelementptr inbounds [5 x double], ptr %2, i32 0, i32 4\nstore double 5.500000e+00, ptr %9, align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 40, ptr %4)\n%10 = getelementptr inbounds [5 x double], ptr %2, i64 0, i64 0\n%11 = getelementptr inbounds [5 x double], ptr %3, i64 0, i64 0\n%12 = call i32 @copy_arr(ptr noundef %10, ptr noundef %11, i32 noundef 5)\n%13 = getelementptr inbounds [5 x double], ptr %2, i64 0, i64 0\n%14 = getelementptr inbounds [5 x double], ptr %4, i64 0, i64 0\n%15 = call i32 @copy_ptr(ptr noundef %13, ptr noundef %14, i32 noundef 5)\ncall void @llvm.lifetime.end.p0(i64 40, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 40, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 40, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca [5 x double], align 16\n%1 = alloca [5 x double], align 16\n%2 = alloca [5 x double], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\nstore <4 x double> <double 1.100000e+00, double 2.200000e+00, double 3.300000e+00, double 4.400000e+00>, ptr %0, align 16\n%3 = getelementptr inbounds [5 x double], ptr %0, i64 0, i64 4\nstore double 5.500000e+00, ptr %3, align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %2)\n%4 = call i32 @copy_arr(ptr noundef nonnull %0, ptr noundef nonnull %1, i32 noundef 5)\n%5 = call i32 @copy_ptr(ptr noundef nonnull %0, ptr noundef nonnull %2, i32 noundef 5)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca [5 x double], align 16\n%1 = alloca [5 x double], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(40) %0, i8 0, i64 40, i1 false)\nstore <4 x double> <double 1.100000e+00, double 2.200000e+00, double 3.300000e+00, double 4.400000e+00>, ptr %0, align 16\n%2 = getelementptr inbounds [5 x double], ptr %0, i64 0, i64 4\nstore double 5.500000e+00, ptr %2, align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %1)\n%3 = call i32 @copy_arr(ptr noundef nonnull %0, ptr noundef nonnull %1, i32 noundef 5)\n%4 = call i32 @copy_ptr(ptr noundef nonnull %0, ptr noundef nonnull %1, i32 noundef 5)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca [5 x double], align 16\n%1 = alloca [5 x double], align 16\n%2 = alloca [5 x double], align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(40) %0, i8 0, i64 40, i1 false)\nstore <4 x double> <double 1.100000e+00, double 2.200000e+00, double 3.300000e+00, double 4.400000e+00>, ptr %0, align 16\n%3 = getelementptr inbounds [5 x double], ptr %0, i64 0, i64 4\nstore double 5.500000e+00, ptr %3, align 16\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %2)\n%4 = call i32 @copy_arr(ptr noundef nonnull %0, ptr noundef nonnull %1, i32 noundef 5)\n%5 = call i32 @copy_ptr(ptr noundef nonnull %0, ptr noundef nonnull %2, i32 noundef 5)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret i32 0\n}"}, "define internal i32 @s5h1420_getfec(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = call i32 @s5h1420_readreg(ptr noundef %4, i32 noundef 50)\n%6 = and i32 %5, 7\nswitch i32 %6, label %19 [\ni32 0, label %7\ni32 1, label %9\ni32 2, label %11\ni32 3, label %13\ni32 4, label %15\ni32 5, label %17\n]\n\n7:\n%8 = load i32, ptr @FEC_1_2, align 4\nstore i32 %8, ptr %2, align 4\nbr label %21\n\n9:\n%10 = load i32, ptr @FEC_2_3, align 4\nstore i32 %10, ptr %2, align 4\nbr label %21\n\n11:\n%12 = load i32, ptr @FEC_3_4, align 4\nstore i32 %12, ptr %2, align 4\nbr label %21\n\n13:\n%14 = load i32, ptr @FEC_5_6, align 4\nstore i32 %14, ptr %2, align 4\nbr label %21\n\n15:\n%16 = load i32, ptr @FEC_6_7, align 4\nstore i32 %16, ptr %2, align 4\nbr label %21\n\n17:\n%18 = load i32, ptr @FEC_7_8, align 4\nstore i32 %18, ptr %2, align 4\nbr label %21\n\n19:\n%20 = load i32, ptr @FEC_NONE, align 4\nstore i32 %20, ptr %2, align 4\nbr label %21\n\n21:\n%22 = load i32, ptr %2, align 4\nret i32 %22\n}": {"base_truth": "define internal i32 @s5h1420_getfec(ptr noundef %0) {\nB:\n%1 = tail call i32 @s5h1420_readreg(ptr noundef %0, i32 noundef 50)\n%2 = and i32 %1, 7\n%3 = icmp ult i32 %2, 6\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = zext i32 %2 to i64\n%5 = getelementptr inbounds [6 x ptr], ptr @switch.table.s5h1420_getfec, i64 0, i64 %4\n%6 = load ptr, ptr %5, align 8\nbr label %B2\n\nB2:\n%7 = phi ptr [ %6, %B1 ], [ @FEC_NONE, %B ]\n%8 = load i32, ptr %7, align 4\nret i32 %8\n}", "codellama": "define internal i32 @s5h1420_getfec(ptr noundef %0) {\nB:\n%1 = tail call i32 @s5h1420_readreg(ptr noundef %0, i32 noundef 50)\n%2 = and i32 %1, 7\n%3 = icmp ult i32 %2, 7\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds [7 x ptr], ptr @switch.table.s5h1420_getfec, i64 0, i64 %4\n%6 = load ptr, ptr %5, align 8\nbr label %B2\n\nB2:\n%7 = phi ptr [ %6, %B1 ], [ @FEC_NONE, %B ]\n%8 = load i32, ptr %7, align 4\nret i32 %8\n}", "codegemma": "define internal i32 @s5h1420_getfec(ptr noundef %0) {\nB:\n%1 = tail call i32 @s5h1420_readreg(ptr noundef %0, i32 noundef 50)\n%2 = and i32 %1, 7\n%3 = add i32 %2, -1\n%4 = icmp ult i32 %3, 7\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = sext i32 %3 to i64\n%6 = getelementptr inbounds [7 x ptr], ptr @switch.table.s5h1420_getfec, i64 0, i64 %5\n%7 = load ptr, ptr %6, align 8\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ @FEC_NONE, %B ]\n%9 = load i32, ptr %8, align 4\nret i32 %9\n}"}, "define dso_local i32 @kvm_arch_vcpu_ioctl_set_sregs(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr @ENOTSUPP, align 4\n%6 = sub nsw i32 0, %5\nret i32 %6\n}": {"base_truth": "define dso_local i32 @kvm_arch_vcpu_ioctl_set_sregs(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @ENOTSUPP, align 4\n%3 = sub nsw i32 0, %2\nret i32 %3\n}", "codellama": "define dso_local i32 @kvm_arch_vcpu_ioctl_set_sregs(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @ENOTSUPP, align 4\n%3 = sub nsw i32 0, %2\nret i32 %3\n}", "codegemma": "define dso_local i32 @kvm_arch_vcpu_ioctl_set_sregs(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @ENOTSUPP, align 4\n%3 = sub nsw i32 0, %2\nret i32 %3\n}"}, "define internal i32 @sun4d_startup_irq(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.irq_data ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @irq_link(i32 noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @sun4d_unmask_irq(ptr noundef %7)\nret i32 0\n}": {"base_truth": "define internal i32 @sun4d_startup_irq(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @irq_link(i32 noundef %1)\n%3 = tail call i32 @sun4d_unmask_irq(ptr noundef nonnull %0)\nret i32 0\n}", "codellama": "define internal i32 @sun4d_startup_irq(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @irq_link(i32 noundef %1)\n%3 = tail call i32 @sun4d_unmask_irq(ptr noundef nonnull %0)\nret i32 0\n}", "codegemma": "define internal i32 @sun4d_startup_irq(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @irq_link(i32 noundef %1)\n%3 = tail call i32 @sun4d_unmask_irq(ptr noundef nonnull %0)\nret i32 0\n}"}, "define dso_local void @sepgsql_schema_rename(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @SEPG_DB_SCHEMA__ADD_NAME, align 4\n%5 = load i32, ptr @SEPG_DB_SCHEMA__REMOVE_NAME, align 4\n%6 = or i32 %4, %5\n%7 = call i32 @check_schema_perms(i32 noundef %3, i32 noundef %6, i32 noundef 1)\nret void\n}": {"base_truth": "define dso_local void @sepgsql_schema_rename(i32 noundef %0) {\nB:\n%1 = load i32, ptr @SEPG_DB_SCHEMA__ADD_NAME, align 4\n%2 = load i32, ptr @SEPG_DB_SCHEMA__REMOVE_NAME, align 4\n%3 = or i32 %2, %1\n%4 = tail call i32 @check_schema_perms(i32 noundef %0, i32 noundef %3, i32 noundef 1)\nret void\n}", "codellama": "define dso_local void @sepgsql_schema_rename(i32 noundef %0) {\nB:\n%1 = load i32, ptr @SEPG_DB_SCHEMA__ADD_NAME, align 4\n%2 = load i32, ptr @SEPG_DB_SCHEMA__REMOVE_NAME, align 4\n%3 = or i32 %2, %1\n%4 = tail call i32 @check_schema_perms(i32 noundef %0, i32 noundef %3, i32 noundef 1)\nret void\n}", "codegemma": "define dso_local void @sepgsql_schema_rename(i32 noundef %0) {\nB:\n%1 = load i32, ptr @SEPG_DB_SCHEMA__ADD_NAME, align 4\n%2 = load i32, ptr @SEPG_DB_SCHEMA__REMOVE_NAME, align 4\n%3 = or i32 %2, %1\n%4 = tail call i32 @check_schema_perms(i32 noundef %0, i32 noundef %3, i32 noundef 1)\nret void\n}"}, "define internal i32 @LoadExt_NV_point_sprite() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\n%2 = call i64 @IntGetProcAddress(ptr noundef @.str)\nstore i64 %2, ptr @_funcptr_glPointParameteriNV, align 8\n%3 = load i64, ptr @_funcptr_glPointParameteriNV, align 8\n%4 = icmp ne i64 %3, 0\nbr i1 %4, label %8, label %5\n\n5:\n%6 = load i32, ptr %1, align 4\n%7 = add nsw i32 %6, 1\nstore i32 %7, ptr %1, align 4\nbr label %8\n\n8:\n%9 = call i64 @IntGetProcAddress(ptr noundef @.str.1)\nstore i64 %9, ptr @_funcptr_glPointParameterivNV, align 8\n%10 = load i64, ptr @_funcptr_glPointParameterivNV, align 8\n%11 = icmp ne i64 %10, 0\nbr i1 %11, label %15, label %12\n\n12:\n%13 = load i32, ptr %1, align 4\n%14 = add nsw i32 %13, 1\nstore i32 %14, ptr %1, align 4\nbr label %15\n\n15:\n%16 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %16\n}": {"base_truth": "define internal i32 @LoadExt_NV_point_sprite() {\nB:\n%0 = tail call i64 @IntGetProcAddress(ptr noundef nonnull @.str)\nstore i64 %0, ptr @_funcptr_glPointParameteriNV, align 8\n%1 = icmp eq i64 %0, 0\n%2 = zext i1 %1 to i32\n%3 = tail call i64 @IntGetProcAddress(ptr noundef nonnull @.str.1)\nstore i64 %3, ptr @_funcptr_glPointParameterivNV, align 8\n%4 = icmp eq i64 %3, 0\n%5 = select i1 %1, i32 2, i32 1\n%6 = select i1 %4, i32 %5, i32 %2\nret i32 %6\n}", "codellama": "define internal i32 @LoadExt_NV_point_sprite() {\nB:\n%0 = tail call i64 @IntGetProcAddress(ptr noundef nonnull @.str)\nstore i64 %0, ptr @_funcptr_glPointParameteriNV, align 8\n%1 = icmp eq i64 %0, 0\n%2 = zext i1 %1 to i32\n%3 = tail call i64 @IntGetProcAddress(ptr noundef nonnull @.str.1)\nstore i64 %3, ptr @_funcptr_glPointParameterivNV, align 8\n%4 = icmp eq i64 %3, 0\n%5 = select i1 %1, i32 2, i32 1\n%6 = select i1 %4, i32 %5, i32 %2\nret i32 %6\n}", "codegemma": "define internal i32 @LoadExt_NV_point_sprite() {\nB:\n%0 = tail call i64 @IntGetProcAddress(ptr noundef nonnull @.str)\nstore i64 %0, ptr @_funcptr_glPointParameteriNV, align 8\n%1 = icmp eq i64 %0, 0\n%2 = zext i1 %1 to i32\n%3 = tail call i64 @IntGetProcAddress(ptr noundef nonnull @.str.1)\nstore i64 %3, ptr @_funcptr_glPointParameterivNV, align 8\n%4 = icmp eq i64 %3, 0\n%5 = select i1 %1, i32 2, i32 1\n%6 = select i1 %4, i32 %5, i32 %2\nret i32 %6\n}"}, "define dso_local void @native_machine_restart(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 (...) @bfin_read_SYSCR()\n%4 = and i32 %3, 7\n%5 = icmp eq i32 %4, 3\nbr i1 %5, label %6, label %9\n\n6:\n%7 = load i32, ptr @P_DEFAULT_BOOT_SPI_CS, align 4\n%8 = call i32 @bfin_reset_boot_spi_cs(i32 noundef %7)\nbr label %9\n\n9:\nret void\n}": {"base_truth": "define dso_local void @native_machine_restart(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @bfin_read_SYSCR()\n%2 = and i32 %1, 7\n%3 = icmp eq i32 %2, 3\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @P_DEFAULT_BOOT_SPI_CS, align 4\n%5 = tail call i32 @bfin_reset_boot_spi_cs(i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @native_machine_restart(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @bfin_read_SYSCR()\n%2 = and i32 %1, 7\n%3 = icmp eq i32 %2, 3\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @P_DEFAULT_BOOT_SPI_CS, align 4\n%5 = tail call i32 @bfin_reset_boot_spi_cs(i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @native_machine_restart(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @bfin_read_SYSCR()\n%2 = and i32 %1, 7\n%3 = icmp eq i32 %2, 3\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @P_DEFAULT_BOOT_SPI_CS, align 4\n%5 = tail call i32 @bfin_reset_boot_spi_cs(i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i32 @cns3xxx_i2c_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @platform_get_drvdata(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = call i32 (...) @CNS3xxx_I2C_DISABLE_INTR()\n%8 = call i32 (...) @CNS3xxx_I2C_DISABLE()\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.cns3xxx_i2c ptr %9, i32 0, i32 1\n%11 = call i32 @i2c_del_adapter(ptr noundef %10)\n%12 = load ptr, ptr %2, align 8\n%13 = call i32 @platform_set_drvdata(ptr noundef %12, ptr noundef null)\n%14 = load ptr, ptr %2, align 8\n%15 = load i32, ptr @IORESOURCE_IRQ, align 4\n%16 = call ptr @platform_get_resource(ptr noundef %14, i32 noundef %15, i32 noundef 0)\nstore ptr %16, ptr %4, align 8\n%17 = load ptr, ptr %4, align 8\n%18 = icmp ne ptr %17, null\nbr i1 %18, label %19, label %25\n\n19:\n%20 = load ptr, ptr %4, align 8\n%21 = getelementptr inbounds %struct.resource ptr %20, i32 0, i32 0\n%22 = load i64, ptr %21, align 8\n%23 = load ptr, ptr %3, align 8\n%24 = call i32 @free_irq(i64 noundef %22, ptr noundef %23)\nbr label %25\n\n25:\n%26 = load ptr, ptr %3, align 8\n%27 = getelementptr inbounds %struct.cns3xxx_i2c ptr %26, i32 0, i32 0\n%28 = load i32, ptr %27, align 4\n%29 = call i32 @iounmap(i32 noundef %28)\n%30 = load ptr, ptr %2, align 8\n%31 = load i32, ptr @IORESOURCE_MEM, align 4\n%32 = call ptr @platform_get_resource(ptr noundef %30, i32 noundef %31, i32 noundef 0)\nstore ptr %32, ptr %4, align 8\n%33 = load ptr, ptr %4, align 8\n%34 = icmp ne ptr %33, null\nbr i1 %34, label %35, label %48\n\n35:\n%36 = load ptr, ptr %4, align 8\n%37 = getelementptr inbounds %struct.resource ptr %36, i32 0, i32 0\n%38 = load i64, ptr %37, align 8\n%39 = load ptr, ptr %4, align 8\n%40 = getelementptr inbounds %struct.resource ptr %39, i32 0, i32 1\n%41 = load i64, ptr %40, align 8\n%42 = load ptr, ptr %4, align 8\n%43 = getelementptr inbounds %struct.resource ptr %42, i32 0, i32 0\n%44 = load i64, ptr %43, align 8\n%45 = sub nsw i64 %41, %44\n%46 = add nsw i64 %45, 1\n%47 = call i32 @release_mem_region(i64 noundef %38, i64 noundef %46)\nbr label %48\n\n48:\n%49 = load ptr, ptr %3, align 8\n%50 = call i32 @kfree(ptr noundef %49)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @cns3xxx_i2c_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call i32 (...) @CNS3xxx_I2C_DISABLE_INTR()\n%3 = tail call i32 (...) @CNS3xxx_I2C_DISABLE()\n%4 = getelementptr inbounds %struct.cns3xxx_i2c, ptr %1, i64 0, i32 1\n%5 = tail call i32 @i2c_del_adapter(ptr noundef nonnull %4)\n%6 = tail call i32 @platform_set_drvdata(ptr noundef %0, ptr noundef null)\n%7 = load i32, ptr @IORESOURCE_IRQ, align 4\n%8 = tail call ptr @platform_get_resource(ptr noundef %0, i32 noundef %7, i32 noundef 0)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = load i64, ptr %8, align 8\n%11 = tail call i32 @free_irq(i64 noundef %10, ptr noundef %1)\nbr label %B2\n\nB2:\n%12 = load i32, ptr %1, align 4\n%13 = tail call i32 @iounmap(i32 noundef %12)\n%14 = load i32, ptr @IORESOURCE_MEM, align 4\n%15 = tail call ptr @platform_get_resource(ptr noundef %0, i32 noundef %14, i32 noundef 0)\n%16 = icmp eq ptr %15, null\nbr i1 %16, label %B4, label %B3\n\nB3:\n%17 = load i64, ptr %15, align 8\n%18 = getelementptr inbounds %struct.resource, ptr %15, i64 0, i32 1\n%19 = load i64, ptr %18, align 8\n%20 = sub i64 %19, %17\n%21 = add i64 %20, 1\n%22 = tail call i32 @release_mem_region(i64 noundef %17, i64 noundef %21)\nbr label %B4\n\nB4:\n%23 = tail call i32 @kfree(ptr noundef nonnull %1)\nret i32 0\n}", "codellama": "define internal i32 @cns3xxx_i2c_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call i32 (...) @CNS3xxx_I2C_DISABLE_INTR()\n%3 = tail call i32 (...) @CNS3xxx_I2C_DISABLE()\n%4 = getelementptr inbounds %struct.cns3xxx_i2c, ptr %1, i64 0, i32 1\n%5 = tail call i32 @i2c_del_adapter(ptr noundef nonnull %4)\n%6 = tail call i32 @platform_set_drvdata(ptr noundef %0, ptr noundef null)\n%7 = load i32, ptr @IORESOURCE_IRQ, align 4\n%8 = tail call ptr @platform_get_resource(ptr noundef %0, i32 noundef %7, i32 noundef 0)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = load i64, ptr %8, align 8\n%11 = tail call i32 @free_irq(i64 noundef %10, ptr noundef %1)\nbr label %B2\n\nB2:\n%12 = load i32, ptr %1, align 4\n%13 = tail call i32 @iounmap(i32 noundef %12)\n%14 = load i32, ptr @IORESOURCE_MEM, align 4\n%15 = tail call ptr @platform_get_resource(ptr noundef %0, i32 noundef %14, i32 noundef 0)\n%16 = icmp eq ptr %15, null\nbr i1 %16, label %B4, label %B3\n\nB3:\n%17 = load i64, ptr %15, align 8\n%18 = getelementptr inbounds %struct.resource, ptr %15, i64 0, i32 1\n%19 = load i64, ptr %18, align 8\n%20 = add i64 %19, 1\n%21 = sub i64 %20, %17\n%22 = tail call i32 @release_mem_region(i64 noundef %17, i64 noundef %21)\nbr label %B4\n\nB4:\n%23 = tail call i32 @kfree(ptr noundef nonnull %1)\nret i32 0\n}", "codegemma": "define internal i32 @cns3xxx_i2c_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call i32 (...) @CNS3xxx_I2C_DISABLE_INTR()\n%3 = tail call i32 (...) @CNS3xxx_I2C_DISABLE()\n%4 = getelementptr inbounds %struct.cns3xxx_i2c, ptr %1, i64 0, i32 1\n%5 = tail call i32 @i2c_del_adapter(ptr noundef nonnull %4)\n%6 = tail call i32 @platform_set_drvdata(ptr noundef %0, ptr noundef null)\n%7 = load i32, ptr @IORESOURCE_IRQ, align 4\n%8 = tail call ptr @platform_get_resource(ptr noundef %0, i32 noundef %7, i32 noundef 0)\n%9 = icmp eq ptr %8, null\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = load i64, ptr %8, align 8\n%11 = tail call i32 @free_irq(i64 noundef %10, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%12 = load i32, ptr %1, align 4\n%13 = tail call i32 @iounmap(i32 noundef %12)\n%14 = load i32, ptr @IORESOURCE_MEM, align 4\n%15 = tail call ptr @platform_get_resource(ptr noundef %0, i32 noundef %14, i32 noundef 0)\n%16 = icmp eq ptr %15, null\nbr i1 %16, label %B4, label %B3\n\nB3:\n%17 = getelementptr inbounds %struct.resource, ptr %15, i64 0, i32 1\n%18 = load i64, ptr %15, align 8\n%19 = sub i64 %18, %18\n%20 = add i64 %19, 1\n%21 = tail call i32 @release_mem_region(i64 noundef %18, i64 noundef %20)\nbr label %B4\n\nB4:\n%22 = tail call i32 @kfree(ptr noundef nonnull %1)\nret i32 0\n}"}, "define dso_local i32 @uart_charav(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = add nsw i32 765, %3\n%5 = call i32 @inb(i32 noundef %4)\n%6 = and i32 %5, 1\nret i32 %6\n}": {"base_truth": "define dso_local i32 @uart_charav(i32 noundef %0) {\nB:\n%1 = add nsw i32 %0, 765\n%2 = tail call i32 @inb(i32 noundef %1)\n%3 = and i32 %2, 1\nret i32 %3\n}", "codellama": "define dso_local i32 @uart_charav(i32 noundef %0) {\nB:\n%1 = add nsw i32 %0, 765\n%2 = tail call i32 @inb(i32 noundef %1)\n%3 = and i32 %2, 1\nret i32 %3\n}", "codegemma": "define dso_local i32 @uart_charav(i32 noundef %0) {\nB:\n%1 = add nsw i32 %0, 765\n%2 = tail call i32 @inb(i32 noundef %1)\n%3 = and i32 %2, 1\nret i32 %3\n}"}, "define dso_local void @cw1200_skb_dtor(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %5, align 8\n%8 = load ptr, ptr %6, align 8\n%9 = getelementptr inbounds %struct.cw1200_txpriv ptr %8, i32 0, i32 3\n%10 = load i32, ptr %9, align 8\n%11 = call i32 @skb_pull(ptr noundef %7, i32 noundef %10)\n%12 = load ptr, ptr %6, align 8\n%13 = getelementptr inbounds %struct.cw1200_txpriv ptr %12, i32 0, i32 0\n%14 = load i64, ptr %13, align 8\n%15 = load i64, ptr @CW1200_INVALID_RATE_ID, align 8\n%16 = icmp ne i64 %14, %15\nbr i1 %16, label %17, label %32\n\n17:\n%18 = load ptr, ptr %4, align 8\n%19 = load ptr, ptr %5, align 8\n%20 = load ptr, ptr %6, align 8\n%21 = getelementptr inbounds %struct.cw1200_txpriv ptr %20, i32 0, i32 2\n%22 = load i32, ptr %21, align 4\n%23 = load ptr, ptr %6, align 8\n%24 = getelementptr inbounds %struct.cw1200_txpriv ptr %23, i32 0, i32 1\n%25 = load i32, ptr %24, align 8\n%26 = call i32 @cw1200_notify_buffered_tx(ptr noundef %18, ptr noundef %19, i32 noundef %22, i32 noundef %25)\n%27 = load ptr, ptr %4, align 8\n%28 = load ptr, ptr %6, align 8\n%29 = getelementptr inbounds %struct.cw1200_txpriv ptr %28, i32 0, i32 0\n%30 = load i64, ptr %29, align 8\n%31 = call i32 @tx_policy_put(ptr noundef %27, i64 noundef %30)\nbr label %32\n\n32:\n%33 = load ptr, ptr %4, align 8\n%34 = getelementptr inbounds %struct.cw1200_common ptr %33, i32 0, i32 0\n%35 = load i32, ptr %34, align 4\n%36 = load ptr, ptr %5, align 8\n%37 = call i32 @ieee80211_tx_status(i32 noundef %35, ptr noundef %36)\nret void\n}": {"base_truth": "define dso_local void @cw1200_skb_dtor(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 3\n%4 = load i32, ptr %3, align 8\n%5 = tail call i32 @skb_pull(ptr noundef %1, i32 noundef %4)\n%6 = load i64, ptr %2, align 8\n%7 = load i64, ptr @CW1200_INVALID_RATE_ID, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %B2, label %B1\n\nB1:\n%9 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = tail call i32 @cw1200_notify_buffered_tx(ptr noundef %0, ptr noundef %1, i32 noundef %10, i32 noundef %12)\n%14 = load i64, ptr %2, align 8\n%15 = tail call i32 @tx_policy_put(ptr noundef %0, i64 noundef %14)\nbr label %B2\n\nB2:\n%16 = load i32, ptr %0, align 4\n%17 = tail call i32 @ieee80211_tx_status(i32 noundef %16, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @cw1200_skb_dtor(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 3\n%4 = load i32, ptr %3, align 8\n%5 = tail call i32 @skb_pull(ptr noundef %1, i32 noundef %4)\n%6 = load i64, ptr %2, align 8\n%7 = load i64, ptr @CW1200_INVALID_RATE_ID, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %B2, label %B1\n\nB1:\n%9 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = tail call i32 @cw1200_notify_buffered_tx(ptr noundef %0, ptr noundef %1, i32 noundef %10, i32 noundef %12)\n%14 = load i64, ptr %2, align 8\n%15 = tail call i32 @tx_policy_put(ptr noundef %0, i64 noundef %14)\nbr label %B2\n\nB2:\n%16 = load i32, ptr %0, align 4\n%17 = tail call i32 @ieee80211_tx_status(i32 noundef %16, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @cw1200_skb_dtor(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 3\n%4 = load i32, ptr %3, align 8\n%5 = tail call i32 @skb_pull(ptr noundef %1, i32 noundef %4)\n%6 = load i64, ptr %2, align 8\n%7 = load i64, ptr @CW1200_INVALID_RATE_ID, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %B2, label %B1\n\nB1:\n%9 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 2\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds %struct.cw1200_txpriv, ptr %2, i64 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = tail call i32 @cw1200_notify_buffered_tx(ptr noundef %0, ptr noundef %1, i32 noundef %10, i32 noundef %12)\n%14 = load i64, ptr %2, align 8\n%15 = tail call i32 @tx_policy_put(ptr noundef %0, i64 noundef %14)\nbr label %B2\n\nB2:\n%16 = load i32, ptr %0, align 4\n%17 = tail call i32 @ieee80211_tx_status(i32 noundef %16, ptr noundef %1)\nret void\n}"}, "define dso_local void @VIRTUAL_parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @parser__ReduceAction294__action(ptr noundef %5, ptr noundef %6)\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @VIRTUAL_parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @VIRTUAL_parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @VIRTUAL_parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction294__action(ptr noundef %0, ptr noundef %1)\nret void\n}"}, "define dso_local i64 @stop() {\n%1 = call i32 @gettimeofday(ptr noundef @tstop, ptr noundef null)\n%2 = call i64 @usecs(ptr noundef @tstop)\n%3 = call i64 @usecs(ptr noundef @tstart)\n%4 = sub nsw i64 %2, %3\nret i64 %4\n}": {"base_truth": "define dso_local i64 @stop() {\nB:\n%0 = tail call i32 @gettimeofday(ptr noundef nonnull @tstop, ptr noundef null)\n%1 = tail call i64 @usecs(ptr noundef nonnull @tstop)\n%2 = tail call i64 @usecs(ptr noundef nonnull @tstart)\n%3 = sub nsw i64 %1, %2\nret i64 %3\n}", "codellama": "define dso_local i64 @stop() {\nB:\n%0 = tail call i32 @gettimeofday(ptr noundef nonnull @tstop, ptr noundef null)\n%1 = tail call i64 @usecs(ptr noundef nonnull @tstop)\n%2 = tail call i64 @usecs(ptr noundef nonnull @tstart)\n%3 = sub nsw i64 %1, %2\nret i64 %3\n}", "codegemma": "define dso_local i64 @stop() {\nB:\n%0 = tail call i32 @gettimeofday(ptr noundef nonnull @tstop, ptr noundef null)\n%1 = tail call i64 @usecs(ptr noundef nonnull @tstop)\n%2 = tail call i64 @usecs(ptr noundef nonnull @tstart)\n%3 = sub nsw i64 %1, %2\nret i64 %3\n}"}, "define dso_local void @del_intern_pool(i64 %0) {\n%2 = alloca %struct.TYPE_7__, align 4\nstore i64 %0, ptr %2, align 4\n%3 = getelementptr inbounds %struct.TYPE_7__, ptr %2, i32 0, i32 1\n%4 = getelementptr inbounds %struct.TYPE_5__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @free(i32 noundef %5)\n%7 = getelementptr inbounds %struct.TYPE_7__, ptr %2, i32 0, i32 0\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i32 @free(i32 noundef %9)\nret void\n}": {"base_truth": "define dso_local void @del_intern_pool(i64 %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = lshr i64 %0, 32\n%3 = trunc i64 %2 to i32\n%4 = tail call i32 @free(i32 noundef %3)\n%5 = tail call i32 @free(i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @del_intern_pool(i64 %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = lshr i64 %0, 32\n%3 = trunc i64 %2 to i32\n%4 = tail call i32 @free(i32 noundef %3)\n%5 = tail call i32 @free(i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @del_intern_pool(i64 %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = ashr i32 %1, 32\n%3 = tail call i32 @free(i32 noundef %2)\n%4 = tail call i32 @free(i32 noundef %1)\nret void\n}"}, "define dso_local i64 @f() {\n%1 = load i64, ptr @a, align 8\n%2 = load i64, ptr @b, align 8\n%3 = mul nsw i64 %1, %2\n%4 = ashr i64 %3, 16\nret i64 %4\n}": {"base_truth": "define dso_local i64 @f() {\nB:\n%0 = load i64, ptr @a, align 8\n%1 = load i64, ptr @b, align 8\n%2 = mul nsw i64 %1, %0\n%3 = ashr i64 %2, 16\nret i64 %3\n}", "codellama": "define dso_local i64 @f() {\nB:\n%0 = load i64, ptr @a, align 8\n%1 = load i64, ptr @b, align 8\n%2 = mul nsw i64 %1, %0\n%3 = ashr i64 %2, 16\nret i64 %3\n}", "codegemma": "define dso_local i64 @f() {\nB:\n%0 = load i64, ptr @a, align 8\n%1 = load i64, ptr @b, align 8\n%2 = mul nsw i64 %1, %0\n%3 = ashr i64 %2, 16\nret i64 %3\n}"}, "define dso_local void @problem_output() {\n%1 = load double, ptr @dt, align 8\n%2 = fmul fast double 1.000000e+01, %1\n%3 = fptosi double %2 to i32\n%4 = call i64 @output_check(i32 noundef %3)\n%5 = icmp ne i64 %4, 0\nbr i1 %5, label %6, label %8\n\n6:\n%7 = call i32 (...) @output_timing()\nbr label %8\n\n8:\n%9 = call i64 @output_check(i32 noundef 1)\n%10 = icmp ne i64 %9, 0\nbr i1 %10, label %11, label %13\n\n11:\n%12 = call i32 @output_ascii(ptr noundef @.str)\nbr label %13\n\n13:\nret void\n}": {"base_truth": "define dso_local void @problem_output() {\nB:\n%0 = load double, ptr @dt, align 8\n%1 = fmul fast double %0, 1.000000e+01\n%2 = fptosi double %1 to i32\n%3 = tail call i64 @output_check(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 (...) @output_timing()\nbr label %B2\n\nB2:\n%6 = tail call i64 @output_check(i32 noundef 1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = tail call i32 @output_ascii(ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @problem_output() {\nB:\n%0 = load double, ptr @dt, align 8\n%1 = fmul fast double %0, 1.000000e+01\n%2 = fptosi double %1 to i32\n%3 = tail call i64 @output_check(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 (...) @output_timing()\nbr label %B2\n\nB2:\n%6 = tail call i64 @output_check(i32 noundef 1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = tail call i32 @output_ascii(ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @problem_output() {\nB:\n%0 = load double, ptr @dt, align 8\n%1 = fmul fast double %0, 1.000000e+01\n%2 = fptosi double %1 to i32\n%3 = tail call i64 @output_check(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 (...) @output_timing()\nbr label %B2\n\nB2:\n%6 = tail call i64 @output_check(i32 noundef 1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B4, label %B3\n\nB3:\n%8 = tail call i32 @output_ascii(ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\nret void\n}"}, "define dso_local i64 @clk_get_rate(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load i64, ptr @AT91X40_MASTER_CLOCK, align 8\nret i64 %3\n}": {"base_truth": "define dso_local i64 @clk_get_rate(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i64, ptr @AT91X40_MASTER_CLOCK, align 8\nret i64 %1\n}", "codellama": "define dso_local i64 @clk_get_rate(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i64, ptr @AT91X40_MASTER_CLOCK, align 8\nret i64 %1\n}", "codegemma": "define dso_local i64 @clk_get_rate(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i64, ptr @AT91X40_MASTER_CLOCK, align 8\nret i64 %1\n}"}, "define weak dso_local void @ANATOP_TEMP_PANIC_IRQHandler() {\n%1 = call i32 (...) @ANATOP_TEMP_PANIC_DriverIRQHandler()\nret void\n}": {"base_truth": "define weak dso_local void @ANATOP_TEMP_PANIC_IRQHandler() {\nB:\n%0 = tail call i32 (...) @ANATOP_TEMP_PANIC_DriverIRQHandler()\nret void\n}", "codellama": "define weak dso_local void @ANATOP_TEMP_PANIC_IRQHandler() {\nB:\n%0 = tail call i32 (...) @ANATOP_TEMP_PANIC_DriverIRQHandler()\nret void\n}", "codegemma": "define weak dso_local void @ANATOP_TEMP_PANIC_IRQHandler() {\nB:\n%0 = tail call i32 (...) @ANATOP_TEMP_PANIC_DriverIRQHandler()\nret void\n}"}, "define dso_local void @Net_TCPCloseSocket(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 8\n%6 = icmp ne i32 %5, -1\nbr i1 %6, label %7, label %14\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.TYPE_7__, ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 8\n%11 = call i32 @close(i32 noundef %10)\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.TYPE_7__, ptr %12, i32 0, i32 0\nstore i32 -1, ptr %13, align 8\nbr label %14\n\n14:\n%15 = load ptr, ptr %2, align 8\n%16 = getelementptr inbounds %struct.TYPE_7__, ptr %15, i32 0, i32 2\n%17 = getelementptr inbounds %struct.TYPE_5__, ptr %16, i32 0, i32 0\nstore i64 0, ptr %17, align 8\n%18 = load ptr, ptr %2, align 8\n%19 = getelementptr inbounds %struct.TYPE_7__, ptr %18, i32 0, i32 1\n%20 = getelementptr inbounds %struct.TYPE_6__, ptr %19, i32 0, i32 0\nstore i64 0, ptr %20, align 8\nret void\n}": {"base_truth": "define dso_local void @Net_TCPCloseSocket(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp eq i32 %1, -1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @close(i32 noundef %1)\nstore i32 -1, ptr %0, align 8\nbr label %B2\n\nB2:\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %0, i64 0, i32 1\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %4, i8 0, i64 16, i1 false)\nret void\n}", "codellama": "define dso_local void @Net_TCPCloseSocket(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp eq i32 %1, -1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @close(i32 noundef %1)\nstore i32 -1, ptr %0, align 8\nbr label %B2\n\nB2:\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %0, i64 0, i32 1\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %4, i8 0, i64 16, i1 false)\nret void\n}", "codegemma": "define dso_local void @Net_TCPCloseSocket(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 8\n%2 = icmp eq i32 %1, -1\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @close(i32 noundef %1)\nstore i32 -1, ptr %0, align 8\nbr label %B2\n\nB2:\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %0, i64 0, i32 1\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %4, i8 0, i64 16, i1 false)\nret void\n}"}, "define internal i32 @get_current_limit(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.bd70528_psy ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\n%12 = load i32, ptr @BD70528_REG_CHG_DCIN_ILIM, align 4\n%13 = call i32 @regmap_read(i32 noundef %11, i32 noundef %12, ptr noundef %6)\nstore i32 %13, ptr %7, align 4\n%14 = load i32, ptr %7, align 4\n%15 = icmp ne i32 %14, 0\nbr i1 %15, label %16, label %23\n\n16:\n%17 = load ptr, ptr %4, align 8\n%18 = getelementptr inbounds %struct.bd70528_psy ptr %17, i32 0, i32 0\n%19 = load i32, ptr %18, align 4\n%20 = load i32, ptr %7, align 4\n%21 = call i32 @dev_err(i32 noundef %19, ptr noundef @.str, i32 noundef %20)\n%22 = load i32, ptr %7, align 4\nstore i32 %22, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %39\n\n23:\n%24 = load i32, ptr @BD70528_MASK_CHG_DCIN_ILIM, align 4\n%25 = load i32, ptr %6, align 4\n%26 = and i32 %25, %24\nstore i32 %26, ptr %6, align 4\n%27 = load ptr, ptr @current_limit_ranges, align 8\n%28 = getelementptr inbounds i32, ptr %27, i64 0\n%29 = load ptr, ptr @current_limit_ranges, align 8\n%30 = call i32 @ARRAY_SIZE(ptr noundef %29)\n%31 = load i32, ptr %6, align 4\n%32 = load ptr, ptr %5, align 8\n%33 = call i32 @find_value_for_selector_low(ptr noundef %28, i32 noundef %30, i32 noundef %31, ptr noundef %32)\nstore i32 %33, ptr %7, align 4\n%34 = load i32, ptr %7, align 4\n%35 = icmp ne i32 %34, 0\nbr i1 %35, label %36, label %38\n\n36:\n%37 = load ptr, ptr %5, align 8\nstore i32 500, ptr %37, align 4\nbr label %38\n\n38:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %39\n\n39:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%40 = load i32, ptr %3, align 4\nret i32 %40\n}": {"base_truth": "define internal i32 @get_current_limit(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = getelementptr inbounds %struct.bd70528_psy, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @BD70528_REG_CHG_DCIN_ILIM, align 4\n%6 = call i32 @regmap_read(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %2)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @dev_err(i32 noundef %8, ptr noundef nonnull @.str, i32 noundef %6)\nbr label %B4\n\nB2:\n%10 = load i32, ptr @BD70528_MASK_CHG_DCIN_ILIM, align 4\n%11 = load i32, ptr %2, align 4\n%12 = and i32 %11, %10\nstore i32 %12, ptr %2, align 4\n%13 = load ptr, ptr @current_limit_ranges, align 8\n%14 = call i32 @ARRAY_SIZE(ptr noundef %13)\n%15 = load i32, ptr %2, align 4\n%16 = call i32 @find_value_for_selector_low(ptr noundef %13, i32 noundef %14, i32 noundef %15, ptr noundef %1)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B4, label %B3\n\nB3:\nstore i32 500, ptr %1, align 4\nbr label %B4\n\nB4:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %6\n}", "codellama": "define internal i32 @get_current_limit(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = getelementptr inbounds %struct.bd70528_psy, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @BD70528_REG_CHG_DCIN_ILIM, align 4\n%6 = call i32 @regmap_read(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %2)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @dev_err(i32 noundef %8, ptr noundef nonnull @.str, i32 noundef %6)\nbr label %B3\n\nB2:\n%10 = load i32, ptr @BD70528_MASK_CHG_DCIN_ILIM, align 4\n%11 = load i32, ptr %2, align 4\n%12 = and i32 %11, %10\nstore i32 %12, ptr %2, align 4\n%13 = load ptr, ptr @current_limit_ranges, align 8\n%14 = call i32 @ARRAY_SIZE(ptr noundef %13)\n%15 = call i32 @find_value_for_selector_low(ptr noundef %13, i32 noundef %14, i32 noundef %12, ptr noundef %1)\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B3, label %B4\n\nB3:\nbr label %B4\n\nB4:\n%17 = phi i32 [ %6, %B3 ], [ 0, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %17\n}", "codegemma": "define internal i32 @get_current_limit(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = getelementptr inbounds %struct.bd70528_psy, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @BD70528_REG_CHG_DCIN_ILIM, align 4\n%6 = call i32 @regmap_read(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %2)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @dev_err(i32 noundef %8, ptr noundef nonnull @.str, i32 noundef %6)\nbr label %B4\n\nB2:\n%10 = load i32, ptr @BD70528_MASK_CHG_DCIN_ILIM, align 4\n%11 = load i32, ptr %2, align 4\n%12 = and i32 %11, %10\nstore i32 %12, ptr %2, align 4\n%13 = load ptr, ptr @current_limit_ranges, align 8\n%14 = call i32 @ARRAY_SIZE(ptr noundef %13)\n%15 = load i32, ptr %2, align 4\n%16 = call i32 @find_value_for_selector_low(ptr noundef %13, i32 noundef %14, i32 noundef %15, ptr noundef %1)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B4, label %B3\n\nB3:\nstore i32 500, ptr %1, align 4\nbr label %B4\n\nB4:\n%18 = phi i32 [ %6, %B1 ], [ 0, %B3 ], [ 0, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %18\n}"}, "define internal void @prefixexp(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.TYPE_10__, ptr %6, i32 0, i32 2\n%8 = getelementptr inbounds %struct.TYPE_9__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\nswitch i32 %9, label %31 [\ni32 40, label %10\ni32 128, label %27\n]\n\n10:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.TYPE_10__, ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\nstore i32 %13, ptr %5, align 4\n%14 = load ptr, ptr %3, align 8\n%15 = call i32 @luaX_next(ptr noundef %14)\n%16 = load ptr, ptr %3, align 8\n%17 = load ptr, ptr %4, align 8\n%18 = call i32 @expr(ptr noundef %16, ptr noundef %17)\n%19 = load ptr, ptr %3, align 8\n%20 = load i32, ptr %5, align 4\n%21 = call i32 @check_match(ptr noundef %19, i8 noundef signext 41, i8 noundef signext 40, i32 noundef %20)\n%22 = load ptr, ptr %3, align 8\n%23 = getelementptr inbounds %struct.TYPE_10__, ptr %22, i32 0, i32 1\n%24 = load i32, ptr %23, align 4\n%25 = load ptr, ptr %4, align 8\n%26 = call i32 @luaK_dischargevars(i32 noundef %24, ptr noundef %25)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nbr label %34\n\n27:\n%28 = load ptr, ptr %3, align 8\n%29 = load ptr, ptr %4, align 8\n%30 = call i32 @singlevar(ptr noundef %28, ptr noundef %29)\nbr label %34\n\n31:\n%32 = load ptr, ptr %3, align 8\n%33 = call i32 @luaX_syntaxerror(ptr noundef %32, ptr noundef @.str)\nbr label %34\n\n34:\nret void\n}": {"base_truth": "define internal void @prefixexp(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_10__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %B3 [\ni32 40, label %B1\ni32 128, label %B2\n]\n\nB1:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @luaX_next(ptr noundef nonnull %0)\n%6 = tail call i32 @expr(ptr noundef nonnull %0, ptr noundef %1)\n%7 = tail call i32 @check_match(ptr noundef nonnull %0, i8 noundef signext 41, i8 noundef signext 40, i32 noundef %4)\n%8 = getelementptr inbounds %struct.TYPE_10__, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @luaK_dischargevars(i32 noundef %9, ptr noundef %1)\nbr label %B4\n\nB2:\n%11 = tail call i32 @singlevar(ptr noundef nonnull %0, ptr noundef %1)\nbr label %B4\n\nB3:\n%12 = tail call i32 @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define internal void @prefixexp(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_10__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %B3 [\ni32 40, label %B1\ni32 128, label %B2\n]\n\nB1:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @luaX_next(ptr noundef nonnull %0)\n%6 = tail call i32 @expr(ptr noundef nonnull %0, ptr noundef %1)\n%7 = tail call i32 @check_match(ptr noundef nonnull %0, i8 noundef signext 41, i8 noundef signext 40, i32 noundef %4)\n%8 = getelementptr inbounds %struct.TYPE_10__, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @luaK_dischargevars(i32 noundef %9, ptr noundef %1)\nbr label %B4\n\nB2:\n%11 = tail call i32 @singlevar(ptr noundef nonnull %0, ptr noundef %1)\nbr label %B4\n\nB3:\n%12 = tail call i32 @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define internal void @prefixexp(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_10__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %B3 [\ni32 40, label %B1\ni32 128, label %B2\n]\n\nB1:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @luaX_next(ptr noundef nonnull %0)\n%6 = tail call i32 @expr(ptr noundef nonnull %0, ptr noundef %1)\n%7 = tail call i32 @check_match(ptr noundef nonnull %0, i8 noundef signext 41, i8 noundef signext 40, i32 noundef %4)\n%8 = getelementptr inbounds %struct.TYPE_10__, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = tail call i32 @luaK_dischargevars(i32 noundef %9, ptr noundef %1)\nbr label %B4\n\nB2:\n%11 = tail call i32 @singlevar(ptr noundef nonnull %0, ptr noundef %1)\nbr label %B4\n\nB3:\n%12 = tail call i32 @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\nret void\n}"}, "define dso_local i32 @test_whitespace_char_token() {\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 8 %1, ptr align 8 @__const.test_whitespace_char_token.token, i64 24, i1 false)\n%2 = load i32, ptr @CPARSER_STATE_TOKEN, align 4\n%3 = call i32 @test_state_transition(ptr noundef @.str.1, i32 noundef %2, i32 noundef 0, ptr noundef %1, i32 noundef 2, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 24, ptr %1)\nret i32 %3\n}": {"base_truth": "define dso_local i32 @test_whitespace_char_token() {\nB:\n%0 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %0, ptr noundef nonnull align 8 dereferenceable(24) @__const.test_whitespace_char_token.token, i64 24, i1 false)\n%1 = load i32, ptr @CPARSER_STATE_TOKEN, align 4\n%2 = call i32 @test_state_transition(ptr noundef nonnull @.str.1, i32 noundef %1, i32 noundef 0, ptr noundef nonnull %0, i32 noundef 2, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %0)\nret i32 %2\n}", "codellama": "define dso_local i32 @test_whitespace_char_token() {\nB:\n%0 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %0, ptr noundef nonnull align 8 dereferenceable(24) @__const.test_whitespace_char_token.token, i64 24, i1 false)\n%1 = load i32, ptr @CPARSER_STATE_TOKEN, align 4\n%2 = call i32 @test_state_transition(ptr noundef nonnull @.str.1, i32 noundef %1, i32 noundef 0, ptr noundef nonnull %0, i32 noundef 2, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %0)\nret i32 %2\n}", "codegemma": "define dso_local i32 @test_whitespace_char_token() {\nB:\n%0 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %0, ptr noundef nonnull align 8 dereferenceable(24) @__const.test_whitespace_char_token.token, i64 24, i1 false)\n%1 = load i32, ptr @CPARSER_STATE_TOKEN, align 4\n%2 = call i32 @test_state_transition(ptr noundef nonnull @.str.1, i32 noundef %1, i32 noundef 0, ptr noundef nonnull %0, i32 noundef 2, i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %0)\nret i32 %2\n}"}, "define dso_local i32 @xdr_READDIRPLUS3res(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load ptr, ptr %5, align 8\n%8 = getelementptr inbounds %struct.TYPE_5__, ptr %7, i32 0, i32 0\n%9 = call i32 @xdr_nfsstat3(ptr noundef %6, ptr noundef %8)\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %13, label %11\n\n11:\n%12 = load i32, ptr @FALSE, align 4\nstore i32 %12, ptr %3, align 4\nbr label %39\n\n13:\n%14 = load ptr, ptr %5, align 8\n%15 = getelementptr inbounds %struct.TYPE_5__, ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 4\nswitch i32 %16, label %27 [\ni32 128, label %17\n]\n\n17:\n%18 = load ptr, ptr %4, align 8\n%19 = load ptr, ptr %5, align 8\n%20 = getelementptr inbounds %struct.TYPE_5__, ptr %19, i32 0, i32 1\n%21 = getelementptr inbounds %struct.TYPE_4__, ptr %20, i32 0, i32 1\n%22 = call i32 @xdr_READDIRPLUS3resok(ptr noundef %18, ptr noundef %21)\n%23 = icmp ne i32 %22, 0\nbr i1 %23, label %26, label %24\n\n24:\n%25 = load i32, ptr @FALSE, align 4\nstore i32 %25, ptr %3, align 4\nbr label %39\n\n26:\nbr label %37\n\n27:\n%28 = load ptr, ptr %4, align 8\n%29 = load ptr, ptr %5, align 8\n%30 = getelementptr inbounds %struct.TYPE_5__, ptr %29, i32 0, i32 1\n%31 = getelementptr inbounds %struct.TYPE_4__, ptr %30, i32 0, i32 0\n%32 = call i32 @xdr_READDIRPLUS3resfail(ptr noundef %28, ptr noundef %31)\n%33 = icmp ne i32 %32, 0\nbr i1 %33, label %36, label %34\n\n34:\n%35 = load i32, ptr @FALSE, align 4\nstore i32 %35, ptr %3, align 4\nbr label %39\n\n36:\nbr label %37\n\n37:\n%38 = load i32, ptr @TRUE, align 4\nstore i32 %38, ptr %3, align 4\nbr label %39\n\n39:\n%40 = load i32, ptr %3, align 4\nret i32 %40\n}": {"base_truth": "define dso_local i32 @xdr_READDIRPLUS3res(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_nfsstat3(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = load i32, ptr %1, align 4\n%5 = icmp eq i32 %4, 128\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1, i32 1\n%7 = tail call i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef nonnull %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B5, label %B4\n\nB3:\n%9 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%10 = tail call i32 @xdr_READDIRPLUS3resfail(ptr noundef %0, ptr noundef nonnull %9)\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B5, label %B4\n\nB4:\nbr label %B5\n\nB5:\n%12 = phi ptr [ @TRUE, %B4 ], [ @FALSE, %B ], [ @FALSE, %B2 ], [ @FALSE, %B3 ]\n%13 = load i32, ptr %12, align 4\nret i32 %13\n}", "codellama": "define dso_local i32 @xdr_READDIRPLUS3res(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_nfsstat3(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = load i32, ptr %1, align 4\n%5 = icmp eq i32 %4, 128\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1, i32 1\n%7 = tail call i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef nonnull %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B5, label %B4\n\nB3:\n%9 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%10 = tail call i32 @xdr_READDIRPLUS3resfail(ptr noundef %0, ptr noundef nonnull %9)\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B5, label %B4\n\nB4:\nbr label %B5\n\nB5:\n%12 = phi ptr [ @TRUE, %B4 ], [ @FALSE, %B ], [ @FALSE, %B3 ], [ @FALSE, %B2 ]\n%13 = load i32, ptr %12, align 4\nret i32 %13\n}", "codegemma": "define dso_local i32 @xdr_READDIRPLUS3res(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_nfsstat3(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = load i32, ptr %1, align 4\n%5 = icmp eq i32 %4, 128\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1, i32 1\n%7 = tail call i32 @xdr_READDIRPLUS3resok(ptr noundef %0, ptr noundef nonnull %6)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B5\n\nB3:\n%9 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%10 = tail call i32 @xdr_READDIRPLUS3resfail(ptr noundef %0, ptr noundef nonnull %9)\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B4, label %B5\n\nB4:\n%12 = phi ptr [ @FALSE, %B ], [ @FALSE, %B2 ], [ @FALSE, %B3 ]\n%13 = load i32, ptr %12, align 4\nbr label %B5\n\nB5:\n%14 = phi i32 [ @TRUE, %B3 ], [ @TRUE, %B2 ], [ %13, %B4 ]\nret i32 %14\n}"}, "define internal i32 @next(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = call ptr (...) @lex()\nstore ptr %6, ptr %4, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %3, align 4\n%9 = call i64 @is_keyword(ptr noundef %7, i32 noundef %8)\n%10 = icmp ne i64 %9, 0\nbr i1 %10, label %11, label %12\n\n11:\nstore i32 1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %15\n\n12:\n%13 = load ptr, ptr %4, align 8\n%14 = call i32 @unget_token(ptr noundef %13)\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %15\n\n15:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%16 = load i32, ptr %2, align 4\nret i32 %16\n}": {"base_truth": "define internal i32 @next(i32 noundef %0) {\nB:\n%1 = tail call ptr (...) @lex()\n%2 = tail call i64 @is_keyword(ptr noundef %1, i32 noundef %0)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @unget_token(ptr noundef %1)\nbr label %B2\n\nB2:\n%5 = phi i32 [ 0, %B1 ], [ 1, %B ]\nret i32 %5\n}", "codellama": "define internal i32 @next(i32 noundef %0) {\nB:\n%1 = tail call ptr (...) @lex()\n%2 = tail call i64 @is_keyword(ptr noundef %1, i32 noundef %0)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @unget_token(ptr noundef %1)\nbr label %B2\n\nB2:\n%5 = phi i32 [ 0, %B1 ], [ 1, %B ]\nret i32 %5\n}", "codegemma": "define internal i32 @next(i32 noundef %0) {\nB:\n%1 = tail call ptr (...) @lex()\n%2 = tail call i64 @is_keyword(ptr noundef %1, i32 noundef %0)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = tail call i32 @unget_token(ptr noundef %1)\nbr label %B2\n\nB2:\n%5 = phi i32 [ 0, %B1 ], [ 1, %B ]\nret i32 %5\n}"}, "define internal void @spa_read_history_destroy(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_7__, ptr %4, i32 0, i32 0\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 0\nstore ptr %6, ptr %3, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.TYPE_8__, ptr %7, i32 0, i32 0\n%9 = call i32 @procfs_list_uninstall(ptr noundef %8)\n%10 = load ptr, ptr %3, align 8\n%11 = call i32 @spa_read_history_truncate(ptr noundef %10, i32 noundef 0)\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.TYPE_8__, ptr %12, i32 0, i32 0\n%14 = call i32 @procfs_list_destroy(ptr noundef %13)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @spa_read_history_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 @procfs_list_uninstall(ptr noundef %0)\n%2 = tail call i32 @spa_read_history_truncate(ptr noundef %0, i32 noundef 0)\n%3 = tail call i32 @procfs_list_destroy(ptr noundef %0)\nret void\n}", "codellama": "define internal void @spa_read_history_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 @procfs_list_uninstall(ptr noundef %0)\n%2 = tail call i32 @spa_read_history_truncate(ptr noundef %0, i32 noundef 0)\n%3 = tail call i32 @procfs_list_destroy(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @spa_read_history_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 @procfs_list_uninstall(ptr noundef %0)\n%2 = tail call i32 @spa_read_history_truncate(ptr noundef %0, i32 noundef 0)\n%3 = tail call i32 @procfs_list_destroy(ptr noundef %0)\nret void\n}"}, "define internal i32 @qd_check_sync(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore ptr %2, ptr %7, align 8\n%8 = load i32, ptr @QDF_LOCKED, align 4\n%9 = load ptr, ptr %6, align 8\n%10 = getelementptr inbounds %struct.gfs2_quota_data ptr %9, i32 0, i32 3\n%11 = call i64 @test_bit(i32 noundef %8, ptr noundef %10)\n%12 = icmp ne i64 %11, 0\nbr i1 %12, label %29, label %13\n\n13:\n%14 = load i32, ptr @QDF_CHANGE, align 4\n%15 = load ptr, ptr %6, align 8\n%16 = getelementptr inbounds %struct.gfs2_quota_data ptr %15, i32 0, i32 3\n%17 = call i64 @test_bit(i32 noundef %14, ptr noundef %16)\n%18 = icmp ne i64 %17, 0\nbr i1 %18, label %19, label %29\n\n19:\n%20 = load ptr, ptr %7, align 8\n%21 = icmp ne ptr %20, null\nbr i1 %21, label %22, label %30\n\n22:\n%23 = load ptr, ptr %6, align 8\n%24 = getelementptr inbounds %struct.gfs2_quota_data ptr %23, i32 0, i32 0\n%25 = load i64, ptr %24, align 8\n%26 = load ptr, ptr %7, align 8\n%27 = load i64, ptr %26, align 8\n%28 = icmp sge i64 %25, %27\nbr i1 %28, label %29, label %30\n\n29:\nstore i32 0, ptr %4, align 4\nbr label %53\n\n30:\n%31 = load ptr, ptr %6, align 8\n%32 = getelementptr inbounds %struct.gfs2_quota_data ptr %31, i32 0, i32 5\n%33 = call i32 @lockref_get_not_dead(ptr noundef %32)\n%34 = icmp ne i32 %33, 0\nbr i1 %34, label %36, label %35\n\n35:\nstore i32 0, ptr %4, align 4\nbr label %53\n\n36:\n%37 = load ptr, ptr %6, align 8\n%38 = getelementptr inbounds %struct.gfs2_quota_data ptr %37, i32 0, i32 4\n%39 = load ptr, ptr %5, align 8\n%40 = getelementptr inbounds %struct.gfs2_sbd ptr %39, i32 0, i32 0\n%41 = call i32 @list_move_tail(ptr noundef %38, ptr noundef %40)\n%42 = load i32, ptr @QDF_LOCKED, align 4\n%43 = load ptr, ptr %6, align 8\n%44 = getelementptr inbounds %struct.gfs2_quota_data ptr %43, i32 0, i32 3\n%45 = call i32 @set_bit(i32 noundef %42, ptr noundef %44)\n%46 = load ptr, ptr %6, align 8\n%47 = getelementptr inbounds %struct.gfs2_quota_data ptr %46, i32 0, i32 1\n%48 = load i32, ptr %47, align 8\n%49 = load ptr, ptr %6, align 8\n%50 = getelementptr inbounds %struct.gfs2_quota_data ptr %49, i32 0, i32 2\nstore i32 %48, ptr %50, align 4\n%51 = load ptr, ptr %6, align 8\n%52 = call i32 @slot_hold(ptr noundef %51)\nstore i32 1, ptr %4, align 4\nbr label %53\n\n53:\n%54 = load i32, ptr %4, align 4\nret i32 %54\n}": {"base_truth": "define internal i32 @qd_check_sync(ptr noundef %0, ptr noundef %1, ptr noundef readonly %2) {\nB:\n%3 = load i32, ptr @QDF_LOCKED, align 4\n%4 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 3\n%5 = tail call i64 @test_bit(i32 noundef %3, ptr noundef nonnull %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B1, label %B6\n\nB1:\n%7 = load i32, ptr @QDF_CHANGE, align 4\n%8 = tail call i64 @test_bit(i32 noundef %7, ptr noundef nonnull %4)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B6, label %B2\n\nB2:\n%10 = icmp eq ptr %2, null\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i64, ptr %1, align 8\n%12 = load i64, ptr %2, align 8\n%13 = icmp slt i64 %11, %12\nbr i1 %13, label %B4, label %B6\n\nB4:\n%14 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 5\n%15 = tail call i32 @lockref_get_not_dead(ptr noundef nonnull %14)\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B6, label %B5\n\nB5:\n%17 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 4\n%18 = tail call i32 @list_move_tail(ptr noundef nonnull %17, ptr noundef %0)\n%19 = load i32, ptr @QDF_LOCKED, align 4\n%20 = tail call i32 @set_bit(i32 noundef %19, ptr noundef nonnull %4)\n%21 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 1\n%22 = load i32, ptr %21, align 8\n%23 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 2\nstore i32 %22, ptr %23, align 4\n%24 = tail call i32 @slot_hold(ptr noundef %1)\nbr label %B6\n\nB6:\n%25 = phi i32 [ 1, %B5 ], [ 0, %B3 ], [ 0, %B1 ], [ 0, %B ], [ 0, %B4 ]\nret i32 %25\n}", "codellama": "define internal i32 @qd_check_sync(ptr noundef %0, ptr noundef %1, ptr noundef readonly %2) {\nB:\n%3 = load i32, ptr @QDF_LOCKED, align 4\n%4 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 3\n%5 = tail call i64 @test_bit(i32 noundef %3, ptr noundef nonnull %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B1, label %B6\n\nB1:\n%7 = load i32, ptr @QDF_CHANGE, align 4\n%8 = tail call i64 @test_bit(i32 noundef %7, ptr noundef nonnull %4)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B6, label %B2\n\nB2:\n%10 = icmp eq ptr %2, null\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = load i64, ptr %1, align 8\n%12 = load i64, ptr %2, align 8\n%13 = icmp slt i64 %11, %12\nbr i1 %13, label %B4, label %B6\n\nB4:\n%14 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 5\n%15 = tail call i32 @lockref_get_not_dead(ptr noundef nonnull %14)\n%16 = icmp eq i32 %15, 0\nbr i1 %16, label %B6, label %B5\n\nB5:\n%17 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 4\n%18 = tail call i32 @list_move_tail(ptr noundef nonnull %17, ptr noundef %0)\n%19 = load i32, ptr @QDF_LOCKED, align 4\n%20 = tail call i32 @set_bit(i32 noundef %19, ptr noundef nonnull %4)\n%21 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 1\n%22 = load i32, ptr %21, align 8\n%23 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 2\nstore i32 %22, ptr %23, align 4\n%24 = tail call i32 @slot_hold(ptr noundef nonnull %1)\nbr label %B6\n\nB6:\n%25 = phi i32 [ 1, %B5 ], [ 0, %B3 ], [ 0, %B1 ], [ 0, %B ], [ 0, %B4 ]\nret i32 %25\n}", "codegemma": "define internal i32 @qd_check_sync(ptr noundef %0, ptr noundef %1, ptr noundef readonly %2) {\nB:\n%3 = load i32, ptr @QDF_LOCKED, align 4\n%4 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 3\n%5 = tail call i64 @test_bit(i32 noundef %3, ptr noundef nonnull %4)\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B1, label %B6\n\nB1:\n%7 = load i32, ptr @QDF_CHANGE, align 4\n%8 = tail call i64 @test_bit(i32 noundef %7, ptr noundef nonnull %4)\n%9 = icmp eq i64 %8, 0\n%10 = icmp ne ptr %2, null\n%11 = and i1 %10, %9\nbr i1 %11, label %B2, label %B5\n\nB2:\n%12 = load i64, ptr %1, align 8\n%13 = load i64, ptr %2, align 8\n%14 = icmp slt i64 %12, %13\nbr i1 %14, label %B5, label %B6\n\nB3:\n%15 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 4\n%16 = tail call i32 @list_move_tail(ptr noundef nonnull %15, ptr noundef %0)\n%17 = load i32, ptr @QDF_LOCKED, align 4\n%18 = tail call i32 @set_bit(i32 noundef %17, ptr noundef nonnull %4)\n%19 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 1\n%20 = load i32, ptr %19, align 8\n%21 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 2\nstore i32 %20, ptr %21, align 4\n%22 = tail call i32 @slot_hold(ptr noundef nonnull %1)\nbr label %B6\n\nB4:\n%23 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 2\n%24 = load i32, ptr %23, align 4\n%25 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 1\nstore i32 %24, ptr %25, align 8\n%26 = tail call i32 @slot_hold(ptr noundef nonnull %1)\nbr label %B6\n\nB5:\n%27 = getelementptr inbounds %struct.gfs2_quota_data, ptr %1, i64 0, i32 5\n%28 = tail call i32 @lockref_get_not_dead(ptr noundef nonnull %27)\n%29 = icmp eq i32 %28, 0\nbr i1 %29, label %B6, label %B3\n\nB6:\n%30 = phi i32 [ 1, %B3 ], [ 1, %B4 ], [ 0, %B2 ], [ 0, %B ], [ 0, %B5 ]\nret i32 %30\n}"}, "define internal i32 @clk_mux_get_parent(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @to_clk_mux(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = call i32 @clk_mux_readl(ptr noundef %7)\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.clk_mux ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = ashr i32 %8, %11\nstore i32 %12, ptr %4, align 4\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.clk_mux ptr %13, i32 0, i32 1\n%15 = load i32, ptr %14, align 4\n%16 = load i32, ptr %4, align 4\n%17 = and i32 %16, %15\nstore i32 %17, ptr %4, align 4\n%18 = load ptr, ptr %2, align 8\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.clk_mux ptr %19, i32 0, i32 3\n%21 = load i32, ptr %20, align 4\n%22 = load ptr, ptr %3, align 8\n%23 = getelementptr inbounds %struct.clk_mux ptr %22, i32 0, i32 2\n%24 = load i32, ptr %23, align 4\n%25 = load i32, ptr %4, align 4\n%26 = call i32 @clk_mux_val_to_index(ptr noundef %18, i32 noundef %21, i32 noundef %24, i32 noundef %25)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %26\n}": {"base_truth": "define internal i32 @clk_mux_get_parent(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_clk_mux(ptr noundef %0)\n%2 = tail call i32 @clk_mux_readl(ptr noundef %1)\n%3 = load i32, ptr %1, align 4\n%4 = ashr i32 %2, %3\n%5 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = and i32 %4, %6\n%8 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 3\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 2\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @clk_mux_val_to_index(ptr noundef %0, i32 noundef %9, i32 noundef %11, i32 noundef %7)\nret i32 %12\n}", "codellama": "define internal i32 @clk_mux_get_parent(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_clk_mux(ptr noundef %0)\n%2 = tail call i32 @clk_mux_readl(ptr noundef %1)\n%3 = load i32, ptr %1, align 4\n%4 = ashr i32 %2, %3\n%5 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = and i32 %4, %6\n%8 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 3\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 2\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @clk_mux_val_to_index(ptr noundef %0, i32 noundef %9, i32 noundef %11, i32 noundef %7)\nret i32 %12\n}", "codegemma": "define internal i32 @clk_mux_get_parent(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_clk_mux(ptr noundef %0)\n%2 = tail call i32 @clk_mux_readl(ptr noundef %1)\n%3 = load i32, ptr %1, align 4\n%4 = ashr i32 %2, %3\n%5 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = and i32 %6, %4\n%8 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 3\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.clk_mux, ptr %1, i64 0, i32 2\n%11 = load i32, ptr %10, align 4\n%12 = tail call i32 @clk_mux_val_to_index(ptr noundef %0, i32 noundef %9, i32 noundef %11, i32 noundef %7)\nret i32 %12\n}"}, "define internal void @e1000_power_up_serdes_link_82575(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%5 = call i32 @DEBUGFUNC(ptr noundef @.str)\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.e1000_hw, ptr %6, i32 0, i32 0\n%8 = getelementptr inbounds %struct.TYPE_2__, ptr %7, i32 0, i32 0\n%9 = load i64, ptr %8, align 8\n%10 = load i64, ptr @e1000_media_type_internal_serdes, align 8\n%11 = icmp ne i64 %9, %10\nbr i1 %11, label %12, label %17\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = call i32 @e1000_sgmii_active_82575(ptr noundef %13)\n%15 = icmp ne i32 %14, 0\nbr i1 %15, label %17, label %16\n\n16:\nstore i32 1, ptr %4, align 4\nbr label %42\n\n17:\n%18 = load ptr, ptr %2, align 8\n%19 = load i32, ptr @E1000_PCS_CFG0, align 4\n%20 = call i32 @E1000_READ_REG(ptr noundef %18, i32 noundef %19)\nstore i32 %20, ptr %3, align 4\n%21 = load i32, ptr @E1000_PCS_CFG_PCS_EN, align 4\n%22 = load i32, ptr %3, align 4\n%23 = or i32 %22, %21\nstore i32 %23, ptr %3, align 4\n%24 = load ptr, ptr %2, align 8\n%25 = load i32, ptr @E1000_PCS_CFG0, align 4\n%26 = load i32, ptr %3, align 4\n%27 = call i32 @E1000_WRITE_REG(ptr noundef %24, i32 noundef %25, i32 noundef %26)\n%28 = load ptr, ptr %2, align 8\n%29 = load i32, ptr @E1000_CTRL_EXT, align 4\n%30 = call i32 @E1000_READ_REG(ptr noundef %28, i32 noundef %29)\nstore i32 %30, ptr %3, align 4\n%31 = load i32, ptr @E1000_CTRL_EXT_SDP3_DATA, align 4\n%32 = xor i32 %31, -1\n%33 = load i32, ptr %3, align 4\n%34 = and i32 %33, %32\nstore i32 %34, ptr %3, align 4\n%35 = load ptr, ptr %2, align 8\n%36 = load i32, ptr @E1000_CTRL_EXT, align 4\n%37 = load i32, ptr %3, align 4\n%38 = call i32 @E1000_WRITE_REG(ptr noundef %35, i32 noundef %36, i32 noundef %37)\n%39 = load ptr, ptr %2, align 8\n%40 = call i32 @E1000_WRITE_FLUSH(ptr noundef %39)\n%41 = call i32 @msec_delay(i32 noundef 1)\nstore i32 0, ptr %4, align 4\nbr label %42\n\n42:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\n%43 = load i32, ptr %4, align 4\nswitch i32 %43, label %45 [\ni32 0, label %44\ni32 1, label %44\n]\n\n44:\nret void\n\n45:\nunreachable\n}": {"base_truth": "define internal void @e1000_power_up_serdes_link_82575(ptr noundef %0) {\nB:\n%1 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @e1000_media_type_internal_serdes, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @e1000_sgmii_active_82575(ptr noundef nonnull %0)\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr @E1000_PCS_CFG0, align 4\n%8 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %7)\n%9 = load i32, ptr @E1000_PCS_CFG_PCS_EN, align 4\n%10 = or i32 %9, %8\n%11 = load i32, ptr @E1000_PCS_CFG0, align 4\n%12 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %11, i32 noundef %10)\n%13 = load i32, ptr @E1000_CTRL_EXT, align 4\n%14 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %13)\n%15 = load i32, ptr @E1000_CTRL_EXT_SDP3_DATA, align 4\n%16 = xor i32 %15, -1\n%17 = and i32 %14, %16\n%18 = load i32, ptr @E1000_CTRL_EXT, align 4\n%19 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %18, i32 noundef %17)\n%20 = tail call i32 @E1000_WRITE_FLUSH(ptr noundef nonnull %0)\n%21 = tail call i32 @msec_delay(i32 noundef 1)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @e1000_power_up_serdes_link_82575(ptr noundef %0) {\nB:\n%1 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @e1000_media_type_internal_serdes, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @e1000_sgmii_active_82575(ptr noundef nonnull %0)\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr @E1000_PCS_CFG0, align 4\n%8 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %7)\n%9 = load i32, ptr @E1000_PCS_CFG_PCS_EN, align 4\n%10 = or i32 %9, %8\n%11 = load i32, ptr @E1000_PCS_CFG0, align 4\n%12 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %11, i32 noundef %10)\n%13 = load i32, ptr @E1000_CTRL_EXT, align 4\n%14 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %13)\n%15 = load i32, ptr @E1000_CTRL_EXT_SDP3_DATA, align 4\n%16 = xor i32 %15, -1\n%17 = and i32 %14, %16\n%18 = load i32, ptr @E1000_CTRL_EXT, align 4\n%19 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %18, i32 noundef %17)\n%20 = tail call i32 @E1000_WRITE_FLUSH(ptr noundef nonnull %0)\n%21 = tail call i32 @msec_delay(i32 noundef 1)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @e1000_power_up_serdes_link_82575(ptr noundef %0) {\nB:\n%1 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr @e1000_media_type_internal_serdes, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @e1000_sgmii_active_82575(ptr noundef nonnull %0)\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B3, label %B2\n\nB2:\n%7 = load i32, ptr @E1000_PCS_CFG0, align 4\n%8 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %7)\n%9 = load i32, ptr @E1000_PCS_CFG_PCS_EN, align 4\n%10 = or i32 %9, %8\n%11 = load i32, ptr @E1000_PCS_CFG0, align 4\n%12 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %11, i32 noundef %10)\n%13 = load i32, ptr @E1000_CTRL_EXT, align 4\n%14 = tail call i32 @E1000_READ_REG(ptr noundef nonnull %0, i32 noundef %13)\n%15 = load i32, ptr @E1000_CTRL_EXT_SDP3_DATA, align 4\n%16 = xor i32 %15, -1\n%17 = and i32 %14, %16\n%18 = load i32, ptr @E1000_CTRL_EXT, align 4\n%19 = tail call i32 @E1000_WRITE_REG(ptr noundef nonnull %0, i32 noundef %18, i32 noundef %17)\n%20 = tail call i32 @E1000_WRITE_FLUSH(ptr noundef nonnull %0)\n%21 = tail call i32 @msec_delay(i32 noundef 1)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local void @bna_rx_vlan_strip_enable(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.bna_rx ptr %4, i32 0, i32 0\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.bna_rxf ptr %6, i32 0, i32 0\n%8 = load i64, ptr %7, align 8\n%9 = load i64, ptr @BNA_STATUS_T_DISABLED, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %11, label %20\n\n11:\n%12 = load i64, ptr @BNA_STATUS_T_ENABLED, align 8\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.bna_rxf ptr %13, i32 0, i32 0\nstore i64 %12, ptr %14, align 8\n%15 = load ptr, ptr %3, align 8\n%16 = getelementptr inbounds %struct.bna_rxf ptr %15, i32 0, i32 1\nstore i32 1, ptr %16, align 8\n%17 = load ptr, ptr %3, align 8\n%18 = load i32, ptr @RXF_E_CONFIG, align 4\n%19 = call i32 @bfa_fsm_send_event(ptr noundef %17, i32 noundef %18)\nbr label %20\n\n20:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @bna_rx_vlan_strip_enable(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @BNA_STATUS_T_DISABLED, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i64, ptr @BNA_STATUS_T_ENABLED, align 8\nstore i64 %4, ptr %0, align 8\n%5 = getelementptr inbounds %struct.bna_rxf, ptr %0, i64 0, i32 1\nstore i32 1, ptr %5, align 8\n%6 = load i32, ptr @RXF_E_CONFIG, align 4\n%7 = tail call i32 @bfa_fsm_send_event(ptr noundef nonnull %0, i32 noundef %6)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @bna_rx_vlan_strip_enable(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @BNA_STATUS_T_DISABLED, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i64, ptr @BNA_STATUS_T_ENABLED, align 8\nstore i64 %4, ptr %0, align 8\n%5 = getelementptr inbounds %struct.bna_rxf, ptr %0, i64 0, i32 1\nstore i32 1, ptr %5, align 8\n%6 = load i32, ptr @RXF_E_CONFIG, align 4\n%7 = tail call i32 @bfa_fsm_send_event(ptr noundef nonnull %0, i32 noundef %6)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @bna_rx_vlan_strip_enable(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @BNA_STATUS_T_DISABLED, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i64, ptr @BNA_STATUS_T_ENABLED, align 8\nstore i64 %4, ptr %0, align 8\n%5 = getelementptr inbounds %struct.bna_rxf, ptr %0, i64 0, i32 1\nstore i32 1, ptr %5, align 8\n%6 = load i32, ptr @RXF_E_CONFIG, align 4\n%7 = tail call i32 @bfa_fsm_send_event(ptr noundef nonnull %0, i32 noundef %6)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @cutils_cdar_DynamicArray_double_append_default2(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @cutils_cdar_DynamicArray_void_ptr_append(ptr noundef %5, i32 noundef 1, ptr noundef %6)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @cutils_cdar_DynamicArray_double_append_default2(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @cutils_cdar_DynamicArray_void_ptr_append(ptr noundef %0, i32 noundef 1, ptr noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @cutils_cdar_DynamicArray_double_append_default2(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @cutils_cdar_DynamicArray_void_ptr_append(ptr noundef %0, i32 noundef 1, ptr noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @cutils_cdar_DynamicArray_double_append_default2(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @cutils_cdar_DynamicArray_void_ptr_append(ptr noundef %0, i32 noundef 1, ptr noundef %1)\nret i32 %2\n}"}, "define dso_local i32 @Export_BotLibVarSet(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @LibVarSet(ptr noundef %5, ptr noundef %6)\n%8 = load i32, ptr @BLERR_NOERROR, align 4\nret i32 %8\n}": {"base_truth": "define dso_local i32 @Export_BotLibVarSet(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @LibVarSet(ptr noundef %0, ptr noundef %1)\n%3 = load i32, ptr @BLERR_NOERROR, align 4\nret i32 %3\n}", "codellama": "define dso_local i32 @Export_BotLibVarSet(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @LibVarSet(ptr noundef %0, ptr noundef %1)\n%3 = load i32, ptr @BLERR_NOERROR, align 4\nret i32 %3\n}", "codegemma": "define dso_local i32 @Export_BotLibVarSet(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @LibVarSet(ptr noundef %0, ptr noundef %1)\n%3 = load i32, ptr @BLERR_NOERROR, align 4\nret i32 %3\n}"}, "define dso_local void @scic_sds_controller_reset_hardware(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @scic_controller_disable_interrupts(ptr noundef %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @SMU_SMUSRCR_WRITE(ptr noundef %5, i32 noundef -1)\n%7 = call i32 @scic_cb_stall_execution(i32 noundef 1000)\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @SMU_CQGR_WRITE(ptr noundef %8, i32 noundef 0)\n%10 = load ptr, ptr %2, align 8\n%11 = call i32 @SCU_UFQGP_WRITE(ptr noundef %10, i32 noundef 0)\nret void\n}": {"base_truth": "define dso_local void @scic_sds_controller_reset_hardware(ptr noundef %0) {\nB:\n%1 = tail call i32 @scic_controller_disable_interrupts(ptr noundef %0)\n%2 = tail call i32 @SMU_SMUSRCR_WRITE(ptr noundef %0, i32 noundef -1)\n%3 = tail call i32 @scic_cb_stall_execution(i32 noundef 1000)\n%4 = tail call i32 @SMU_CQGR_WRITE(ptr noundef %0, i32 noundef 0)\n%5 = tail call i32 @SCU_UFQGP_WRITE(ptr noundef %0, i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @scic_sds_controller_reset_hardware(ptr noundef %0) {\nB:\n%1 = tail call i32 @scic_controller_disable_interrupts(ptr noundef %0)\n%2 = tail call i32 @SMU_SMUSRCR_WRITE(ptr noundef %0, i32 noundef -1)\n%3 = tail call i32 @scic_cb_stall_execution(i32 noundef 1000)\n%4 = tail call i32 @SMU_CQGR_WRITE(ptr noundef %0, i32 noundef 0)\n%5 = tail call i32 @SCU_UFQGP_WRITE(ptr noundef %0, i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @scic_sds_controller_reset_hardware(ptr noundef %0) {\nB:\n%1 = tail call i32 @scic_controller_disable_interrupts(ptr noundef %0)\n%2 = tail call i32 @SMU_SMUSRCR_WRITE(ptr noundef %0, i32 noundef -1)\n%3 = tail call i32 @scic_cb_stall_execution(i32 noundef 1000)\n%4 = tail call i32 @SMU_CQGR_WRITE(ptr noundef %0, i32 noundef 0)\n%5 = tail call i32 @SCU_UFQGP_WRITE(ptr noundef %0, i32 noundef 0)\nret void\n}"}, "define dso_local void @print() {\n%1 = call i32 @printf(ptr noundef @.str, double noundef nofpclass(nan inf) 0x400921FB53C8D4F1)\nret void\n}": {"base_truth": "define dso_local void @print() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, double noundef nofpclass(nan inf) 0x400921FB53C8D4F1)\nret void\n}", "codellama": "define dso_local void @print() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, double noundef nofpclass(nan inf) 0x400921FB53C8D4F1)\nret void\n}", "codegemma": "define dso_local void @print() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, double noundef nofpclass(nan inf) 0x400921FB53C8D4F1)\nret void\n}"}, "define internal i32 @ahash_sha256_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @crypto_ahash_reqtfm(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @crypto_ahash_ctx(ptr noundef %7)\nstore ptr %8, ptr %4, align 8\n%9 = load i32, ptr @HASH_DATA_8_BITS, align 4\n%10 = load ptr, ptr %4, align 8\n%11 = getelementptr inbounds %struct.hash_ctx ptr %10, i32 0, i32 1\n%12 = getelementptr inbounds %struct.TYPE_2__, ptr %11, i32 0, i32 2\nstore i32 %9, ptr %12, align 4\n%13 = load i32, ptr @HASH_ALGO_SHA256, align 4\n%14 = load ptr, ptr %4, align 8\n%15 = getelementptr inbounds %struct.hash_ctx ptr %14, i32 0, i32 1\n%16 = getelementptr inbounds %struct.TYPE_2__, ptr %15, i32 0, i32 1\nstore i32 %13, ptr %16, align 4\n%17 = load i32, ptr @HASH_OPER_MODE_HASH, align 4\n%18 = load ptr, ptr %4, align 8\n%19 = getelementptr inbounds %struct.hash_ctx ptr %18, i32 0, i32 1\n%20 = getelementptr inbounds %struct.TYPE_2__, ptr %19, i32 0, i32 0\nstore i32 %17, ptr %20, align 4\n%21 = load i32, ptr @SHA256_DIGEST_SIZE, align 4\n%22 = load ptr, ptr %4, align 8\n%23 = getelementptr inbounds %struct.hash_ctx ptr %22, i32 0, i32 0\nstore i32 %21, ptr %23, align 4\n%24 = load ptr, ptr %2, align 8\n%25 = call i32 @hash_init(ptr noundef %24)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %25\n}": {"base_truth": "define internal i32 @ahash_sha256_init(ptr noundef %0) {\nB:\n%1 = tail call ptr @crypto_ahash_reqtfm(ptr noundef %0)\n%2 = tail call ptr @crypto_ahash_ctx(ptr noundef %1)\n%3 = load i32, ptr @HASH_DATA_8_BITS, align 4\n%4 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1\n%5 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1, i32 2\nstore i32 %3, ptr %5, align 4\n%6 = load i32, ptr @HASH_ALGO_SHA256, align 4\n%7 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1, i32 1\nstore i32 %6, ptr %7, align 4\n%8 = load i32, ptr @HASH_OPER_MODE_HASH, align 4\nstore i32 %8, ptr %4, align 4\n%9 = load i32, ptr @SHA256_DIGEST_SIZE, align 4\nstore i32 %9, ptr %2, align 4\n%10 = tail call i32 @hash_init(ptr noundef %0)\nret i32 %10\n}", "codellama": "define internal i32 @ahash_sha256_init(ptr noundef %0) {\nB:\n%1 = tail call ptr @crypto_ahash_reqtfm(ptr noundef %0)\n%2 = tail call ptr @crypto_ahash_ctx(ptr noundef %1)\n%3 = load i32, ptr @HASH_DATA_8_BITS, align 4\n%4 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1, i32 2\nstore i32 %3, ptr %4, align 4\n%5 = load i32, ptr @HASH_ALGO_SHA256, align 4\n%6 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1, i32 1\nstore i32 %5, ptr %6, align 4\n%7 = load i32, ptr @HASH_OPER_MODE_HASH, align 4\n%8 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1\nstore i32 %7, ptr %8, align 4\n%9 = load i32, ptr @SHA256_DIGEST_SIZE, align 4\nstore i32 %9, ptr %2, align 4\n%10 = tail call i32 @hash_init(ptr noundef %0)\nret i32 %10\n}", "codegemma": "define internal i32 @ahash_sha256_init(ptr noundef %0) {\nB:\n%1 = tail call ptr @crypto_ahash_reqtfm(ptr noundef %0)\n%2 = tail call ptr @crypto_ahash_ctx(ptr noundef %1)\n%3 = load i32, ptr @HASH_DATA_8_BITS, align 4\n%4 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1\n%5 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1, i32 2\nstore i32 %3, ptr %5, align 4\n%6 = load i32, ptr @HASH_ALGO_SHA256, align 4\n%7 = getelementptr inbounds %struct.hash_ctx, ptr %2, i64 0, i32 1, i32 1\nstore i32 %6, ptr %7, align 4\n%8 = load i32, ptr @HASH_OPER_MODE_HASH, align 4\nstore i32 %8, ptr %4, align 4\n%9 = load i32, ptr @SHA256_DIGEST_SIZE, align 4\nstore i32 %9, ptr %2, align 4\n%10 = tail call i32 @hash_init(ptr noundef %0)\nret i32 %10\n}"}, "define internal void @mtk_mipi_tx_power_off_signal(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @phy_get_drvdata(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = load i32, ptr @MIPITX_DSI_TOP_CON, align 4\n%9 = load i32, ptr @RG_DSI_PAD_TIE_LOW_EN, align 4\n%10 = call i32 @mtk_mipi_tx_set_bits(ptr noundef %7, i32 noundef %8, i32 noundef %9)\n%11 = load i64, ptr @MIPITX_DSI_CLOCK_LANE, align 8\nstore i64 %11, ptr %4, align 8\nbr label %12\n\n12:\n%13 = load i64, ptr %4, align 8\n%14 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%15 = icmp sle i64 %13, %14\nbr i1 %15, label %16, label %24\n\n16:\n%17 = load ptr, ptr %3, align 8\n%18 = load i64, ptr %4, align 8\n%19 = load i32, ptr @RG_DSI_LNTx_LDOOUT_EN, align 4\n%20 = call i32 @mtk_mipi_tx_clear_bits(ptr noundef %17, i64 noundef %18, i32 noundef %19)\nbr label %21\n\n21:\n%22 = load i64, ptr %4, align 8\n%23 = add nsw i64 %22, 4\nstore i64 %23, ptr %4, align 8\nbr label %12\n\n24:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @mtk_mipi_tx_power_off_signal(ptr noundef %0) {\nB:\n%1 = tail call ptr @phy_get_drvdata(ptr noundef %0)\n%2 = load i32, ptr @MIPITX_DSI_TOP_CON, align 4\n%3 = load i32, ptr @RG_DSI_PAD_TIE_LOW_EN, align 4\n%4 = tail call i32 @mtk_mipi_tx_set_bits(ptr noundef %1, i32 noundef %2, i32 noundef %3)\n%5 = load i64, ptr @MIPITX_DSI_CLOCK_LANE, align 8\n%6 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%7 = icmp sgt i64 %5, %6\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = phi i64 [ %11, %B1 ], [ %5, %B ]\n%9 = load i32, ptr @RG_DSI_LNTx_LDOOUT_EN, align 4\n%10 = tail call i32 @mtk_mipi_tx_clear_bits(ptr noundef %1, i64 noundef %8, i32 noundef %9)\n%11 = add nsw i64 %8, 4\n%12 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%13 = icmp sgt i64 %11, %12\nbr i1 %13, label %B2, label %B1\n\nB2:\nret void\n}", "codellama": "define internal void @mtk_mipi_tx_power_off_signal(ptr noundef %0) {\nB:\n%1 = tail call ptr @phy_get_drvdata(ptr noundef %0)\n%2 = load i32, ptr @MIPITX_DSI_TOP_CON, align 4\n%3 = load i32, ptr @RG_DSI_PAD_TIE_LOW_EN, align 4\n%4 = tail call i32 @mtk_mipi_tx_set_bits(ptr noundef %1, i32 noundef %2, i32 noundef %3)\n%5 = load i64, ptr @MIPITX_DSI_CLOCK_LANE, align 8\n%6 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%7 = icmp sgt i64 %5, %6\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = phi i64 [ %12, %B1 ], [ %5, %B ]\n%9 = load i32, ptr @RG_DSI_LNTx_LDOOUT_EN, align 4\n%10 = tail call i32 @mtk_mipi_tx_clear_bits(ptr noundef %1, i64 noundef %8, i32 noundef %9)\n%11 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%12 = add nsw i64 %8, 4\n%13 = icmp sgt i64 %8, %11\nbr i1 %13, label %B2, label %B1\n\nB2:\nret void\n}", "codegemma": "define internal void @mtk_mipi_tx_power_off_signal(ptr noundef %0) {\nB:\n%1 = tail call ptr @phy_get_drvdata(ptr noundef %0)\n%2 = load i32, ptr @MIPITX_DSI_TOP_CON, align 4\n%3 = load i32, ptr @RG_DSI_PAD_TIE_LOW_EN, align 4\n%4 = tail call i32 @mtk_mipi_tx_set_bits(ptr noundef %1, i32 noundef %2, i32 noundef %3)\n%5 = load i64, ptr @MIPITX_DSI_CLOCK_LANE, align 8\n%6 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%7 = icmp sgt i64 %5, %6\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = phi i64 [ %11, %B1 ], [ %5, %B ]\n%9 = load i32, ptr @RG_DSI_LNTx_LDOOUT_EN, align 4\n%10 = tail call i32 @mtk_mipi_tx_clear_bits(ptr noundef %1, i64 noundef %8, i32 noundef %9)\n%11 = add nsw i64 %8, 4\n%12 = load i64, ptr @MIPITX_DSI_CLOCK_LANE, align 8\n%13 = load i64, ptr @MIPITX_DSI_DATA_LANE3, align 8\n%14 = icmp sgt i64 %12, %13\nbr i1 %14, label %B2, label %B1\n\nB2:\nret void\n}"}, "define internal void @dtrace_probe_exit(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load ptr, ptr @curthread, align 8\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %3, i32 0, i32 0\nstore i64 0, ptr %4, align 8\n%5 = load i32, ptr %2, align 4\n%6 = call i32 @dtrace_interrupt_enable(i32 noundef %5)\nret void\n}": {"base_truth": "define internal void @dtrace_probe_exit(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @curthread, align 8\nstore i64 0, ptr %1, align 8\n%2 = tail call i32 @dtrace_interrupt_enable(i32 noundef %0)\nret void\n}", "codellama": "define internal void @dtrace_probe_exit(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @curthread, align 8\nstore i64 0, ptr %1, align 8\n%2 = tail call i32 @dtrace_interrupt_enable(i32 noundef %0)\nret void\n}", "codegemma": "define internal void @dtrace_probe_exit(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @curthread, align 8\nstore i64 0, ptr %1, align 8\n%2 = tail call i32 @dtrace_interrupt_enable(i32 noundef %0)\nret void\n}"}, "define internal i32 @b43_aphy_op_radio_read(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, 1\n%7 = zext i1 %6 to i32\n%8 = call i32 @B43_WARN_ON(i32 noundef %7)\n%9 = load i32, ptr %4, align 4\n%10 = or i32 %9, 64\nstore i32 %10, ptr %4, align 4\n%11 = load ptr, ptr %3, align 8\n%12 = load i32, ptr @B43_MMIO_RADIO_CONTROL, align 4\n%13 = load i32, ptr %4, align 4\n%14 = call i32 @b43_write16(ptr noundef %11, i32 noundef %12, i32 noundef %13)\n%15 = load ptr, ptr %3, align 8\n%16 = load i32, ptr @B43_MMIO_RADIO_DATA_LOW, align 4\n%17 = call i32 @b43_read16(ptr noundef %15, i32 noundef %16)\nret i32 %17\n}": {"base_truth": "define internal i32 @b43_aphy_op_radio_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 1\n%3 = zext i1 %2 to i32\n%4 = tail call i32 @B43_WARN_ON(i32 noundef %3)\n%5 = or i32 %1, 64\n%6 = load i32, ptr @B43_MMIO_RADIO_CONTROL, align 4\n%7 = tail call i32 @b43_write16(ptr noundef %0, i32 noundef %6, i32 noundef %5)\n%8 = load i32, ptr @B43_MMIO_RADIO_DATA_LOW, align 4\n%9 = tail call i32 @b43_read16(ptr noundef %0, i32 noundef %8)\nret i32 %9\n}", "codellama": "define internal i32 @b43_aphy_op_radio_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 1\n%3 = zext i1 %2 to i32\n%4 = tail call i32 @B43_WARN_ON(i32 noundef %3)\n%5 = or i32 %1, 64\n%6 = load i32, ptr @B43_MMIO_RADIO_CONTROL, align 4\n%7 = tail call i32 @b43_write16(ptr noundef %0, i32 noundef %6, i32 noundef %5)\n%8 = load i32, ptr @B43_MMIO_RADIO_DATA_LOW, align 4\n%9 = tail call i32 @b43_read16(ptr noundef %0, i32 noundef %8)\nret i32 %9\n}", "codegemma": "define internal i32 @b43_aphy_op_radio_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 1\n%3 = zext i1 %2 to i32\n%4 = tail call i32 @B43_WARN_ON(i32 noundef %3)\n%5 = or i32 %1, 64\n%6 = load i32, ptr @B43_MMIO_RADIO_CONTROL, align 4\n%7 = tail call i32 @b43_write16(ptr noundef %0, i32 noundef %6, i32 noundef %5)\n%8 = load i32, ptr @B43_MMIO_RADIO_DATA_LOW, align 4\n%9 = tail call i32 @b43_read16(ptr noundef %0, i32 noundef %8)\nret i32 %9\n}"}, "define internal void @show_callee_regs(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.callee_regs ptr %3, i32 0, i32 0\n%5 = call i32 @print_reg_file(ptr noundef %4, i32 noundef 13)\nret void\n}": {"base_truth": "define internal void @show_callee_regs(ptr noundef %0) {\nB:\n%1 = tail call i32 @print_reg_file(ptr noundef %0, i32 noundef 13)\nret void\n}", "codellama": "define internal void @show_callee_regs(ptr noundef %0) {\nB:\n%1 = tail call i32 @print_reg_file(ptr noundef %0, i32 noundef 13)\nret void\n}", "codegemma": "define internal void @show_callee_regs(ptr noundef %0) {\nB:\n%1 = tail call i32 @print_reg_file(ptr noundef %0, i32 noundef 13)\nret void\n}"}, "define dso_local void @trie_setup(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr %6, align 4\n%10 = call i32 @trie_setup_full(ptr noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef 1)\nret void\n}": {"base_truth": "define dso_local void @trie_setup(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @trie_setup_full(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 1)\nret void\n}", "codellama": "define dso_local void @trie_setup(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @trie_setup_full(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 1)\nret void\n}", "codegemma": "define dso_local void @trie_setup(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @trie_setup_full(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 1)\nret void\n}"}, "define dso_local ptr @r400collect(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore ptr null, ptr %3, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @r400resolve_in(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load i64, ptr @oBC32smart_eiffel, align 8\n%7 = inttoptr i64 %6 to ptr\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @r111collect_constant(ptr noundef %7, ptr noundef %8)\n%10 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %10\n}": {"base_truth": "define dso_local ptr @r400collect(ptr noundef %0) {\nB:\n%1 = tail call ptr @r400resolve_in(ptr noundef %0)\n%2 = load i64, ptr @oBC32smart_eiffel, align 8\n%3 = inttoptr i64 %2 to ptr\n%4 = tail call i32 @r111collect_constant(ptr noundef %3, ptr noundef %1)\nret ptr %1\n}", "codellama": "define dso_local ptr @r400collect(ptr noundef %0) {\nB:\n%1 = tail call ptr @r400resolve_in(ptr noundef %0)\n%2 = load i64, ptr @oBC32smart_eiffel, align 8\n%3 = inttoptr i64 %2 to ptr\n%4 = tail call i32 @r111collect_constant(ptr noundef %3, ptr noundef %1)\nret ptr %1\n}", "codegemma": "define dso_local ptr @r400collect(ptr noundef %0) {\nB:\n%1 = tail call ptr @r400resolve_in(ptr noundef %0)\n%2 = load i64, ptr @oBC32smart_eiffel, align 8\n%3 = inttoptr i64 %2 to ptr\n%4 = tail call i32 @r111collect_constant(ptr noundef %3, ptr noundef %1)\nret ptr %1\n}"}, "define internal void @rpcrdma_schedule_tasklet(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load i64, ptr %3, align 8\n%5 = call i32 @spin_lock_irqsave(ptr noundef @rpcrdma_tk_lock_g, i64 noundef %4)\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.rpcrdma_rep ptr %6, i32 0, i32 0\n%8 = call i32 @list_add_tail(ptr noundef %7, ptr noundef @rpcrdma_tasklets_g)\n%9 = load i64, ptr %3, align 8\n%10 = call i32 @spin_unlock_irqrestore(ptr noundef @rpcrdma_tk_lock_g, i64 noundef %9)\n%11 = call i32 @tasklet_schedule(ptr noundef @rpcrdma_tasklet_g)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @rpcrdma_schedule_tasklet(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull @rpcrdma_tk_lock_g, i64 noundef undef)\n%2 = tail call i32 @list_add_tail(ptr noundef %0, ptr noundef nonnull @rpcrdma_tasklets_g)\n%3 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull @rpcrdma_tk_lock_g, i64 noundef undef)\n%4 = tail call i32 @tasklet_schedule(ptr noundef nonnull @rpcrdma_tasklet_g)\nret void\n}", "codellama": "define internal void @rpcrdma_schedule_tasklet(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull @rpcrdma_tk_lock_g, i64 noundef undef)\n%2 = tail call i32 @list_add_tail(ptr noundef %0, ptr noundef nonnull @rpcrdma_tasklets_g)\n%3 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull @rpcrdma_tk_lock_g, i64 noundef undef)\n%4 = tail call i32 @tasklet_schedule(ptr noundef nonnull @rpcrdma_tasklet_g)\nret void\n}", "codegemma": "define internal void @rpcrdma_schedule_tasklet(ptr noundef %0) {\nB:\n%1 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull @rpcrdma_tk_lock_g, i64 noundef undef)\n%2 = tail call i32 @list_add_tail(ptr noundef %0, ptr noundef nonnull @rpcrdma_tasklets_g)\n%3 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull @rpcrdma_tk_lock_g, i64 noundef undef)\n%4 = tail call i32 @tasklet_schedule(ptr noundef nonnull @rpcrdma_tasklet_g)\nret void\n}"}, "define internal i32 @tda8083_get_fec(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call i32 @tda8083_readreg(ptr noundef %4, i32 noundef 14)\n%6 = and i32 %5, 7\n%7 = sext i32 %6 to i64\nstore i64 %7, ptr %3, align 8\n%8 = load i64, ptr %3, align 8\n%9 = getelementptr inbounds [8 x i32], ptr @tda8083_get_fec.fec_tab, i64 0, i64 %8\n%10 = load i32, ptr %9, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %10\n}": {"base_truth": "define internal i32 @tda8083_get_fec(ptr noundef %0) {\nB:\n%1 = tail call i32 @tda8083_readreg(ptr noundef %0, i32 noundef 14)\n%2 = and i32 %1, 7\n%3 = zext i32 %2 to i64\n%4 = getelementptr inbounds [8 x i32], ptr @tda8083_get_fec.fec_tab, i64 0, i64 %3\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}", "codellama": "define internal i32 @tda8083_get_fec(ptr noundef %0) {\nB:\n%1 = tail call i32 @tda8083_readreg(ptr noundef %0, i32 noundef 14)\n%2 = and i32 %1, 7\n%3 = zext i32 %2 to i64\n%4 = getelementptr inbounds [8 x i32], ptr @tda8083_get_fec.fec_tab, i64 0, i64 %3\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}", "codegemma": "define internal i32 @tda8083_get_fec(ptr noundef %0) {\nB:\n%1 = tail call i32 @tda8083_readreg(ptr noundef %0, i32 noundef 14)\n%2 = and i32 %1, 7\n%3 = zext i32 %2 to i64\n%4 = getelementptr inbounds [8 x i32], ptr @tda8083_get_fec.fec_tab, i64 0, i64 %3\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}"}, "define dso_local void @rfftf(i32 noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore i32 %0, ptr %4, align 4\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load i32, ptr %4, align 4\n%8 = icmp eq i32 %7, 1\nbr i1 %8, label %9, label %10\n\n9:\nbr label %24\n\n10:\n%11 = load i32, ptr %4, align 4\n%12 = load ptr, ptr %5, align 8\n%13 = load ptr, ptr %6, align 8\n%14 = load ptr, ptr %6, align 8\n%15 = load i32, ptr %4, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds double, ptr %14, i64 %16\n%18 = load ptr, ptr %6, align 8\n%19 = load i32, ptr %4, align 4\n%20 = mul nsw i32 2, %19\n%21 = sext i32 %20 to i64\n%22 = getelementptr inbounds double, ptr %18, i64 %21\n%23 = call i32 @rfftf1(i32 noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %17, ptr noundef %22)\nbr label %24\n\n24:\nret void\n}": {"base_truth": "define dso_local void @rfftf(i32 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i32 %0, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = shl nsw i32 %0, 1\n%5 = sext i32 %4 to i64\n%6 = getelementptr inbounds double, ptr %2, i64 %5\n%7 = sext i32 %0 to i64\n%8 = getelementptr inbounds double, ptr %2, i64 %7\n%9 = tail call i32 @rfftf1(i32 noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %8, ptr noundef %6)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @rfftf(i32 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i32 %0, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = shl nsw i32 %0, 1\n%5 = sext i32 %4 to i64\n%6 = getelementptr inbounds double, ptr %2, i64 %5\n%7 = sext i32 %0 to i64\n%8 = getelementptr inbounds double, ptr %2, i64 %7\n%9 = tail call i32 @rfftf1(i32 noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %8, ptr noundef %6)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @rfftf(i32 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = icmp eq i32 %0, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = sext i32 %0 to i64\n%5 = getelementptr inbounds double, ptr %2, i64 %4\n%6 = sext i32 %0 to i64\n%7 = mul nsw i64 %6, 2\n%8 = getelementptr inbounds double, ptr %2, i64 %7\n%9 = tail call i32 @rfftf1(i32 noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %5, ptr noundef %8)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @luaO_int2fb(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\n%6 = load i32, ptr %3, align 4\n%7 = icmp slt i32 %6, 8\nbr i1 %7, label %8, label %10\n\n8:\n%9 = load i32, ptr %3, align 4\nstore i32 %9, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %27\n\n10:\nbr label %11\n\n11:\n%12 = load i32, ptr %3, align 4\n%13 = icmp sge i32 %12, 16\nbr i1 %13, label %14, label %20\n\n14:\n%15 = load i32, ptr %3, align 4\n%16 = add nsw i32 %15, 1\n%17 = ashr i32 %16, 1\nstore i32 %17, ptr %3, align 4\n%18 = load i32, ptr %4, align 4\n%19 = add nsw i32 %18, 1\nstore i32 %19, ptr %4, align 4\nbr label %11\n\n20:\n%21 = load i32, ptr %4, align 4\n%22 = add nsw i32 %21, 1\n%23 = shl i32 %22, 3\n%24 = load i32, ptr %3, align 4\n%25 = sub nsw i32 %24, 8\n%26 = or i32 %23, %25\nstore i32 %26, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %27\n\n27:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%28 = load i32, ptr %2, align 4\nret i32 %28\n}": {"base_truth": "define dso_local i32 @luaO_int2fb(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 8\nbr i1 %1, label %B5, label %B1\n\nB1:\n%2 = icmp ugt i32 %0, 15\nbr i1 %2, label %B2, label %B4\n\nB2:\n%3 = phi i32 [ %7, %B2 ], [ 0, %B1 ]\n%4 = phi i32 [ %6, %B2 ], [ %0, %B1 ]\n%5 = add nuw nsw i32 %4, 1\n%6 = lshr i32 %5, 1\n%7 = add nuw nsw i32 %3, 1\n%8 = icmp ugt i32 %4, 30\nbr i1 %8, label %B2, label %B3\n\nB3:\n%9 = shl i32 %7, 3\n%10 = add i32 %9, 8\nbr label %B4\n\nB4:\n%11 = phi i32 [ %0, %B1 ], [ %6, %B3 ]\n%12 = phi i32 [ 8, %B1 ], [ %10, %B3 ]\n%13 = add nsw i32 %11, -8\n%14 = or i32 %12, %13\nbr label %B5\n\nB5:\n%15 = phi i32 [ %14, %B4 ], [ %0, %B ]\nret i32 %15\n}", "codellama": "define dso_local i32 @luaO_int2fb(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 8\nbr i1 %1, label %B4, label %B1\n\nB1:\n%2 = icmp ugt i32 %0, 15\nbr i1 %2, label %B2, label %B3\n\nB2:\n%3 = phi i32 [ %6, %B2 ], [ 0, %B1 ]\n%4 = phi i32 [ %5, %B2 ], [ %0, %B1 ]\n%5 = add nuw nsw i32 %4, 1\n%6 = add nuw nsw i32 %3, 1\n%7 = icmp ugt i32 %5, 15\nbr i1 %7, label %B3, label %B2\n\nB3:\n%8 = phi i32 [ 0, %B1 ], [ %6, %B2 ]\n%9 = phi i32 [ %0, %B1 ], [ %5, %B2 ]\n%10 = add nuw nsw i32 %9, -8\n%11 = shl nuw nsw i32 %8, 3\n%12 = add nuw nsw i32 %11, 8\n%13 = or i32 %12, %10\nbr label %B4\n\nB4:\n%14 = phi i32 [ %13, %B3 ], [ %0, %B ]\nret i32 %14\n}", "codegemma": "define dso_local i32 @luaO_int2fb(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 8\nbr i1 %1, label %B4, label %B1\n\nB1:\n%2 = icmp sgt i32 %0, 15\nbr i1 %2, label %B2, label %B3\n\nB2:\n%3 = phi i32 [ %5, %B2 ], [ %0, %B1 ]\n%4 = phi i32 [ %6, %B2 ], [ 0, %B1 ]\n%5 = add nsw i32 %3, 1\n%6 = add nuw nsw i32 %4, 1\n%7 = icmp sgt i32 %3, 23\nbr i1 %7, label %B2, label %B3\n\nB3:\n%8 = add nuw nsw i32 %6, 24\n%9 = add nsw i32 %3, -8\n%10 = or i32 %8, %9\nbr label %B4\n\nB4:\n%11 = phi i32 [ %10, %B3 ], [ %0, %B ]\nret i32 %11\n}"}, "define internal i32 @auth_xfer_setup(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %8, label %11\n\n8:\n%9 = load ptr, ptr %5, align 8\n%10 = icmp ne ptr %9, null\nbr i1 %10, label %12, label %11\n\n11:\nstore i32 1, ptr %3, align 4\nbr label %19\n\n12:\n%13 = load ptr, ptr %4, align 8\n%14 = load ptr, ptr %5, align 8\n%15 = call i32 @xfr_find_soa(ptr noundef %13, ptr noundef %14)\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %18, label %17\n\n17:\nstore i32 1, ptr %3, align 4\nbr label %19\n\n18:\nstore i32 1, ptr %3, align 4\nbr label %19\n\n19:\n%20 = load i32, ptr %3, align 4\nret i32 %20\n}": {"base_truth": "define internal i32 @auth_xfer_setup(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @xfr_find_soa(ptr noundef nonnull %0, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret i32 1\n}", "codellama": "define internal i32 @auth_xfer_setup(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @xfr_find_soa(ptr noundef nonnull %0, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret i32 1\n}", "codegemma": "define internal i32 @auth_xfer_setup(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ne ptr %0, null\n%3 = icmp ne ptr %1, null\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @xfr_find_soa(ptr noundef nonnull %0, ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%6 = phi i32 [ 1, %B ], [ 1, %B1 ]\nret i32 %6\n}"}, "define dso_local void @optc2_lock_doublebuffer_disable(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @DCN10TG_FROM_TG(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%7 = load i32, ptr @MASTER_UPDATE_LOCK_DB_X, align 4\n%8 = load i32, ptr @MASTER_UPDATE_LOCK_DB_Y, align 4\n%9 = call i32 @REG_UPDATE_2(i32 noundef %6, i32 noundef %7, i32 noundef 0, i32 noundef %8, i32 noundef 0)\n%10 = load i32, ptr @OTG_GLOBAL_CONTROL2, align 4\n%11 = load i32, ptr @GLOBAL_UPDATE_LOCK_EN, align 4\n%12 = load i32, ptr @DIG_UPDATE_LOCATION, align 4\n%13 = call i32 @REG_UPDATE_2(i32 noundef %10, i32 noundef %11, i32 noundef 0, i32 noundef %12, i32 noundef 0)\n%14 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%15 = load i32, ptr @MASTER_UPDATE_LOCK_DB_EN, align 4\n%16 = call i32 @REG_UPDATE(i32 noundef %14, i32 noundef %15, i32 noundef 0)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @optc2_lock_doublebuffer_disable(ptr noundef %0) {\nB:\n%1 = tail call ptr @DCN10TG_FROM_TG(ptr noundef %0)\n%2 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%3 = load i32, ptr @MASTER_UPDATE_LOCK_DB_X, align 4\n%4 = load i32, ptr @MASTER_UPDATE_LOCK_DB_Y, align 4\n%5 = tail call i32 @REG_UPDATE_2(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %4, i32 noundef 0)\n%6 = load i32, ptr @OTG_GLOBAL_CONTROL2, align 4\n%7 = load i32, ptr @GLOBAL_UPDATE_LOCK_EN, align 4\n%8 = load i32, ptr @DIG_UPDATE_LOCATION, align 4\n%9 = tail call i32 @REG_UPDATE_2(i32 noundef %6, i32 noundef %7, i32 noundef 0, i32 noundef %8, i32 noundef 0)\n%10 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%11 = load i32, ptr @MASTER_UPDATE_LOCK_DB_EN, align 4\n%12 = tail call i32 @REG_UPDATE(i32 noundef %10, i32 noundef %11, i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @optc2_lock_doublebuffer_disable(ptr noundef %0) {\nB:\n%1 = tail call ptr @DCN10TG_FROM_TG(ptr noundef %0)\n%2 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%3 = load i32, ptr @MASTER_UPDATE_LOCK_DB_X, align 4\n%4 = load i32, ptr @MASTER_UPDATE_LOCK_DB_Y, align 4\n%5 = tail call i32 @REG_UPDATE_2(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %4, i32 noundef 0)\n%6 = load i32, ptr @OTG_GLOBAL_CONTROL2, align 4\n%7 = load i32, ptr @GLOBAL_UPDATE_LOCK_EN, align 4\n%8 = load i32, ptr @DIG_UPDATE_LOCATION, align 4\n%9 = tail call i32 @REG_UPDATE_2(i32 noundef %6, i32 noundef %7, i32 noundef 0, i32 noundef %8, i32 noundef 0)\n%10 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%11 = load i32, ptr @MASTER_UPDATE_LOCK_DB_EN, align 4\n%12 = tail call i32 @REG_UPDATE(i32 noundef %10, i32 noundef %11, i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @optc2_lock_doublebuffer_disable(ptr noundef %0) {\nB:\n%1 = tail call ptr @DCN10TG_FROM_TG(ptr noundef %0)\n%2 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%3 = load i32, ptr @MASTER_UPDATE_LOCK_DB_X, align 4\n%4 = load i32, ptr @MASTER_UPDATE_LOCK_DB_Y, align 4\n%5 = tail call i32 @REG_UPDATE_2(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %4, i32 noundef 0)\n%6 = load i32, ptr @OTG_GLOBAL_CONTROL2, align 4\n%7 = load i32, ptr @GLOBAL_UPDATE_LOCK_EN, align 4\n%8 = load i32, ptr @DIG_UPDATE_LOCATION, align 4\n%9 = tail call i32 @REG_UPDATE_2(i32 noundef %6, i32 noundef %7, i32 noundef 0, i32 noundef %8, i32 noundef 0)\n%10 = load i32, ptr @OTG_GLOBAL_CONTROL1, align 4\n%11 = load i32, ptr @MASTER_UPDATE_LOCK_DB_EN, align 4\n%12 = tail call i32 @REG_UPDATE(i32 noundef %10, i32 noundef %11, i32 noundef 0)\nret void\n}"}, "define internal i32 @synic_get_sint_vector(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @HV_SYNIC_SINT_MASKED, align 4\n%6 = and i32 %4, %5\n%7 = icmp ne i32 %6, 0\nbr i1 %7, label %8, label %9\n\n8:\nstore i32 -1, ptr %2, align 4\nbr label %13\n\n9:\n%10 = load i32, ptr %3, align 4\n%11 = load i32, ptr @HV_SYNIC_SINT_VECTOR_MASK, align 4\n%12 = and i32 %10, %11\nstore i32 %12, ptr %2, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %2, align 4\nret i32 %14\n}": {"base_truth": "define internal i32 @synic_get_sint_vector(i32 noundef %0) {\nB:\n%1 = load i32, ptr @HV_SYNIC_SINT_MASKED, align 4\n%2 = and i32 %1, %0\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @HV_SYNIC_SINT_VECTOR_MASK, align 4\n%5 = and i32 %4, %0\n%6 = select i1 %3, i32 %5, i32 -1\nret i32 %6\n}", "codellama": "define internal i32 @synic_get_sint_vector(i32 noundef %0) {\nB:\n%1 = load i32, ptr @HV_SYNIC_SINT_MASKED, align 4\n%2 = and i32 %1, %0\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @HV_SYNIC_SINT_VECTOR_MASK, align 4\n%5 = and i32 %4, %0\n%6 = select i1 %3, i32 %5, i32 -1\nret i32 %6\n}", "codegemma": "define internal i32 @synic_get_sint_vector(i32 noundef %0) {\nB:\n%1 = load i32, ptr @HV_SYNIC_SINT_MASKED, align 4\n%2 = and i32 %1, %0\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @HV_SYNIC_SINT_VECTOR_MASK, align 4\n%5 = and i32 %4, %0\n%6 = select i1 %3, i32 %5, i32 -1\nret i32 %6\n}"}, "define internal void @_ff_layout_free_lseg(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %5, label %10\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = call i32 @ff_layout_free_mirror_array(ptr noundef %6)\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @kfree(ptr noundef %8)\nbr label %10\n\n10:\nret void\n}": {"base_truth": "define internal void @_ff_layout_free_lseg(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @ff_layout_free_mirror_array(ptr noundef nonnull %0)\n%3 = tail call i32 @kfree(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @_ff_layout_free_lseg(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @ff_layout_free_mirror_array(ptr noundef nonnull %0)\n%3 = tail call i32 @kfree(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @_ff_layout_free_lseg(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @ff_layout_free_mirror_array(ptr noundef nonnull %0)\n%3 = tail call i32 @kfree(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @CurrentNext(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\nret i32 2\n}": {"base_truth": "define dso_local i32 @CurrentNext(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\nret i32 2\n}", "codellama": "define dso_local i32 @CurrentNext(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\nret i32 2\n}", "codegemma": "define dso_local i32 @CurrentNext(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\nret i32 2\n}"}, "define dso_local void @_Lazy_glSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5) {\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\n%12 = alloca i32, align 4\nstore i32 %0, ptr %7, align 4\nstore i32 %1, ptr %8, align 4\nstore i32 %2, ptr %9, align 4\nstore i32 %3, ptr %10, align 4\nstore i32 %4, ptr %11, align 4\nstore i32 %5, ptr %12, align 4\n%13 = call i64 (...) @GLeeInit()\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %23\n\n15:\n%16 = load i32, ptr %7, align 4\n%17 = load i32, ptr %8, align 4\n%18 = load i32, ptr %9, align 4\n%19 = load i32, ptr %10, align 4\n%20 = load i32, ptr %11, align 4\n%21 = load i32, ptr %12, align 4\n%22 = call i32 @pglSwizzleEXT(i32 noundef %16, i32 noundef %17, i32 noundef %18, i32 noundef %19, i32 noundef %20, i32 noundef %21)\nbr label %23\n\n23:\nret void\n}": {"base_truth": "define dso_local void @_Lazy_glSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5) {\nB:\n%6 = tail call i64 (...) @GLeeInit()\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = tail call i32 @pglSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @_Lazy_glSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5) {\nB:\n%6 = tail call i64 (...) @GLeeInit()\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = tail call i32 @pglSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @_Lazy_glSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5) {\nB:\n%6 = tail call i64 (...) @GLeeInit()\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = tail call i32 @pglSwizzleEXT(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i64 @zmalloc_used_memory() {\n%1 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i64, ptr @used_memory, align 8\nstore i64 %2, ptr %1, align 8\n%3 = load i64, ptr %1, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i64 %3\n}": {"base_truth": "define dso_local i64 @zmalloc_used_memory() {\nB:\n%0 = load i64, ptr @used_memory, align 8\nret i64 %0\n}", "codellama": "define dso_local i64 @zmalloc_used_memory() {\nB:\n%0 = load i64, ptr @used_memory, align 8\nret i64 %0\n}", "codegemma": "define dso_local i64 @zmalloc_used_memory() {\nB:\n%0 = load i64, ptr @used_memory, align 8\nret i64 %0\n}"}, "define internal void @rw_lock(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\n%7 = load i32, ptr %4, align 4\n%8 = icmp ne i32 %7, 0\nbr i1 %8, label %9, label %15\n\n9:\n%10 = load ptr, ptr %5, align 8\n%11 = getelementptr inbounds %struct.btree ptr %10, i32 0, i32 1\n%12 = load i32, ptr %6, align 4\n%13 = add nsw i32 %12, 1\n%14 = call i32 @down_write_nested(ptr noundef %11, i32 noundef %13)\nbr label %21\n\n15:\n%16 = load ptr, ptr %5, align 8\n%17 = getelementptr inbounds %struct.btree ptr %16, i32 0, i32 1\n%18 = load i32, ptr %6, align 4\n%19 = add nsw i32 %18, 1\n%20 = call i32 @down_read_nested(ptr noundef %17, i32 noundef %19)\nbr label %21\n\n21:\n%22 = phi i32 [ %14, %9 ], [ %20, %15 ]\n%23 = load i32, ptr %4, align 4\n%24 = icmp ne i32 %23, 0\nbr i1 %24, label %25, label %30\n\n25:\n%26 = load ptr, ptr %5, align 8\n%27 = getelementptr inbounds %struct.btree ptr %26, i32 0, i32 0\n%28 = load i32, ptr %27, align 4\n%29 = add nsw i32 %28, 1\nstore i32 %29, ptr %27, align 4\nbr label %30\n\n30:\nret void\n}": {"base_truth": "define internal void @rw_lock(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = icmp eq i32 %0, 0\n%4 = getelementptr inbounds %struct.btree, ptr %1, i64 0, i32 1\n%5 = add nsw i32 %2, 1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @down_read_nested(ptr noundef nonnull %4, i32 noundef %5)\nbr label %B3\n\nB2:\n%7 = tail call i32 @down_write_nested(ptr noundef nonnull %4, i32 noundef %5)\n%8 = load i32, ptr %1, align 4\n%9 = add nsw i32 %8, 1\nstore i32 %9, ptr %1, align 4\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @rw_lock(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = icmp eq i32 %0, 0\n%4 = getelementptr inbounds %struct.btree, ptr %1, i64 0, i32 1\n%5 = add nsw i32 %2, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @down_write_nested(ptr noundef nonnull %4, i32 noundef %5)\nbr label %B3\n\nB2:\n%7 = tail call i32 @down_read_nested(ptr noundef nonnull %4, i32 noundef %5)\nbr label %B3\n\nB3:\n%8 = phi i32 [ %6, %B1 ], [ %7, %B2 ]\n%9 = load i32, ptr %1, align 4\n%10 = add nsw i32 %9, 1\n%11 = select i1 %3, i32 0, i32 %10\nstore i32 %11, ptr %1, align 4\nret void\n}", "codegemma": "define internal void @rw_lock(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = icmp eq i32 %0, 0\n%4 = getelementptr inbounds %struct.btree, ptr %1, i64 0, i32 1\n%5 = add nsw i32 %2, 1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @down_write_nested(ptr noundef nonnull %4, i32 noundef %5)\nbr label %B3\n\nB2:\n%7 = tail call i32 @down_read_nested(ptr noundef nonnull %4, i32 noundef %5)\nbr label %B3\n\nB3:\n%8 = phi i32 [ %6, %B1 ], [ %7, %B2 ]\n%9 = load i32, ptr %1, align 4\n%10 = add nsw i32 %9, 1\nstore i32 %10, ptr %1, align 4\nret void\n}"}, "define dso_local i32 @glk_schannel_create(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\nret i32 0\n}": {"base_truth": "define dso_local i32 @glk_schannel_create(i32 noundef %0) {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @glk_schannel_create(i32 noundef %0) {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @glk_schannel_create(i32 noundef %0) {\nB:\nret i32 0\n}"}, "define dso_local void @TimerIntUnregister(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %3, align 8\n%6 = call i32 @TimerBaseValid(i64 noundef %5)\n%7 = call i32 @ASSERT(i32 noundef %6)\n%8 = load i64, ptr %4, align 8\n%9 = load i64, ptr @TIMER_A, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %19, label %11\n\n11:\n%12 = load i64, ptr %4, align 8\n%13 = load i64, ptr @TIMER_B, align 8\n%14 = icmp eq i64 %12, %13\nbr i1 %14, label %19, label %15\n\n15:\n%16 = load i64, ptr %4, align 8\n%17 = load i64, ptr @TIMER_BOTH, align 8\n%18 = icmp eq i64 %16, %17\nbr label %19\n\n19:\n%20 = phi i1 [ true, %11 ], [ true, %2 ], [ %18, %15 ]\n%21 = zext i1 %20 to i32\n%22 = call i32 @ASSERT(i32 noundef %21)\n%23 = load i64, ptr %3, align 8\n%24 = load i64, ptr @TIMERA0_BASE, align 8\n%25 = icmp eq i64 %23, %24\nbr i1 %25, label %26, label %28\n\n26:\n%27 = load i64, ptr @INT_TIMERA0A, align 8\nbr label %46\n\n28:\n%29 = load i64, ptr %3, align 8\n%30 = load i64, ptr @TIMERA1_BASE, align 8\n%31 = icmp eq i64 %29, %30\nbr i1 %31, label %32, label %34\n\n32:\n%33 = load i64, ptr @INT_TIMERA1A, align 8\nbr label %44\n\n34:\n%35 = load i64, ptr %3, align 8\n%36 = load i64, ptr @TIMERA2_BASE, align 8\n%37 = icmp eq i64 %35, %36\nbr i1 %37, label %38, label %40\n\n38:\n%39 = load i64, ptr @INT_TIMERA2A, align 8\nbr label %42\n\n40:\n%41 = load i64, ptr @INT_TIMERA3A, align 8\nbr label %42\n\n42:\n%43 = phi i64 [ %39, %38 ], [ %41, %40 ]\nbr label %44\n\n44:\n%45 = phi i64 [ %33, %32 ], [ %43, %42 ]\nbr label %46\n\n46:\n%47 = phi i64 [ %27, %26 ], [ %45, %44 ]\nstore i64 %47, ptr %3, align 8\n%48 = load i64, ptr %4, align 8\n%49 = load i64, ptr @TIMER_A, align 8\n%50 = and i64 %48, %49\n%51 = icmp ne i64 %50, 0\nbr i1 %51, label %52, label %57\n\n52:\n%53 = load i64, ptr %3, align 8\n%54 = call i32 @IntDisable(i64 noundef %53)\n%55 = load i64, ptr %3, align 8\n%56 = call i32 @IntUnregister(i64 noundef %55)\nbr label %57\n\n57:\n%58 = load i64, ptr %4, align 8\n%59 = load i64, ptr @TIMER_B, align 8\n%60 = and i64 %58, %59\n%61 = icmp ne i64 %60, 0\nbr i1 %61, label %62, label %69\n\n62:\n%63 = load i64, ptr %3, align 8\n%64 = add i64 %63, 1\n%65 = call i32 @IntDisable(i64 noundef %64)\n%66 = load i64, ptr %3, align 8\n%67 = add i64 %66, 1\n%68 = call i32 @IntUnregister(i64 noundef %67)\nbr label %69\n\n69:\nret void\n}": {"base_truth": "define dso_local void @TimerIntUnregister(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i32 @TimerBaseValid(i64 noundef %0)\n%3 = tail call i32 @ASSERT(i32 noundef %2)\n%4 = load i64, ptr @TIMER_A, align 8\n%5 = icmp eq i64 %4, %1\n%6 = load i64, ptr @TIMER_B, align 8\n%7 = icmp eq i64 %6, %1\n%8 = select i1 %5, i1 true, i1 %7\n%9 = load i64, ptr @TIMER_BOTH, align 8\n%10 = icmp eq i64 %9, %1\n%11 = select i1 %8, i1 true, i1 %10\n%12 = zext i1 %11 to i32\n%13 = tail call i32 @ASSERT(i32 noundef %12)\n%14 = load i64, ptr @TIMERA0_BASE, align 8\n%15 = icmp eq i64 %14, %0\nbr i1 %15, label %B1, label %B2\n\nB1:\n%16 = load i64, ptr @INT_TIMERA0A, align 8\nbr label %B5\n\nB2:\n%17 = load i64, ptr @TIMERA1_BASE, align 8\n%18 = icmp eq i64 %17, %0\nbr i1 %18, label %B3, label %B4\n\nB3:\n%19 = load i64, ptr @INT_TIMERA1A, align 8\nbr label %B5\n\nB4:\n%20 = load i64, ptr @TIMERA2_BASE, align 8\n%21 = icmp eq i64 %20, %0\n%22 = load i64, ptr @INT_TIMERA2A, align 8\n%23 = load i64, ptr @INT_TIMERA3A, align 8\n%24 = select i1 %21, i64 %22, i64 %23\nbr label %B5\n\nB5:\n%25 = phi i64 [ %16, %B1 ], [ %19, %B3 ], [ %24, %B4 ]\n%26 = load i64, ptr @TIMER_A, align 8\n%27 = and i64 %26, %1\n%28 = icmp eq i64 %27, 0\nbr i1 %28, label %B7, label %B6\n\nB6:\n%29 = tail call i32 @IntDisable(i64 noundef %25)\n%30 = tail call i32 @IntUnregister(i64 noundef %25)\nbr label %B7\n\nB7:\n%31 = load i64, ptr @TIMER_B, align 8\n%32 = and i64 %31, %1\n%33 = icmp eq i64 %32, 0\nbr i1 %33, label %B9, label %B8\n\nB8:\n%34 = add i64 %25, 1\n%35 = tail call i32 @IntDisable(i64 noundef %34)\n%36 = tail call i32 @IntUnregister(i64 noundef %34)\nbr label %B9\n\nB9:\nret void\n}", "codellama": "define dso_local void @TimerIntUnregister(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i32 @TimerBaseValid(i64 noundef %0)\n%3 = tail call i32 @ASSERT(i32 noundef %2)\n%4 = load i64, ptr @TIMER_A, align 8\n%5 = icmp eq i64 %4, %1\n%6 = load i64, ptr @TIMER_B, align 8\n%7 = icmp eq i64 %6, %1\n%8 = select i1 %5, i1 true, i1 %7\n%9 = load i64, ptr @TIMER_BOTH, align 8\n%10 = icmp eq i64 %9, %1\n%11 = select i1 %8, i1 true, i1 %10\n%12 = zext i1 %11 to i32\n%13 = tail call i32 @ASSERT(i32 noundef %12)\n%14 = load i64, ptr @TIMERA0_BASE, align 8\n%15 = icmp eq i64 %14, %0\nbr i1 %15, label %B2, label %B1\n\nB1:\n%16 = load i64, ptr @TIMERA1_BASE, align 8\n%17 = icmp eq i64 %16, %0\n%18 = load i64, ptr @TIMERA2_BASE, align 8\n%19 = icmp eq i64 %18, %0\n%20 = load i64, ptr @INT_TIMERA1A, align 8\n%21 = load i64, ptr @INT_TIMERA2A, align 8\n%22 = load i64, ptr @INT_TIMERA3A, align 8\n%23 = select i1 %19, i64 %21, i64 %22\n%24 = select i1 %17, i64 %20, i64 %23\n%25 = select i1 %18, i64 %16, i64 %0\n%26 = select i1 %19, i64 %16, i64 %0\nbr label %B2\n\nB2:\n%27 = phi i64 [ %14, %B ], [ %25, %B1 ]\n%28 = phi i64 [ %1, %B ], [ %24, %B1 ]\n%29 = phi i64 [ %0, %B ], [ %26, %B1 ]\n%30 = icmp eq i64 %28, %4\n%31 = icmp eq i64 %28, %6\n%32 = select i1 %30, i1 true, i1 %31\nbr i1 %32, label %B3, label %B4\n\nB3:\n%33 = tail call i32 @IntDisable(i64 noundef %29)\n%34 = tail call i32 @IntUnregister(i64 noundef %29)\nbr label %B4\n\nB4:\nbr i1 %31, label %B5, label %B6\n\nB5:\n%35 = add i64 %29, 1\n%36 = tail call i32 @IntDisable(i64 noundef %35)\n%37 = tail call i32 @IntUnregister(i64 noundef %35)\nbr label %B6\n\nB6:\nret void\n}", "codegemma": "define dso_local void @TimerIntUnregister(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i32 @TimerBaseValid(i64 noundef %0)\n%3 = tail call i32 @ASSERT(i32 noundef %2)\n%4 = load i64, ptr @TIMER_A, align 8\n%5 = icmp eq i64 %4, %1\n%6 = load i64, ptr @TIMER_B, align 8\n%7 = icmp eq i64 %6, %1\n%8 = select i1 %5, i1 true, i1 %7\n%9 = load i64, ptr @TIMER_BOTH, align 8\n%10 = icmp eq i64 %9, %1\n%11 = select i1 %8, i1 true, i1 %10\n%12 = zext i1 %11 to i32\n%13 = tail call i32 @ASSERT(i32 noundef %12)\n%14 = load i64, ptr @TIMERA0_BASE, align 8\n%15 = icmp eq i64 %14, %0\nbr i1 %15, label %B1, label %B2\n\nB1:\n%16 = load i64, ptr @INT_TIMERA0A, align 8\nbr label %B3\n\nB2:\n%17 = load i64, ptr @TIMERA1_BASE, align 8\n%18 = icmp eq i64 %17, %0\n%19 = load i64, ptr @INT_TIMERA1A, align 8\n%20 = load i64, ptr @TIMERA2_BASE, align 8\n%21 = icmp eq i64 %20, %0\n%22 = load i64, ptr @INT_TIMERA2A, align 8\n%23 = load i64, ptr @INT_TIMERA3A, align 8\n%24 = select i1 %21, i64 %22, i64 %23\n%25 = select i1 %18, i64 %19, i64 %24\nbr label %B3\n\nB3:\n%26 = phi i64 [ %16, %B1 ], [ %25, %B2 ]\n%27 = and i64 %26, %1\n%28 = icmp eq i64 %27, 0\nbr i1 %28, label %B5, label %B4\n\nB4:\n%29 = tail call i32 @IntDisable(i64 noundef %26)\n%30 = tail call i32 @IntUnregister(i64 noundef %26)\nbr label %B5\n\nB5:\n%31 = load i64, ptr @TIMER_B, align 8\n%32 = and i64 %31, %1\n%33 = icmp eq i64 %32, 0\nbr i1 %33, label %B7, label %B6\n\nB6:\n%34 = add i64 %26, 1\n%35 = tail call i32 @IntDisable(i64 noundef %34)\n%36 = tail call i32 @IntUnregister(i64 noundef %34)\nbr label %B7\n\nB7:\nret void\n}"}, "define dso_local i32 @specialVertexCheck(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore i32 %0, ptr %4, align 4\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr @gCurRecord, align 8\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i32 0, i32 0\n%8 = load double, ptr %7, align 8\n%9 = fcmp fast olt double %8, 1.000000e-10\nbr i1 %9, label %10, label %22\n\n10:\n%11 = load i32, ptr %4, align 4\n%12 = load ptr, ptr %5, align 8\n%13 = load i64, ptr @gNumVariables, align 8\n%14 = sub nsw i64 %13, 1\n%15 = call i64 @LP_getx(i32 noundef %11, ptr noundef %12, i32 noundef 0, i64 noundef %14)\n%16 = icmp ne i64 %15, 0\nbr i1 %16, label %17, label %21\n\n17:\n%18 = load i32, ptr @gStdErrFile, align 4\n%19 = call i32 @fprintf(i32 noundef %18, ptr noundef @.str)\n%20 = call i32 @exit(i32 noundef -1)\nunreachable\n\n21:\nstore i32 1, ptr %3, align 4\nbr label %23\n\n22:\nstore i32 0, ptr %3, align 4\nbr label %23\n\n23:\n%24 = load i32, ptr %3, align 4\nret i32 %24\n}": {"base_truth": "define dso_local i32 @specialVertexCheck(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = load ptr, ptr @gCurRecord, align 8\n%3 = load double, ptr %2, align 8\n%4 = fcmp fast olt double %3, 1.000000e-10\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i64, ptr @gNumVariables, align 8\n%6 = add nsw i64 %5, -1\n%7 = tail call i64 @LP_getx(i32 noundef %0, ptr noundef %1, i32 noundef 0, i64 noundef %6)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = load i32, ptr @gStdErrFile, align 4\n%10 = tail call i32 @fprintf(i32 noundef %9, ptr noundef nonnull @.str)\n%11 = tail call i32 @exit(i32 noundef -1)\nunreachable\n\nB3:\n%12 = phi i32 [ 1, %B1 ], [ 0, %B ]\nret i32 %12\n}", "codellama": "define dso_local i32 @specialVertexCheck(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = load ptr, ptr @gCurRecord, align 8\n%3 = load double, ptr %2, align 8\n%4 = fcmp fast olt double %3, 1.000000e-10\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i64, ptr @gNumVariables, align 8\n%6 = add nsw i64 %5, -1\n%7 = tail call i64 @LP_getx(i32 noundef %0, ptr noundef %1, i32 noundef 0, i64 noundef %6)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = load i32, ptr @gStdErrFile, align 4\n%10 = tail call i32 @fprintf(i32 noundef %9, ptr noundef nonnull @.str)\n%11 = tail call i32 @exit(i32 noundef -1)\nunreachable\n\nB3:\n%12 = phi i32 [ 1, %B1 ], [ 0, %B ]\nret i32 %12\n}", "codegemma": "define dso_local i32 @specialVertexCheck(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = load ptr, ptr @gCurRecord, align 8\n%3 = load double, ptr %2, align 8\n%4 = fcmp fast olt double %3, 1.000000e-10\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i64, ptr @gNumVariables, align 8\n%6 = add nsw i64 %5, -1\n%7 = tail call i64 @LP_getx(i32 noundef %0, ptr noundef %1, i32 noundef 0, i64 noundef %6)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = load i32, ptr @gStdErrFile, align 4\n%10 = tail call i32 @fprintf(i32 noundef %9, ptr noundef nonnull @.str)\n%11 = tail call i32 @exit(i32 noundef -1)\nunreachable\n\nB3:\n%12 = phi i32 [ -1, %B2 ], [ 1, %B1 ], [ 0, %B ]\nret i32 %12\n}"}, "define dso_local void @rct_set_usb_clk() {\n%1 = load i32, ptr @HAL_BASE_VP, align 4\n%2 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%3 = call i64 @amb_set_usb_port1_clock_source(i32 noundef %1, i32 noundef %2)\n%4 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%5 = icmp ne i64 %3, %4\nbr i1 %5, label %6, label %8\n\n6:\n%7 = call i32 @printk(ptr noundef @.str)\nbr label %8\n\n8:\n%9 = load i32, ptr @HAL_BASE_VP, align 4\n%10 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%11 = call i64 @amb_set_usb_port0_clock_source(i32 noundef %9, i32 noundef %10)\n%12 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%13 = icmp ne i64 %11, %12\nbr i1 %13, label %14, label %16\n\n14:\n%15 = call i32 @printk(ptr noundef @.str.1)\nbr label %16\n\n16:\nret void\n}": {"base_truth": "define dso_local void @rct_set_usb_clk() {\nB:\n%0 = load i32, ptr @HAL_BASE_VP, align 4\n%1 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%2 = tail call i64 @amb_set_usb_port1_clock_source(i32 noundef %0, i32 noundef %1)\n%3 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @printk(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%6 = load i32, ptr @HAL_BASE_VP, align 4\n%7 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%8 = tail call i64 @amb_set_usb_port0_clock_source(i32 noundef %6, i32 noundef %7)\n%9 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @printk(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @rct_set_usb_clk() {\nB:\n%0 = load i32, ptr @HAL_BASE_VP, align 4\n%1 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%2 = tail call i64 @amb_set_usb_port1_clock_source(i32 noundef %0, i32 noundef %1)\n%3 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @printk(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%6 = load i32, ptr @HAL_BASE_VP, align 4\n%7 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%8 = tail call i64 @amb_set_usb_port0_clock_source(i32 noundef %6, i32 noundef %7)\n%9 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @printk(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @rct_set_usb_clk() {\nB:\n%0 = load i32, ptr @HAL_BASE_VP, align 4\n%1 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%2 = tail call i64 @amb_set_usb_port1_clock_source(i32 noundef %0, i32 noundef %1)\n%3 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @printk(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%6 = load i32, ptr @HAL_BASE_VP, align 4\n%7 = load i32, ptr @AMB_USB_CLK_CORE_48MHZ, align 4\n%8 = tail call i64 @amb_set_usb_port0_clock_source(i32 noundef %6, i32 noundef %7)\n%9 = load i64, ptr @AMB_HAL_SUCCESS, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = tail call i32 @printk(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\nret void\n}"}, "define dso_local void @conversation_window_clear(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @conversation_window_clear(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @conversation_window_clear(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @conversation_window_clear(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define dso_local void @test_logic() {\n%1 = load i32, ptr @m1, align 4\n%2 = load i32, ptr @m2, align 4\n%3 = call i32 @_mm_or_ps(i32 noundef %1, i32 noundef %2)\nstore i32 %3, ptr @res, align 4\n%4 = load i32, ptr @m1, align 4\n%5 = load i32, ptr @m2, align 4\n%6 = call i32 @_mm_and_ps(i32 noundef %4, i32 noundef %5)\nstore i32 %6, ptr @res, align 4\n%7 = load i32, ptr @m1, align 4\n%8 = load i32, ptr @m2, align 4\n%9 = call i32 @_mm_andnot_ps(i32 noundef %7, i32 noundef %8)\nstore i32 %9, ptr @res, align 4\n%10 = load i32, ptr @m1, align 4\n%11 = load i32, ptr @m2, align 4\n%12 = call i32 @_mm_xor_ps(i32 noundef %10, i32 noundef %11)\nstore i32 %12, ptr @res, align 4\nret void\n}": {"base_truth": "define dso_local void @test_logic() {\nB:\n%0 = load i32, ptr @m1, align 4\n%1 = load i32, ptr @m2, align 4\n%2 = tail call i32 @_mm_or_ps(i32 noundef %0, i32 noundef %1)\nstore i32 %2, ptr @res, align 4\n%3 = load i32, ptr @m1, align 4\n%4 = load i32, ptr @m2, align 4\n%5 = tail call i32 @_mm_and_ps(i32 noundef %3, i32 noundef %4)\nstore i32 %5, ptr @res, align 4\n%6 = load i32, ptr @m1, align 4\n%7 = load i32, ptr @m2, align 4\n%8 = tail call i32 @_mm_andnot_ps(i32 noundef %6, i32 noundef %7)\nstore i32 %8, ptr @res, align 4\n%9 = load i32, ptr @m1, align 4\n%10 = load i32, ptr @m2, align 4\n%11 = tail call i32 @_mm_xor_ps(i32 noundef %9, i32 noundef %10)\nstore i32 %11, ptr @res, align 4\nret void\n}", "codellama": "define dso_local void @test_logic() {\nB:\n%0 = load i32, ptr @m1, align 4\n%1 = load i32, ptr @m2, align 4\n%2 = tail call i32 @_mm_or_ps(i32 noundef %0, i32 noundef %1)\nstore i32 %2, ptr @res, align 4\n%3 = load i32, ptr @m1, align 4\n%4 = load i32, ptr @m2, align 4\n%5 = tail call i32 @_mm_and_ps(i32 noundef %3, i32 noundef %4)\nstore i32 %5, ptr @res, align 4\n%6 = load i32, ptr @m1, align 4\n%7 = load i32, ptr @m2, align 4\n%8 = tail call i32 @_mm_andnot_ps(i32 noundef %6, i32 noundef %7)\nstore i32 %8, ptr @res, align 4\n%9 = load i32, ptr @m1, align 4\n%10 = load i32, ptr @m2, align 4\n%11 = tail call i32 @_mm_xor_ps(i32 noundef %9, i32 noundef %10)\nstore i32 %11, ptr @res, align 4\nret void\n}", "codegemma": "define dso_local void @test_logic() {\nB:\n%0 = load i32, ptr @m1, align 4\n%1 = load i32, ptr @m2, align 4\n%2 = tail call i32 @_mm_or_ps(i32 noundef %0, i32 noundef %1)\nstore i32 %2, ptr @res, align 4\n%3 = load i32, ptr @m1, align 4\n%4 = load i32, ptr @m2, align 4\n%5 = tail call i32 @_mm_and_ps(i32 noundef %3, i32 noundef %4)\nstore i32 %5, ptr @res, align 4\n%6 = load i32, ptr @m1, align 4\n%7 = load i32, ptr @m2, align 4\n%8 = tail call i32 @_mm_andnot_ps(i32 noundef %6, i32 noundef %7)\nstore i32 %8, ptr @res, align 4\n%9 = load i32, ptr @m1, align 4\n%10 = load i32, ptr @m2, align 4\n%11 = tail call i32 @_mm_xor_ps(i32 noundef %9, i32 noundef %10)\nstore i32 %11, ptr @res, align 4\nret void\n}"}, "define dso_local i32 @mapIndexPoint(i32 %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca %struct.TYPE_3__, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 0\nstore i32 %0, ptr %8, align 4\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%9 = load i32, ptr %5, align 4\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = mul nsw i32 %9, %11\n%13 = load i32, ptr %6, align 4\n%14 = add nsw i32 %12, %13\nstore i32 %14, ptr %7, align 4\n%15 = load i32, ptr %7, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret i32 %15\n}": {"base_truth": "define dso_local i32 @mapIndexPoint(i32 %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = mul nsw i32 %1, %0\n%4 = add nsw i32 %3, %2\nret i32 %4\n}", "codellama": "define dso_local i32 @mapIndexPoint(i32 %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = mul nsw i32 %1, %0\n%4 = add nsw i32 %3, %2\nret i32 %4\n}", "codegemma": "define dso_local i32 @mapIndexPoint(i32 %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = mul nsw i32 %1, %0\n%4 = add nsw i32 %3, %2\nret i32 %4\n}"}, "define internal i32 @fts5ApiRowid(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @fts5CursorRowid(ptr noundef %3)\nret i32 %4\n}": {"base_truth": "define internal i32 @fts5ApiRowid(ptr noundef %0) {\nB:\n%1 = tail call i32 @fts5CursorRowid(ptr noundef %0)\nret i32 %1\n}", "codellama": "define internal i32 @fts5ApiRowid(ptr noundef %0) {\nB:\n%1 = tail call i32 @fts5CursorRowid(ptr noundef %0)\nret i32 %1\n}", "codegemma": "define internal i32 @fts5ApiRowid(ptr noundef %0) {\nB:\n%1 = tail call i32 @fts5CursorRowid(ptr noundef %0)\nret i32 %1\n}"}, "define internal void @tipc_net_finalize(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @tipc_net(ptr noundef %7)\nstore ptr %8, ptr %5, align 8\n%9 = load ptr, ptr %5, align 8\n%10 = getelementptr inbounds %struct.tipc_net ptr %9, i32 0, i32 0\n%11 = load i32, ptr %4, align 4\n%12 = call i64 @cmpxchg(ptr noundef %10, i32 noundef 0, i32 noundef %11)\n%13 = icmp ne i64 %12, 0\nbr i1 %13, label %14, label %15\n\n14:\nstore i32 1, ptr %6, align 4\nbr label %30\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = load i32, ptr %4, align 4\n%18 = call i32 @tipc_set_node_addr(ptr noundef %16, i32 noundef %17)\n%19 = load ptr, ptr %3, align 8\n%20 = call i32 @tipc_named_reinit(ptr noundef %19)\n%21 = load ptr, ptr %3, align 8\n%22 = call i32 @tipc_sk_reinit(ptr noundef %21)\n%23 = load ptr, ptr %3, align 8\n%24 = load i32, ptr @TIPC_CFG_SRV, align 4\n%25 = load i32, ptr %4, align 4\n%26 = load i32, ptr %4, align 4\n%27 = load i32, ptr @TIPC_CLUSTER_SCOPE, align 4\n%28 = load i32, ptr %4, align 4\n%29 = call i32 @tipc_nametbl_publish(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef 0, i32 noundef %28)\nstore i32 0, ptr %6, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\n%31 = load i32, ptr %6, align 4\nswitch i32 %31, label %33 [\ni32 0, label %32\ni32 1, label %32\n]\n\n32:\nret void\n\n33:\nunreachable\n}": {"base_truth": "define internal void @tipc_net_finalize(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @tipc_net(ptr noundef %0)\n%3 = tail call i64 @cmpxchg(ptr noundef %2, i32 noundef 0, i32 noundef %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @tipc_set_node_addr(ptr noundef %0, i32 noundef %1)\n%6 = tail call i32 @tipc_named_reinit(ptr noundef %0)\n%7 = tail call i32 @tipc_sk_reinit(ptr noundef %0)\n%8 = load i32, ptr @TIPC_CFG_SRV, align 4\n%9 = load i32, ptr @TIPC_CLUSTER_SCOPE, align 4\n%10 = tail call i32 @tipc_nametbl_publish(ptr noundef %0, i32 noundef %8, i32 noundef %1, i32 noundef %1, i32 noundef %9, i32 noundef 0, i32 noundef %1)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @tipc_net_finalize(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @tipc_net(ptr noundef %0)\n%3 = tail call i64 @cmpxchg(ptr noundef %2, i32 noundef 0, i32 noundef %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @tipc_set_node_addr(ptr noundef %0, i32 noundef %1)\n%6 = tail call i32 @tipc_named_reinit(ptr noundef %0)\n%7 = tail call i32 @tipc_sk_reinit(ptr noundef %0)\n%8 = load i32, ptr @TIPC_CFG_SRV, align 4\n%9 = load i32, ptr @TIPC_CLUSTER_SCOPE, align 4\n%10 = tail call i32 @tipc_nametbl_publish(ptr noundef %0, i32 noundef %8, i32 noundef %1, i32 noundef %1, i32 noundef %9, i32 noundef 0, i32 noundef %1)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @tipc_net_finalize(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @tipc_net(ptr noundef %0)\n%3 = tail call i64 @cmpxchg(ptr noundef %2, i32 noundef 0, i32 noundef %1)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @tipc_set_node_addr(ptr noundef %0, i32 noundef %1)\n%6 = tail call i32 @tipc_named_reinit(ptr noundef %0)\n%7 = tail call i32 @tipc_sk_reinit(ptr noundef %0)\n%8 = load i32, ptr @TIPC_CFG_SRV, align 4\n%9 = load i32, ptr @TIPC_CLUSTER_SCOPE, align 4\n%10 = tail call i32 @tipc_nametbl_publish(ptr noundef %0, i32 noundef %8, i32 noundef %1, i32 noundef %1, i32 noundef %9, i32 noundef 0, i32 noundef %1)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local ptr @netRecieveLongString(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load i32, ptr %2, align 4\n%5 = call ptr @netGetLongString(i32 noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %8, label %10\n\n8:\n%9 = call i32 (...) @noWarnAbort()\nbr label %10\n\n10:\n%11 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %11\n}": {"base_truth": "define dso_local ptr @netRecieveLongString(i32 noundef %0) {\nB:\n%1 = tail call ptr @netGetLongString(i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 (...) @noWarnAbort()\nbr label %B2\n\nB2:\nret ptr %1\n}", "codellama": "define dso_local ptr @netRecieveLongString(i32 noundef %0) {\nB:\n%1 = tail call ptr @netGetLongString(i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 (...) @noWarnAbort()\nbr label %B2\n\nB2:\nret ptr %1\n}", "codegemma": "define dso_local ptr @netRecieveLongString(i32 noundef %0) {\nB:\n%1 = tail call ptr @netGetLongString(i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 (...) @noWarnAbort()\nbr label %B2\n\nB2:\nret ptr %1\n}"}, "define dso_local void @ReleaseListener(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %15\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_4__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i64 @Release(i32 noundef %9)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %12, label %15\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = call i32 @CleanupListener(ptr noundef %13)\nbr label %15\n\n15:\nret void\n}": {"base_truth": "define dso_local void @ReleaseListener(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @Release(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @CleanupListener(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @ReleaseListener(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @Release(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @CleanupListener(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @ReleaseListener(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @Release(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @CleanupListener(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\nret void\n}"}, "define internal i32 @whc_std_last(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.whc_std ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = icmp sle i32 %5, 1\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define internal i32 @whc_std_last(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp slt i32 %1, 2\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define internal i32 @whc_std_last(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp slt i32 %1, 2\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define internal i32 @whc_std_last(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp slt i32 %1, 2\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define internal signext i16 @wenc_clip_short(i32 noundef %0) {\n%2 = alloca i16, align 2\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = add nsw i32 %4, 32768\n%6 = and i32 %5, -65536\n%7 = icmp ne i32 %6, 0\nbr i1 %7, label %8, label %13\n\n8:\n%9 = load i32, ptr %3, align 4\n%10 = ashr i32 %9, 31\n%11 = xor i32 %10, 32767\n%12 = trunc i32 %11 to i16\nstore i16 %12, ptr %2, align 2\nbr label %16\n\n13:\n%14 = load i32, ptr %3, align 4\n%15 = trunc i32 %14 to i16\nstore i16 %15, ptr %2, align 2\nbr label %16\n\n16:\n%17 = load i16, ptr %2, align 2\nret i16 %17\n}": {"base_truth": "define internal signext i16 @wenc_clip_short(i32 noundef %0) {\nB:\n%1 = tail call i32 @llvm.smax.i32(i32 %0, i32 -32768)\n%2 = tail call i32 @llvm.smin.i32(i32 %1, i32 32767)\n%3 = trunc i32 %2 to i16\nret i16 %3\n}", "codellama": "define internal signext i16 @wenc_clip_short(i32 noundef %0) {\nB:\n%1 = add nsw i32 %0, 32768\n%2 = icmp ult i32 %1, 65536\n%3 = trunc i32 %0 to i16\n%4 = trunc i32 %1 to i16\n%5 = select i1 %2, i16 %3, i16 %4\nret i16 %5\n}", "codegemma": "define internal signext i16 @wenc_clip_short(i32 noundef %0) {\nB:\n%1 = add nsw i32 %0, 32768\n%2 = icmp ult i32 %1, 65536\n%3 = ashr i32 %0, 31\n%4 = trunc i32 %3 to i16\n%5 = xor i16 %4, 32767\n%6 = select i1 %2, i16 %4, i16 %5\nret i16 %6\n}"}, "define internal i32 @test__checkevent_raw(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @perf_evlist__first(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.perf_evlist ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = icmp eq i32 1, %8\n%10 = zext i1 %9 to i32\n%11 = call i32 @TEST_ASSERT_VAL(ptr noundef @.str, i32 noundef %10)\n%12 = load i64, ptr @PERF_TYPE_RAW, align 8\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.perf_evsel ptr %13, i32 0, i32 0\n%15 = getelementptr inbounds %struct.TYPE_2__, ptr %14, i32 0, i32 0\n%16 = load i64, ptr %15, align 8\n%17 = icmp eq i64 %12, %16\n%18 = zext i1 %17 to i32\n%19 = call i32 @TEST_ASSERT_VAL(ptr noundef @.str.1, i32 noundef %18)\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.perf_evsel ptr %20, i32 0, i32 0\n%22 = getelementptr inbounds %struct.TYPE_2__, ptr %21, i32 0, i32 1\n%23 = load i32, ptr %22, align 8\n%24 = icmp eq i32 26, %23\n%25 = zext i1 %24 to i32\n%26 = call i32 @TEST_ASSERT_VAL(ptr noundef @.str.2, i32 noundef %25)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @test__checkevent_raw(ptr noundef %0) {\nB:\n%1 = tail call ptr @perf_evlist__first(ptr noundef %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str, i32 noundef %4)\n%6 = load i64, ptr @PERF_TYPE_RAW, align 8\n%7 = load i64, ptr %1, align 8\n%8 = icmp eq i64 %6, %7\n%9 = zext i1 %8 to i32\n%10 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str.1, i32 noundef %9)\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %1, i64 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = icmp eq i32 %12, 26\n%14 = zext i1 %13 to i32\n%15 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str.2, i32 noundef %14)\nret i32 0\n}", "codellama": "define internal i32 @test__checkevent_raw(ptr noundef %0) {\nB:\n%1 = tail call ptr @perf_evlist__first(ptr noundef %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str, i32 noundef %4)\n%6 = load i64, ptr @PERF_TYPE_RAW, align 8\n%7 = load i64, ptr %1, align 8\n%8 = icmp eq i64 %6, %7\n%9 = zext i1 %8 to i32\n%10 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str.1, i32 noundef %9)\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %1, i64 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = icmp eq i32 %12, 26\n%14 = zext i1 %13 to i32\n%15 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str.2, i32 noundef %14)\nret i32 0\n}", "codegemma": "define internal i32 @test__checkevent_raw(ptr noundef %0) {\nB:\n%1 = tail call ptr @perf_evlist__first(ptr noundef %0)\n%2 = load i32, ptr %0, align 4\n%3 = icmp eq i32 %2, 1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str, i32 noundef %4)\n%6 = load i64, ptr @PERF_TYPE_RAW, align 8\n%7 = load i64, ptr %1, align 8\n%8 = icmp eq i64 %6, %7\n%9 = zext i1 %8 to i32\n%10 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str.1, i32 noundef %9)\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %1, i64 0, i32 1\n%12 = load i32, ptr %11, align 8\n%13 = icmp eq i32 %12, 26\n%14 = zext i1 %13 to i32\n%15 = tail call i32 @TEST_ASSERT_VAL(ptr noundef nonnull @.str.2, i32 noundef %14)\nret i32 0\n}"}, "define dso_local void @HMAC_CTX_free(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %11\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @HMAC_CTX_cleanup(ptr noundef %7)\n%9 = load ptr, ptr %2, align 8\n%10 = call i32 @free(ptr noundef %9)\nbr label %11\n\n11:\nret void\n}": {"base_truth": "define dso_local void @HMAC_CTX_free(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @HMAC_CTX_cleanup(ptr noundef nonnull %0)\n%3 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @HMAC_CTX_free(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @HMAC_CTX_cleanup(ptr noundef nonnull %0)\n%3 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @HMAC_CTX_free(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @HMAC_CTX_cleanup(ptr noundef nonnull %0)\n%3 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @zend_shutdown_extensions() {\n%1 = load i64, ptr @zend_extension_shutdown, align 8\n%2 = trunc i64 %1 to i32\n%3 = call i32 @zend_llist_apply(ptr noundef @zend_extensions, i32 noundef %2)\n%4 = call i32 @zend_llist_destroy(ptr noundef @zend_extensions)\nret void\n}": {"base_truth": "define dso_local void @zend_shutdown_extensions() {\nB:\n%0 = load i64, ptr @zend_extension_shutdown, align 8\n%1 = trunc i64 %0 to i32\n%2 = tail call i32 @zend_llist_apply(ptr noundef nonnull @zend_extensions, i32 noundef %1)\n%3 = tail call i32 @zend_llist_destroy(ptr noundef nonnull @zend_extensions)\nret void\n}", "codellama": "define dso_local void @zend_shutdown_extensions() {\nB:\n%0 = load i64, ptr @zend_extension_shutdown, align 8\n%1 = trunc i64 %0 to i32\n%2 = tail call i32 @zend_llist_apply(ptr noundef nonnull @zend_extensions, i32 noundef %1)\n%3 = tail call i32 @zend_llist_destroy(ptr noundef nonnull @zend_extensions)\nret void\n}", "codegemma": "define dso_local void @zend_shutdown_extensions() {\nB:\n%0 = load i64, ptr @zend_extension_shutdown, align 8\n%1 = trunc i64 %0 to i32\n%2 = tail call i32 @zend_llist_apply(ptr noundef nonnull @zend_extensions, i32 noundef %1)\n%3 = tail call i32 @zend_llist_destroy(ptr noundef nonnull @zend_extensions)\nret void\n}"}, "define dso_local i32 @filaCheiaDouble(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 0\n%6 = load i64, ptr %5, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = icmp eq i64 %6, %9\nbr i1 %10, label %11, label %12\n\n11:\nstore i32 1, ptr %2, align 4\nbr label %13\n\n12:\nstore i32 0, ptr %2, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %2, align 4\nret i32 %14\n}": {"base_truth": "define dso_local i32 @filaCheiaDouble(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define dso_local i32 @filaCheiaDouble(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codegemma": "define dso_local i32 @filaCheiaDouble(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp eq i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}"}, "define dso_local i32 @xrdp_tcp_send(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%8 = load ptr, ptr %5, align 8\n%9 = getelementptr inbounds %struct.stream ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\n%11 = load ptr, ptr %5, align 8\n%12 = getelementptr inbounds %struct.stream ptr %11, i32 0, i32 1\n%13 = load i32, ptr %12, align 4\n%14 = sub nsw i32 %10, %13\nstore i32 %14, ptr %6, align 4\n%15 = load ptr, ptr %4, align 8\n%16 = getelementptr inbounds %struct.xrdp_tcp ptr %15, i32 0, i32 0\n%17 = load i32, ptr %16, align 4\n%18 = load ptr, ptr %5, align 8\n%19 = call i64 @trans_force_write_s(i32 noundef %17, ptr noundef %18)\n%20 = icmp ne i64 %19, 0\nbr i1 %20, label %21, label %22\n\n21:\nstore i32 1, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %23\n\n22:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %23\n\n23:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%24 = load i32, ptr %3, align 4\nret i32 %24\n}": {"base_truth": "define dso_local i32 @xrdp_tcp_send(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @trans_force_write_s(i32 noundef %2, ptr noundef %1)\n%4 = icmp ne i64 %3, 0\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define dso_local i32 @xrdp_tcp_send(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds %struct.stream, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = sub nsw i32 %2, %4\n%6 = load i32, ptr %0, align 4\n%7 = tail call i64 @trans_force_write_s(i32 noundef %6, ptr noundef nonnull %1)\n%8 = icmp ne i64 %7, 0\n%9 = zext i1 %8 to i32\nret i32 %9\n}", "codegemma": "define dso_local i32 @xrdp_tcp_send(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds %struct.stream, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = sub nsw i32 %2, %4\n%6 = load i32, ptr %0, align 4\n%7 = tail call i64 @trans_force_write_s(i32 noundef %6, ptr noundef nonnull %1)\n%8 = icmp ne i64 %7, 0\n%9 = zext i1 %8 to i32\nret i32 %9\n}"}, "define dso_local ptr @object_delete(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %6, label %7\n\n6:\nstore ptr null, ptr %2, align 8\nbr label %10\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @free(ptr noundef %8)\nstore ptr null, ptr %3, align 8\nstore ptr null, ptr %2, align 8\nbr label %10\n\n10:\n%11 = load ptr, ptr %2, align 8\nret ptr %11\n}": {"base_truth": "define dso_local noalias ptr @object_delete(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret ptr null\n}", "codellama": "define dso_local noalias ptr @object_delete(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret ptr null\n}", "codegemma": "define dso_local noalias ptr @object_delete(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret ptr null\n}"}, "define dso_local i64 @crypto_core_ristretto255_scalarbytes() {\n%1 = load i64, ptr @crypto_core_ristretto255_SCALARBYTES, align 8\nret i64 %1\n}": {"base_truth": "define dso_local i64 @crypto_core_ristretto255_scalarbytes() {\nB:\n%0 = load i64, ptr @crypto_core_ristretto255_SCALARBYTES, align 8\nret i64 %0\n}", "codellama": "define dso_local i64 @crypto_core_ristretto255_scalarbytes() {\nB:\n%0 = load i64, ptr @crypto_core_ristretto255_SCALARBYTES, align 8\nret i64 %0\n}", "codegemma": "define dso_local i64 @crypto_core_ristretto255_scalarbytes() {\nB:\n%0 = load i64, ptr @crypto_core_ristretto255_SCALARBYTES, align 8\nret i64 %0\n}"}, "define dso_local void @Errors__fatal(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca [2048 x i32], align 16\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8192, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = getelementptr inbounds [2048 x i32], ptr %3, i64 0, i64 0\n%7 = call i32 @Streams__new_buffer(i32 noundef 2048, ptr noundef %6)\nstore i32 %7, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\nstore ptr %4, ptr %5, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = load ptr, ptr %2, align 8\n%10 = call i32 @Streams__printf(ptr noundef %8, ptr noundef @.str, ptr noundef @.str.1, ptr noundef %9)\n%11 = load ptr, ptr %5, align 8\n%12 = call i32 @Errors__issue(ptr noundef %11, i32 noundef 1)\n%13 = load ptr, ptr %5, align 8\n%14 = call i32 @Streams__close(ptr noundef %13)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8192, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @Errors__fatal(ptr noundef %0) {\nB:\n%1 = alloca [2048 x i32], align 16\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8192, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = call i32 @Streams__new_buffer(i32 noundef 2048, ptr noundef nonnull %1)\nstore i32 %3, ptr %2, align 4\n%4 = call i32 @Streams__printf(ptr noundef nonnull %2, ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, ptr noundef %0)\n%5 = call i32 @Errors__issue(ptr noundef nonnull %2, i32 noundef 1)\n%6 = call i32 @Streams__close(ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8192, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @Errors__fatal(ptr noundef %0) {\nB:\n%1 = alloca [2048 x i32], align 16\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8192, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = call i32 @Streams__new_buffer(i32 noundef 2048, ptr noundef nonnull %1)\nstore i32 %3, ptr %2, align 4\n%4 = call i32 @Streams__printf(ptr noundef nonnull %2, ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, ptr noundef %0)\n%5 = call i32 @Errors__issue(ptr noundef nonnull %2, i32 noundef 1)\n%6 = call i32 @Streams__close(ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8192, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @Errors__fatal(ptr noundef %0) {\nB:\n%1 = alloca [2048 x i32], align 16\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8192, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = call i32 @Streams__new_buffer(i32 noundef 2048, ptr noundef nonnull %1)\nstore i32 %3, ptr %2, align 4\n%4 = call i32 @Streams__printf(ptr noundef nonnull %2, ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, ptr noundef %0)\n%5 = call i32 @Errors__issue(ptr noundef nonnull %2, i32 noundef 1)\n%6 = call i32 @Streams__close(ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8192, ptr nonnull %1)\nret void\n}"}, "define internal void @trinity_setup_uvd_dpm_interval(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%10 = load i32, ptr @PM_TP, align 4\n%11 = call i32 @RREG32_SMC(i32 noundef %10)\nstore i32 %11, ptr %7, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\n%12 = load ptr, ptr %3, align 8\n%13 = call i32 @radeon_get_xclk(ptr noundef %12)\nstore i32 %13, ptr %9, align 4\n%14 = load i32, ptr %4, align 4\n%15 = load i32, ptr %9, align 4\n%16 = call i32 @r600_calculate_u_and_p(i32 noundef %14, i32 noundef %15, i32 noundef 16, ptr noundef %5, ptr noundef %6)\n%17 = load i32, ptr %5, align 4\n%18 = load i32, ptr %7, align 4\n%19 = add nsw i32 %17, %18\n%20 = sub nsw i32 %19, 1\n%21 = load i32, ptr %7, align 4\n%22 = sdiv i32 %20, %21\nstore i32 %22, ptr %8, align 4\n%23 = load i32, ptr @SMU_UVD_DPM_CNTL, align 4\n%24 = load i32, ptr %8, align 4\n%25 = call i32 @WREG32_SMC(i32 noundef %23, i32 noundef %24)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @trinity_setup_uvd_dpm_interval(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = load i32, ptr @PM_TP, align 4\n%5 = tail call i32 @RREG32_SMC(i32 noundef %4)\n%6 = tail call i32 @radeon_get_xclk(ptr noundef %0)\n%7 = call i32 @r600_calculate_u_and_p(i32 noundef %1, i32 noundef %6, i32 noundef 16, ptr noundef nonnull %2, ptr noundef nonnull %3)\n%8 = load i32, ptr %2, align 4\n%9 = add i32 %5, -1\n%10 = add i32 %9, %8\n%11 = sdiv i32 %10, %5\n%12 = load i32, ptr @SMU_UVD_DPM_CNTL, align 4\n%13 = call i32 @WREG32_SMC(i32 noundef %12, i32 noundef %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret void\n}", "codellama": "define internal void @trinity_setup_uvd_dpm_interval(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = load i32, ptr @PM_TP, align 4\n%5 = tail call i32 @RREG32_SMC(i32 noundef %4)\n%6 = tail call i32 @radeon_get_xclk(ptr noundef %0)\n%7 = call i32 @r600_calculate_u_and_p(i32 noundef %1, i32 noundef %6, i32 noundef 16, ptr noundef nonnull %2, ptr noundef nonnull %3)\n%8 = load i32, ptr %2, align 4\n%9 = add i32 %5, -1\n%10 = add i32 %9, %8\n%11 = sdiv i32 %10, %5\n%12 = load i32, ptr @SMU_UVD_DPM_CNTL, align 4\n%13 = call i32 @WREG32_SMC(i32 noundef %12, i32 noundef %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret void\n}", "codegemma": "define internal void @trinity_setup_uvd_dpm_interval(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = load i32, ptr @PM_TP, align 4\n%5 = tail call i32 @RREG32_SMC(i32 noundef %4)\n%6 = tail call i32 @radeon_get_xclk(ptr noundef %0)\n%7 = call i32 @r600_calculate_u_and_p(i32 noundef %1, i32 noundef %6, i32 noundef 16, ptr noundef nonnull %2, ptr noundef nonnull %3)\n%8 = load i32, ptr %2, align 4\n%9 = add i32 %8, %5\n%10 = add i32 %9, -1\n%11 = sdiv i32 %10, %5\n%12 = load i32, ptr @SMU_UVD_DPM_CNTL, align 4\n%13 = call i32 @WREG32_SMC(i32 noundef %12, i32 noundef %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret void\n}"}, "define dso_local void @scrollFramebuffer() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca %struct.TYPE_4__, align 4\n%5 = alloca %struct.TYPE_4__, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 1, ptr %1, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %1, align 4\n%8 = icmp slt i32 %7, 25\nbr i1 %8, label %10, label %9\n\n9:\nstore i32 2, ptr %2, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nbr label %35\n\n10:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\nbr label %11\n\n11:\n%12 = load i32, ptr %3, align 4\n%13 = icmp slt i32 %12, 80\nbr i1 %13, label %15, label %14\n\n14:\nstore i32 5, ptr %2, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nbr label %31\n\n15:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%16 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i32 0, i32 0\n%17 = load i32, ptr %3, align 4\nstore i32 %17, ptr %16, align 4\n%18 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i32 0, i32 1\n%19 = load i32, ptr %1, align 4\nstore i32 %19, ptr %18, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%20 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 0\n%21 = load i32, ptr %3, align 4\nstore i32 %21, ptr %20, align 4\n%22 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 1\n%23 = load i32, ptr %1, align 4\n%24 = sub nsw i32 %23, 1\nstore i32 %24, ptr %22, align 4\n%25 = load i64, ptr %4, align 4\n%26 = load i64, ptr %5, align 4\n%27 = call i32 @copyCharToPos(i64 %25, i64 %26)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\nbr label %28\n\n28:\n%29 = load i32, ptr %3, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %3, align 4\nbr label %11\n\n31:\nbr label %32\n\n32:\n%33 = load i32, ptr %1, align 4\n%34 = add nsw i32 %33, 1\nstore i32 %34, ptr %1, align 4\nbr label %6\n\n35:\nret void\n}": {"base_truth": "define dso_local void @scrollFramebuffer() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i64 [ 1, %B ], [ %4, %B3 ]\n%1 = shl nuw nsw i64 %0, 32\n%2 = shl i64 %0, 32\n%3 = add i64 %2, -4294967296\nbr label %B4\n\nB2:\nret void\n\nB3:\n%4 = add nuw nsw i64 %0, 1\n%5 = icmp eq i64 %4, 25\nbr i1 %5, label %B2, label %B1\n\nB4:\n%6 = phi i64 [ 0, %B1 ], [ %10, %B4 ]\n%7 = or i64 %1, %6\n%8 = or i64 %3, %6\n%9 = tail call i32 @copyCharToPos(i64 %7, i64 %8)\n%10 = add nuw nsw i64 %6, 1\n%11 = icmp eq i64 %10, 80\nbr i1 %11, label %B3, label %B4\n}", "codellama": "define dso_local void @scrollFramebuffer() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 1, %B ], [ %10, %B3 ]\nbr label %B2\n\nB2:\n%1 = phi i32 [ 0, %B1 ], [ %7, %B2 ]\n%2 = zext i32 %1 to i64\n%3 = shl nuw nsw i64 %2, 32\n%4 = zext i32 %0 to i64\n%5 = or i64 %3, %4\n%6 = tail call i32 @copyCharToPos(i64 %5, i64 poison)\n%7 = add nuw nsw i32 %1, 1\n%8 = icmp eq i32 %7, 80\nbr i1 %8, label %B3, label %B2\n\nB3:\n%9 = add nuw nsw i32 %0, 1\n%10 = icmp eq i32 %9, 25\nbr i1 %10, label %B4, label %B1\n\nB4:\nret void\n}", "codegemma": "define dso_local void @scrollFramebuffer() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 1, %B ], [ %11, %B3 ]\n%1 = phi i32 [ 0, %B ], [ %12, %B3 ]\n%2 = icmp slt i32 %0, 25\nbr i1 %2, label %B2, label %B4\n\nB2:\n%3 = phi i32 [ %10, %B2 ], [ 0, %B1 ]\n%4 = phi i32 [ %9, %B2 ], [ 1, %B1 ]\n%5 = tail call i32 @copyCharToPos(i64 0, i64 0)\n%6 = tail call i32 @copyCharToPos(i64 0, i64 0)\n%7 = tail call i32 @copyCharToPos(i64 0, i64 0)\n%8 = tail call i32 @copyCharToPos(i64 0, i64 0)\n%9 = add nuw nsw i32 %4, 1\n%10 = add nuw nsw i32 %3, 1\n%11 = add nuw nsw i32 %0, 1\n%12 = icmp ult i32 %3, 79\nbr i1 %12, label %B2, label %B3\n\nB3:\n%13 = add nuw nsw i32 %0, 1\n%14 = icmp ult i32 %0, 24\nbr i1 %14, label %B1, label %B4\n\nB4:\nret void\n}"}, "define dso_local void @SCB_SCB_IRQ_StartEx(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = call i32 (...) @SCB_SCB_IRQ_Disable()\n%4 = load i32, ptr %2, align 4\n%5 = call i32 @SCB_SCB_IRQ_SetVector(i32 noundef %4)\n%6 = call i32 @SCB_SCB_IRQ_SetPriority(i32 noundef 3)\n%7 = call i32 (...) @SCB_SCB_IRQ_Enable()\nret void\n}": {"base_truth": "define dso_local void @SCB_SCB_IRQ_StartEx(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @SCB_SCB_IRQ_Disable()\n%2 = tail call i32 @SCB_SCB_IRQ_SetVector(i32 noundef %0)\n%3 = tail call i32 @SCB_SCB_IRQ_SetPriority(i32 noundef 3)\n%4 = tail call i32 (...) @SCB_SCB_IRQ_Enable()\nret void\n}", "codellama": "define dso_local void @SCB_SCB_IRQ_StartEx(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @SCB_SCB_IRQ_Disable()\n%2 = tail call i32 @SCB_SCB_IRQ_SetVector(i32 noundef %0)\n%3 = tail call i32 @SCB_SCB_IRQ_SetPriority(i32 noundef 3)\n%4 = tail call i32 (...) @SCB_SCB_IRQ_Enable()\nret void\n}", "codegemma": "define dso_local void @SCB_SCB_IRQ_StartEx(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @SCB_SCB_IRQ_Disable()\n%2 = tail call i32 @SCB_SCB_IRQ_SetVector(i32 noundef %0)\n%3 = tail call i32 @SCB_SCB_IRQ_SetPriority(i32 noundef 3)\n%4 = tail call i32 (...) @SCB_SCB_IRQ_Enable()\nret void\n}"}, "define dso_local i32 @bxt_dsi_get_pclk(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca ptr, align 8\n%10 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.intel_encoder ptr %11, i32 0, i32 0\n%13 = call ptr @enc_to_intel_dsi(ptr noundef %12)\nstore ptr %13, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.intel_encoder ptr %14, i32 0, i32 0\n%16 = getelementptr inbounds %struct.TYPE_4__, ptr %15, i32 0, i32 0\n%17 = load i32, ptr %16, align 4\n%18 = call ptr @to_i915(i32 noundef %17)\nstore ptr %18, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\n%19 = load ptr, ptr %8, align 8\n%20 = getelementptr inbounds %struct.intel_dsi ptr %19, i32 0, i32 1\n%21 = load i32, ptr %20, align 4\n%22 = call i32 @mipi_dsi_pixel_format_to_bpp(i32 noundef %21)\nstore i32 %22, ptr %10, align 4\n%23 = load i32, ptr @BXT_DSI_PLL_CTL, align 4\n%24 = call i32 @I915_READ(i32 noundef %23)\n%25 = load ptr, ptr %4, align 8\n%26 = getelementptr inbounds %struct.intel_crtc_state ptr %25, i32 0, i32 0\n%27 = getelementptr inbounds %struct.TYPE_3__, ptr %26, i32 0, i32 0\nstore i32 %24, ptr %27, align 4\n%28 = load ptr, ptr %4, align 8\n%29 = getelementptr inbounds %struct.intel_crtc_state ptr %28, i32 0, i32 0\n%30 = getelementptr inbounds %struct.TYPE_3__, ptr %29, i32 0, i32 0\n%31 = load i32, ptr %30, align 4\n%32 = load i32, ptr @BXT_DSI_PLL_RATIO_MASK, align 4\n%33 = and i32 %31, %32\nstore i32 %33, ptr %7, align 4\n%34 = load i32, ptr %7, align 4\n%35 = load i32, ptr @BXT_REF_CLOCK_KHZ, align 4\n%36 = mul nsw i32 %34, %35\n%37 = sdiv i32 %36, 2\nstore i32 %37, ptr %6, align 4\n%38 = load i32, ptr %6, align 4\n%39 = load ptr, ptr %8, align 8\n%40 = getelementptr inbounds %struct.intel_dsi ptr %39, i32 0, i32 0\n%41 = load i32, ptr %40, align 4\n%42 = mul nsw i32 %38, %41\n%43 = load i32, ptr %10, align 4\n%44 = call i32 @DIV_ROUND_CLOSEST(i32 noundef %42, i32 noundef %43)\nstore i32 %44, ptr %5, align 4\n%45 = load i32, ptr %5, align 4\n%46 = call i32 @DRM_DEBUG_DRIVER(ptr noundef @.str, i32 noundef %45)\n%47 = load i32, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %47\n}": {"base_truth": "define dso_local i32 @bxt_dsi_get_pclk(ptr noundef %0, ptr nocapture noundef writeonly %1) {\nB:\n%2 = tail call ptr @enc_to_intel_dsi(ptr noundef %0)\n%3 = load i32, ptr %0, align 4\n%4 = tail call ptr @to_i915(i32 noundef %3)\n%5 = getelementptr inbounds %struct.intel_dsi, ptr %2, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @mipi_dsi_pixel_format_to_bpp(i32 noundef %6)\n%8 = load i32, ptr @BXT_DSI_PLL_CTL, align 4\n%9 = tail call i32 @I915_READ(i32 noundef %8)\nstore i32 %9, ptr %1, align 4\n%10 = load i32, ptr @BXT_DSI_PLL_RATIO_MASK, align 4\n%11 = and i32 %10, %9\n%12 = load i32, ptr @BXT_REF_CLOCK_KHZ, align 4\n%13 = mul nsw i32 %11, %12\n%14 = sdiv i32 %13, 2\n%15 = load i32, ptr %2, align 4\n%16 = mul nsw i32 %14, %15\n%17 = tail call i32 @DIV_ROUND_CLOSEST(i32 noundef %16, i32 noundef %7)\n%18 = tail call i32 @DRM_DEBUG_DRIVER(ptr noundef nonnull @.str, i32 noundef %17)\nret i32 %17\n}", "codellama": "define dso_local i32 @bxt_dsi_get_pclk(ptr noundef %0, ptr nocapture noundef writeonly %1) {\nB:\n%2 = tail call ptr @enc_to_intel_dsi(ptr noundef %0)\n%3 = load i32, ptr %0, align 4\n%4 = tail call ptr @to_i915(i32 noundef %3)\n%5 = getelementptr inbounds %struct.intel_dsi, ptr %2, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @mipi_dsi_pixel_format_to_bpp(i32 noundef %6)\n%8 = load i32, ptr @BXT_DSI_PLL_CTL, align 4\n%9 = tail call i32 @I915_READ(i32 noundef %8)\nstore i32 %9, ptr %1, align 4\n%10 = load i32, ptr @BXT_DSI_PLL_RATIO_MASK, align 4\n%11 = and i32 %10, %9\n%12 = load i32, ptr @BXT_REF_CLOCK_KHZ, align 4\n%13 = mul nsw i32 %11, %12\n%14 = sdiv i32 %13, 2\n%15 = load i32, ptr %2, align 4\n%16 = mul nsw i32 %14, %15\n%17 = tail call i32 @DIV_ROUND_CLOSEST(i32 noundef %16, i32 noundef %7)\n%18 = tail call i32 @DRM_DEBUG_DRIVER(ptr noundef nonnull @.str, i32 noundef %17)\nret i32 %17\n}", "codegemma": "define dso_local i32 @bxt_dsi_get_pclk(ptr noundef %0, ptr nocapture noundef writeonly %1) {\nB:\n%2 = tail call ptr @enc_to_intel_dsi(ptr noundef %0)\n%3 = load i32, ptr %0, align 4\n%4 = tail call ptr @to_i915(i32 noundef %3)\n%5 = getelementptr inbounds %struct.intel_dsi, ptr %2, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = tail call i32 @mipi_dsi_pixel_format_to_bpp(i32 noundef %6)\n%8 = load i32, ptr @BXT_DSI_PLL_CTL, align 4\n%9 = tail call i32 @I915_READ(i32 noundef %8)\nstore i32 %9, ptr %1, align 4\n%10 = load i32, ptr @BXT_DSI_PLL_RATIO_MASK, align 4\n%11 = and i32 %10, %9\n%12 = load i32, ptr @BXT_REF_CLOCK_KHZ, align 4\n%13 = mul nsw i32 %12, %11\n%14 = sdiv i32 %13, 2\n%15 = load i32, ptr %2, align 4\n%16 = mul nsw i32 %14, %15\n%17 = tail call i32 @DIV_ROUND_CLOSEST(i32 noundef %16, i32 noundef %7)\n%18 = tail call i32 @DRM_DEBUG_DRIVER(ptr noundef nonnull @.str, i32 noundef %17)\nret i32 %17\n}"}, "define dso_local ptr @machine__new_host() {\n%1 = alloca ptr, align 8\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%4 = call ptr @malloc(i32 noundef 4)\nstore ptr %4, ptr %2, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %7, label %16\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = load i32, ptr @HOST_KERNEL_ID, align 4\n%10 = call i32 @machine__init(ptr noundef %8, ptr noundef @.str, i32 noundef %9)\n%11 = load ptr, ptr %2, align 8\n%12 = call i64 @machine__create_kernel_maps(ptr noundef %11)\n%13 = icmp slt i64 %12, 0\nbr i1 %13, label %14, label %15\n\n14:\nbr label %18\n\n15:\nbr label %16\n\n16:\n%17 = load ptr, ptr %2, align 8\nstore ptr %17, ptr %1, align 8\nstore i32 1, ptr %3, align 4\nbr label %21\n\n18:\n%19 = load ptr, ptr %2, align 8\n%20 = call i32 @free(ptr noundef %19)\nstore ptr null, ptr %1, align 8\nstore i32 1, ptr %3, align 4\nbr label %21\n\n21:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\n%22 = load ptr, ptr %1, align 8\nret ptr %22\n}": {"base_truth": "define dso_local ptr @machine__new_host() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 4)\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr @HOST_KERNEL_ID, align 4\n%3 = tail call i32 @machine__init(ptr noundef nonnull %0, ptr noundef nonnull @.str, i32 noundef %2)\n%4 = tail call i64 @machine__create_kernel_maps(ptr noundef nonnull %0)\n%5 = icmp slt i64 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%7 = phi ptr [ null, %B2 ], [ %0, %B1 ], [ null, %B ]\nret ptr %7\n}", "codellama": "define dso_local ptr @machine__new_host() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 4)\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr @HOST_KERNEL_ID, align 4\n%3 = tail call i32 @machine__init(ptr noundef nonnull %0, ptr noundef nonnull @.str, i32 noundef %2)\n%4 = tail call i64 @machine__create_kernel_maps(ptr noundef nonnull %0)\n%5 = icmp slt i64 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%7 = phi ptr [ null, %B2 ], [ %0, %B1 ], [ null, %B ]\nret ptr %7\n}", "codegemma": "define dso_local ptr @machine__new_host() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 4)\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr @HOST_KERNEL_ID, align 4\n%3 = tail call i32 @machine__init(ptr noundef nonnull %0, ptr noundef nonnull @.str, i32 noundef %2)\n%4 = tail call i64 @machine__create_kernel_maps(ptr noundef nonnull %0)\n%5 = icmp slt i64 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\n%7 = phi ptr [ null, %B2 ], [ null, %B1 ], [ %0, %B ]\nret ptr %7\n}"}, "define dso_local void @arch_remove_kprobe(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @s390_free_insn_slot(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @arch_remove_kprobe(ptr noundef %0) {\nB:\n%1 = tail call i32 @s390_free_insn_slot(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @arch_remove_kprobe(ptr noundef %0) {\nB:\n%1 = tail call i32 @s390_free_insn_slot(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @arch_remove_kprobe(ptr noundef %0) {\nB:\n%1 = tail call i32 @s390_free_insn_slot(ptr noundef %0)\nret void\n}"}, "define dso_local void @run_clicked(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr @power, align 4\n%6 = icmp ne i32 %5, 0\nbr i1 %6, label %8, label %7\n\n7:\nbr label %18\n\n8:\n%9 = load i32, ptr @cpu_bus, align 4\n%10 = and i32 %9, 8\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %13\n\n12:\nbr label %18\n\n13:\n%14 = load i32, ptr %3, align 4\nswitch i32 %14, label %17 [\ni32 0, label %15\ni32 1, label %16\n]\n\n15:\nstore i32 0, ptr @fp_led_wait, align 4\nstore i32 1, ptr @cpu_switch, align 4\nbr label %18\n\n16:\nstore i32 0, ptr @cpu_state, align 4\nstore i32 1, ptr @fp_led_wait, align 4\nstore i32 0, ptr @cpu_switch, align 4\nbr label %18\n\n17:\nbr label %18\n\n18:\nret void\n}": {"base_truth": "define dso_local void @run_clicked(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @power, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = load i32, ptr @cpu_bus, align 4\n%5 = and i32 %4, 8\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B5\n\nB2:\nswitch i32 %0, label %B5 [\ni32 0, label %B4\ni32 1, label %B3\n]\n\nB3:\nstore i32 0, ptr @cpu_state, align 4\nbr label %B4\n\nB4:\n%7 = phi i32 [ 0, %B3 ], [ 1, %B2 ]\nstore i32 %0, ptr @fp_led_wait, align 4\nstore i32 %7, ptr @cpu_switch, align 4\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define dso_local void @run_clicked(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @power, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = load i32, ptr @cpu_bus, align 4\n%5 = and i32 %4, 8\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B4\n\nB2:\nswitch i32 %0, label %B4 [\ni32 0, label %B3\ni32 1, label %B5\n]\n\nB3:\nstore i32 0, ptr @fp_led_wait, align 4\nstore i32 1, ptr @cpu_switch, align 4\nbr label %B4\n\nB4:\nret void\n\nB5:\nstore i32 0, ptr @cpu_state, align 4\nstore i32 1, ptr @fp_led_wait, align 4\nstore i32 0, ptr @cpu_switch, align 4\nbr label %B4\n}", "codegemma": "define dso_local void @run_clicked(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @power, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = load i32, ptr @cpu_bus, align 4\n%5 = and i32 %4, 8\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B2, label %B4\n\nB2:\n%7 = icmp eq i32 %0, 1\nbr i1 %7, label %B3, label %B4\n\nB3:\n%8 = load i32, ptr @cpu_state, align 4\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB4:\n%10 = phi i32 [ 0, %B1 ], [ 0, %B2 ], [ 0, %B ], [ 1, %B3 ]\n%11 = phi i32 [ 1, %B1 ], [ 0, %B2 ], [ 0, %B ], [ 1, %B3 ]\nstore i32 %10, ptr @fp_led_wait, align 4\nstore i32 %11, ptr @cpu_switch, align 4\nret void\n}"}, "define dso_local nofpclass(nan inf) double @gsl_nan() {\n%1 = call fast nofpclass(nan inf) double @gsl_fdiv(double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00)\nret double %1\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @gsl_nan() {\nB:\n%0 = tail call fast nofpclass(nan inf) double @gsl_fdiv(double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00)\nret double %0\n}", "codellama": "define dso_local nofpclass(nan inf) double @gsl_nan() {\nB:\n%0 = tail call fast nofpclass(nan inf) double @gsl_fdiv(double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00)\nret double %0\n}", "codegemma": "define dso_local nofpclass(nan inf) double @gsl_nan() {\nB:\n%0 = tail call fast nofpclass(nan inf) double @gsl_fdiv(double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00)\nret double %0\n}"}, "define internal i32 @kv_force_dpm_lowest(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @amdgpu_kv_dpm_get_enable_mask(ptr noundef %8, ptr noundef %5)\nstore i32 %9, ptr %4, align 4\n%10 = load i32, ptr %4, align 4\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %14\n\n12:\n%13 = load i32, ptr %4, align 4\nstore i32 %13, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %51\n\n14:\nstore i32 0, ptr %6, align 4\nbr label %15\n\n15:\n%16 = load i32, ptr %6, align 4\n%17 = load i32, ptr @SMU7_MAX_LEVELS_GRAPHICS, align 4\n%18 = icmp slt i32 %16, %17\nbr i1 %18, label %19, label %30\n\n19:\n%20 = load i32, ptr %5, align 4\n%21 = load i32, ptr %6, align 4\n%22 = shl i32 1, %21\n%23 = and i32 %20, %22\n%24 = icmp ne i32 %23, 0\nbr i1 %24, label %25, label %26\n\n25:\nbr label %30\n\n26:\nbr label %27\n\n27:\n%28 = load i32, ptr %6, align 4\n%29 = add nsw i32 %28, 1\nstore i32 %29, ptr %6, align 4\nbr label %15\n\n30:\n%31 = load ptr, ptr %3, align 8\n%32 = getelementptr inbounds %struct.amdgpu_device, ptr %31, i32 0, i32 0\n%33 = load i64, ptr %32, align 8\n%34 = load i64, ptr @CHIP_KABINI, align 8\n%35 = icmp eq i64 %33, %34\nbr i1 %35, label %42, label %36\n\n36:\n%37 = load ptr, ptr %3, align 8\n%38 = getelementptr inbounds %struct.amdgpu_device, ptr %37, i32 0, i32 0\n%39 = load i64, ptr %38, align 8\n%40 = load i64, ptr @CHIP_MULLINS, align 8\n%41 = icmp eq i64 %39, %40\nbr i1 %41, label %42, label %47\n\n42:\n%43 = load ptr, ptr %3, align 8\n%44 = load i32, ptr @PPSMC_MSG_DPM_ForceState, align 4\n%45 = load i32, ptr %6, align 4\n%46 = call i32 @amdgpu_kv_send_msg_to_smc_with_parameter(ptr noundef %43, i32 noundef %44, i32 noundef %45)\nstore i32 %46, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %51\n\n47:\n%48 = load ptr, ptr %3, align 8\n%49 = load i32, ptr %6, align 4\n%50 = call i32 @kv_set_enabled_level(ptr noundef %48, i32 noundef %49)\nstore i32 %50, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %51\n\n51:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%52 = load i32, ptr %2, align 4\nret i32 %52\n}": {"base_truth": "define internal i32 @kv_force_dpm_lowest(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @amdgpu_kv_dpm_get_enable_mask(ptr noundef %0, ptr noundef nonnull %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B8\n\nB1:\n%4 = load i32, ptr @SMU7_MAX_LEVELS_GRAPHICS, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B2, label %B5\n\nB2:\n%6 = load i32, ptr %1, align 4\nbr label %B3\n\nB3:\n%7 = phi i32 [ 0, %B2 ], [ %11, %B4 ]\n%8 = shl nuw i32 1, %7\n%9 = and i32 %6, %8\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B4, label %B5\n\nB4:\n%11 = add nuw nsw i32 %7, 1\n%12 = icmp eq i32 %11, %4\nbr i1 %12, label %B5, label %B3\n\nB5:\n%13 = phi i32 [ 0, %B1 ], [ %7, %B3 ], [ %4, %B4 ]\n%14 = load i64, ptr %0, align 8\n%15 = load i64, ptr @CHIP_KABINI, align 8\n%16 = icmp eq i64 %14, %15\n%17 = load i64, ptr @CHIP_MULLINS, align 8\n%18 = icmp eq i64 %14, %17\n%19 = select i1 %16, i1 true, i1 %18\nbr i1 %19, label %B6, label %B7\n\nB6:\n%20 = load i32, ptr @PPSMC_MSG_DPM_ForceState, align 4\n%21 = call i32 @amdgpu_kv_send_msg_to_smc_with_parameter(ptr noundef nonnull %0, i32 noundef %20, i32 noundef %13)\nbr label %B8\n\nB7:\n%22 = call i32 @kv_set_enabled_level(ptr noundef nonnull %0, i32 noundef %13)\nbr label %B8\n\nB8:\n%23 = phi i32 [ %21, %B6 ], [ %22, %B7 ], [ %2, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %23\n}", "codellama": "define internal i32 @kv_force_dpm_lowest(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @amdgpu_kv_dpm_get_enable_mask(ptr noundef %0, ptr noundef nonnull %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B7\n\nB1:\n%4 = load i32, ptr @SMU7_MAX_LEVELS_GRAPHICS, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = phi i32 [ %10, %B2 ], [ 0, %B1 ]\n%7 = load i32, ptr %1, align 4\n%8 = shl nuw i32 1, %6\n%9 = and i32 %7, %8\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B3, label %B4\n\nB3:\n%11 = phi i32 [ 0, %B1 ], [ %6, %B2 ]\n%12 = load i64, ptr %0, align 8\n%13 = load i64, ptr @CHIP_KABINI, align 8\n%14 = icmp eq i64 %12, %13\n%15 = load i64, ptr @CHIP_MULLINS, align 8\n%16 = icmp eq i64 %12, %15\n%17 = select i1 %14, i1 true, i1 %16\nbr i1 %17, label %B5, label %B6\n\nB4:\n%18 = phi i32 [ %22, %B4 ], [ %6, %B2 ]\n%19 = add nuw nsw i32 %18, 1\n%20 = load i32, ptr @SMU7_MAX_LEVELS_GRAPHICS, align 4\n%21 = icmp slt i32 %19, %20\nbr i1 %21, label %B2, label %B5\n\nB5:\n%22 = phi i32 [ %11, %B3 ], [ %19, %B4 ]\n%23 = load i32, ptr @PPSMC_MSG_DPM_ForceState, align 4\n%24 = call i32 @amdgpu_kv_send_msg_to_smc_with_parameter(ptr noundef nonnull %0, i32 noundef %23, i32 noundef %22)\nbr label %B7\n\nB6:\n%25 = call i32 @kv_set_enabled_level(ptr noundef nonnull %0, i32 noundef %11)\nbr label %B7\n\nB7:\n%26 = phi i32 [ %24, %B5 ], [ %25, %B6 ], [ %2, %B ], [ 0, %B3 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %26\n}", "codegemma": "define internal i32 @kv_force_dpm_lowest(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @amdgpu_kv_dpm_get_enable_mask(ptr noundef %0, ptr noundef nonnull %1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B1, label %B6\n\nB1:\n%4 = load i32, ptr @SMU7_MAX_LEVELS_GRAPHICS, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = phi i32 [ %10, %B2 ], [ 0, %B1 ]\n%7 = load i32, ptr %1, align 4\n%8 = shl nuw i32 1, %6\n%9 = and i32 %7, %8\n%10 = add nuw nsw i32 %6, 1\n%11 = icmp eq i32 %10, %4\nbr i1 %11, label %B3, label %B2\n\nB3:\n%12 = load i64, ptr %0, align 8\n%13 = load i64, ptr @CHIP_KABINI, align 8\n%14 = icmp eq i64 %12, %13\n%15 = load i64, ptr @CHIP_MULLINS, align 8\n%16 = icmp eq i64 %12, %15\n%17 = select i1 %14, i1 true, i1 %16\nbr i1 %17, label %B4, label %B5\n\nB4:\n%18 = load i32, ptr @PPSMC_MSG_DPM_ForceState, align 4\n%19 = call i32 @amdgpu_kv_send_msg_to_smc_with_parameter(ptr noundef nonnull %0, i32 noundef %18, i32 noundef %6)\nbr label %B6\n\nB5:\n%20 = call i32 @kv_set_enabled_level(ptr noundef nonnull %0, i32 noundef %6)\nbr label %B6\n\nB6:\n%21 = phi i32 [ %19, %B4 ], [ %20, %B5 ], [ %2, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %21\n}"}, "define internal i32 @arm_bpf_get_reg32(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\n%7 = load i32, ptr %4, align 4\n%8 = call i64 @is_stacked(i32 noundef %7)\n%9 = icmp ne i64 %8, 0\nbr i1 %9, label %10, label %19\n\n10:\n%11 = load i32, ptr %5, align 4\n%12 = load i32, ptr @ARM_FP, align 4\n%13 = load i32, ptr %4, align 4\n%14 = call i32 @EBPF_SCRATCH_TO_ARM_FP(i32 noundef %13)\n%15 = call i32 @ARM_LDR_I(i32 noundef %11, i32 noundef %12, i32 noundef %14)\n%16 = load ptr, ptr %6, align 8\n%17 = call i32 @emit(i32 noundef %15, ptr noundef %16)\n%18 = load i32, ptr %5, align 4\nstore i32 %18, ptr %4, align 4\nbr label %19\n\n19:\n%20 = load i32, ptr %4, align 4\nret i32 %20\n}": {"base_truth": "define internal i32 @arm_bpf_get_reg32(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i64 @is_stacked(i32 noundef %0)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @ARM_FP, align 4\n%6 = tail call i32 @EBPF_SCRATCH_TO_ARM_FP(i32 noundef %0)\n%7 = tail call i32 @ARM_LDR_I(i32 noundef %1, i32 noundef %5, i32 noundef %6)\n%8 = tail call i32 @emit(i32 noundef %7, ptr noundef %2)\nbr label %B2\n\nB2:\n%9 = phi i32 [ %1, %B1 ], [ %0, %B ]\nret i32 %9\n}", "codellama": "define internal i32 @arm_bpf_get_reg32(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i64 @is_stacked(i32 noundef %0)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @ARM_FP, align 4\n%6 = tail call i32 @EBPF_SCRATCH_TO_ARM_FP(i32 noundef %0)\n%7 = tail call i32 @ARM_LDR_I(i32 noundef %1, i32 noundef %5, i32 noundef %6)\n%8 = tail call i32 @emit(i32 noundef %7, ptr noundef %2)\nbr label %B2\n\nB2:\n%9 = phi i32 [ %1, %B1 ], [ %0, %B ]\nret i32 %9\n}", "codegemma": "define internal i32 @arm_bpf_get_reg32(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i64 @is_stacked(i32 noundef %0)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @ARM_FP, align 4\n%6 = tail call i32 @EBPF_SCRATCH_TO_ARM_FP(i32 noundef %0)\n%7 = tail call i32 @ARM_LDR_I(i32 noundef %1, i32 noundef %5, i32 noundef %6)\n%8 = tail call i32 @emit(i32 noundef %7, ptr noundef %2)\nbr label %B2\n\nB2:\n%9 = phi i32 [ %1, %B1 ], [ %0, %B ]\nret i32 %9\n}"}, "define internal ptr @extent_changeset_alloc() {\n%1 = alloca ptr, align 8\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%4 = load i32, ptr @GFP_KERNEL, align 4\n%5 = call ptr @kmalloc(i32 noundef 4, i32 noundef %4)\nstore ptr %5, ptr %2, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %9, label %8\n\n8:\nstore ptr null, ptr %1, align 8\nstore i32 1, ptr %3, align 4\nbr label %13\n\n9:\n%10 = load ptr, ptr %2, align 8\n%11 = call i32 @extent_changeset_init(ptr noundef %10)\n%12 = load ptr, ptr %2, align 8\nstore ptr %12, ptr %1, align 8\nstore i32 1, ptr %3, align 4\nbr label %13\n\n13:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\n%14 = load ptr, ptr %1, align 8\nret ptr %14\n}": {"base_truth": "define internal ptr @extent_changeset_alloc() {\nB:\n%0 = load i32, ptr @GFP_KERNEL, align 4\n%1 = tail call ptr @kmalloc(i32 noundef 4, i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @extent_changeset_init(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret ptr %1\n}", "codellama": "define internal ptr @extent_changeset_alloc() {\nB:\n%0 = load i32, ptr @GFP_KERNEL, align 4\n%1 = tail call ptr @kmalloc(i32 noundef 4, i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @extent_changeset_init(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret ptr %1\n}", "codegemma": "define internal ptr @extent_changeset_alloc() {\nB:\n%0 = load i32, ptr @GFP_KERNEL, align 4\n%1 = tail call ptr @kmalloc(i32 noundef 4, i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @extent_changeset_init(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\nret ptr %1\n}"}, "define dso_local void @SetNoNeedToRead(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %9\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\nstore i32 1, ptr %8, align 4\nbr label %9\n\n9:\nret void\n}": {"base_truth": "define dso_local void @SetNoNeedToRead(ptr noundef writeonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\nstore i32 1, ptr %0, align 4\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @SetNoNeedToRead(ptr noundef writeonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\nstore i32 1, ptr %0, align 4\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @SetNoNeedToRead(ptr noundef writeonly %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\nstore i32 1, ptr %0, align 4\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i32 @unixGetpagesize() {\n%1 = load i32, ptr @_SC_PAGESIZE, align 4\n%2 = call i64 @sysconf(i32 noundef %1)\n%3 = trunc i64 %2 to i32\nret i32 %3\n}": {"base_truth": "define internal i32 @unixGetpagesize() {\nB:\n%0 = load i32, ptr @_SC_PAGESIZE, align 4\n%1 = tail call i64 @sysconf(i32 noundef %0)\n%2 = trunc i64 %1 to i32\nret i32 %2\n}", "codellama": "define internal i32 @unixGetpagesize() {\nB:\n%0 = load i32, ptr @_SC_PAGESIZE, align 4\n%1 = tail call i64 @sysconf(i32 noundef %0)\n%2 = trunc i64 %1 to i32\nret i32 %2\n}", "codegemma": "define internal i32 @unixGetpagesize() {\nB:\n%0 = load i32, ptr @_SC_PAGESIZE, align 4\n%1 = tail call i64 @sysconf(i32 noundef %0)\n%2 = trunc i64 %1 to i32\nret i32 %2\n}"}, "define dso_local void @finish(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr @server, align 4\n%4 = call i32 @close(i32 noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = call i32 @exit(i32 noundef %5)\nunreachable\n}": {"base_truth": "define dso_local void @finish(i32 noundef %0) {\nB:\n%1 = load i32, ptr @server, align 4\n%2 = tail call i32 @close(i32 noundef %1)\n%3 = tail call i32 @exit(i32 noundef %0)\nunreachable\n}", "codellama": "define dso_local void @finish(i32 noundef %0) {\nB:\n%1 = load i32, ptr @server, align 4\n%2 = tail call i32 @close(i32 noundef %1)\n%3 = tail call i32 @exit(i32 noundef %0)\nunreachable\n}", "codegemma": "define dso_local void @finish(i32 noundef %0) {\nB:\n%1 = load i32, ptr @server, align 4\n%2 = tail call i32 @close(i32 noundef %1)\n%3 = tail call i32 @exit(i32 noundef %0)\nunreachable\n}"}, "define dso_local i32 @xdr_COMMIT3args(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load ptr, ptr %5, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 2\n%9 = call i32 @xdr_nfs_fh3(ptr noundef %6, ptr noundef %8)\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %13, label %11\n\n11:\n%12 = load i32, ptr @FALSE, align 4\nstore i32 %12, ptr %3, align 4\nbr label %31\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = load ptr, ptr %5, align 8\n%16 = getelementptr inbounds %struct.TYPE_3__, ptr %15, i32 0, i32 1\n%17 = call i32 @xdr_offset3(ptr noundef %14, ptr noundef %16)\n%18 = icmp ne i32 %17, 0\nbr i1 %18, label %21, label %19\n\n19:\n%20 = load i32, ptr @FALSE, align 4\nstore i32 %20, ptr %3, align 4\nbr label %31\n\n21:\n%22 = load ptr, ptr %4, align 8\n%23 = load ptr, ptr %5, align 8\n%24 = getelementptr inbounds %struct.TYPE_3__, ptr %23, i32 0, i32 0\n%25 = call i32 @xdr_count3(ptr noundef %22, ptr noundef %24)\n%26 = icmp ne i32 %25, 0\nbr i1 %26, label %29, label %27\n\n27:\n%28 = load i32, ptr @FALSE, align 4\nstore i32 %28, ptr %3, align 4\nbr label %31\n\n29:\n%30 = load i32, ptr @TRUE, align 4\nstore i32 %30, ptr %3, align 4\nbr label %31\n\n31:\n%32 = load i32, ptr %3, align 4\nret i32 %32\n}": {"base_truth": "define dso_local i32 @xdr_COMMIT3args(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = tail call i32 @xdr_nfs_fh3(ptr noundef %0, ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%6 = tail call i32 @xdr_offset3(ptr noundef %0, ptr noundef nonnull %5)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = tail call i32 @xdr_count3(ptr noundef %0, ptr noundef %1)\n%9 = icmp eq i32 %8, 0\n%10 = select i1 %9, ptr @FALSE, ptr @TRUE\nbr label %B3\n\nB3:\n%11 = phi ptr [ @FALSE, %B ], [ @FALSE, %B1 ], [ %10, %B2 ]\n%12 = load i32, ptr %11, align 4\nret i32 %12\n}", "codellama": "define dso_local i32 @xdr_COMMIT3args(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = tail call i32 @xdr_nfs_fh3(ptr noundef %0, ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%6 = tail call i32 @xdr_offset3(ptr noundef %0, ptr noundef nonnull %5)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = tail call i32 @xdr_count3(ptr noundef %0, ptr noundef %1)\n%9 = icmp eq i32 %8, 0\n%10 = select i1 %9, ptr @FALSE, ptr @TRUE\nbr label %B3\n\nB3:\n%11 = phi ptr [ @FALSE, %B ], [ @FALSE, %B1 ], [ %10, %B2 ]\n%12 = load i32, ptr %11, align 4\nret i32 %12\n}", "codegemma": "define dso_local i32 @xdr_COMMIT3args(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 2\n%3 = tail call i32 @xdr_nfs_fh3(ptr noundef %0, ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B3, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%6 = tail call i32 @xdr_offset3(ptr noundef %0, ptr noundef nonnull %5)\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = tail call i32 @xdr_count3(ptr noundef %0, ptr noundef %1)\n%9 = icmp eq i32 %8, 0\n%10 = select i1 %9, ptr @FALSE, ptr @TRUE\nbr label %B3\n\nB3:\n%11 = phi ptr [ @FALSE, %B ], [ @FALSE, %B1 ], [ %10, %B2 ]\n%12 = load i32, ptr %11, align 4\nret i32 %12\n}"}, "define dso_local void @shlib_first() {\n%1 = call i32 @shlib_second(i32 noundef 0)\nret void\n}": {"base_truth": "define dso_local void @shlib_first() {\nB:\n%0 = tail call i32 @shlib_second(i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @shlib_first() {\nB:\n%0 = tail call i32 @shlib_second(i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @shlib_first() {\nB:\n%0 = tail call i32 @shlib_second(i32 noundef 0)\nret void\n}"}, "define internal void @sfs_vnode_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @vfs_hash_remove(ptr noundef %3)\nret void\n}": {"base_truth": "define internal void @sfs_vnode_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @vfs_hash_remove(ptr noundef %0)\nret void\n}", "codellama": "define internal void @sfs_vnode_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @vfs_hash_remove(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @sfs_vnode_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @vfs_hash_remove(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @tlsv1_server_get_write_alerts(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.tlsv1_server ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @tlsv1_server_get_write_alerts(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @tlsv1_server_get_write_alerts(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @tlsv1_server_get_write_alerts(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local i32 @ogg_sync_wrote(ptr noundef %0, i64 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i64 @ogg_sync_check(ptr noundef %6)\n%8 = icmp ne i64 %7, 0\nbr i1 %8, label %9, label %10\n\n9:\nstore i32 -1, ptr %3, align 4\nbr label %27\n\n10:\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.TYPE_4__, ptr %11, i32 0, i32 0\n%13 = load i64, ptr %12, align 8\n%14 = load i64, ptr %5, align 8\n%15 = add nsw i64 %13, %14\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %16, i32 0, i32 1\n%18 = load i64, ptr %17, align 8\n%19 = icmp sgt i64 %15, %18\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 -1, ptr %3, align 4\nbr label %27\n\n21:\n%22 = load i64, ptr %5, align 8\n%23 = load ptr, ptr %4, align 8\n%24 = getelementptr inbounds %struct.TYPE_4__, ptr %23, i32 0, i32 0\n%25 = load i64, ptr %24, align 8\n%26 = add nsw i64 %25, %22\nstore i64 %26, ptr %24, align 8\nstore i32 0, ptr %3, align 4\nbr label %27\n\n27:\n%28 = load i32, ptr %3, align 4\nret i32 %28\n}": {"base_truth": "define dso_local i32 @ogg_sync_wrote(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @ogg_sync_check(ptr noundef %0)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B3\n\nB1:\n%4 = load i64, ptr %0, align 8\n%5 = add nsw i64 %4, %1\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%7 = load i64, ptr %6, align 8\n%8 = icmp sgt i64 %5, %7\nbr i1 %8, label %B3, label %B2\n\nB2:\nstore i64 %5, ptr %0, align 8\nbr label %B3\n\nB3:\n%9 = phi i32 [ 0, %B2 ], [ -1, %B ], [ -1, %B1 ]\nret i32 %9\n}", "codellama": "define dso_local i32 @ogg_sync_wrote(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @ogg_sync_check(ptr noundef %0)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B3\n\nB1:\n%4 = load i64, ptr %0, align 8\n%5 = add nsw i64 %4, %1\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%7 = load i64, ptr %6, align 8\n%8 = icmp sgt i64 %5, %7\nbr i1 %8, label %B3, label %B2\n\nB2:\nstore i64 %5, ptr %0, align 8\nbr label %B3\n\nB3:\n%9 = phi i32 [ 0, %B2 ], [ -1, %B ], [ -1, %B1 ]\nret i32 %9\n}", "codegemma": "define dso_local i32 @ogg_sync_wrote(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @ogg_sync_check(ptr noundef %0)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B1, label %B3\n\nB1:\n%4 = load i64, ptr %0, align 8\n%5 = add nsw i64 %4, %1\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%7 = load i64, ptr %6, align 8\n%8 = icmp sgt i64 %5, %7\nbr i1 %8, label %B3, label %B2\n\nB2:\nstore i64 %5, ptr %0, align 8\nbr label %B3\n\nB3:\n%9 = phi i32 [ 0, %B2 ], [ -1, %B ], [ -1, %B1 ]\nret i32 %9\n}"}, "define dso_local i32 @suncore_mouse_baud_detection(i8 noundef zeroext %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i8, align 1\n%5 = alloca i32, align 4\nstore i8 %0, ptr %4, align 1\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %5, align 4\n%7 = icmp ne i32 %6, 0\nbr i1 %7, label %8, label %16\n\n8:\n%9 = load i32, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %11, label %15\n\n11:\n%12 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%13 = icmp slt i32 %12, 8\nbr i1 %13, label %14, label %15\n\n14:\nstore i32 1, ptr %3, align 4\nbr label %28\n\n15:\nstore i32 0, ptr @suncore_mouse_baud_detection.ctr, align 4\nstore i32 1, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\nstore i32 2, ptr %3, align 4\nbr label %28\n\n16:\n%17 = load i32, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\n%18 = icmp ne i32 %17, 0\nbr i1 %18, label %19, label %27\n\n19:\n%20 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%21 = add nsw i32 %20, 1\nstore i32 %21, ptr @suncore_mouse_baud_detection.ctr, align 4\n%22 = load i8, ptr %4, align 1\n%23 = zext i8 %22 to i32\n%24 = icmp eq i32 %23, 135\nbr i1 %24, label %25, label %26\n\n25:\nstore i32 0, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\nbr label %26\n\n26:\nstore i32 1, ptr %3, align 4\nbr label %28\n\n27:\nstore i32 0, ptr %3, align 4\nbr label %28\n\n28:\n%29 = load i32, ptr %3, align 4\nret i32 %29\n}": {"base_truth": "define dso_local i32 @suncore_mouse_baud_detection(i8 noundef zeroext %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\n%3 = load i32, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\nbr i1 %2, label %B3, label %B1\n\nB1:\n%4 = icmp ne i32 %3, 0\n%5 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%6 = icmp slt i32 %5, 8\n%7 = select i1 %4, i1 %6, i1 false\nbr i1 %7, label %B6, label %B2\n\nB2:\nstore i32 0, ptr @suncore_mouse_baud_detection.ctr, align 4\nbr label %B5\n\nB3:\n%8 = icmp eq i32 %3, 0\nbr i1 %8, label %B6, label %B4\n\nB4:\n%9 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%10 = add nsw i32 %9, 1\nstore i32 %10, ptr @suncore_mouse_baud_detection.ctr, align 4\n%11 = icmp eq i8 %0, -121\nbr i1 %11, label %B5, label %B6\n\nB5:\n%12 = phi i32 [ 1, %B2 ], [ 0, %B4 ]\n%13 = phi i32 [ 2, %B2 ], [ 1, %B4 ]\nstore i32 %12, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\nbr label %B6\n\nB6:\n%14 = phi i32 [ 1, %B1 ], [ 1, %B4 ], [ 0, %B3 ], [ %13, %B5 ]\nret i32 %14\n}", "codellama": "define dso_local i32 @suncore_mouse_baud_detection(i8 noundef zeroext %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\n%3 = load i32, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\n%4 = icmp ne i32 %3, 0\n%5 = icmp slt i32 %3, 8\n%6 = select i1 %2, i1 %4, i1 %5\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%8 = icmp slt i32 %7, 8\nbr i1 %8, label %B3, label %B2\n\nB2:\nstore i32 0, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\nbr label %B3\n\nB3:\n%9 = phi i32 [ 2, %B2 ], [ 1, %B ], [ 1, %B1 ]\nret i32 %9\n}", "codegemma": "define dso_local i32 @suncore_mouse_baud_detection(i8 noundef zeroext %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\n%3 = load i32, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\n%4 = icmp ne i32 %3, 0\n%5 = icmp slt i32 %3, 8\n%6 = and i1 %4, %5\nbr i1 %2, label %B2, label %B1\n\nB1:\n%7 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%8 = icmp slt i32 %7, 8\n%9 = icmp ne i32 %3, 0\n%10 = and i1 %8, %9\nbr i1 %10, label %B3, label %B4\n\nB2:\n%11 = load i32, ptr @suncore_mouse_baud_detection.ctr, align 4\n%12 = add nsw i32 %11, 1\nstore i32 %12, ptr @suncore_mouse_baud_detection.ctr, align 4\n%13 = icmp eq i8 %0, 135\nbr i1 %13, label %B3, label %B4\n\nB3:\n%14 = phi i32 [ 1, %B1 ], [ 0, %B2 ]\nstore i32 0, ptr @suncore_mouse_baud_detection.mouse_got_break, align 4\nbr label %B4\n\nB4:\n%15 = phi i32 [ 1, %B3 ], [ 1, %B2 ], [ 0, %B1 ]\nret i32 %15\n}"}, "define internal i32 @ngx_rtmp_access_play(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load i32, ptr @NGX_RTMP_ACCESS_PLAY, align 4\n%8 = call i64 @ngx_rtmp_access(ptr noundef %6, i32 noundef %7)\n%9 = load i64, ptr @NGX_OK, align 8\n%10 = icmp ne i64 %8, %9\nbr i1 %10, label %11, label %13\n\n11:\n%12 = load i32, ptr @NGX_ERROR, align 4\nstore i32 %12, ptr %3, align 4\nbr label %17\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = load ptr, ptr %5, align 8\n%16 = call i32 @next_play(ptr noundef %14, ptr noundef %15)\nstore i32 %16, ptr %3, align 4\nbr label %17\n\n17:\n%18 = load i32, ptr %3, align 4\nret i32 %18\n}": {"base_truth": "define internal i32 @ngx_rtmp_access_play(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @NGX_RTMP_ACCESS_PLAY, align 4\n%3 = tail call i64 @ngx_rtmp_access(ptr noundef %0, i32 noundef %2)\n%4 = load i64, ptr @NGX_OK, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = load i32, ptr @NGX_ERROR, align 4\nbr label %B3\n\nB2:\n%7 = tail call i32 @next_play(ptr noundef %0, ptr noundef %1)\nbr label %B3\n\nB3:\n%8 = phi i32 [ %6, %B1 ], [ %7, %B2 ]\nret i32 %8\n}", "codellama": "define internal i32 @ngx_rtmp_access_play(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @NGX_RTMP_ACCESS_PLAY, align 4\n%3 = tail call i64 @ngx_rtmp_access(ptr noundef %0, i32 noundef %2)\n%4 = load i64, ptr @NGX_OK, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = load i32, ptr @NGX_ERROR, align 4\nbr label %B3\n\nB2:\n%7 = tail call i32 @next_play(ptr noundef %0, ptr noundef %1)\nbr label %B3\n\nB3:\n%8 = phi i32 [ %6, %B1 ], [ %7, %B2 ]\nret i32 %8\n}", "codegemma": "define internal i32 @ngx_rtmp_access_play(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @NGX_RTMP_ACCESS_PLAY, align 4\n%3 = tail call i64 @ngx_rtmp_access(ptr noundef %0, i32 noundef %2)\n%4 = load i64, ptr @NGX_OK, align 8\n%5 = icmp eq i64 %3, %4\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = load i32, ptr @NGX_ERROR, align 4\nbr label %B3\n\nB2:\n%7 = tail call i32 @next_play(ptr noundef %0, ptr noundef %1)\nbr label %B3\n\nB3:\n%8 = phi i32 [ %6, %B1 ], [ %7, %B2 ]\nret i32 %8\n}"}, "define dso_local void @tlsProcessPendingData() {\nret void\n}": {"base_truth": "define dso_local void @tlsProcessPendingData() {\nB:\nret void\n}", "codellama": "define dso_local void @tlsProcessPendingData() {\nB:\nret void\n}", "codegemma": "define dso_local void @tlsProcessPendingData() {\nB:\nret void\n}"}, "define dso_local i32 @Fcdar(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @istype(i32 noundef %6, i32 noundef 1)\n%8 = icmp ne i32 %7, 0\nbr i1 %8, label %9, label %19\n\n9:\n%10 = load i32, ptr %4, align 4\n%11 = call i32 @car(i32 noundef %10)\nstore i32 %11, ptr %4, align 4\n%12 = call i32 @istype(i32 noundef %11, i32 noundef 1)\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %14, label %19\n\n14:\n%15 = load i32, ptr %4, align 4\n%16 = call i32 @car(i32 noundef %15)\nstore i32 %16, ptr %4, align 4\n%17 = call i32 @istype(i32 noundef %16, i32 noundef 1)\n%18 = icmp ne i32 %17, 0\nbr i1 %18, label %20, label %19\n\n19:\nstore i32 16777215, ptr %3, align 4\nbr label %23\n\n20:\n%21 = load i32, ptr %4, align 4\n%22 = call i32 @cdr(i32 noundef %21)\nstore i32 %22, ptr %3, align 4\nbr label %23\n\n23:\n%24 = load i32, ptr %3, align 4\nret i32 %24\n}": {"base_truth": "define dso_local i32 @Fcdar(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @istype(i32 noundef %0, i32 noundef 1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i32 @car(i32 noundef %0)\n%5 = tail call i32 @istype(i32 noundef %4, i32 noundef 1)\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B4, label %B2\n\nB2:\n%7 = tail call i32 @car(i32 noundef %4)\n%8 = tail call i32 @istype(i32 noundef %7, i32 noundef 1)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = tail call i32 @cdr(i32 noundef %7)\nbr label %B4\n\nB4:\n%11 = phi i32 [ %10, %B3 ], [ 16777215, %B2 ], [ 16777215, %B1 ], [ 16777215, %B ]\nret i32 %11\n}", "codellama": "define dso_local i32 @Fcdar(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @istype(i32 noundef %0, i32 noundef 1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i32 @car(i32 noundef %0)\n%5 = tail call i32 @istype(i32 noundef %4, i32 noundef 1)\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B4, label %B2\n\nB2:\n%7 = tail call i32 @car(i32 noundef %4)\n%8 = tail call i32 @istype(i32 noundef %7, i32 noundef 1)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = tail call i32 @cdr(i32 noundef %7)\nbr label %B4\n\nB4:\n%11 = phi i32 [ %10, %B3 ], [ 16777215, %B2 ], [ 16777215, %B1 ], [ 16777215, %B ]\nret i32 %11\n}", "codegemma": "define dso_local i32 @Fcdar(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @istype(i32 noundef %0, i32 noundef 1)\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = tail call i32 @car(i32 noundef %0)\n%5 = tail call i32 @istype(i32 noundef %4, i32 noundef 1)\n%6 = icmp eq i32 %5, 0\nbr i1 %6, label %B4, label %B2\n\nB2:\n%7 = tail call i32 @car(i32 noundef %4)\n%8 = tail call i32 @istype(i32 noundef %7, i32 noundef 1)\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B4, label %B3\n\nB3:\n%10 = tail call i32 @cdr(i32 noundef %7)\nbr label %B4\n\nB4:\n%11 = phi i32 [ %10, %B3 ], [ 16777215, %B2 ], [ 16777215, %B1 ], [ 16777215, %B ]\nret i32 %11\n}"}, "define dso_local i32 @apr_pool_abort_get(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @apr_pool_abort_get(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @apr_pool_abort_get(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @apr_pool_abort_get(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local void @Displayer_display_example_passed() {\n%1 = call i32 (...) @displays_example_passed()\nret void\n}": {"base_truth": "define dso_local void @Displayer_display_example_passed() {\nB:\n%0 = tail call i32 (...) @displays_example_passed()\nret void\n}", "codellama": "define dso_local void @Displayer_display_example_passed() {\nB:\n%0 = tail call i32 (...) @displays_example_passed()\nret void\n}", "codegemma": "define dso_local void @Displayer_display_example_passed() {\nB:\n%0 = tail call i32 (...) @displays_example_passed()\nret void\n}"}, "define internal ptr @sctp_auth_make_peer_vector(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.sctp_association ptr %5, i32 0, i32 0\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i32 0, i32 2\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.sctp_association ptr %9, i32 0, i32 0\n%11 = getelementptr inbounds %struct.TYPE_2__, ptr %10, i32 0, i32 1\n%12 = load i32, ptr %11, align 4\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.sctp_association ptr %13, i32 0, i32 0\n%15 = getelementptr inbounds %struct.TYPE_2__, ptr %14, i32 0, i32 0\n%16 = load i32, ptr %15, align 4\n%17 = load i32, ptr %4, align 4\n%18 = call ptr @sctp_auth_make_key_vector(i32 noundef %8, i32 noundef %12, i32 noundef %16, i32 noundef %17)\nret ptr %18\n}": {"base_truth": "define internal ptr @sctp_auth_make_peer_vector(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr %0, align 4\n%7 = tail call ptr @sctp_auth_make_key_vector(i32 noundef %3, i32 noundef %5, i32 noundef %6, i32 noundef %1)\nret ptr %7\n}", "codellama": "define internal ptr @sctp_auth_make_peer_vector(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr %0, align 4\n%7 = tail call ptr @sctp_auth_make_key_vector(i32 noundef %3, i32 noundef %5, i32 noundef %6, i32 noundef %1)\nret ptr %7\n}", "codegemma": "define internal ptr @sctp_auth_make_peer_vector(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr %0, align 4\n%7 = tail call ptr @sctp_auth_make_key_vector(i32 noundef %3, i32 noundef %5, i32 noundef %6, i32 noundef %1)\nret ptr %7\n}"}, "define dso_local i32 @fus_compiler_frame_stack_size_bubbles_up(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @fus_compiler_frame_is_root_scope(i32 noundef %3)\n%5 = icmp ne i32 %4, 0\nbr i1 %5, label %9, label %6\n\n6:\n%7 = load i32, ptr %2, align 4\n%8 = icmp ne i32 %7, 3\nbr label %9\n\n9:\n%10 = phi i1 [ false, %1 ], [ %8, %6 ]\n%11 = zext i1 %10 to i32\nret i32 %11\n}": {"base_truth": "define dso_local i32 @fus_compiler_frame_stack_size_bubbles_up(i32 noundef %0) {\nB:\n%1 = tail call i32 @fus_compiler_frame_is_root_scope(i32 noundef %0)\n%2 = icmp eq i32 %1, 0\n%3 = icmp ne i32 %0, 3\n%4 = and i1 %3, %2\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define dso_local i32 @fus_compiler_frame_stack_size_bubbles_up(i32 noundef %0) {\nB:\n%1 = tail call i32 @fus_compiler_frame_is_root_scope(i32 noundef %0)\n%2 = icmp eq i32 %1, 0\n%3 = icmp ne i32 %0, 3\n%4 = and i1 %3, %2\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codegemma": "define dso_local i32 @fus_compiler_frame_stack_size_bubbles_up(i32 noundef %0) {\nB:\n%1 = tail call i32 @fus_compiler_frame_is_root_scope(i32 noundef %0)\n%2 = icmp eq i32 %1, 0\n%3 = icmp ne i32 %0, 3\n%4 = and i1 %3, %2\n%5 = zext i1 %4 to i32\nret i32 %5\n}"}, "define dso_local i32 @msrp_add_reports_line(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = icmp ne ptr %7, null\nbr i1 %8, label %10, label %9\n\n9:\nstore i32 -1, ptr %3, align 4\nbr label %54\n\n10:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\n%11 = load i32, ptr %5, align 4\n%12 = load i32, ptr @MSRP_SUCCESS_REPORT, align 4\n%13 = and i32 %11, %12\n%14 = icmp ne i32 %13, 0\nbr i1 %14, label %15, label %20\n\n15:\n%16 = load ptr, ptr %4, align 8\n%17 = call i32 @msrp_add_line(ptr noundef %16, ptr noundef @.str)\n%18 = load i32, ptr %6, align 4\n%19 = or i32 %18, %17\nstore i32 %19, ptr %6, align 4\nbr label %31\n\n20:\n%21 = load i32, ptr %5, align 4\n%22 = load i32, ptr @MSRP_SUCCESS_REPORT_PARTIAL, align 4\n%23 = and i32 %21, %22\n%24 = icmp ne i32 %23, 0\nbr i1 %24, label %25, label %30\n\n25:\n%26 = load ptr, ptr %4, align 8\n%27 = call i32 @msrp_add_line(ptr noundef %26, ptr noundef @.str.1)\n%28 = load i32, ptr %6, align 4\n%29 = or i32 %28, %27\nstore i32 %29, ptr %6, align 4\nbr label %30\n\n30:\nbr label %31\n\n31:\n%32 = load i32, ptr %5, align 4\n%33 = load i32, ptr @MSRP_FAILURE_REPORT, align 4\n%34 = and i32 %32, %33\n%35 = icmp ne i32 %34, 0\nbr i1 %35, label %36, label %41\n\n36:\n%37 = load ptr, ptr %4, align 8\n%38 = call i32 @msrp_add_line(ptr noundef %37, ptr noundef @.str.2)\n%39 = load i32, ptr %6, align 4\n%40 = or i32 %39, %38\nstore i32 %40, ptr %6, align 4\nbr label %52\n\n41:\n%42 = load i32, ptr %5, align 4\n%43 = load i32, ptr @MSRP_FAILURE_REPORT_PARTIAL, align 4\n%44 = and i32 %42, %43\n%45 = icmp ne i32 %44, 0\nbr i1 %45, label %46, label %51\n\n46:\n%47 = load ptr, ptr %4, align 8\n%48 = call i32 @msrp_add_line(ptr noundef %47, ptr noundef @.str.3)\n%49 = load i32, ptr %6, align 4\n%50 = or i32 %49, %48\nstore i32 %50, ptr %6, align 4\nbr label %51\n\n51:\nbr label %52\n\n52:\n%53 = load i32, ptr %6, align 4\nstore i32 %53, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\nbr label %54\n\n54:\n%55 = load i32, ptr %3, align 4\nret i32 %55\n}": {"base_truth": "define dso_local i32 @msrp_add_reports_line(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B7, label %B1\n\nB1:\n%3 = load i32, ptr @MSRP_SUCCESS_REPORT, align 4\n%4 = and i32 %3, %1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = load i32, ptr @MSRP_SUCCESS_REPORT_PARTIAL, align 4\n%7 = and i32 %6, %1\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = phi ptr [ @.str, %B1 ], [ @.str.1, %B2 ]\n%10 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull %9)\nbr label %B4\n\nB4:\n%11 = phi i32 [ 0, %B2 ], [ %10, %B3 ]\n%12 = load i32, ptr @MSRP_FAILURE_REPORT, align 4\n%13 = and i32 %12, %1\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B5, label %B6\n\nB5:\n%15 = load i32, ptr @MSRP_FAILURE_REPORT_PARTIAL, align 4\n%16 = and i32 %15, %1\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B7, label %B6\n\nB6:\n%18 = phi ptr [ @.str.2, %B4 ], [ @.str.3, %B5 ]\n%19 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull %18)\n%20 = or i32 %19, %11\nbr label %B7\n\nB7:\n%21 = phi i32 [ -1, %B ], [ %11, %B5 ], [ %20, %B6 ]\nret i32 %21\n}", "codellama": "define dso_local i32 @msrp_add_reports_line(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B7, label %B1\n\nB1:\n%3 = load i32, ptr @MSRP_SUCCESS_REPORT, align 4\n%4 = and i32 %3, %1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B6\n\nB3:\n%7 = load i32, ptr @MSRP_SUCCESS_REPORT_PARTIAL, align 4\n%8 = and i32 %7, %1\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B5, label %B4\n\nB4:\n%10 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull @.str.1)\nbr label %B5\n\nB5:\n%11 = phi i32 [ %10, %B4 ], [ 0, %B3 ]\nbr label %B6\n\nB6:\n%12 = phi i32 [ 0, %B2 ], [ %11, %B5 ]\n%13 = load i32, ptr @MSRP_FAILURE_REPORT, align 4\n%14 = and i32 %13, %1\n%15 = icmp eq i32 %14, 0\nbr i1 %15, label %B8, label %B9\n\nB7:\n%16 = tail call i32 @llvm.smax.i32(i32 %12, i32 -1)\nbr label %B10\n\nB8:\n%17 = load i32, ptr @MSRP_FAILURE_REPORT_PARTIAL, align 4\n%18 = and i32 %17, %1\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B10, label %B9\n\nB9:\n%20 = phi ptr [ @.str.2, %B6 ], [ @.str.3, %B8 ]\n%21 = phi i32 [ 0, %B6 ], [ %12, %B8 ]\n%22 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull %20)\n%23 = or i32 %22, %21\nbr label %B10\n\nB10:\n%24 = phi i32 [ %16, %B7 ], [ %23, %B9 ], [ %12, %B8 ]\nret i32 %24\n}", "codegemma": "define dso_local i32 @msrp_add_reports_line(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B7, label %B1\n\nB1:\n%3 = load i32, ptr @MSRP_SUCCESS_REPORT, align 4\n%4 = and i32 %3, %1\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B7\n\nB3:\n%7 = load i32, ptr @MSRP_SUCCESS_REPORT_PARTIAL, align 4\n%8 = and i32 %7, %1\n%9 = icmp eq i32 %8, 0\nbr i1 %9, label %B5, label %B4\n\nB4:\n%10 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull @.str.1)\nbr label %B7\n\nB5:\n%11 = load i32, ptr @MSRP_FAILURE_REPORT, align 4\n%12 = and i32 %11, %1\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B7, label %B6\n\nB6:\n%14 = tail call i32 @msrp_add_line(ptr noundef nonnull %0, ptr noundef nonnull @.str.2)\nbr label %B7\n\nB7:\n%15 = phi i32 [ -1, %B ], [ %14, %B6 ], [ %10, %B4 ], [ %6, %B2 ]\nret i32 %15\n}"}, "define dso_local void @audit_arg_atfd1(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = call ptr (...) @currecord()\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %8, label %9\n\n8:\nstore i32 1, ptr %4, align 4\nbr label %17\n\n9:\n%10 = load i32, ptr %2, align 4\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.kaudit_record ptr %11, i32 0, i32 0\n%13 = getelementptr inbounds %struct.TYPE_2__, ptr %12, i32 0, i32 0\nstore i32 %10, ptr %13, align 4\n%14 = load ptr, ptr %3, align 8\n%15 = load i32, ptr @ARG_ATFD1, align 4\n%16 = call i32 @ARG_SET_VALID(ptr noundef %14, i32 noundef %15)\nstore i32 0, ptr %4, align 4\nbr label %17\n\n17:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\n%18 = load i32, ptr %4, align 4\nswitch i32 %18, label %20 [\ni32 0, label %19\ni32 1, label %19\n]\n\n19:\nret void\n\n20:\nunreachable\n}": {"base_truth": "define dso_local void @audit_arg_atfd1(i32 noundef %0) {\nB:\n%1 = tail call ptr (...) @currecord()\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\nstore i32 %0, ptr %1, align 4\n%3 = load i32, ptr @ARG_ATFD1, align 4\n%4 = tail call i32 @ARG_SET_VALID(ptr noundef nonnull %1, i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @audit_arg_atfd1(i32 noundef %0) {\nB:\n%1 = tail call ptr (...) @currecord()\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\nstore i32 %0, ptr %1, align 4\n%3 = load i32, ptr @ARG_ATFD1, align 4\n%4 = tail call i32 @ARG_SET_VALID(ptr noundef nonnull %1, i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @audit_arg_atfd1(i32 noundef %0) {\nB:\n%1 = tail call ptr (...) @currecord()\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\nstore i32 %0, ptr %1, align 4\n%3 = load i32, ptr @ARG_ATFD1, align 4\n%4 = tail call i32 @ARG_SET_VALID(ptr noundef nonnull %1, i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @XXH32_reset(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca %struct.TYPE_6__, align 8\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 24, ptr %5)\n%6 = call i32 @memset(ptr noundef %5, i32 noundef 0, i32 noundef 24)\n%7 = load i32, ptr %4, align 4\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 0\nstore i32 %7, ptr %8, align 8\n%9 = load i32, ptr %4, align 4\n%10 = add i32 %9, -1640531535\n%11 = add i32 %10, -2048144777\n%12 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 1\nstore i32 %11, ptr %12, align 4\n%13 = load i32, ptr %4, align 4\n%14 = add i32 %13, -2048144777\n%15 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 2\nstore i32 %14, ptr %15, align 8\n%16 = load i32, ptr %4, align 4\n%17 = add i32 %16, 0\n%18 = zext i32 %17 to i64\n%19 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 4\nstore i64 %18, ptr %19, align 8\n%20 = load i32, ptr %4, align 4\n%21 = sub i32 %20, -1640531535\n%22 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 3\nstore i32 %21, ptr %22, align 4\n%23 = load ptr, ptr %3, align 8\n%24 = call i32 @memcpy(ptr noundef %23, ptr noundef %5, i32 noundef 24)\n%25 = load i32, ptr @XXH_OK, align 4\ncall void @llvm.lifetime.end.p0(i64 24, ptr %5)\nret i32 %25\n}": {"base_truth": "define dso_local i32 @XXH32_reset(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_6__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %2)\n%3 = call i32 @memset(ptr noundef nonnull %2, i32 noundef 0, i32 noundef 24)\nstore i32 %1, ptr %2, align 8\n%4 = add i32 %1, 606290984\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\nstore i32 %4, ptr %5, align 4\n%6 = add i32 %1, -2048144777\n%7 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 2\nstore i32 %6, ptr %7, align 8\n%8 = zext i32 %1 to i64\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 4\nstore i64 %8, ptr %9, align 8\n%10 = add i32 %1, 1640531535\n%11 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 3\nstore i32 %10, ptr %11, align 4\n%12 = call i32 @memcpy(ptr noundef %0, ptr noundef nonnull %2, i32 noundef 24)\n%13 = load i32, ptr @XXH_OK, align 4\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %2)\nret i32 %13\n}", "codellama": "define dso_local i32 @XXH32_reset(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_6__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %2)\n%3 = call i32 @memset(ptr noundef nonnull %2, i32 noundef 0, i32 noundef 24)\nstore i32 %1, ptr %2, align 8\n%4 = add i32 %1, -1640531535\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\nstore i32 %4, ptr %5, align 4\n%6 = add i32 %1, -2048144777\n%7 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 2\nstore i32 %6, ptr %7, align 8\n%8 = zext i32 %1 to i64\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 4\nstore i64 %8, ptr %9, align 8\nstore i32 %4, ptr %2, align 8\n%10 = call i32 @memcpy(ptr noundef %0, ptr noundef nonnull %2, i32 noundef 24)\n%11 = load i32, ptr @XXH_OK, align 4\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %2)\nret i32 %11\n}", "codegemma": "define dso_local i32 @XXH32_reset(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_6__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %2)\n%3 = call i32 @memset(ptr noundef nonnull %2, i32 noundef 0, i32 noundef 24)\nstore i32 %1, ptr %2, align 8\n%4 = add i32 %1, -1640531535\n%5 = add i32 %4, -2048144777\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 1\nstore i32 %5, ptr %6, align 4\n%7 = add i32 %1, -2048144777\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 2\nstore i32 %7, ptr %8, align 8\n%9 = zext i32 %1 to i64\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 4\nstore i64 %9, ptr %10, align 8\n%11 = add i32 %4, 0\n%12 = getelementptr inbounds %struct.TYPE_6__, ptr %2, i64 0, i32 3\nstore i32 %11, ptr %12, align 4\n%13 = call i32 @memcpy(ptr noundef %0, ptr noundef nonnull %2, i32 noundef 24)\n%14 = load i32, ptr @XXH_OK, align 4\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %2)\nret i32 %14\n}"}, "define dso_local i32 @md_queue_length(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = call i32 @md_mutex_lock(i32 noundef %6)\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\nstore i32 %10, ptr %3, align 4\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %11, i32 0, i32 1\n%13 = load i32, ptr %12, align 4\n%14 = call i32 @md_mutex_unlock(i32 noundef %13)\n%15 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %15\n}": {"base_truth": "define dso_local i32 @md_queue_length(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @md_mutex_lock(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr %1, align 4\n%6 = tail call i32 @md_mutex_unlock(i32 noundef %5)\nret i32 %4\n}", "codellama": "define dso_local i32 @md_queue_length(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @md_mutex_lock(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr %1, align 4\n%6 = tail call i32 @md_mutex_unlock(i32 noundef %5)\nret i32 %4\n}", "codegemma": "define dso_local i32 @md_queue_length(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @md_mutex_lock(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr %1, align 4\n%6 = tail call i32 @md_mutex_unlock(i32 noundef %5)\nret i32 %4\n}"}, "define dso_local void @fftwf_codelet_hf2_20(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @hf2_20, align 4\n%5 = call i32 @fftwf_khc2hc_register(ptr noundef %3, i32 noundef %4, ptr noundef @desc)\nret void\n}": {"base_truth": "define dso_local void @fftwf_codelet_hf2_20(ptr noundef %0) {\nB:\n%1 = load i32, ptr @hf2_20, align 4\n%2 = tail call i32 @fftwf_khc2hc_register(ptr noundef %0, i32 noundef %1, ptr noundef nonnull @desc)\nret void\n}", "codellama": "define dso_local void @fftwf_codelet_hf2_20(ptr noundef %0) {\nB:\n%1 = load i32, ptr @hf2_20, align 4\n%2 = tail call i32 @fftwf_khc2hc_register(ptr noundef %0, i32 noundef %1, ptr noundef nonnull @desc)\nret void\n}", "codegemma": "define dso_local void @fftwf_codelet_hf2_20(ptr noundef %0) {\nB:\n%1 = load i32, ptr @hf2_20, align 4\n%2 = tail call i32 @fftwf_khc2hc_register(ptr noundef %0, i32 noundef %1, ptr noundef nonnull @desc)\nret void\n}"}, "define internal i32 @snd_fm801_playback_pointer(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @snd_pcm_substream_chip(ptr noundef %7)\nstore ptr %8, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.fm801 ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 8\n%12 = load i32, ptr @FM801_START, align 4\n%13 = and i32 %11, %12\n%14 = icmp ne i32 %13, 0\nbr i1 %14, label %16, label %15\n\n15:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %62\n\n16:\n%17 = load ptr, ptr %4, align 8\n%18 = getelementptr inbounds %struct.fm801 ptr %17, i32 0, i32 4\n%19 = call i32 @spin_lock(ptr noundef %18)\n%20 = load ptr, ptr %4, align 8\n%21 = getelementptr inbounds %struct.fm801 ptr %20, i32 0, i32 1\n%22 = load i32, ptr %21, align 4\n%23 = load ptr, ptr %4, align 8\n%24 = getelementptr inbounds %struct.fm801 ptr %23, i32 0, i32 2\n%25 = load i32, ptr %24, align 8\n%26 = sub nsw i32 %25, 1\n%27 = add nsw i32 %22, %26\n%28 = load ptr, ptr %4, align 8\n%29 = load i32, ptr @PLY_COUNT, align 4\n%30 = call i32 @FM801_REG(ptr noundef %28, i32 noundef %29)\n%31 = call i32 @inw(i32 noundef %30)\n%32 = sub nsw i32 %27, %31\n%33 = sext i32 %32 to i64\nstore i64 %33, ptr %5, align 8\n%34 = load ptr, ptr %4, align 8\n%35 = load i32, ptr @IRQ_STATUS, align 4\n%36 = call i32 @FM801_REG(ptr noundef %34, i32 noundef %35)\n%37 = call i32 @inw(i32 noundef %36)\n%38 = load i32, ptr @FM801_IRQ_PLAYBACK, align 4\n%39 = and i32 %37, %38\n%40 = icmp ne i32 %39, 0\nbr i1 %40, label %41, label %53\n\n41:\n%42 = load ptr, ptr %4, align 8\n%43 = getelementptr inbounds %struct.fm801 ptr %42, i32 0, i32 2\n%44 = load i32, ptr %43, align 8\n%45 = sext i32 %44 to i64\n%46 = load i64, ptr %5, align 8\n%47 = add i64 %46, %45\nstore i64 %47, ptr %5, align 8\n%48 = load ptr, ptr %4, align 8\n%49 = getelementptr inbounds %struct.fm801 ptr %48, i32 0, i32 3\n%50 = load i64, ptr %49, align 8\n%51 = load i64, ptr %5, align 8\n%52 = urem i64 %51, %50\nstore i64 %52, ptr %5, align 8\nbr label %53\n\n53:\n%54 = load ptr, ptr %4, align 8\n%55 = getelementptr inbounds %struct.fm801 ptr %54, i32 0, i32 4\n%56 = call i32 @spin_unlock(ptr noundef %55)\n%57 = load ptr, ptr %3, align 8\n%58 = getelementptr inbounds %struct.snd_pcm_substream ptr %57, i32 0, i32 0\n%59 = load i32, ptr %58, align 4\n%60 = load i64, ptr %5, align 8\n%61 = call i32 @bytes_to_frames(i32 noundef %59, i64 noundef %60)\nstore i32 %61, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %62\n\n62:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%63 = load i32, ptr %2, align 4\nret i32 %63\n}": {"base_truth": "define internal i32 @snd_fm801_playback_pointer(ptr noundef %0) {\nB:\n%1 = tail call ptr @snd_pcm_substream_chip(ptr noundef %0)\n%2 = load i32, ptr %1, align 8\n%3 = load i32, ptr @FM801_START, align 4\n%4 = and i32 %3, %2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 4\n%7 = tail call i32 @spin_lock(ptr noundef nonnull %6)\n%8 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 2\n%11 = load i32, ptr %10, align 8\n%12 = load i32, ptr @PLY_COUNT, align 4\n%13 = tail call i32 @FM801_REG(ptr noundef nonnull %1, i32 noundef %12)\n%14 = tail call i32 @inw(i32 noundef %13)\n%15 = add i32 %9, -1\n%16 = add i32 %15, %11\n%17 = sub i32 %16, %14\n%18 = sext i32 %17 to i64\n%19 = load i32, ptr @IRQ_STATUS, align 4\n%20 = tail call i32 @FM801_REG(ptr noundef nonnull %1, i32 noundef %19)\n%21 = tail call i32 @inw(i32 noundef %20)\n%22 = load i32, ptr @FM801_IRQ_PLAYBACK, align 4\n%23 = and i32 %22, %21\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %B3, label %B2\n\nB2:\n%25 = load i32, ptr %10, align 8\n%26 = sext i32 %25 to i64\n%27 = add nsw i64 %26, %18\n%28 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 3\n%29 = load i64, ptr %28, align 8\n%30 = urem i64 %27, %29\nbr label %B3\n\nB3:\n%31 = phi i64 [ %30, %B2 ], [ %18, %B1 ]\n%32 = tail call i32 @spin_unlock(ptr noundef nonnull %6)\n%33 = load i32, ptr %0, align 4\n%34 = tail call i32 @bytes_to_frames(i32 noundef %33, i64 noundef %31)\nbr label %B4\n\nB4:\n%35 = phi i32 [ %34, %B3 ], [ 0, %B ]\nret i32 %35\n}", "codellama": "define internal i32 @snd_fm801_playback_pointer(ptr noundef %0) {\nB:\n%1 = tail call ptr @snd_pcm_substream_chip(ptr noundef %0)\n%2 = load i32, ptr %1, align 8\n%3 = load i32, ptr @FM801_START, align 4\n%4 = and i32 %3, %2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 4\n%7 = tail call i32 @spin_lock(ptr noundef nonnull %6)\n%8 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 2\n%11 = load i32, ptr %10, align 8\n%12 = add nsw i32 %11, -1\n%13 = add nsw i32 %12, %9\n%14 = load i32, ptr @PLY_COUNT, align 4\n%15 = tail call i32 @FM801_REG(ptr noundef nonnull %1, i32 noundef %14)\n%16 = tail call i32 @inw(i32 noundef %15)\n%17 = sub i32 %13, %16\n%18 = sext i32 %17 to i64\n%19 = load i32, ptr @IRQ_STATUS, align 4\n%20 = tail call i32 @FM801_REG(ptr noundef nonnull %1, i32 noundef %19)\n%21 = tail call i32 @inw(i32 noundef %20)\n%22 = load i32, ptr @FM801_IRQ_PLAYBACK, align 4\n%23 = and i32 %22, %21\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %B3, label %B2\n\nB2:\n%25 = load i32, ptr %10, align 8\n%26 = sext i32 %25 to i64\n%27 = add nsw i64 %26, %18\n%28 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 3\n%29 = load i64, ptr %28, align 8\n%30 = urem i64 %27, %29\nbr label %B3\n\nB3:\n%31 = phi i64 [ %30, %B2 ], [ %18, %B1 ]\n%32 = tail call i32 @spin_unlock(ptr noundef nonnull %6)\n%33 = load i32, ptr %0, align 4\n%34 = tail call i32 @bytes_to_frames(i32 noundef %33, i64 noundef %31)\nbr label %B4\n\nB4:\n%35 = phi i32 [ %34, %B3 ], [ 0, %B ]\nret i32 %35\n}", "codegemma": "define internal i32 @snd_fm801_playback_pointer(ptr noundef %0) {\nB:\n%1 = tail call ptr @snd_pcm_substream_chip(ptr noundef %0)\n%2 = load i32, ptr %1, align 8\n%3 = load i32, ptr @FM801_START, align 4\n%4 = and i32 %3, %2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 4\n%7 = tail call i32 @spin_lock(ptr noundef nonnull %6)\n%8 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 2\n%11 = load i32, ptr %10, align 8\n%12 = add i32 %11, -1\n%13 = add i32 %12, %9\n%14 = load i32, ptr @PLY_COUNT, align 4\n%15 = tail call i32 @FM801_REG(ptr noundef nonnull %1, i32 noundef %14)\n%16 = tail call i32 @inw(i32 noundef %15)\n%17 = sub i32 %13, %16\n%18 = sext i32 %17 to i64\n%19 = load i32, ptr @IRQ_STATUS, align 4\n%20 = tail call i32 @FM801_REG(ptr noundef nonnull %1, i32 noundef %19)\n%21 = tail call i32 @inw(i32 noundef %20)\n%22 = load i32, ptr @FM801_IRQ_PLAYBACK, align 4\n%23 = and i32 %22, %21\n%24 = icmp eq i32 %23, 0\nbr i1 %24, label %B3, label %B2\n\nB2:\n%25 = load i32, ptr %10, align 8\n%26 = sext i32 %25 to i64\n%27 = add i64 %18, %26\n%28 = getelementptr inbounds %struct.fm801, ptr %1, i64 0, i32 3\n%29 = load i64, ptr %28, align 8\n%30 = urem i64 %27, %29\nbr label %B3\n\nB3:\n%31 = phi i64 [ %30, %B2 ], [ %18, %B1 ]\n%32 = tail call i32 @spin_unlock(ptr noundef nonnull %6)\n%33 = load i32, ptr %0, align 4\n%34 = tail call i32 @bytes_to_frames(i32 noundef %33, i64 noundef %31)\nbr label %B4\n\nB4:\n%35 = phi i32 [ %34, %B3 ], [ 0, %B ]\nret i32 %35\n}"}, "define internal i32 @ActivateFilter(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\nstore ptr %7, ptr %4, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.TYPE_6__, ptr %8, i32 0, i32 1\n%10 = load i32, ptr %9, align 8\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %12, label %17\n\n12:\n%13 = load ptr, ptr %4, align 8\n%14 = getelementptr inbounds %struct.TYPE_6__, ptr %13, i32 0, i32 0\n%15 = load ptr, ptr %14, align 8\n%16 = icmp eq ptr %15, null\nbr i1 %16, label %17, label %19\n\n17:\n%18 = load i32, ptr @VLC_EGENERIC, align 4\nstore i32 %18, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %36\n\n19:\n%20 = load ptr, ptr %4, align 8\n%21 = call i32 @vlc_object_parent(ptr noundef %20)\n%22 = call i64 @var_Type(i32 noundef %21, ptr noundef @.str)\n%23 = icmp ne i64 %22, 0\nbr i1 %23, label %24, label %26\n\n24:\n%25 = load i32, ptr @VLC_EGENERIC, align 4\nstore i32 %25, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %36\n\n26:\n%27 = load ptr, ptr %4, align 8\n%28 = load i32, ptr @VLC_VAR_INTEGER, align 4\n%29 = call i32 @var_Create(ptr noundef %27, ptr noundef @.str, i32 noundef %28)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%30 = load ptr, ptr %4, align 8\n%31 = load i32, ptr @BuildFilterChain, align 4\n%32 = call i32 @Activate(ptr noundef %30, i32 noundef %31)\nstore i32 %32, ptr %6, align 4\n%33 = load ptr, ptr %4, align 8\n%34 = call i32 @var_Destroy(ptr noundef %33, ptr noundef @.str)\n%35 = load i32, ptr %6, align 4\nstore i32 %35, ptr %2, align 4\nstore i32 1, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\nbr label %36\n\n36:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%37 = load i32, ptr %2, align 4\nret i32 %37\n}": {"base_truth": "define internal i32 @ActivateFilter(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 8\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = load ptr, ptr %0, align 8\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B2, label %B3\n\nB2:\n%6 = load i32, ptr @VLC_EGENERIC, align 4\nbr label %B6\n\nB3:\n%7 = tail call i32 @vlc_object_parent(ptr noundef nonnull %0)\n%8 = tail call i64 @var_Type(i32 noundef %7, ptr noundef nonnull @.str)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B5, label %B4\n\nB4:\n%10 = load i32, ptr @VLC_EGENERIC, align 4\nbr label %B6\n\nB5:\n%11 = load i32, ptr @VLC_VAR_INTEGER, align 4\n%12 = tail call i32 @var_Create(ptr noundef nonnull %0, ptr noundef nonnull @.str, i32 noundef %11)\n%13 = load i32, ptr @BuildFilterChain, align 4\n%14 = tail call i32 @Activate(ptr noundef nonnull %0, i32 noundef %13)\n%15 = tail call i32 @var_Destroy(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B6\n\nB6:\n%16 = phi i32 [ %6, %B2 ], [ %10, %B4 ], [ %14, %B5 ]\nret i32 %16\n}", "codellama": "define internal i32 @ActivateFilter(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 8\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = load ptr, ptr %0, align 8\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B4, label %B2\n\nB2:\n%6 = tail call i32 @vlc_object_parent(ptr noundef nonnull %0)\n%7 = tail call i64 @var_Type(i32 noundef %6, ptr noundef nonnull @.str)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B3, label %B4\n\nB3:\n%9 = load i32, ptr @VLC_VAR_INTEGER, align 4\n%10 = tail call i32 @var_Create(ptr noundef nonnull %0, ptr noundef nonnull @.str, i32 noundef %9)\n%11 = load i32, ptr @BuildFilterChain, align 4\n%12 = tail call i32 @Activate(ptr noundef nonnull %0, i32 noundef %11)\n%13 = tail call i32 @var_Destroy(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B4\n\nB4:\n%14 = phi i32 [ %12, %B3 ], [ %1, %B1 ], [ %2, %B ], [ %7, %B2 ]\n%15 = load i32, ptr @VLC_EGENERIC, align 4\n%16 = icmp eq i32 %14, %15\n%17 = select i1 %16, i32 %15, i32 %14\nret i32 %17\n}", "codegemma": "define internal i32 @ActivateFilter(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 8\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B3, label %B1\n\nB1:\n%4 = load ptr, ptr %0, align 8\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B3, label %B2\n\nB2:\n%6 = tail call i32 @vlc_object_parent(ptr noundef nonnull %0)\n%7 = tail call i64 @var_Type(i32 noundef %6, ptr noundef nonnull @.str)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = load i32, ptr @VLC_EGENERIC, align 4\nbr label %B5\n\nB4:\n%10 = load i32, ptr @VLC_VAR_INTEGER, align 4\n%11 = tail call i32 @var_Create(ptr noundef nonnull %0, ptr noundef nonnull @.str, i32 noundef %10)\n%12 = load i32, ptr @BuildFilterChain, align 4\n%13 = tail call i32 @Activate(ptr noundef nonnull %0, i32 noundef %12)\n%14 = tail call i32 @var_Destroy(ptr noundef nonnull %0, ptr noundef nonnull @.str)\nbr label %B5\n\nB5:\n%15 = phi i32 [ %13, %B4 ], [ %9, %B3 ]\nret i32 %15\n}"}, "define dso_local void @logerror(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\nret void\n}": {"base_truth": "define dso_local void @logerror(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\nret void\n}", "codellama": "define dso_local void @logerror(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\nret void\n}", "codegemma": "define dso_local void @logerror(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\nret void\n}"}, "define dso_local i32 @ic_stmt_if_destroy(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load ptr, ptr %4, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %10, label %8\n\n8:\n%9 = call i32 @puts(ptr noundef @.str)\nstore i32 0, ptr %3, align 4\nbr label %59\n\n10:\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.ic_stmt_if ptr %11, i32 0, i32 2\n%13 = load i64, ptr %12, align 8\n%14 = icmp ne i64 %13, 0\nbr i1 %14, label %15, label %24\n\n15:\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.ic_stmt_if ptr %16, i32 0, i32 2\n%18 = load i64, ptr %17, align 8\n%19 = call i32 @ic_expr_destroy(i64 noundef %18, i32 noundef 1)\n%20 = icmp ne i32 %19, 0\nbr i1 %20, label %23, label %21\n\n21:\n%22 = call i32 @puts(ptr noundef @.str.1)\nstore i32 0, ptr %3, align 4\nbr label %59\n\n23:\nbr label %24\n\n24:\n%25 = load ptr, ptr %4, align 8\n%26 = getelementptr inbounds %struct.ic_stmt_if ptr %25, i32 0, i32 1\n%27 = load i64, ptr %26, align 8\n%28 = icmp ne i64 %27, 0\nbr i1 %28, label %29, label %38\n\n29:\n%30 = load ptr, ptr %4, align 8\n%31 = getelementptr inbounds %struct.ic_stmt_if ptr %30, i32 0, i32 1\n%32 = load i64, ptr %31, align 8\n%33 = call i32 @ic_body_destroy(i64 noundef %32, i32 noundef 1)\n%34 = icmp ne i32 %33, 0\nbr i1 %34, label %37, label %35\n\n35:\n%36 = call i32 @puts(ptr noundef @.str.2)\nstore i32 0, ptr %3, align 4\nbr label %59\n\n37:\nbr label %38\n\n38:\n%39 = load ptr, ptr %4, align 8\n%40 = getelementptr inbounds %struct.ic_stmt_if ptr %39, i32 0, i32 0\n%41 = load i64, ptr %40, align 8\n%42 = icmp ne i64 %41, 0\nbr i1 %42, label %43, label %52\n\n43:\n%44 = load ptr, ptr %4, align 8\n%45 = getelementptr inbounds %struct.ic_stmt_if ptr %44, i32 0, i32 0\n%46 = load i64, ptr %45, align 8\n%47 = call i32 @ic_body_destroy(i64 noundef %46, i32 noundef 1)\n%48 = icmp ne i32 %47, 0\nbr i1 %48, label %51, label %49\n\n49:\n%50 = call i32 @puts(ptr noundef @.str.2)\nstore i32 0, ptr %3, align 4\nbr label %59\n\n51:\nbr label %52\n\n52:\n%53 = load i32, ptr %5, align 4\n%54 = icmp ne i32 %53, 0\nbr i1 %54, label %55, label %58\n\n55:\n%56 = load ptr, ptr %4, align 8\n%57 = call i32 @free(ptr noundef %56)\nbr label %58\n\n58:\nstore i32 1, ptr %3, align 4\nbr label %59\n\n59:\n%60 = load i32, ptr %3, align 4\nret i32 %60\n}": {"base_truth": "define dso_local i32 @ic_stmt_if_destroy(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B13\n\nB2:\n%4 = getelementptr inbounds %struct.ic_stmt_if, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B5, label %B3\n\nB3:\n%7 = tail call i32 @ic_expr_destroy(i64 noundef %5, i32 noundef 1)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B5\n\nB4:\n%9 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.1)\nbr label %B13\n\nB5:\n%10 = getelementptr inbounds %struct.ic_stmt_if, ptr %0, i64 0, i32 1\n%11 = load i64, ptr %10, align 8\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B8, label %B6\n\nB6:\n%13 = tail call i32 @ic_body_destroy(i64 noundef %11, i32 noundef 1)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B7, label %B8\n\nB7:\n%15 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.2)\nbr label %B13\n\nB8:\n%16 = load i64, ptr %0, align 8\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B11, label %B9\n\nB9:\n%18 = tail call i32 @ic_body_destroy(i64 noundef %16, i32 noundef 1)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B10, label %B11\n\nB10:\n%20 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.2)\nbr label %B13\n\nB11:\n%21 = icmp eq i32 %1, 0\nbr i1 %21, label %B13, label %B12\n\nB12:\n%22 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B13\n\nB13:\n%23 = phi i32 [ 0, %B10 ], [ 0, %B7 ], [ 0, %B4 ], [ 0, %B1 ], [ 1, %B12 ], [ 1, %B11 ]\nret i32 %23\n}", "codellama": "define dso_local i32 @ic_stmt_if_destroy(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B11\n\nB2:\n%4 = getelementptr inbounds %struct.ic_stmt_if, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B5, label %B3\n\nB3:\n%7 = tail call i32 @ic_expr_destroy(i64 noundef %5, i32 noundef 1)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B5\n\nB4:\n%9 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.1)\nbr label %B11\n\nB5:\n%10 = getelementptr inbounds %struct.ic_stmt_if, ptr %0, i64 0, i32 1\n%11 = load i64, ptr %10, align 8\n%12 = icmp eq i64 %11, 0\nbr i1 %12, label %B8, label %B6\n\nB6:\n%13 = tail call i32 @ic_body_destroy(i64 noundef %11, i32 noundef 1)\n%14 = icmp eq i32 %13, 0\nbr i1 %14, label %B7, label %B8\n\nB7:\n%15 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.2)\nbr label %B11\n\nB8:\n%16 = load i64, ptr %0, align 8\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B10, label %B9\n\nB9:\n%18 = tail call i32 @ic_body_destroy(i64 noundef %16, i32 noundef 1)\n%19 = icmp eq i32 %18, 0\nbr i1 %19, label %B10, label %B11\n\nB10:\n%20 = icmp eq i32 %1, 0\nbr i1 %20, label %B12, label %B11\n\nB11:\n%21 = phi i32 [ 0, %B7 ], [ 0, %B4 ], [ 0, %B1 ], [ 1, %B10 ], [ 1, %B9 ], [ 1, %B8 ]\n%22 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B12\n\nB12:\n%23 = phi i32 [ 1, %B11 ], [ %21, %B10 ]\nret i32 %23\n}", "codegemma": "define dso_local i32 @ic_stmt_if_destroy(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp eq ptr %0, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str)\nbr label %B13\n\nB2:\n%4 = getelementptr inbounds %struct.ic_stmt_if, ptr %0, i64 0, i32 2\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = tail call i32 @ic_expr_destroy(i64 noundef %5, i32 noundef 1)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B13, label %B4\n\nB4:\n%9 = getelementptr inbounds %struct.ic_stmt_if, ptr %0, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %B6, label %B5\n\nB5:\n%12 = tail call i32 @ic_body_destroy(i64 noundef %10, i32 noundef 1)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B13, label %B6\n\nB6:\n%14 = load i64, ptr %0, align 8\n%15 = icmp eq i64 %14, 0\nbr i1 %15, label %B8, label %B7\n\nB7:\n%16 = tail call i32 @ic_body_destroy(i64 noundef %14, i32 noundef 1)\n%17 = icmp eq i32 %16, 0\nbr i1 %17, label %B13, label %B8\n\nB8:\n%18 = icmp eq i32 %1, 0\nbr i1 %18, label %B13, label %B9\n\nB9:\n%19 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B13\n\nB10:\n%20 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.2)\nbr label %B13\n\nB11:\n%21 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.2)\nbr label %B13\n\nB12:\n%22 = tail call i32 @puts(ptr noundef nonnull dereferenceable(1) @.str.2)\nbr label %B13\n\nB13:\n%23 = phi i32 [ 0, %B1 ], [ 0, %B3 ], [ 0, %B5 ], [ 0, %B7 ], [ 0, %B9 ], [ 0, %B10 ], [ 0, %B11 ], [ 0, %B12 ], [ 1, %B8 ]\nret i32 %23\n}"}, "define internal void @mdio_sync(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load i32, ptr %3, align 4\n%7 = load i32, ptr @Wn4_PhysicalMgmt, align 4\n%8 = add i32 %6, %7\nstore i32 %8, ptr %5, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %4, align 4\n%11 = add nsw i32 %10, -1\nstore i32 %11, ptr %4, align 4\n%12 = icmp sge i32 %11, 0\nbr i1 %12, label %13, label %22\n\n13:\n%14 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%15 = load i32, ptr %5, align 4\n%16 = call i32 @outw(i32 noundef %14, i32 noundef %15)\n%17 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%18 = load i32, ptr @MDIO_SHIFT_CLK, align 4\n%19 = or i32 %17, %18\n%20 = load i32, ptr %5, align 4\n%21 = call i32 @outw(i32 noundef %19, i32 noundef %20)\nbr label %9\n\n22:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @mdio_sync(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @Wn4_PhysicalMgmt, align 4\n%3 = add i32 %2, %0\n%4 = icmp sgt i32 %1, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = phi i32 [ %6, %B1 ], [ %1, %B ]\n%6 = add nsw i32 %5, -1\n%7 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%8 = tail call i32 @outw(i32 noundef %7, i32 noundef %3)\n%9 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%10 = load i32, ptr @MDIO_SHIFT_CLK, align 4\n%11 = or i32 %10, %9\n%12 = tail call i32 @outw(i32 noundef %11, i32 noundef %3)\n%13 = icmp ugt i32 %5, 1\nbr i1 %13, label %B1, label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @mdio_sync(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @Wn4_PhysicalMgmt, align 4\n%3 = add i32 %2, %0\n%4 = icmp sgt i32 %1, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = phi i32 [ %11, %B1 ], [ %1, %B ]\n%6 = phi i32 [ %12, %B1 ], [ %3, %B ]\n%7 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%8 = tail call i32 @outw(i32 noundef %7, i32 noundef %6)\n%9 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%10 = load i32, ptr @MDIO_SHIFT_CLK, align 4\n%11 = add nsw i32 %5, -1\n%12 = add i32 %6, %10\n%13 = icmp ugt i32 %5, 1\n%14 = select i1 %13, i32 %12, i32 %6\n%15 = select i1 %13, i32 %10, i32 0\n%16 = tail call i32 @outw(i32 noundef %9, i32 noundef %14)\n%17 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%18 = tail call i32 @outw(i32 noundef %17, i32 noundef %14)\n%19 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%20 = load i32, ptr @MDIO_SHIFT_CLK, align 4\n%21 = or i32 %20, %15\n%22 = tail call i32 @outw(i32 noundef %19, i32 noundef %21)\n%23 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%24 = tail call i32 @outw(i32 noundef %23, i32 noundef %21)\n%25 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%26 = tail call i32 @outw(i32 noundef %25, i32 noundef %21)\n%27 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%28 = tail call i32 @outw(i32 noundef %27, i32 noundef %21)\n%29 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%30 = tail call i32 @outw(i32 noundef %29, i32 noundef %21)\n%31 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%32 = tail call i32 @outw(i32 noundef %31, i32 noundef %21)\n%33 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%34 = tail call i32 @outw(i32 noundef %33, i32 noundef %21)\n%35 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%36 = tail call i32 @outw(i32 noundef %35, i32 noundef %21)\n%37 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%38 = tail call i32 @outw(i32 noundef %37, i32 noundef %21)\n%39 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%40 = tail call i32 @outw(i32 noundef %39, i32 noundef %21)\n%41 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%42 = tail call i32 @outw(i32 noundef %41, i32 noundef %21)\n%43 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%44 = tail call i32 @outw(i32 noundef %43, i32 noundef %21)\n%45 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%46 = tail call i32 @outw(i32 noundef %45, i32 noundef %21)\n%47 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%48 = tail call i32 @outw(i32 noundef %47, i32 noundef %21)\n%49 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%50 = tail call i32 @outw(i32 noundef %49, i32 noundef %21)\n%51 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%52 = tail call i32 @outw(i32 noundef %51, i32 noundef %21)\n%53 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%54 = tail call i32 @outw(i32 noundef %53, i32 noundef %21)\n%55 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%56 = tail call i32 @outw(i32 noundef %55, i32 noundef %21)\n%57 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%58 = tail call i32 @outw(i32 noundef %57, i32 noundef %21)\n%59 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%60 = tail call i32 @outw(i32 noundef %59, i32 noundef %21)\n%61 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%62 = tail call i32 @outw(i32 noundef %61, i32 noundef %21)\n%63 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%64 = tail call i32 @outw(i32 noundef %63, i32 noundef %21)\n%65 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%66 = tail call i32 @outw(i32 noundef %65, i32 noundef %21)\n%67 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%68 = tail call i32 @outw(i32 noundef %67, i32 noundef %21)\n%69 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%70 = tail call i32 @outw(i32 noundef %69, i32 noundef %21)\n%71 =</s>", "codegemma": "define internal void @mdio_sync(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @Wn4_PhysicalMgmt, align 4\n%3 = add i32 %2, %0\n%4 = icmp sgt i32 %1, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = phi i32 [ %6, %B1 ], [ %1, %B ]\n%6 = add nsw i32 %5, -1\n%7 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%8 = tail call i32 @outw(i32 noundef %7, i32 noundef %3)\n%9 = load i32, ptr @MDIO_DATA_WRITE1, align 4\n%10 = load i32, ptr @MDIO_SHIFT_CLK, align 4\n%11 = or i32 %10, %9\n%12 = tail call i32 @outw(i32 noundef %11, i32 noundef %3)\n%13 = icmp ugt i32 %5, 1\nbr i1 %13, label %B1, label %B2\n\nB2:\nret void\n}"}, "define dso_local void @USART3_IRQHandler() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\nstore ptr @uartPort3, ptr %1, align 8\n%2 = load ptr, ptr %1, align 8\n%3 = call i32 @usartIrqHandler(ptr noundef %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @USART3_IRQHandler() {\nB:\n%0 = tail call i32 @usartIrqHandler(ptr noundef nonnull @uartPort3)\nret void\n}", "codellama": "define dso_local void @USART3_IRQHandler() {\nB:\n%0 = tail call i32 @usartIrqHandler(ptr noundef nonnull @uartPort3)\nret void\n}", "codegemma": "define dso_local void @USART3_IRQHandler() {\nB:\n%0 = tail call i32 @usartIrqHandler(ptr noundef nonnull @uartPort3)\nret void\n}"}, "define dso_local void @hsp2RndDelete(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %5, label %8\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = call i32 @free(ptr noundef %6)\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @hsp2RndDelete(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @hsp2RndDelete(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @hsp2RndDelete(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @ft_strncmp(ptr noundef %0, ptr noundef %1, i64 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i64, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i64 %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\nstore i32 0, ptr %8, align 4\nbr label %10\n\n10:\n%11 = load i64, ptr %7, align 8\n%12 = icmp ugt i64 %11, 0\nbr i1 %12, label %13, label %56\n\n13:\n%14 = load ptr, ptr %5, align 8\n%15 = load i32, ptr %8, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds i8, ptr %14, i64 %16\n%18 = load i8, ptr %17, align 1\n%19 = sext i8 %18 to i32\n%20 = load ptr, ptr %6, align 8\n%21 = load i32, ptr %8, align 4\n%22 = sext i32 %21 to i64\n%23 = getelementptr inbounds i8, ptr %20, i64 %22\n%24 = load i8, ptr %23, align 1\n%25 = sext i8 %24 to i32\n%26 = icmp ne i32 %19, %25\nbr i1 %26, label %27, label %41\n\n27:\n%28 = load ptr, ptr %5, align 8\n%29 = load i32, ptr %8, align 4\n%30 = sext i32 %29 to i64\n%31 = getelementptr inbounds i8, ptr %28, i64 %30\n%32 = load i8, ptr %31, align 1\n%33 = zext i8 %32 to i32\n%34 = load ptr, ptr %6, align 8\n%35 = load i32, ptr %8, align 4\n%36 = sext i32 %35 to i64\n%37 = getelementptr inbounds i8, ptr %34, i64 %36\n%38 = load i8, ptr %37, align 1\n%39 = zext i8 %38 to i32\n%40 = sub nsw i32 %33, %39\nstore i32 %40, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %57\n\n41:\n%42 = load ptr, ptr %5, align 8\n%43 = load i32, ptr %8, align 4\n%44 = sext i32 %43 to i64\n%45 = getelementptr inbounds i8, ptr %42, i64 %44\n%46 = load i8, ptr %45, align 1\n%47 = sext i8 %46 to i32\n%48 = icmp eq i32 %47, 0\nbr i1 %48, label %49, label %50\n\n49:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %57\n\n50:\nbr label %51\n\n51:\n%52 = load i32, ptr %8, align 4\n%53 = add nsw i32 %52, 1\nstore i32 %53, ptr %8, align 4\n%54 = load i64, ptr %7, align 8\n%55 = add i64 %54, -1\nstore i64 %55, ptr %7, align 8\nbr label %10\n\n56:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %57\n\n57:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\n%58 = load i32, ptr %4, align 4\nret i32 %58\n}": {"base_truth": "define dso_local i32 @ft_strncmp(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = phi i64 [ %15, %B4 ], [ 0, %B ]\n%5 = phi i64 [ %16, %B4 ], [ %2, %B ]\n%6 = getelementptr inbounds i8, ptr %0, i64 %4\n%7 = load i8, ptr %6, align 1\n%8 = getelementptr inbounds i8, ptr %1, i64 %4\n%9 = load i8, ptr %8, align 1\n%10 = icmp eq i8 %7, %9\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = zext i8 %7 to i32\n%12 = zext i8 %9 to i32\n%13 = sub nsw i32 %11, %12\nbr label %B5\n\nB3:\n%14 = icmp eq i8 %7, 0\nbr i1 %14, label %B5, label %B4\n\nB4:\n%15 = add nuw i64 %4, 1\n%16 = add i64 %5, -1\n%17 = icmp eq i64 %16, 0\nbr i1 %17, label %B5, label %B1\n\nB5:\n%18 = phi i32 [ %13, %B2 ], [ 0, %B ], [ 0, %B4 ], [ 0, %B3 ]\nret i32 %18\n}", "codellama": "define dso_local i32 @ft_strncmp(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B4, label %B1\n\nB1:\n%4 = phi i64 [ %16, %B3 ], [ %2, %B ]\n%5 = phi i32 [ %15, %B3 ], [ 0, %B ]\n%6 = getelementptr inbounds i8, ptr %0, i64 %5\n%7 = load i8, ptr %6, align 1\n%8 = getelementptr inbounds i8, ptr %1, i64 %5\n%9 = load i8, ptr %8, align 1\n%10 = icmp eq i8 %7, %9\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = sub nsw i8 %7, %9\n%12 = zext i8 %11 to i32\nbr label %B4\n\nB3:\n%13 = icmp eq i8 %7, 0\n%14 = icmp ult i64 %4, 2\n%15 = add nuw nsw i32 %5, 1\n%16 = add i64 %4, -1\n%17 = icmp eq i64 %16, 0\n%18 = select i1 %13, i1 true, i1 %17\nbr i1 %18, label %B4, label %B1\n\nB4:\n%19 = phi i32 [ %12, %B2 ], [ 0, %B ], [ 0, %B3 ]\nret i32 %19\n}", "codegemma": "define dso_local i32 @ft_strncmp(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i64 noundef %2) {\nB:\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B5, label %B1\n\nB1:\n%4 = phi i64 [ %11, %B4 ], [ %2, %B ]\n%5 = phi i32 [ %12, %B4 ], [ 0, %B ]\n%6 = getelementptr inbounds i8, ptr %0, i64 %5\n%7 = load i8, ptr %6, align 1\n%8 = getelementptr inbounds i8, ptr %1, i64 %5\n%9 = load i8, ptr %8, align 1\n%10 = icmp eq i8 %7, %9\nbr i1 %10, label %B3, label %B2\n\nB2:\n%11 = add i64 %4, -1\n%12 = add nuw nsw i32 %5, 1\n%13 = icmp eq i64 %11, 0\nbr i1 %13, label %B5, label %B1\n\nB3:\n%14 = icmp eq i8 %7, 0\nbr i1 %14, label %B5, label %B4\n\nB4:\n%15 = zext i8 %7 to i32\n%16 = zext i8 %9 to i32\n%17 = sub nsw i32 %15, %16\nbr label %B5\n\nB5:\n%18 = phi i32 [ %17, %B4 ], [ 0, %B3 ], [ 0, %B ]\nret i32 %18\n}"}, "define dso_local void @rv515_debugfs(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i64 @r100_debugfs_rbbm_init(ptr noundef %3)\n%5 = icmp ne i64 %4, 0\nbr i1 %5, label %6, label %8\n\n6:\n%7 = call i32 @DRM_ERROR(ptr noundef @.str)\nbr label %8\n\n8:\n%9 = load ptr, ptr %2, align 8\n%10 = call i64 @rv515_debugfs_pipes_info_init(ptr noundef %9)\n%11 = icmp ne i64 %10, 0\nbr i1 %11, label %12, label %14\n\n12:\n%13 = call i32 @DRM_ERROR(ptr noundef @.str.1)\nbr label %14\n\n14:\n%15 = load ptr, ptr %2, align 8\n%16 = call i64 @rv515_debugfs_ga_info_init(ptr noundef %15)\n%17 = icmp ne i64 %16, 0\nbr i1 %17, label %18, label %20\n\n18:\n%19 = call i32 @DRM_ERROR(ptr noundef @.str.1)\nbr label %20\n\n20:\nret void\n}": {"base_truth": "define dso_local void @rv515_debugfs(ptr noundef %0) {\nB:\n%1 = tail call i64 @r100_debugfs_rbbm_init(ptr noundef %0)\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%4 = tail call i64 @rv515_debugfs_pipes_info_init(ptr noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B3\n\nB3:\n%6 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%7 = tail call i64 @rv515_debugfs_ga_info_init(ptr noundef %0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B6, label %B5\n\nB5:\n%9 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str.1)\nbr label %B6\n\nB6:\nret void\n}", "codellama": "define dso_local void @rv515_debugfs(ptr noundef %0) {\nB:\n%1 = tail call i64 @r100_debugfs_rbbm_init(ptr noundef %0)\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%4 = tail call i64 @rv515_debugfs_pipes_info_init(ptr noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B3\n\nB3:\n%6 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%7 = tail call i64 @rv515_debugfs_ga_info_init(ptr noundef %0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B6, label %B5\n\nB5:\n%9 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str.1)\nbr label %B6\n\nB6:\nret void\n}", "codegemma": "define dso_local void @rv515_debugfs(ptr noundef %0) {\nB:\n%1 = tail call i64 @r100_debugfs_rbbm_init(ptr noundef %0)\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\n%4 = tail call i64 @rv515_debugfs_pipes_info_init(ptr noundef %0)\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B3\n\nB3:\n%6 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str.1)\nbr label %B4\n\nB4:\n%7 = tail call i64 @rv515_debugfs_ga_info_init(ptr noundef %0)\n%8 = icmp eq i64 %7, 0\nbr i1 %8, label %B6, label %B5\n\nB5:\n%9 = tail call i32 @DRM_ERROR(ptr noundef nonnull @.str.1)\nbr label %B6\n\nB6:\nret void\n}"}, "define internal void @uiTableModel_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define internal void @uiTableModel_init(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define internal void @uiTableModel_init(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define internal void @uiTableModel_init(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define internal void @smbd_disconnect_rdma_connection(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.smbd_connection ptr %3, i32 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.smbd_connection ptr %6, i32 0, i32 0\n%8 = call i32 @queue_work(i32 noundef %5, ptr noundef %7)\nret void\n}": {"base_truth": "define internal void @smbd_disconnect_rdma_connection(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.smbd_connection, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @queue_work(i32 noundef %2, ptr noundef %0)\nret void\n}", "codellama": "define internal void @smbd_disconnect_rdma_connection(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.smbd_connection, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @queue_work(i32 noundef %2, ptr noundef %0)\nret void\n}", "codegemma": "define internal void @smbd_disconnect_rdma_connection(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.smbd_connection, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @queue_work(i32 noundef %2, ptr noundef %0)\nret void\n}"}, "define dso_local nofpclass(nan inf) double @libballistics_moa2mil(double noundef nofpclass(nan inf) %0, i32 noundef %1) {\n%3 = alloca double, align 8\n%4 = alloca double, align 8\n%5 = alloca i32, align 4\nstore double %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %5, align 4\n%7 = load i32, ptr @MilDotArmy, align 4\n%8 = icmp eq i32 %6, %7\nbr i1 %8, label %9, label %12\n\n9:\n%10 = load double, ptr %4, align 8\n%11 = fdiv fast double %10, 3.375000e+00\nstore double %11, ptr %3, align 8\nbr label %15\n\n12:\n%13 = load double, ptr %4, align 8\n%14 = fdiv fast double %13, 3.438000e+00\nstore double %14, ptr %3, align 8\nbr label %15\n\n15:\n%16 = load double, ptr %3, align 8\nret double %16\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @libballistics_moa2mil(double noundef nofpclass(nan inf) %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MilDotArmy, align 4\n%3 = icmp eq i32 %2, %1\n%4 = select i1 %3, double 0x3FD2F684BDA12F68, double 0x3FD29D8FB62240A2\n%5 = fmul fast double %4, %0\nret double %5\n}", "codellama": "define dso_local nofpclass(nan inf) double @libballistics_moa2mil(double noundef nofpclass(nan inf) %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MilDotArmy, align 4\n%3 = icmp eq i32 %2, %1\n%4 = select i1 %3, double 3.375000e+00, double 3.438000e+00\n%5 = fmul fast double %0, 1.000000e-01\n%6 = fmul fast double %5, %4\nret double %6\n}", "codegemma": "define dso_local nofpclass(nan inf) double @libballistics_moa2mil(double noundef nofpclass(nan inf) %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MilDotArmy, align 4\n%3 = icmp eq i32 %2, %1\n%4 = fdiv fast double %0, 3.375000e+00\n%5 = fdiv fast double %0, 3.438000e+00\n%6 = select i1 %3, double %4, double %5\nret double %6\n}"}, "define internal i32 @mpc_demux_chap_find(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call i32 @mpc_demux_chap_find_inner(ptr noundef %4)\nstore i32 %5, ptr %3, align 4\n%6 = load i32, ptr %3, align 4\n%7 = call i64 @MPC_IS_FAILURE(i32 noundef %6)\n%8 = icmp ne i64 %7, 0\nbr i1 %8, label %9, label %12\n\n9:\n%10 = load ptr, ptr %2, align 8\n%11 = call i32 @mpc_demux_chap_empty(ptr noundef %10)\nbr label %12\n\n12:\n%13 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %13\n}": {"base_truth": "define internal i32 @mpc_demux_chap_find(ptr noundef %0) {\nB:\n%1 = tail call i32 @mpc_demux_chap_find_inner(ptr noundef %0)\n%2 = tail call i64 @MPC_IS_FAILURE(i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @mpc_demux_chap_empty(ptr noundef %0)\nbr label %B2\n\nB2:\nret i32 %1\n}", "codellama": "define internal i32 @mpc_demux_chap_find(ptr noundef %0) {\nB:\n%1 = tail call i32 @mpc_demux_chap_find_inner(ptr noundef %0)\n%2 = tail call i64 @MPC_IS_FAILURE(i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @mpc_demux_chap_empty(ptr noundef %0)\nbr label %B2\n\nB2:\nret i32 %1\n}", "codegemma": "define internal i32 @mpc_demux_chap_find(ptr noundef %0) {\nB:\n%1 = tail call i32 @mpc_demux_chap_find_inner(ptr noundef %0)\n%2 = tail call i64 @MPC_IS_FAILURE(i32 noundef %1)\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @mpc_demux_chap_empty(ptr noundef %0)\nbr label %B2\n\nB2:\nret i32 %1\n}"}, "define dso_local i32 @TOP_LEVEL_linalg_vectorSum_shp(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\nret i32 0\n}": {"base_truth": "define dso_local i32 @TOP_LEVEL_linalg_vectorSum_shp(i32 noundef %0) {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @TOP_LEVEL_linalg_vectorSum_shp(i32 noundef %0) {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @TOP_LEVEL_linalg_vectorSum_shp(i32 noundef %0) {\nB:\nret i32 0\n}"}, "define dso_local i32 @_sqrt_recursion(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = icmp slt i32 %4, 0\nbr i1 %5, label %6, label %7\n\n6:\nstore i32 -1, ptr %2, align 4\nbr label %10\n\n7:\n%8 = load i32, ptr %3, align 4\n%9 = call i32 @find_sqrt(i32 noundef 0, i32 noundef %8)\nstore i32 %9, ptr %2, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %2, align 4\nret i32 %11\n}": {"base_truth": "define dso_local i32 @_sqrt_recursion(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @find_sqrt(i32 noundef 0, i32 noundef %0)\nbr label %B2\n\nB2:\n%3 = phi i32 [ %2, %B1 ], [ -1, %B ]\nret i32 %3\n}", "codellama": "define dso_local i32 @_sqrt_recursion(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @find_sqrt(i32 noundef 0, i32 noundef %0)\nbr label %B2\n\nB2:\n%3 = phi i32 [ %2, %B1 ], [ -1, %B ]\nret i32 %3\n}", "codegemma": "define dso_local i32 @_sqrt_recursion(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @find_sqrt(i32 noundef 0, i32 noundef %0)\nbr label %B2\n\nB2:\n%3 = phi i32 [ %2, %B1 ], [ -1, %B ]\nret i32 %3\n}"}, "define dso_local void @cumanascsi_setup(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\nret void\n}": {"base_truth": "define dso_local void @cumanascsi_setup(ptr nocapture noundef %0, ptr nocapture noundef %1) {\nB:\nret void\n}", "codellama": "define dso_local void @cumanascsi_setup(ptr nocapture noundef %0, ptr nocapture noundef %1) {\nB:\nret void\n}", "codegemma": "define dso_local void @cumanascsi_setup(ptr nocapture noundef %0, ptr nocapture noundef %1) {\nB:\nret void\n}"}, "define dso_local void @emit_writeword_imm(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @assem_debug(ptr noundef @.str, i32 noundef %5, i32 noundef %6)\n%8 = call i32 @output_byte(i32 noundef 199)\n%9 = call i32 @output_modrm(i32 noundef 0, i32 noundef 5, i32 noundef 0)\n%10 = load i32, ptr %4, align 4\n%11 = load i64, ptr @out, align 8\n%12 = trunc i64 %11 to i32\n%13 = sub nsw i32 %10, %12\n%14 = sub nsw i32 %13, 8\n%15 = call i32 @output_w32(i32 noundef %14)\n%16 = load i32, ptr %3, align 4\n%17 = call i32 @output_w32(i32 noundef %16)\nret void\n}": {"base_truth": "define dso_local void @emit_writeword_imm(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @assem_debug(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 @output_byte(i32 noundef 199)\n%4 = tail call i32 @output_modrm(i32 noundef 0, i32 noundef 5, i32 noundef 0)\n%5 = load i64, ptr @out, align 8\n%6 = trunc i64 %5 to i32\n%7 = add i32 %1, -8\n%8 = sub i32 %7, %6\n%9 = tail call i32 @output_w32(i32 noundef %8)\n%10 = tail call i32 @output_w32(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @emit_writeword_imm(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @assem_debug(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 @output_byte(i32 noundef 199)\n%4 = tail call i32 @output_modrm(i32 noundef 0, i32 noundef 5, i32 noundef 0)\n%5 = load i64, ptr @out, align 8\n%6 = trunc i64 %5 to i32\n%7 = add i32 %1, -8\n%8 = sub i32 %7, %6\n%9 = tail call i32 @output_w32(i32 noundef %8)\n%10 = tail call i32 @output_w32(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @emit_writeword_imm(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @assem_debug(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 @output_byte(i32 noundef 199)\n%4 = tail call i32 @output_modrm(i32 noundef 0, i32 noundef 5, i32 noundef 0)\n%5 = load i64, ptr @out, align 8\n%6 = trunc i64 %5 to i32\n%7 = add i32 %1, -8\n%8 = sub i32 %7, %6\n%9 = tail call i32 @output_w32(i32 noundef %8)\n%10 = tail call i32 @output_w32(i32 noundef %0)\nret void\n}"}, "define dso_local zeroext i16 @turtle_get_slot() {\n%1 = load i16, ptr @slot, align 2\nret i16 %1\n}": {"base_truth": "define dso_local zeroext i16 @turtle_get_slot() {\nB:\n%0 = load i16, ptr @slot, align 2\nret i16 %0\n}", "codellama": "define dso_local zeroext i16 @turtle_get_slot() {\nB:\n%0 = load i16, ptr @slot, align 2\nret i16 %0\n}", "codegemma": "define dso_local zeroext i16 @turtle_get_slot() {\nB:\n%0 = load i16, ptr @slot, align 2\nret i16 %0\n}"}, "define dso_local i64 @Q_GetElOrder(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = call i64 (...) @LASResult()\n%5 = load i64, ptr @LASOK, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %7, label %11\n\n7:\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %8, i32 0, i32 0\n%10 = load i64, ptr %9, align 8\nstore i64 %10, ptr %3, align 8\nbr label %12\n\n11:\nstore i64 0, ptr %3, align 8\nbr label %12\n\n12:\n%13 = load i64, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i64 %13\n}": {"base_truth": "define dso_local i64 @Q_GetElOrder(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call i64 (...) @LASResult()\n%2 = load i64, ptr @LASOK, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i64, ptr %0, align 8\nbr label %B2\n\nB2:\n%5 = phi i64 [ %4, %B1 ], [ 0, %B ]\nret i64 %5\n}", "codellama": "define dso_local i64 @Q_GetElOrder(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call i64 (...) @LASResult()\n%2 = load i64, ptr @LASOK, align 8\n%3 = icmp eq i64 %1, %2\n%4 = select i1 %3, ptr %0, ptr @.str\n%5 = load i64, ptr %4, align 8\nret i64 %5\n}", "codegemma": "define dso_local i64 @Q_GetElOrder(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call i64 (...) @LASResult()\n%2 = load i64, ptr @LASOK, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i64, ptr %0, align 8\nbr label %B2\n\nB2:\n%5 = phi i64 [ %4, %B1 ], [ 0, %B ]\nret i64 %5\n}"}, "define internal void @rtl8192_set_mode(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = load i32, ptr @EPROM_CMD, align 4\n%8 = call i32 @read_nic_byte(ptr noundef %6, i32 noundef %7)\nstore i32 %8, ptr %5, align 4\n%9 = load i32, ptr %5, align 4\n%10 = load i32, ptr @EPROM_CMD_OPERATING_MODE_MASK, align 4\n%11 = xor i32 %10, -1\n%12 = and i32 %9, %11\nstore i32 %12, ptr %5, align 4\n%13 = load i32, ptr %5, align 4\n%14 = load i32, ptr %4, align 4\n%15 = load i32, ptr @EPROM_CMD_OPERATING_MODE_SHIFT, align 4\n%16 = shl i32 %14, %15\n%17 = or i32 %13, %16\nstore i32 %17, ptr %5, align 4\n%18 = load i32, ptr %5, align 4\n%19 = load i32, ptr @EPROM_CS_SHIFT, align 4\n%20 = shl i32 1, %19\n%21 = xor i32 %20, -1\n%22 = and i32 %18, %21\nstore i32 %22, ptr %5, align 4\n%23 = load i32, ptr %5, align 4\n%24 = load i32, ptr @EPROM_CK_SHIFT, align 4\n%25 = shl i32 1, %24\n%26 = xor i32 %25, -1\n%27 = and i32 %23, %26\nstore i32 %27, ptr %5, align 4\n%28 = load ptr, ptr %3, align 8\n%29 = load i32, ptr @EPROM_CMD, align 4\n%30 = load i32, ptr %5, align 4\n%31 = call i32 @write_nic_byte(ptr noundef %28, i32 noundef %29, i32 noundef %30)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @rtl8192_set_mode(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @EPROM_CMD, align 4\n%3 = tail call i32 @read_nic_byte(ptr noundef %0, i32 noundef %2)\n%4 = load i32, ptr @EPROM_CMD_OPERATING_MODE_MASK, align 4\n%5 = xor i32 %4, -1\n%6 = and i32 %3, %5\n%7 = load i32, ptr @EPROM_CMD_OPERATING_MODE_SHIFT, align 4\n%8 = shl i32 %1, %7\n%9 = or i32 %8, %6\n%10 = load i32, ptr @EPROM_CS_SHIFT, align 4\n%11 = shl nuw i32 1, %10\n%12 = load i32, ptr @EPROM_CK_SHIFT, align 4\n%13 = shl nuw i32 1, %12\n%14 = or i32 %13, %11\n%15 = xor i32 %14, -1\n%16 = and i32 %9, %15\n%17 = load i32, ptr @EPROM_CMD, align 4\n%18 = tail call i32 @write_nic_byte(ptr noundef %0, i32 noundef %17, i32 noundef %16)\nret void\n}", "codellama": "define internal void @rtl8192_set_mode(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @EPROM_CMD, align 4\n%3 = tail call i32 @read_nic_byte(ptr noundef %0, i32 noundef %2)\n%4 = load i32, ptr @EPROM_CMD_OPERATING_MODE_MASK, align 4\n%5 = xor i32 %4, -1\n%6 = and i32 %3, %5\n%7 = load i32, ptr @EPROM_CMD_OPERATING_MODE_SHIFT, align 4\n%8 = shl i32 %1, %7\n%9 = or i32 %8, %6\n%10 = load i32, ptr @EPROM_CS_SHIFT, align 4\n%11 = shl nuw i32 1, %10\n%12 = xor i32 %11, -1\n%13 = and i32 %9, %12\n%14 = load i32, ptr @EPROM_CK_SHIFT, align 4\n%15 = shl nuw i32 1, %14\n%16 = xor i32 %15, -1\n%17 = and i32 %13, %16\n%18 = load i32, ptr @EPROM_CMD, align 4\n%19 = tail call i32 @write_nic_byte(ptr noundef %0, i32 noundef %18, i32 noundef %17)\nret void\n}", "codegemma": "define internal void @rtl8192_set_mode(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @EPROM_CMD, align 4\n%3 = tail call i32 @read_nic_byte(ptr noundef %0, i32 noundef %2)\n%4 = load i32, ptr @EPROM_CMD_OPERATING_MODE_MASK, align 4\n%5 = xor i32 %4, -1\n%6 = and i32 %3, %5\n%7 = load i32, ptr @EPROM_CMD_OPERATING_MODE_SHIFT, align 4\n%8 = shl i32 %1, %7\n%9 = or i32 %8, %6\n%10 = load i32, ptr @EPROM_CS_SHIFT, align 4\n%11 = shl nuw i32 1, %10\n%12 = xor i32 %11, -1\n%13 = and i32 %9, %12\n%14 = load i32, ptr @EPROM_CK_SHIFT, align 4\n%15 = shl nuw i32 1, %14\n%16 = xor i32 %15, -1\n%17 = and i32 %13, %16\n%18 = load i32, ptr @EPROM_CMD, align 4\n%19 = tail call i32 @write_nic_byte(ptr noundef %0, i32 noundef %18, i32 noundef %17)\nret void\n}"}, "define dso_local i32 @restart_write(i64 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i64, align 8\n%8 = alloca i64, align 8\n%9 = alloca i64, align 8\n%10 = alloca i64, align 8\n%11 = alloca i32, align 4\nstore i64 %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%12 = load i32, ptr @MAXFILENAME, align 4\n%13 = zext i32 %12 to i64\n%14 = call ptr @llvm.stacksave()\nstore ptr %14, ptr %6, align 8\n%15 = alloca i8, i64 %13, align 16\nstore i64 %13, ptr %7, align 8\n%16 = load i32, ptr @MAXFILENAME, align 4\n%17 = zext i32 %16 to i64\n%18 = alloca i8, i64 %17, align 16\nstore i64 %17, ptr %8, align 8\n%19 = load i32, ptr @MAXFILENAME, align 4\n%20 = zext i32 %19 to i64\n%21 = alloca i8, i64 %20, align 16\nstore i64 %20, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %10)\n%22 = load i64, ptr @FLUXB, align 8\n%23 = load i64, ptr @FLUXCTSTAG, align 8\n%24 = icmp eq i64 %22, %23\nbr i1 %24, label %25, label %34\n\n25:\n%26 = load i32, ptr @special3dspc, align 4\n%27 = icmp eq i32 %26, 1\nbr i1 %27, label %28, label %34\n\n28:\n%29 = load i32, ptr @N3, align 4\n%30 = icmp sgt i32 %29, 1\nbr i1 %30, label %31, label %34\n\n31:\n%32 = load i64, ptr %3, align 8\n%33 = call i32 @restartupperpole_write(i64 noundef %32)\nbr label %34\n\n34:\n%35 = load i64, ptr %3, align 8\n%36 = call i32 @trifprintf(ptr noundef @.str, i64 noundef %35)\n%37 = load i32, ptr @RESTARTDUMPTYPE, align 4\nstore i32 %37, ptr %5, align 4\n%38 = load i32, ptr @MPI_FTYPE, align 4\nstore i32 %38, ptr %4, align 4\n%39 = call i32 @strcpy(ptr noundef %15, ptr noundef @.str.1)\n%40 = load i64, ptr %3, align 8\n%41 = icmp sge i64 %40, 0\nbr i1 %41, label %42, label %45\n\n42:\n%43 = call i32 @strcpy(ptr noundef %21, ptr noundef @.str.2)\n%44 = load i64, ptr %3, align 8\nstore i64 %44, ptr %10, align 8\nbr label %50\n\n45:\n%46 = call i32 @strcpy(ptr noundef %21, ptr noundef @.str.3)\n%47 = load i64, ptr %3, align 8\n%48 = sub nsw i64 0, %47\n%49 = sub nsw i64 %48, 1\nstore i64 %49, ptr %10, align 8\nbr label %50\n\n50:\n%51 = call i32 @strcpy(ptr noundef %18, ptr noundef @.str.4)\n%52 = load i32, ptr @WRITEFILE, align 4\n%53 = load i64, ptr %10, align 8\n%54 = load i32, ptr @binaryoutput, align 4\n%55 = load i32, ptr %5, align 4\n%56 = load i32, ptr %4, align 4\n%57 = load i32, ptr @write_restart_header_new, align 4\n%58 = load i32, ptr @rdump_content, align 4\n%59 = call i32 @dump_gen(i32 noundef %52, i64 noundef %53, i32 noundef %54, i32 noundef %55, i32 noundef %56, ptr noundef %15, ptr noundef %21, ptr noundef %18, i32 noundef %57, i32 noundef %58)\n%60 = icmp sge i32 %59, 1\nbr i1 %60, label %61, label %62\n\n61:\nstore i32 1, ptr %2, align 4\nstore i32 1, ptr %11, align 4\nbr label %65\n\n62:\n%63 = load i64, ptr %3, align 8\n%64 = call i32 @trifprintf(ptr noundef @.str.5, i64 noundef %63)\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %11, align 4\nbr label %65\n\n65:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %10)\n%66 = load ptr, ptr %6, align 8\ncall void @llvm.stackrestore(ptr %66)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%67 = load i32, ptr %2, align 4\nret i32 %67\n}": {"base_truth": "define dso_local i32 @restart_write(i64 noundef %0) {\nB:\n%1 = load i32, ptr @MAXFILENAME, align 4\n%2 = zext i32 %1 to i64\n%3 = alloca i8, i64 %2, align 16\n%4 = alloca i8, i64 %2, align 16\n%5 = alloca i8, i64 %2, align 16\n%6 = load i64, ptr @FLUXB, align 8\n%7 = load i64, ptr @FLUXCTSTAG, align 8\n%8 = icmp eq i64 %6, %7\n%9 = load i32, ptr @special3dspc, align 4\n%10 = icmp eq i32 %9, 1\n%11 = select i1 %8, i1 %10, i1 false\n%12 = load i32, ptr @N3, align 4\n%13 = icmp sgt i32 %12, 1\n%14 = select i1 %11, i1 %13, i1 false\nbr i1 %14, label %B1, label %B2\n\nB1:\n%15 = tail call i32 @restartupperpole_write(i64 noundef %0)\nbr label %B2\n\nB2:\n%16 = tail call i32 @trifprintf(ptr noundef nonnull @.str, i64 noundef %0)\n%17 = load i32, ptr @RESTARTDUMPTYPE, align 4\n%18 = load i32, ptr @MPI_FTYPE, align 4\n%19 = call i32 @strcpy(ptr noundef nonnull %3, ptr noundef nonnull @.str.1)\n%20 = icmp sgt i64 %0, -1\nbr i1 %20, label %B3, label %B4\n\nB3:\n%21 = call i32 @strcpy(ptr noundef nonnull %5, ptr noundef nonnull @.str.2)\nbr label %B5\n\nB4:\n%22 = call i32 @strcpy(ptr noundef nonnull %5, ptr noundef nonnull @.str.3)\n%23 = xor i64 %0, -1\nbr label %B5\n\nB5:\n%24 = phi i64 [ %0, %B3 ], [ %23, %B4 ]\n%25 = call i32 @strcpy(ptr noundef nonnull %4, ptr noundef nonnull @.str.4)\n%26 = load i32, ptr @WRITEFILE, align 4\n%27 = load i32, ptr @binaryoutput, align 4\n%28 = load i32, ptr @write_restart_header_new, align 4\n%29 = load i32, ptr @rdump_content, align 4\n%30 = call i32 @dump_gen(i32 noundef %26, i64 noundef %24, i32 noundef %27, i32 noundef %17, i32 noundef %18, ptr noundef nonnull %3, ptr noundef nonnull %5, ptr noundef nonnull %4, i32 noundef %28, i32 noundef %29)\n%31 = icmp sgt i32 %30, 0\nbr i1 %31, label %B7, label %B6\n\nB6:\n%32 = call i32 @trifprintf(ptr noundef nonnull @.str.5, i64 noundef %0)\nbr label %B7\n\nB7:\n%33 = phi i32 [ 0, %B6 ], [ 1, %B5 ]\nret i32 %33\n}", "codellama": "define dso_local i32 @restart_write(i64 noundef %0) {\nB:\n%1 = load i32, ptr @MAXFILENAME, align 4\n%2 = zext i32 %1 to i64\n%3 = alloca i8, i64 %2, align 16\n%4 = alloca i8, i64 %2, align 16\n%5 = alloca i8, i64 %2, align 16\n%6 = load i64, ptr @FLUXB, align 8\n%7 = load i64, ptr @FLUXCTSTAG, align 8\n%8 = icmp eq i64 %6, %7\n%9 = load i32, ptr @special3dspc, align 4\n%10 = icmp eq i32 %9, 1\n%11 = select i1 %8, i1 %10, i1 false\n%12 = load i32, ptr @N3, align 4\n%13 = icmp sgt i32 %12, 1\n%14 = select i1 %11, i1 %13, i1 false\nbr i1 %14, label %B1, label %B2\n\nB1:\n%15 = tail call i32 @restartupperpole_write(i64 noundef %0)\nbr label %B2\n\nB2:\n%16 = tail call i32 @trifprintf(ptr noundef nonnull @.str, i64 noundef %0)\n%17 = load i32, ptr @RESTARTDUMPTYPE, align 4\n%18 = load i32, ptr @MPI_FTYPE, align 4\n%19 = call i32 @strcpy(ptr noundef nonnull %3, ptr noundef nonnull @.str.1)\n%20 = icmp sgt i64 %0, -1\nbr i1 %20, label %B3, label %B4\n\nB3:\n%21 = call i32 @strcpy(ptr noundef nonnull %5, ptr noundef nonnull @.str.2)\nbr label %B5\n\nB4:\n%22 = call i32 @strcpy(ptr noundef nonnull %5, ptr noundef nonnull @.str.3)\n%23 = xor i64 %0, -1\nbr label %B5\n\nB5:\n%24 = phi i64 [ %0, %B3 ], [ %23, %B4 ]\n%25 = call i32 @strcpy(ptr noundef nonnull %4, ptr noundef nonnull @.str.4)\n%26 = load i32, ptr @WRITEFILE, align 4\n%27 = load i32, ptr @binaryoutput, align 4\n%28 = load i32, ptr @write_restart_header_new, align 4\n%29 = load i32, ptr @rd</s>", "codegemma": "define dso_local i32 @restart_write(i64 noundef %0) {\nB:\n%1 = load i32, ptr @MAXFILENAME, align 4\n%2 = zext i32 %1 to i64\n%3 = alloca i8, i64 %2, align 16\n%4 = load i32, ptr @MAXFILENAME, align 4\n%5 = zext i32 %4 to i64\n%6 = alloca i8, i64 %5, align 16\n%7 = load i32, ptr @MAXFILENAME, align 4\n%8 = zext i32 %7 to i64\n%9 = alloca i8, i64 %8, align 16\n%10 = load i64, ptr @FLUXB, align 8\n%11 = load i64, ptr @FLUXCTSTAG, align 8\n%12 = icmp eq i64 %10, %11\n%13 = load i32, ptr @special3dspc, align 4\n%14 = icmp eq i32 %13, 1\n%15 = select i1 %12, i1 %14, i1 false\n%16 = load i32, ptr @N3, align 4\n%17 = icmp sgt i32 %16, 1\n%18 = select i1 %15, i1 %17, i1 false\nbr i1 %18, label %B1, label %B2\n\nB1:\n%19 = tail call i32 @restartupperpole_write(i64 noundef %0)\nbr label %B2\n\nB2:\n%20 = tail call i32 @trifprintf(ptr noundef nonnull @.str, i64 noundef %0)\n%21 = load i32, ptr @RESTARTDUMPTYPE, align 4\n%22 = load i32, ptr @MPI_FTYPE, align 4\n%23 = call i32 @strcpy(ptr noundef nonnull %3, ptr noundef nonnull @.str.1)\n%24 = icmp sgt i64 %0, -1\n%25 = call i32 @strcpy(ptr noundef nonnull %6, ptr noundef nonnull @.str.2)\n%26 = sub nsw i64 0, %0\n%27 = add i64 %26, -1\n%28 = call i32 @strcpy(ptr noundef nonnull %9, ptr noundef nonnull @.str.3)\n%29 = call i32 @strcpy(ptr noundef nonnull %6, ptr noundef nonnull @.str.4)\n%30 = load i32, ptr @WRITEFILE, align 4\n%31 = load i32, ptr @binaryoutput, align 4\n%32 = load i32, ptr @write_restart_header_new, align 4\n%33 = load i32, ptr @rdump_content, align 4\n%34 = call i32 @dump_gen(i32 noundef %30, i64 noundef %27, i32 noundef %31, i32 noundef %21, i32 n<eos>"}, "define dso_local i64 @gfx_get_cursor_enable() {\n%1 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\nstore i64 0, ptr %1, align 8\n%2 = load i32, ptr @gfx_display_type, align 4\n%3 = and i32 %2, 1\n%4 = icmp ne i32 %3, 0\nbr i1 %4, label %5, label %7\n\n5:\n%6 = call i64 (...) @gu1_get_cursor_enable()\nstore i64 %6, ptr %1, align 8\nbr label %7\n\n7:\n%8 = load i32, ptr @gfx_display_type, align 4\n%9 = and i32 %8, 2\n%10 = icmp ne i32 %9, 0\nbr i1 %10, label %11, label %13\n\n11:\n%12 = call i64 (...) @gu2_get_cursor_enable()\nstore i64 %12, ptr %1, align 8\nbr label %13\n\n13:\n%14 = load i64, ptr %1, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i64 %14\n}": {"base_truth": "define dso_local i64 @gfx_get_cursor_enable() {\nB:\n%0 = load i32, ptr @gfx_display_type, align 4\n%1 = and i32 %0, 1\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i64 (...) @gu1_get_cursor_enable()\n%4 = load i32, ptr @gfx_display_type, align 4\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ %0, %B ]\n%6 = phi i64 [ %3, %B1 ], [ 0, %B ]\n%7 = and i32 %5, 2\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i64 (...) @gu2_get_cursor_enable()\nbr label %B4\n\nB4:\n%10 = phi i64 [ %9, %B3 ], [ %6, %B2 ]\nret i64 %10\n}", "codellama": "define dso_local i64 @gfx_get_cursor_enable() {\nB:\n%0 = load i32, ptr @gfx_display_type, align 4\n%1 = and i32 %0, 1\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i64 (...) @gu1_get_cursor_enable()\n%4 = load i32, ptr @gfx_display_type, align 4\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ %0, %B ]\n%6 = phi i64 [ %3, %B1 ], [ 0, %B ]\n%7 = and i32 %5, 2\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i64 (...) @gu2_get_cursor_enable()\nbr label %B4\n\nB4:\n%10 = phi i64 [ %9, %B3 ], [ %6, %B2 ]\nret i64 %10\n}", "codegemma": "define dso_local i64 @gfx_get_cursor_enable() {\nB:\n%0 = load i32, ptr @gfx_display_type, align 4\n%1 = and i32 %0, 1\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call i64 (...) @gu1_get_cursor_enable()\n%4 = load i32, ptr @gfx_display_type, align 4\nbr label %B2\n\nB2:\n%5 = phi i32 [ %4, %B1 ], [ %0, %B ]\n%6 = phi i64 [ %3, %B1 ], [ 0, %B ]\n%7 = and i32 %5, 2\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i64 (...) @gu2_get_cursor_enable()\nbr label %B4\n\nB4:\n%10 = phi i64 [ %9, %B3 ], [ %6, %B2 ]\nret i64 %10\n}"}, "define dso_local void @Dly1ms() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 20, ptr %1, align 4\nbr label %2\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = icmp ne i32 %3, 0\nbr i1 %4, label %5, label %9\n\n5:\n%6 = call i32 (...) @Dly50us()\n%7 = load i32, ptr %1, align 4\n%8 = add nsw i32 %7, -1\nstore i32 %8, ptr %1, align 4\nbr label %2\n\n9:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @Dly1ms() {\nB:\n%0 = tail call i32 (...) @Dly50us()\n%1 = tail call i32 (...) @Dly50us()\n%2 = tail call i32 (...) @Dly50us()\n%3 = tail call i32 (...) @Dly50us()\n%4 = tail call i32 (...) @Dly50us()\n%5 = tail call i32 (...) @Dly50us()\n%6 = tail call i32 (...) @Dly50us()\n%7 = tail call i32 (...) @Dly50us()\n%8 = tail call i32 (...) @Dly50us()\n%9 = tail call i32 (...) @Dly50us()\n%10 = tail call i32 (...) @Dly50us()\n%11 = tail call i32 (...) @Dly50us()\n%12 = tail call i32 (...) @Dly50us()\n%13 = tail call i32 (...) @Dly50us()\n%14 = tail call i32 (...) @Dly50us()\n%15 = tail call i32 (...) @Dly50us()\n%16 = tail call i32 (...) @Dly50us()\n%17 = tail call i32 (...) @Dly50us()\n%18 = tail call i32 (...) @Dly50us()\n%19 = tail call i32 (...) @Dly50us()\nret void\n}", "codellama": "define dso_local void @Dly1ms() {\nB:\n%0 = tail call i32 (...) @Dly50us()\n%1 = tail call i32 (...) @Dly50us()\n%2 = tail call i32 (...) @Dly50us()\n%3 = tail call i32 (...) @Dly50us()\n%4 = tail call i32 (...) @Dly50us()\n%5 = tail call i32 (...) @Dly50us()\n%6 = tail call i32 (...) @Dly50us()\n%7 = tail call i32 (...) @Dly50us()\n%8 = tail call i32 (...) @Dly50us()\n%9 = tail call i32 (...) @Dly50us()\n%10 = tail call i32 (...) @Dly50us()\n%11 = tail call i32 (...) @Dly50us()\n%12 = tail call i32 (...) @Dly50us()\n%13 = tail call i32 (...) @Dly50us()\n%14 = tail call i32 (...) @Dly50us()\n%15 = tail call i32 (...) @Dly50us()\n%16 = tail call i32 (...) @Dly50us()\n%17 = tail call i32 (...) @Dly50us()\n%18 = tail call i32 (...) @Dly50us()\n%19 = tail call i32 (...) @Dly50us()\n%20 = tail call i32 (...) @Dly50us()\n%21 = tail call i32 (...) @Dly50us()\n%22 = tail call i32 (...) @Dly50us()\n%23 = tail call i32 (...) @Dly50us()\n%24 = tail call i32 (...) @Dly50us()\n%25 = tail call i32 (...) @Dly50us()\n%26 = tail call i32 (...) @Dly50us()\n%27 = tail call i32 (...) @Dly50us()\n%28 = tail call i32 (...) @Dly50us()\n%29 = tail call i32 (...) @Dly50us()\n%30 = tail call i32 (...) @Dly50us()\n%31 = tail call i32 (...) @Dly50us()\n%32 = tail call i32 (...) @Dly50us()\n%33 = tail call i32 (...) @Dly50us()\n%34 = tail call i32 (...) @Dly50us()\n%35 = tail call i32 (...) @Dly50us()\n%36 = tail call i32 (...) @Dly50us()\n%37 = tail call i32 (...) @Dly50us()\n%38 = tail call i32 (...) @Dly50us()\n%39 = tail call i32 (...) @Dly50us()\n%40 = tail call i32 (...) @Dly50us()\n%41 = tail call i32 (...) @Dly50us()\n%42 = tail call i32 (...) @Dly50us()\n%43 = tail call i32 (...) @Dly50us()\n%44 = tail call i32 (...) @Dly50us()\n%45 = tail call i32 (...) @Dly50us()\n%46 = tail call i32 (...) @Dly50us()\n%47 = tail call i32 (...) @Dly50us()\n%48 = tail call i32 (...) @Dly50us()\n%49 = tail call i32 (...) @Dly50us()\n%50 = tail call i32 (...) @Dly50us()\n%51 = tail call i32 (...) @Dly50us()\n%52 = tail call i32 (...) @Dly50us()\n%53 = tail call i32 (...) @Dly50us()\n%54 = tail call i32 (...) @Dly50us()\n%55 = tail call i32 (...) @Dly50us()\n%56 = tail call i32 (...) @Dly50us()\n%57 = tail call i32 (...) @Dly50us()\n%58 = tail call i32 (...) @Dly50us()\n%59 = tail call i32 (...) @Dly50us()\n%60 = tail call i32 (...) @Dly50us()\n%61 = tail call i32 (...) @Dly50us()\n%62 = tail call i32 (...) @Dly50us()\n%63 = tail call i32 (...) @Dly50us()\n%64 = tail call i32 (...) @Dly50us()\n%65 = tail call i32 (...) @Dly50us()\n%66 = tail call i32 (...) @Dly50us()\n%67 = tail call i32 (...) @Dly50us()\n%68 = tail call i32 (...) @Dly50us()\n%69 = tail call i32 (...) @Dly50us()\n%70 = tail call i32 (...) @Dly50us()\n%71 = tail call i32 (...) @Dly50us()\n%72 = tail call i32 (...) @Dly50us()\n%73 = tail call i32 (...) @Dly50us()\n%74 = tail call i32 (...) @Dly50us()\n%75 = tail call i32 (...) @Dly50us()\n%76 = tail call i32 (...) @Dly50us()\n%77 = tail call i32 (...) @Dly50us()\n%78 = tail call i32 (...) @Dly50us()\n%79 = tail call i32 (...) @Dly50us()\n%80 = tail call i32 (...) @Dly50us()\n%81 = tail call i32 (...) @Dly50us()\n%82 = tail call i32 (...) @Dly50us()\n%83 = tail call i32 (...) @Dly50us()\n%84 = tail call i32 (...) @Dly50us()\n%85 = tail call i32 (...) @Dly50us()\n%86 = tail call i32 (...) @Dly50us()\n%87 = tail call i32 (...) @Dly50us()\n%88 = tail call i32 (...) @Dly50us()\n%89 = tail call i32 (...) @Dly50us()\n%90 = tail call i32 (...) @Dly50us()\n%91 = tail call i32 (...) @Dly50us()\n%92 = tail call i32 (...) @Dly50us()\n%93 = tail call i32 (...) @Dly50us()\n%94 = tail call i32 (...) @Dly50us()\n%95 = tail call i32 (...) @Dly50us()\n%96 = tail call i32 (...) @Dly50us()\n%97 = tail call i32 (...) @Dly50us()\n%98 = tail call i32 (...) @Dly50us()\n%99 = tail call i32 (...) @Dly50us()\n%100 = tail call i32 (...) @Dly50us()\n%101 = tail call i32 (...) @Dly50us()\n%102 = tail call i32 (...) @Dly50us()\n%103 = tail call i32 (...) @Dly50us()\n%104 = tail call i32 (...) @Dly50us()\n%105 = tail call i32 (...) @Dly50us()\n%106 = tail call i32 (...) @Dly50us()\n%107 = tail call i32 (...) @Dly50us()\n%108 = tail call i32 (...) @Dly50us()\n%109 = tail call i32 (...) @Dly50us()\n%110 = tail call i32 (...) @Dly50us()\n%111 = tail call i32 (...) @Dly50us()\n%112 = tail call i32 (...) @Dly50us()\n%113 = tail call i32 (...) @Dly50us()\n%114 = tail call i32 (...) @Dly50us()\n%115 = tail call i32 (...) @Dly50us()\n%116 = tail call</s>", "codegemma": "define dso_local void @Dly1ms() {\nB:\n%0 = tail call i32 (...) @Dly50us()\n%1 = tail call i32 (...) @Dly50us()\n%2 = tail call i32 (...) @Dly50us()\n%3 = tail call i32 (...) @Dly50us()\n%4 = tail call i32 (...) @Dly50us()\n%5 = tail call i32 (...) @Dly50us()\n%6 = tail call i32 (...) @Dly50us()\n%7 = tail call i32 (...) @Dly50us()\n%8 = tail call i32 (...) @Dly50us()\n%9 = tail call i32 (...) @Dly50us()\n%10 = tail call i32 (...) @Dly50us()\n%11 = tail call i32 (...) @Dly50us()\n%12 = tail call i32 (...) @Dly50us()\n%13 = tail call i32 (...) @Dly50us()\n%14 = tail call i32 (...) @Dly50us()\n%15 = tail call i32 (...) @Dly50us()\n%16 = tail call i32 (...) @Dly50us()\n%17 = tail call i32 (...) @Dly50us()\n%18 = tail call i32 (...) @Dly50us()\n%19 = tail call i32 (...) @Dly50us()\n%20 = tail call i32 (...) @Dly50us()\n%21 = tail call i32 (...) @Dly50us()\n%22 = tail call i32 (...) @Dly50us()\n%23 = tail call i32 (...) @Dly50us()\n%24 = tail call i32 (...) @Dly50us()\n%25 = tail call i32 (...) @Dly50us()\n%26 = tail call i32 (...) @Dly50us()\n%27 = tail call i32 (...) @Dly50us()\n%28 = tail call i32 (...) @Dly50us()\n%29 = tail call i32 (...) @Dly50us()\n%30 = tail call i32 (...) @Dly50us()\n%31 = tail call i32 (...) @Dly50us()\n%32 = tail call i32 (...) @Dly50us()\n%33 = tail call i32 (...) @Dly50us()\n%34 = tail call i32 (...) @Dly50us()\n%35 = tail call i32 (...) @Dly50us()\n%36 = tail call i32 (...) @Dly50us()\n%37 = tail call i32 (...) @Dly50us()\n%38 = tail call i32 (...) @Dly50us()\n%39 = tail call i32 (...) @Dly50us()\n%40 = tail call i32 (...) @Dly50us()\n%41 = tail call i32 (...) @Dly50us()\n%42 = tail call i32 (...) @Dly50us()\n%43 = tail call i32 (...) @Dly50us()\n%44 = tail call i32 (...) @Dly50us()\n%45 = tail call i32 (...) @Dly50us()\n%46 = tail call i32 (...) @Dly50us()\n%47 = tail call i32 (...) @Dly50us()\n%48 = tail call i32 (...) @Dly50us()\n%49 = tail call i32 (...) @Dly50us()\n%50 = tail call i32 (...) @Dly50us()\n%51 = tail call i32 (...) @Dly50us()\n%52 = tail call i32 (...) @Dly50us()\n%53 = tail call i32 (...) @Dly50us()\n%54 = tail call i32 (...) @Dly50us()\n%55 = tail call i32 (...) @Dly50us()\n%56 = tail call i32 (...) @Dly50us()\n%57 = tail call i32 (...) @Dly50us()\n%58 = tail call i32 (...) @Dly50us()\n%59 = tail call i32 (...) @Dly50us()\n%60 = tail call i32 (...) @Dly50us()\n%61 = tail call i32 (...) @Dly50us()\n%62 = tail call i32 (...) @Dly50us()\n%63 = tail call i32 (...) @Dly50us()\n%64 = tail call i32 (...) @Dly50us()\n%65 = tail call i32 (...) @Dly50us()\n%66 = tail call i32 (...) @Dly50us()\n%67 = tail call i32 (...) @Dly50us()\n%68 = tail call i32 (...) @Dly50us()\n%69 = tail call i32 (...) @Dly50us()\n%70 = tail call i32 (...) @Dly50us()\n%71 = tail call i32 (...) @Dly50us()\n%72 = tail call i32 (...) @Dly50us()\n%73 = tail call i32 (...) @Dly50us()\n%74 = tail call i32 (...) @Dly50us()\n%75 = tail call i32 (...) @Dly50us()\n%76 = tail call i32 (...) @Dly50us()\n%77 = tail call i32 (...) @Dly50us()\n%78 = tail call i32 (...) @Dly50us()\n%79 = tail call i32 (...) @Dly50us()\n%80 = tail call i32 (...) @Dly50us()\n%81 = tail call i32 (...) @Dly50us()\n%82 = tail call i32 (...) @Dly50us()\n%83 = tail call i32 (...) @Dly50us()\n%84 = tail call i32 (...) @Dly50us()\n%85 = tail call i32 (...) @Dly50us()\n%86 = tail call i32 (...) @Dly50us()\n%87 = tail call i32 (...) @Dly50us()\n%88 = tail call i32 (...) @Dly50us()\n%89 = tail call i32 (...) @Dly50us()\n%90 = tail call i32 (...) @Dly50us()\n%91 = tail call i32 (...) @Dly50us()\n%92 = tail call i32 (...) @Dly50us()\n%93 = tail call i32 (...) @Dly50us()\n%94 = tail call i32 (...) @Dly50us()\n%95 = tail call i32 (...) @Dly50us()\n%96 = tail call i32 (...) @Dly50us()\n%97 = tail call i32 (...) @Dly50us()\n%98 = tail call i32 (...) @Dly50us()\n%99 = tail call i32 (...) @Dly50us()\n%100 = tail call i32 (...) @Dly50us()\n%101 = tail call i32 (...) @Dly50us()\n%102 = tail call i32 (...) @Dly50us()\n%103 = tail call i32 (...) @Dly50us()\n%104 = tail call i32 (...) @Dly50us()\n%105 = tail call i32 (...) @Dly50us()\n%106 = tail call i32 (...) @Dly50us()\n%107 = tail call i32 (...) @Dly50us()\n%108 = tail call i32 (...) @Dly50us()\n%109 = tail call i32 (...) @Dly50us()\n%110 = tail call i32 (...) @Dly50us()\n%111 = tail call i32 (...) @Dly50us()\n%112 = tail call i32 (...) @Dly50us()\n%113 = tail call i32 (...) @Dly50us()\n%114 = tail call i32 (...) @Dly50us()\n%115 = tail call i32 (...) @Dly50us()\n%116 = tail call i32 (...) @Dly50us()\n%117 = tail call i32 (...) @Dly50us()\n%118 = tail call i32 (...) @Dly50us()\n%119 = tail call i32 (...) @Dly50us()\n%200 = tail call i32 (...) @Dly50us()\n%201 = tail call i32 (...) @Dly50us()\n%202 = tail call i32 (...) @Dly50us()\n%203 = tail call i<eos>"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca [17 x i8], align 16\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 17, ptr %2)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 16 %2, ptr align 16 @__const.main.str, i64 17, i1 false)\n%3 = call i32 @printf(ptr noundef @.str, i32 noundef ptrtoint (ptr @f to i32))\n%4 = getelementptr inbounds [17 x i8], ptr %2, i64 0, i64 0\n%5 = call i32 @overflow(ptr noundef %4)\ncall void @llvm.lifetime.end.p0(i64 17, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca [17 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 17, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(17) %0, ptr noundef nonnull align 16 dereferenceable(17) @__const.main.str, i64 17, i1 false)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef ptrtoint (ptr @f to i32))\n%2 = call i32 @overflow(ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 17, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca [17 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 17, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(17) %0, ptr noundef nonnull align 16 dereferenceable(17) @__const.main.str, i64 17, i1 false)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef ptrtoint (ptr @f to i32))\n%2 = call i32 @overflow(ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 17, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca [17 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 17, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(17) %0, ptr noundef nonnull align 16 dereferenceable(17) @__const.main.str, i64 17, i1 false)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef ptrtoint (ptr @f to i32))\n%2 = call i32 @overflow(ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 17, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local void @r642rank_name_in(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i64, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore i64 %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %6, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = call i32 @r7append(ptr noundef %7, ptr noundef %8)\n%10 = load i64, ptr %4, align 8\n%11 = call i64 @INT8_C(i32 noundef -1)\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %13, label %16\n\n13:\n%14 = load ptr, ptr %6, align 8\n%15 = call i32 @r7extend(ptr noundef %14, i32 noundef 67)\nbr label %22\n\n16:\n%17 = load ptr, ptr %6, align 8\n%18 = call i32 @r7extend(ptr noundef %17, i32 noundef 97)\n%19 = load i64, ptr %4, align 8\n%20 = load ptr, ptr %6, align 8\n%21 = call i32 @r2append_in(i64 noundef %19, ptr noundef %20)\nbr label %22\n\n22:\nret void\n}": {"base_truth": "define dso_local void @r642rank_name_in(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @r7append(ptr noundef %2, ptr noundef %1)\n%4 = tail call i64 @INT8_C(i32 noundef -1)\n%5 = icmp eq i64 %4, %0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @r7extend(ptr noundef %2, i32 noundef 67)\nbr label %B3\n\nB2:\n%7 = tail call i32 @r7extend(ptr noundef %2, i32 noundef 97)\n%8 = tail call i32 @r2append_in(i64 noundef %0, ptr noundef %2)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @r642rank_name_in(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @r7append(ptr noundef %2, ptr noundef %1)\n%4 = tail call i64 @INT8_C(i32 noundef -1)\n%5 = icmp eq i64 %4, %0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @r7extend(ptr noundef %2, i32 noundef 67)\nbr label %B3\n\nB2:\n%7 = tail call i32 @r7extend(ptr noundef %2, i32 noundef 97)\n%8 = tail call i32 @r2append_in(i64 noundef %0, ptr noundef %2)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @r642rank_name_in(i64 noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @r7append(ptr noundef %2, ptr noundef %1)\n%4 = tail call i64 @INT8_C(i32 noundef -1)\n%5 = icmp eq i64 %4, %0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @r7extend(ptr noundef %2, i32 noundef 67)\nbr label %B3\n\nB2:\n%7 = tail call i32 @r7extend(ptr noundef %2, i32 noundef 97)\n%8 = tail call i32 @r2append_in(i64 noundef %0, ptr noundef %2)\nbr label %B3\n\nB3:\nret void\n}"}, "define internal i32 @cidx_isident(i8 noundef signext %0) {\n%2 = alloca i8, align 1\nstore i8 %0, ptr %2, align 1\n%3 = load i8, ptr %2, align 1\n%4 = sext i8 %3 to i32\n%5 = icmp slt i32 %4, 0\nbr i1 %5, label %34, label %6\n\n6:\n%7 = load i8, ptr %2, align 1\n%8 = sext i8 %7 to i32\n%9 = icmp sge i32 %8, 48\nbr i1 %9, label %10, label %14\n\n10:\n%11 = load i8, ptr %2, align 1\n%12 = sext i8 %11 to i32\n%13 = icmp sle i32 %12, 57\nbr i1 %13, label %34, label %14\n\n14:\n%15 = load i8, ptr %2, align 1\n%16 = sext i8 %15 to i32\n%17 = icmp sge i32 %16, 97\nbr i1 %17, label %18, label %22\n\n18:\n%19 = load i8, ptr %2, align 1\n%20 = sext i8 %19 to i32\n%21 = icmp sle i32 %20, 122\nbr i1 %21, label %34, label %22\n\n22:\n%23 = load i8, ptr %2, align 1\n%24 = sext i8 %23 to i32\n%25 = icmp sge i32 %24, 65\nbr i1 %25, label %26, label %30\n\n26:\n%27 = load i8, ptr %2, align 1\n%28 = sext i8 %27 to i32\n%29 = icmp sle i32 %28, 90\nbr i1 %29, label %34, label %30\n\n30:\n%31 = load i8, ptr %2, align 1\n%32 = sext i8 %31 to i32\n%33 = icmp eq i32 %32, 95\nbr label %34\n\n34:\n%35 = phi i1 [ true, %26 ], [ true, %18 ], [ true, %10 ], [ true, %1 ], [ %33, %30 ]\n%36 = zext i1 %35 to i32\nret i32 %36\n}": {"base_truth": "define internal i32 @cidx_isident(i8 noundef signext %0) {\nB:\n%1 = icmp slt i8 %0, 0\n%2 = add i8 %0, -48\n%3 = icmp ult i8 %2, 10\n%4 = or i1 %1, %3\n%5 = and i8 %0, -33\n%6 = add i8 %5, -65\n%7 = icmp ult i8 %6, 26\n%8 = or i1 %4, %7\n%9 = icmp eq i8 %0, 95\n%10 = or i1 %9, %8\n%11 = zext i1 %10 to i32\nret i32 %11\n}", "codellama": "define internal i32 @cidx_isident(i8 noundef signext %0) {\nB:\n%1 = add i8 %0, -97\n%2 = icmp ult i8 %1, 26\n%3 = add i8 %0, -65\n%4 = icmp ult i8 %3, 26\n%5 = icmp eq i8 %0, 95\n%6 = or i1 %5, %2\n%7 = or i1 %6, %4\n%8 = zext i1 %7 to i32\nret i32 %8\n}", "codegemma": "define internal i32 @cidx_isident(i8 noundef signext %0) {\nB:\n%1 = icmp slt i8 %0, 0\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = add i8 %0, -48\n%3 = icmp ult i8 %2, 10\nbr i1 %3, label %B3, label %B2\n\nB2:\n%4 = add i8 %0, -65\n%5 = icmp ult i8 %4, 26\n%6 = icmp eq i8 %0, 95\n%7 = or i1 %6, %5\n%8 = zext i1 %7 to i32\nbr label %B3\n\nB3:\n%9 = phi i32 [ 1, %B1 ], [ 1, %B ], [ %8, %B2 ]\nret i32 %9\n}"}, "define dso_local i32 @myrand(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = call i32 (...) @rand()\n%4 = load i32, ptr %2, align 4\n%5 = srem i32 %3, %4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @myrand(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @rand()\n%2 = srem i32 %1, %0\nret i32 %2\n}", "codellama": "define dso_local i32 @myrand(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @rand()\n%2 = srem i32 %1, %0\nret i32 %2\n}", "codegemma": "define dso_local i32 @myrand(i32 noundef %0) {\nB:\n%1 = tail call i32 (...) @rand()\n%2 = srem i32 %1, %0\nret i32 %2\n}"}, "define internal void @otg_device_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define internal void @otg_device_init(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define internal void @otg_device_init(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define internal void @otg_device_init(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define internal i32 @rest_of_char_same(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i32 %2, ptr %7, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %7, align 4\n%10 = icmp sgt i32 %9, 0\nbr i1 %10, label %11, label %29\n\n11:\n%12 = load i32, ptr %7, align 4\n%13 = add nsw i32 %12, -1\nstore i32 %13, ptr %7, align 4\n%14 = load ptr, ptr %5, align 8\n%15 = load i32, ptr %7, align 4\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds i8, ptr %14, i64 %16\n%18 = load i8, ptr %17, align 1\n%19 = sext i8 %18 to i32\n%20 = load ptr, ptr %6, align 8\n%21 = load i32, ptr %7, align 4\n%22 = sext i32 %21 to i64\n%23 = getelementptr inbounds i8, ptr %20, i64 %22\n%24 = load i8, ptr %23, align 1\n%25 = sext i8 %24 to i32\n%26 = icmp ne i32 %19, %25\nbr i1 %26, label %27, label %28\n\n27:\nstore i32 0, ptr %4, align 4\nbr label %30\n\n28:\nbr label %8\n\n29:\nstore i32 1, ptr %4, align 4\nbr label %30\n\n30:\n%31 = load i32, ptr %4, align 4\nret i32 %31\n}": {"base_truth": "define internal i32 @rest_of_char_same(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = zext i32 %2 to i64\nbr label %B1\n\nB1:\n%4 = phi i64 [ %7, %B2 ], [ %3, %B ]\n%5 = trunc i64 %4 to i32\n%6 = icmp sgt i32 %5, 0\nbr i1 %6, label %B2, label %B3\n\nB2:\n%7 = add nsw i64 %4, -1\n%8 = getelementptr inbounds i8, ptr %0, i64 %7\n%9 = load i8, ptr %8, align 1\n%10 = getelementptr inbounds i8, ptr %1, i64 %7\n%11 = load i8, ptr %10, align 1\n%12 = icmp eq i8 %9, %11\nbr i1 %12, label %B1, label %B3\n\nB3:\n%13 = phi i32 [ 0, %B2 ], [ 1, %B1 ]\nret i32 %13\n}", "codellama": "define internal i32 @rest_of_char_same(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B4\n\nB1:\n%4 = zext i32 %2 to i64\nbr label %B2\n\nB2:\n%5 = phi i64 [ %4, %B1 ], [ %6, %B3 ]\n%6 = add nsw i64 %5, -1\n%7 = getelementptr inbounds i8, ptr %0, i64 %6\n%8 = load i8, ptr %7, align 1\n%9 = getelementptr inbounds i8, ptr %1, i64 %6\n%10 = load i8, ptr %9, align 1\n%11 = icmp eq i8 %8, %10\nbr i1 %11, label %B3, label %B4\n\nB3:\n%12 = icmp ugt i64 %5, 1\nbr i1 %12, label %B2, label %B4\n\nB4:\n%13 = phi i32 [ 1, %B ], [ 0, %B2 ], [ 1, %B3 ]\nret i32 %13\n}", "codegemma": "define internal i32 @rest_of_char_same(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) {\nB:\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B3\n\nB1:\n%4 = phi i64 [ %5, %B2 ], [ %2, %B ]\n%5 = add nsw i64 %4, -1\n%6 = getelementptr inbounds i8, ptr %0, i64 %5\n%7 = load i8, ptr %6, align 1\n%8 = getelementptr inbounds i8, ptr %1, i64 %5\n%9 = load i8, ptr %8, align 1\n%10 = icmp eq i8 %7, %9\nbr i1 %10, label %B2, label %B3\n\nB2:\n%11 = icmp ugt i64 %4, 1\nbr i1 %11, label %B1, label %B3\n\nB3:\n%12 = phi i32 [ 1, %B ], [ 0, %B1 ], [ 1, %B2 ]\nret i32 %12\n}"}, "define internal i32 @uniphier_spi_transfer_one(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca ptr, align 8\n%9 = alloca i64, align 8\n%10 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore ptr %2, ptr %7, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%11 = load ptr, ptr %5, align 8\n%12 = call ptr @spi_master_get_devdata(ptr noundef %11)\nstore ptr %12, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%13 = load ptr, ptr %7, align 8\n%14 = getelementptr inbounds %struct.spi_transfer ptr %13, i32 0, i32 0\n%15 = load i64, ptr %14, align 8\n%16 = icmp ne i64 %15, 0\nbr i1 %16, label %18, label %17\n\n17:\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %46\n\n18:\n%19 = load ptr, ptr %6, align 8\n%20 = load ptr, ptr %7, align 8\n%21 = call i32 @uniphier_spi_setup_transfer(ptr noundef %19, ptr noundef %20)\n%22 = load i32, ptr @SSI_POLL_TIMEOUT_US, align 4\n%23 = load ptr, ptr %8, align 8\n%24 = getelementptr inbounds %struct.uniphier_spi_priv, ptr %23, i32 0, i32 0\n%25 = load i32, ptr %24, align 4\n%26 = mul nsw i32 %22, %25\n%27 = load i32, ptr @USEC_PER_SEC, align 4\n%28 = load i32, ptr @BITS_PER_BYTE, align 4\n%29 = mul nsw i32 %27, %28\n%30 = call i64 @DIV_ROUND_UP(i32 noundef %26, i32 noundef %29)\nstore i64 %30, ptr %9, align 8\n%31 = load ptr, ptr %7, align 8\n%32 = getelementptr inbounds %struct.spi_transfer ptr %31, i32 0, i32 0\n%33 = load i64, ptr %32, align 8\n%34 = load i64, ptr %9, align 8\n%35 = icmp ugt i64 %33, %34\nbr i1 %35, label %36, label %41\n\n36:\n%37 = load ptr, ptr %5, align 8\n%38 = load ptr, ptr %6, align 8\n%39 = load ptr, ptr %7, align 8\n%40 = call i32 @uniphier_spi_transfer_one_irq(ptr noundef %37, ptr noundef %38, ptr noundef %39)\nstore i32 %40, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %46\n\n41:\n%42 = load ptr, ptr %5, align 8\n%43 = load ptr, ptr %6, align 8\n%44 = load ptr, ptr %7, align 8\n%45 = call i32 @uniphier_spi_transfer_one_poll(ptr noundef %42, ptr noundef %43, ptr noundef %44)\nstore i32 %45, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %46\n\n46:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\n%47 = load i32, ptr %4, align 4\nret i32 %47\n}": {"base_truth": "define internal i32 @uniphier_spi_transfer_one(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @spi_master_get_devdata(ptr noundef %0)\n%4 = load i64, ptr %2, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = tail call i32 @uniphier_spi_setup_transfer(ptr noundef %1, ptr noundef nonnull %2)\n%7 = load i32, ptr @SSI_POLL_TIMEOUT_US, align 4\n%8 = load i32, ptr %3, align 4\n%9 = mul nsw i32 %8, %7\n%10 = load i32, ptr @USEC_PER_SEC, align 4\n%11 = load i32, ptr @BITS_PER_BYTE, align 4\n%12 = mul nsw i32 %11, %10\n%13 = tail call i64 @DIV_ROUND_UP(i32 noundef %9, i32 noundef %12)\n%14 = load i64, ptr %2, align 8\n%15 = icmp ugt i64 %14, %13\nbr i1 %15, label %B2, label %B3\n\nB2:\n%16 = tail call i32 @uniphier_spi_transfer_one_irq(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %2)\nbr label %B4\n\nB3:\n%17 = tail call i32 @uniphier_spi_transfer_one_poll(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %2)\nbr label %B4\n\nB4:\n%18 = phi i32 [ %16, %B2 ], [ %17, %B3 ], [ 0, %B ]\nret i32 %18\n}", "codellama": "define internal i32 @uniphier_spi_transfer_one(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @spi_master_get_devdata(ptr noundef %0)\n%4 = load i64, ptr %2, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = tail call i32 @uniphier_spi_setup_transfer(ptr noundef %1, ptr noundef nonnull %2)\n%7 = load i32, ptr @SSI_POLL_TIMEOUT_US, align 4\n%8 = load i32, ptr %3, align 4\n%9 = mul nsw i32 %8, %7\n%10 = load i32, ptr @USEC_PER_SEC, align 4\n%11 = load i32, ptr @BITS_PER_BYTE, align 4\n%12 = mul nsw i32 %11, %10\n%13 = tail call i64 @DIV_ROUND_UP(i32 noundef %9, i32 noundef %12)\n%14 = load i64, ptr %2, align 8\n%15 = icmp ugt i64 %14, %13\nbr i1 %15, label %B2, label %B3\n\nB2:\n%16 = tail call i32 @uniphier_spi_transfer_one_irq(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %2)\nbr label %B4\n\nB3:\n%17 = tail call i32 @uniphier_spi_transfer_one_poll(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %2)\nbr label %B4\n\nB4:\n%18 = phi i32 [ %16, %B2 ], [ %17, %B3 ], [ 0, %B ]\nret i32 %18\n}", "codegemma": "define internal i32 @uniphier_spi_transfer_one(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @spi_master_get_devdata(ptr noundef %0)\n%4 = load i64, ptr %2, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = tail call i32 @uniphier_spi_setup_transfer(ptr noundef %1, ptr noundef nonnull %2)\n%7 = load i32, ptr @SSI_POLL_TIMEOUT_US, align 4\n%8 = load i32, ptr %3, align 4\n%9 = mul nsw i32 %8, %7\n%10 = load i32, ptr @USEC_PER_SEC, align 4\n%11 = load i32, ptr @BITS_PER_BYTE, align 4\n%12 = mul nsw i32 %11, %10\n%13 = tail call i64 @DIV_ROUND_UP(i32 noundef %9, i32 noundef %12)\n%14 = load i64, ptr %2, align 8\n%15 = icmp ugt i64 %14, %13\nbr i1 %15, label %B2, label %B3\n\nB2:\n%16 = tail call i32 @uniphier_spi_transfer_one_irq(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %2)\nbr label %B4\n\nB3:\n%17 = tail call i32 @uniphier_spi_transfer_one_poll(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %2)\nbr label %B4\n\nB4:\n%18 = phi i32 [ %16, %B2 ], [ %17, %B3 ], [ 0, %B ]\nret i32 %18\n}"}, "define dso_local ptr @copy_seat_config(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.seat_config ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call ptr @new_seat_config(i32 noundef %8)\nstore ptr %9, ptr %4, align 8\n%10 = load ptr, ptr %4, align 8\n%11 = icmp eq ptr %10, null\nbr i1 %11, label %12, label %13\n\n12:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %18\n\n13:\n%14 = load ptr, ptr %4, align 8\n%15 = load ptr, ptr %3, align 8\n%16 = call i32 @merge_seat_config(ptr noundef %14, ptr noundef %15)\n%17 = load ptr, ptr %4, align 8\nstore ptr %17, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %18\n\n18:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%19 = load ptr, ptr %2, align 8\nret ptr %19\n}": {"base_truth": "define dso_local ptr @copy_seat_config(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call ptr @new_seat_config(i32 noundef %1)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @merge_seat_config(ptr noundef nonnull %2, ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret ptr %2\n}", "codellama": "define dso_local ptr @copy_seat_config(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call ptr @new_seat_config(i32 noundef %1)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @merge_seat_config(ptr noundef nonnull %2, ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret ptr %2\n}", "codegemma": "define dso_local ptr @copy_seat_config(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call ptr @new_seat_config(i32 noundef %1)\n%3 = icmp eq ptr %2, null\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @merge_seat_config(ptr noundef nonnull %2, ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret ptr %2\n}"}, "define dso_local void @debugger_init() {\n%1 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr %1)\n%2 = call i32 @memset(ptr noundef %1, i32 noundef 0, i32 noundef 12)\n%3 = load i32, ptr @debugger_signal_handler, align 4\n%4 = getelementptr inbounds %struct.sigaction, ptr %1, i32 0, i32 2\nstore i32 %3, ptr %4, align 4\n%5 = load i32, ptr @SA_RESTART, align 4\n%6 = load i32, ptr @SA_SIGINFO, align 4\n%7 = or i32 %5, %6\n%8 = getelementptr inbounds %struct.sigaction, ptr %1, i32 0, i32 0\nstore i32 %7, ptr %8, align 4\n%9 = getelementptr inbounds %struct.sigaction, ptr %1, i32 0, i32 1\n%10 = call i32 @sigemptyset(ptr noundef %9)\n%11 = load i32, ptr @SIGILL, align 4\n%12 = call i32 @sigaction(i32 noundef %11, ptr noundef %1, ptr noundef null)\n%13 = load i32, ptr @SIGABRT, align 4\n%14 = call i32 @sigaction(i32 noundef %13, ptr noundef %1, ptr noundef null)\n%15 = load i32, ptr @SIGBUS, align 4\n%16 = call i32 @sigaction(i32 noundef %15, ptr noundef %1, ptr noundef null)\n%17 = load i32, ptr @SIGFPE, align 4\n%18 = call i32 @sigaction(i32 noundef %17, ptr noundef %1, ptr noundef null)\n%19 = load i32, ptr @SIGSEGV, align 4\n%20 = call i32 @sigaction(i32 noundef %19, ptr noundef %1, ptr noundef null)\n%21 = load i32, ptr @SIGPIPE, align 4\n%22 = call i32 @sigaction(i32 noundef %21, ptr noundef %1, ptr noundef null)\ncall void @llvm.lifetime.end.p0(i64 12, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @debugger_init() {\nB:\n%0 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %0)\n%1 = call i32 @memset(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 12)\n%2 = load i32, ptr @debugger_signal_handler, align 4\n%3 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 2\nstore i32 %2, ptr %3, align 4\n%4 = load i32, ptr @SA_RESTART, align 4\n%5 = load i32, ptr @SA_SIGINFO, align 4\n%6 = or i32 %5, %4\nstore i32 %6, ptr %0, align 4\n%7 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 1\n%8 = call i32 @sigemptyset(ptr noundef nonnull %7)\n%9 = load i32, ptr @SIGILL, align 4\n%10 = call i32 @sigaction(i32 noundef %9, ptr noundef nonnull %0, ptr noundef null)\n%11 = load i32, ptr @SIGABRT, align 4\n%12 = call i32 @sigaction(i32 noundef %11, ptr noundef nonnull %0, ptr noundef null)\n%13 = load i32, ptr @SIGBUS, align 4\n%14 = call i32 @sigaction(i32 noundef %13, ptr noundef nonnull %0, ptr noundef null)\n%15 = load i32, ptr @SIGFPE, align 4\n%16 = call i32 @sigaction(i32 noundef %15, ptr noundef nonnull %0, ptr noundef null)\n%17 = load i32, ptr @SIGSEGV, align 4\n%18 = call i32 @sigaction(i32 noundef %17, ptr noundef nonnull %0, ptr noundef null)\n%19 = load i32, ptr @SIGPIPE, align 4\n%20 = call i32 @sigaction(i32 noundef %19, ptr noundef nonnull %0, ptr noundef null)\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @debugger_init() {\nB:\n%0 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %0)\n%1 = call i32 @memset(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 12)\n%2 = load i32, ptr @debugger_signal_handler, align 4\n%3 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 2\nstore i32 %2, ptr %3, align 4\n%4 = load i32, ptr @SA_RESTART, align 4\n%5 = load i32, ptr @SA_SIGINFO, align 4\n%6 = or i32 %5, %4\nstore i32 %6, ptr %0, align 4\n%7 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 1\n%8 = call i32 @sigemptyset(ptr noundef nonnull %7)\n%9 = load i32, ptr @SIGILL, align 4\n%10 = call i32 @sigaction(i32 noundef %9, ptr noundef nonnull %0, ptr noundef null)\n%11 = load i32, ptr @SIGABRT, align 4\n%12 = call i32 @sigaction(i32 noundef %11, ptr noundef nonnull %0, ptr noundef null)\n%13 = load i32, ptr @SIGBUS, align 4\n%14 = call i32 @sigaction(i32 noundef %13, ptr noundef nonnull %0, ptr noundef null)\n%15 = load i32, ptr @SIGFPE, align 4\n%16 = call i32 @sigaction(i32 noundef %15, ptr noundef nonnull %0, ptr noundef null)\n%17 = load i32, ptr @SIGSEGV, align 4\n%18 = call i32 @sigaction(i32 noundef %17, ptr noundef nonnull %0, ptr noundef null)\n%19 = load i32, ptr @SIGPIPE, align 4\n%20 = call i32 @sigaction(i32 noundef %19, ptr noundef nonnull %0, ptr noundef null)\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @debugger_init() {\nB:\n%0 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 12, ptr nonnull %0)\n%1 = call i32 @memset(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 12)\n%2 = load i32, ptr @debugger_signal_handler, align 4\n%3 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 2\nstore i32 %2, ptr %3, align 4\n%4 = load i32, ptr @SA_RESTART, align 4\n%5 = load i32, ptr @SA_SIGINFO, align 4\n%6 = or i32 %5, %4\nstore i32 %6, ptr %0, align 4\n%7 = getelementptr inbounds %struct.sigaction, ptr %0, i64 0, i32 1\n%8 = call i32 @sigemptyset(ptr noundef nonnull %7)\n%9 = load i32, ptr @SIGILL, align 4\n%10 = call i32 @sigaction(i32 noundef %9, ptr noundef nonnull %0, ptr noundef null)\n%11 = load i32, ptr @SIGABRT, align 4\n%12 = call i32 @sigaction(i32 noundef %11, ptr noundef nonnull %0, ptr noundef null)\n%13 = load i32, ptr @SIGBUS, align 4\n%14 = call i32 @sigaction(i32 noundef %13, ptr noundef nonnull %0, ptr noundef null)\n%15 = load i32, ptr @SIGFPE, align 4\n%16 = call i32 @sigaction(i32 noundef %15, ptr noundef nonnull %0, ptr noundef null)\n%17 = load i32, ptr @SIGSEGV, align 4\n%18 = call i32 @sigaction(i32 noundef %17, ptr noundef nonnull %0, ptr noundef null)\n%19 = load i32, ptr @SIGPIPE, align 4\n%20 = call i32 @sigaction(i32 noundef %19, ptr noundef nonnull %0, ptr noundef null)\ncall void @llvm.lifetime.end.p0(i64 12, ptr nonnull %0)\nret void\n}"}, "define dso_local void @Z80_SLAH(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\n%7 = call i32 @Z80_SLAHelper(ptr noundef %3, i32 noundef %6)\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.TYPE_4__, ptr %8, i32 0, i32 0\nstore i32 %7, ptr %9, align 4\nret void\n}": {"base_truth": "define dso_local void @Z80_SLAH(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_SLAHelper(ptr noundef nonnull %0, i32 noundef %1)\nstore i32 %2, ptr %0, align 4\nret void\n}", "codellama": "define dso_local void @Z80_SLAH(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_SLAHelper(ptr noundef nonnull %0, i32 noundef %1)\nstore i32 %2, ptr %0, align 4\nret void\n}", "codegemma": "define dso_local void @Z80_SLAH(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_SLAHelper(ptr noundef nonnull %0, i32 noundef %1)\nstore i32 %2, ptr %0, align 4\nret void\n}"}, "define internal i32 @freq_r3A_value(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load i32, ptr %2, align 4\n%5 = icmp slt i32 %4, 5091\nbr i1 %5, label %6, label %7\n\n6:\nstore i32 64, ptr %3, align 4\nbr label %18\n\n7:\n%8 = load i32, ptr %2, align 4\n%9 = icmp slt i32 %8, 5321\nbr i1 %9, label %10, label %11\n\n10:\nstore i32 0, ptr %3, align 4\nbr label %17\n\n11:\n%12 = load i32, ptr %2, align 4\n%13 = icmp slt i32 %12, 5806\nbr i1 %13, label %14, label %15\n\n14:\nstore i32 128, ptr %3, align 4\nbr label %16\n\n15:\nstore i32 64, ptr %3, align 4\nbr label %16\n\n16:\nbr label %17\n\n17:\nbr label %18\n\n18:\n%19 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %19\n}": {"base_truth": "define internal i32 @freq_r3A_value(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 5091\n%2 = icmp ult i32 %0, 5321\n%3 = icmp ult i32 %0, 5806\n%4 = select i1 %3, i32 128, i32 64\n%5 = select i1 %2, i32 0, i32 %4\n%6 = select i1 %1, i32 64, i32 %5\nret i32 %6\n}", "codellama": "define internal i32 @freq_r3A_value(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 5091\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = icmp ult i32 %0, 5321\nbr i1 %2, label %B3, label %B2\n\nB2:\n%3 = icmp ult i32 %0, 5806\n%4 = select i1 %3, i32 128, i32 64\nbr label %B3\n\nB3:\n%5 = phi i32 [ 64, %B ], [ 0, %B1 ], [ %4, %B2 ]\nret i32 %5\n}", "codegemma": "define internal i32 @freq_r3A_value(i32 noundef %0) {\nB:\n%1 = icmp slt i32 %0, 5091\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = icmp slt i32 %0, 5321\nbr i1 %2, label %B3, label %B2\n\nB2:\n%3 = icmp slt i32 %0, 5806\n%4 = select i1 %3, i32 128, i32 64\nbr label %B3\n\nB3:\n%5 = phi i32 [ 64, %B ], [ 0, %B1 ], [ %4, %B2 ]\nret i32 %5\n}"}, "define dso_local void @call_glColor4bv(i64 noundef %0) {\n%2 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\n%3 = load i32, ptr @sub_gl_called, align 4\n%4 = icmp ne i32 %3, 0\nbr i1 %4, label %7, label %5\n\n5:\n%6 = call i32 @error(i32 noundef 270)\nbr label %7\n\n7:\n%8 = load i64, ptr %2, align 8\n%9 = inttoptr i64 %8 to ptr\n%10 = call i32 @glColor4bv(ptr noundef %9)\nret void\n}": {"base_truth": "define dso_local void @call_glColor4bv(i64 noundef %0) {\nB:\n%1 = load i32, ptr @sub_gl_called, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @error(i32 noundef 270)\nbr label %B2\n\nB2:\n%4 = inttoptr i64 %0 to ptr\n%5 = tail call i32 @glColor4bv(ptr noundef %4)\nret void\n}", "codellama": "define dso_local void @call_glColor4bv(i64 noundef %0) {\nB:\n%1 = load i32, ptr @sub_gl_called, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @error(i32 noundef 270)\nbr label %B2\n\nB2:\n%4 = inttoptr i64 %0 to ptr\n%5 = tail call i32 @glColor4bv(ptr noundef %4)\nret void\n}", "codegemma": "define dso_local void @call_glColor4bv(i64 noundef %0) {\nB:\n%1 = load i32, ptr @sub_gl_called, align 4\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @error(i32 noundef 270)\nbr label %B2\n\nB2:\n%4 = inttoptr i64 %0 to ptr\n%5 = tail call i32 @glColor4bv(ptr noundef %4)\nret void\n}"}, "define dso_local ptr @neq_sym() {\n%1 = load ptr, ptr @Neq_sym, align 8\nret ptr %1\n}": {"base_truth": "define dso_local ptr @neq_sym() {\nB:\n%0 = load ptr, ptr @Neq_sym, align 8\nret ptr %0\n}", "codellama": "define dso_local ptr @neq_sym() {\nB:\n%0 = load ptr, ptr @Neq_sym, align 8\nret ptr %0\n}", "codegemma": "define dso_local ptr @neq_sym() {\nB:\n%0 = load ptr, ptr @Neq_sym, align 8\nret ptr %0\n}"}, "define dso_local ptr @subtilis_exp_new_int32_var(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = load ptr, ptr %4, align 8\n%7 = call ptr @subtilis_exp_new_var(ptr noundef @subtilis_type_integer, i32 noundef %5, ptr noundef %6)\nret ptr %7\n}": {"base_truth": "define dso_local ptr @subtilis_exp_new_int32_var(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @subtilis_exp_new_var(ptr noundef nonnull @subtilis_type_integer, i32 noundef %0, ptr noundef %1)\nret ptr %2\n}", "codellama": "define dso_local ptr @subtilis_exp_new_int32_var(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @subtilis_exp_new_var(ptr noundef nonnull @subtilis_type_integer, i32 noundef %0, ptr noundef %1)\nret ptr %2\n}", "codegemma": "define dso_local ptr @subtilis_exp_new_int32_var(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @subtilis_exp_new_var(ptr noundef nonnull @subtilis_type_integer, i32 noundef %0, ptr noundef %1)\nret ptr %2\n}"}, "define dso_local i32 @xdr_int32(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%8 = load ptr, ptr %4, align 8\n%9 = load ptr, ptr %5, align 8\n%10 = call i32 @xdr_long(ptr noundef %8, ptr noundef %9)\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %14, label %12\n\n12:\n%13 = load i32, ptr @FALSE, align 4\nstore i32 %13, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %16\n\n14:\n%15 = load i32, ptr @TRUE, align 4\nstore i32 %15, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %16\n\n16:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%17 = load i32, ptr %3, align 4\nret i32 %17\n}": {"base_truth": "define dso_local i32 @xdr_int32(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_long(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @TRUE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}", "codellama": "define dso_local i32 @xdr_int32(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_long(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @TRUE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}", "codegemma": "define dso_local i32 @xdr_int32(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_long(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @TRUE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}"}, "define dso_local void @do_backspace(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 2\n%6 = load i32, ptr %5, align 8\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 8\n%10 = call i32 @eb_prevc(i32 noundef %6, i32 noundef %9, ptr noundef %3)\n%11 = load i32, ptr %3, align 4\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.TYPE_3__, ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 8\n%15 = icmp slt i32 %11, %14\nbr i1 %15, label %16, label %40\n\n16:\n%17 = load ptr, ptr %2, align 8\n%18 = getelementptr inbounds %struct.TYPE_3__, ptr %17, i32 0, i32 2\n%19 = load i32, ptr %18, align 8\n%20 = load i32, ptr %3, align 4\n%21 = load ptr, ptr %2, align 8\n%22 = getelementptr inbounds %struct.TYPE_3__, ptr %21, i32 0, i32 0\n%23 = load i32, ptr %22, align 8\n%24 = load i32, ptr %3, align 4\n%25 = sub nsw i32 %23, %24\n%26 = call i32 @eb_delete(i32 noundef %19, i32 noundef %20, i32 noundef %25)\n%27 = load i32, ptr %3, align 4\n%28 = load ptr, ptr %2, align 8\n%29 = getelementptr inbounds %struct.TYPE_3__, ptr %28, i32 0, i32 0\nstore i32 %27, ptr %29, align 8\n%30 = load ptr, ptr %2, align 8\n%31 = getelementptr inbounds %struct.TYPE_3__, ptr %30, i32 0, i32 1\n%32 = load i64, ptr %31, align 8\n%33 = icmp sgt i64 %32, 0\nbr i1 %33, label %34, label %39\n\n34:\n%35 = load ptr, ptr %2, align 8\n%36 = getelementptr inbounds %struct.TYPE_3__, ptr %35, i32 0, i32 1\n%37 = load i64, ptr %36, align 8\n%38 = add nsw i64 %37, -1\nstore i64 %38, ptr %36, align 8\nbr label %39\n\n39:\nbr label %40\n\n40:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @do_backspace(ptr nocapture noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 8\n%4 = load i32, ptr %0, align 8\n%5 = call i32 @eb_prevc(i32 noundef %3, i32 noundef %4, ptr noundef nonnull %1)\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr %0, align 8\n%8 = icmp slt i32 %6, %7\nbr i1 %8, label %B1, label %B3\n\nB1:\n%9 = load i32, ptr %2, align 8\n%10 = sub nsw i32 %7, %6\n%11 = call i32 @eb_delete(i32 noundef %9, i32 noundef %6, i32 noundef %10)\n%12 = load i32, ptr %1, align 4\nstore i32 %12, ptr %0, align 8\n%13 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%14 = load i64, ptr %13, align 8\n%15 = icmp sgt i64 %14, 0\nbr i1 %15, label %B2, label %B3\n\nB2:\n%16 = add nsw i64 %14, -1\nstore i64 %16, ptr %13, align 8\nbr label %B3\n\nB3:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @do_backspace(ptr nocapture noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 8\n%4 = load i32, ptr %0, align 8\n%5 = call i32 @eb_prevc(i32 noundef %3, i32 noundef %4, ptr noundef nonnull %1)\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr %0, align 8\n%8 = icmp slt i32 %6, %7\nbr i1 %8, label %B1, label %B3\n\nB1:\n%9 = load i32, ptr %2, align 8\n%10 = sub nsw i32 %7, %6\n%11 = call i32 @eb_delete(i32 noundef %9, i32 noundef %6, i32 noundef %10)\nstore i32 %6, ptr %0, align 8\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%13 = load i64, ptr %12, align 8\n%14 = icmp sgt i64 %13, 0\nbr i1 %14, label %B2, label %B3\n\nB2:\n%15 = add nsw i64 %13, -1\nstore i64 %15, ptr %12, align 8\nbr label %B3\n\nB3:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @do_backspace(ptr nocapture noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%3 = load i32, ptr %2, align 8\n%4 = load i32, ptr %0, align 8\n%5 = call i32 @eb_prevc(i32 noundef %3, i32 noundef %4, ptr noundef nonnull %1)\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr %0, align 8\n%8 = icmp slt i32 %6, %7\nbr i1 %8, label %B1, label %B3\n\nB1:\n%9 = load i32, ptr %2, align 8\n%10 = sub nsw i32 %7, %6\n%11 = call i32 @eb_delete(i32 noundef %9, i32 noundef %6, i32 noundef %10)\nstore i32 %6, ptr %0, align 8\n%12 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%13 = load i64, ptr %12, align 8\n%14 = icmp sgt i64 %13, 0\nbr i1 %14, label %B2, label %B3\n\nB2:\n%15 = add nsw i64 %13, -1\nstore i64 %15, ptr %12, align 8\nbr label %B3\n\nB3:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}"}, "define dso_local void @radio_write_rom_frequency() {\n%1 = alloca i8, align 1\n%2 = alloca i8, align 1\ncall void @llvm.lifetime.start.p0(i64 1, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 1, ptr %2)\n%3 = load i32, ptr @freqency, align 4\n%4 = and i32 %3, 65280\n%5 = ashr i32 %4, 8\n%6 = trunc i32 %5 to i8\nstore i8 %6, ptr %1, align 1\n%7 = load i32, ptr @freqency, align 4\n%8 = and i32 %7, 255\n%9 = trunc i32 %8 to i8\nstore i8 %9, ptr %2, align 1\n%10 = load i8, ptr %2, align 1\n%11 = call i32 @rom_write(i32 noundef 51, i8 noundef zeroext %10)\n%12 = load i8, ptr %1, align 1\n%13 = call i32 @rom_write(i32 noundef 50, i8 noundef zeroext %12)\ncall void @llvm.lifetime.end.p0(i64 1, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 1, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @radio_write_rom_frequency() {\nB:\n%0 = load i32, ptr @freqency, align 4\n%1 = lshr i32 %0, 8\n%2 = trunc i32 %1 to i8\n%3 = trunc i32 %0 to i8\n%4 = tail call i32 @rom_write(i32 noundef 51, i8 noundef zeroext %3)\n%5 = tail call i32 @rom_write(i32 noundef 50, i8 noundef zeroext %2)\nret void\n}", "codellama": "define dso_local void @radio_write_rom_frequency() {\nB:\n%0 = load i32, ptr @freqency, align 4\n%1 = lshr i32 %0, 8\n%2 = and i32 %1, 255\n%3 = trunc i32 %2 to i8\n%4 = and i32 %0, 255\n%5 = trunc i32 %4 to i8\n%6 = tail call i32 @rom_write(i32 noundef 51, i8 noundef zeroext %5)\n%7 = tail call i32 @rom_write(i32 noundef 50, i8 noundef zeroext %3)\nret void\n}", "codegemma": "define dso_local void @radio_write_rom_frequency() {\nB:\n%0 = load i32, ptr @freqency, align 4\n%1 = lshr i32 %0, 8\n%2 = trunc i32 %1 to i8\n%3 = and i8 %2, 255\n%4 = tail call i32 @rom_write(i32 noundef 51, i8 noundef zeroext %3)\n%5 = tail call i32 @rom_write(i32 noundef 50, i8 noundef zeroext %2)\nret void\n}"}, "define dso_local i32 @isAttacking(i64 %0, i64 %1, i64 %2, i64 %3) {\n%5 = alloca %struct.TYPE_4__, align 8\n%6 = alloca %struct.TYPE_4__, align 8\n%7 = getelementptr inbounds { i64, i64 }, ptr %5, i32 0, i32 0\nstore i64 %0, ptr %7, align 8\n%8 = getelementptr inbounds { i64, i64 }, ptr %5, i32 0, i32 1\nstore i64 %1, ptr %8, align 8\n%9 = getelementptr inbounds { i64, i64 }, ptr %6, i32 0, i32 0\nstore i64 %2, ptr %9, align 8\n%10 = getelementptr inbounds { i64, i64 }, ptr %6, i32 0, i32 1\nstore i64 %3, ptr %10, align 8\n%11 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 0\n%12 = load i64, ptr %11, align 8\n%13 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 0\n%14 = load i64, ptr %13, align 8\n%15 = icmp eq i64 %12, %14\nbr i1 %15, label %36, label %16\n\n16:\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 1\n%18 = load i64, ptr %17, align 8\n%19 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 1\n%20 = load i64, ptr %19, align 8\n%21 = icmp eq i64 %18, %20\nbr i1 %21, label %36, label %22\n\n22:\n%23 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 0\n%24 = load i64, ptr %23, align 8\n%25 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 0\n%26 = load i64, ptr %25, align 8\n%27 = sub nsw i64 %24, %26\n%28 = call i64 @abs(i64 noundef %27)\n%29 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 1\n%30 = load i64, ptr %29, align 8\n%31 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 1\n%32 = load i64, ptr %31, align 8\n%33 = sub nsw i64 %30, %32\n%34 = call i64 @abs(i64 noundef %33)\n%35 = icmp eq i64 %28, %34\nbr label %36\n\n36:\n%37 = phi i1 [ true, %16 ], [ true, %4 ], [ %35, %22 ]\n%38 = zext i1 %37 to i32\nret i32 %38\n}": {"base_truth": "define dso_local i32 @isAttacking(i64 %0, i64 %1, i64 %2, i64 %3) {\nB:\n%4 = icmp eq i64 %0, %2\n%5 = icmp eq i64 %1, %3\n%6 = select i1 %4, i1 true, i1 %5\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = sub nsw i64 %1, %3\n%8 = sub nsw i64 %0, %2\n%9 = tail call i64 @abs(i64 noundef %8)\n%10 = tail call i64 @abs(i64 noundef %7)\n%11 = icmp eq i64 %9, %10\n%12 = zext i1 %11 to i32\nbr label %B2\n\nB2:\n%13 = phi i32 [ 1, %B ], [ %12, %B1 ]\nret i32 %13\n}", "codellama": "define dso_local i32 @isAttacking(i64 %0, i64 %1, i64 %2, i64 %3) {\nB:\n%4 = icmp eq i64 %0, %2\n%5 = icmp eq i64 %1, %3\n%6 = select i1 %4, i1 true, i1 %5\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = sub nsw i64 %0, %2\n%8 = tail call i64 @abs(i64 noundef %7)\n%9 = sub nsw i64 %1, %3\n%10 = tail call i64 @abs(i64 noundef %9)\n%11 = icmp eq i64 %8, %10\n%12 = zext i1 %11 to i32\nbr label %B2\n\nB2:\n%13 = phi i32 [ 1, %B ], [ %12, %B1 ]\nret i32 %13\n}", "codegemma": "define dso_local i32 @isAttacking(i64 %0, i64 %1, i64 %2, i64 %3) {\nB:\n%4 = icmp eq i64 %0, %2\n%5 = icmp eq i64 %1, %3\n%6 = or i1 %4, %5\nbr i1 %6, label %B2, label %B1\n\nB1:\n%7 = sub nsw i64 %0, %2\n%8 = tail call i64 @llvm.abs.i64(i64 %7, i1 true)\n%9 = sub nsw i64 %1, %3\n%10 = tail call i64 @llvm.abs.i64(i64 %9, i1 true)\n%11 = icmp eq i64 %8, %10\n%12 = zext i1 %11 to i32\nbr label %B2\n\nB2:\n%13 = phi i32 [ 1, %B ], [ %12, %B1 ]\nret i32 %13\n}"}, "define dso_local void @wCodeEmitVar(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = call i32 @wMemTest(ptr noundef %5, ptr noundef @.str)\n%7 = load ptr, ptr %4, align 8\n%8 = call i32 @wMemTest(ptr noundef %7, ptr noundef @.str.1)\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.TYPE_10__, ptr %9, i32 0, i32 0\n%11 = load i64, ptr %10, align 8\n%12 = load i64, ptr @wTheClassScope, align 8\n%13 = icmp eq i64 %11, %12\nbr i1 %13, label %14, label %34\n\n14:\n%15 = load i32, ptr @wTheCurrentScope, align 4\n%16 = call ptr @wSymbolLookup(i32 noundef %15)\n%17 = getelementptr inbounds %struct.TYPE_11__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = load i32, ptr @W_SYM_ISSHARED, align 4\n%20 = and i32 %18, %19\n%21 = icmp ne i32 %20, 0\nbr i1 %21, label %22, label %25\n\n22:\n%23 = load i32, ptr @W_ERROR_SYNTAX, align 4\n%24 = call i32 @wErrorThrow(i32 noundef %23, ptr noundef @.str.2)\nbr label %25\n\n25:\n%26 = load ptr, ptr %3, align 8\n%27 = load i32, ptr @W_OP_PROP, align 4\n%28 = call i32 @wCodeEmitOp(ptr noundef %26, i32 noundef %27)\n%29 = load ptr, ptr %3, align 8\n%30 = load ptr, ptr %4, align 8\n%31 = getelementptr inbounds %struct.TYPE_10__, ptr %30, i32 0, i32 1\n%32 = load i32, ptr %31, align 8\n%33 = call i32 @wCodeEmit(ptr noundef %29, i32 noundef %32)\nbr label %42\n\n34:\n%35 = load ptr, ptr %3, align 8\n%36 = load i32, ptr @W_OP_VARIABLE, align 4\n%37 = call i32 @wCodeEmitOp(ptr noundef %35, i32 noundef %36)\n%38 = load ptr, ptr %3, align 8\n%39 = load ptr, ptr %4, align 8\n%40 = call i32 @wCodeGetVarIndex(ptr noundef %39)\n%41 = call i32 @wCodeEmit(ptr noundef %38, i32 noundef %40)\nbr label %42\n\n42:\nret void\n}": {"base_truth": "define dso_local void @wCodeEmitVar(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @wMemTest(ptr noundef %0, ptr noundef nonnull @.str)\n%3 = tail call i32 @wMemTest(ptr noundef %1, ptr noundef nonnull @.str.1)\n%4 = load i64, ptr %1, align 8\n%5 = load i64, ptr @wTheClassScope, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B1, label %B4\n\nB1:\n%7 = load i32, ptr @wTheCurrentScope, align 4\n%8 = tail call ptr @wSymbolLookup(i32 noundef %7)\n%9 = load i32, ptr %8, align 4\n%10 = load i32, ptr @W_SYM_ISSHARED, align 4\n%11 = and i32 %10, %9\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B2\n\nB2:\n%13 = load i32, ptr @W_ERROR_SYNTAX, align 4\n%14 = tail call i32 @wErrorThrow(i32 noundef %13, ptr noundef nonnull @.str.2)\nbr label %B3\n\nB3:\n%15 = load i32, ptr @W_OP_PROP, align 4\n%16 = tail call i32 @wCodeEmitOp(ptr noundef %0, i32 noundef %15)\n%17 = getelementptr inbounds %struct.TYPE_10__, ptr %1, i64 0, i32 1\n%18 = load i32, ptr %17, align 8\nbr label %B5\n\nB4:\n%19 = load i32, ptr @W_OP_VARIABLE, align 4\n%20 = tail call i32 @wCodeEmitOp(ptr noundef %0, i32 noundef %19)\n%21 = tail call i32 @wCodeGetVarIndex(ptr noundef nonnull %1)\nbr label %B5\n\nB5:\n%22 = phi i32 [ %21, %B4 ], [ %18, %B3 ]\n%23 = tail call i32 @wCodeEmit(ptr noundef %0, i32 noundef %22)\nret void\n}", "codellama": "define dso_local void @wCodeEmitVar(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @wMemTest(ptr noundef %0, ptr noundef nonnull @.str)\n%3 = tail call i32 @wMemTest(ptr noundef %1, ptr noundef nonnull @.str.1)\n%4 = load i64, ptr %1, align 8\n%5 = load i64, ptr @wTheClassScope, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B1, label %B4\n\nB1:\n%7 = load i32, ptr @wTheCurrentScope, align 4\n%8 = tail call ptr @wSymbolLookup(i32 noundef %7)\n%9 = load i32, ptr %8, align 4\n%10 = load i32, ptr @W_SYM_ISSHARED, align 4\n%11 = and i32 %10, %9\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B2\n\nB2:\n%13 = load i32, ptr @W_ERROR_SYNTAX, align 4\n%14 = tail call i32 @wErrorThrow(i32 noundef %13, ptr noundef nonnull @.str.2)\nbr label %B3\n\nB3:\n%15 = load i32, ptr @W_OP_PROP, align 4\n%16 = tail call i32 @wCodeEmitOp(ptr noundef %0, i32 noundef %15)\n%17 = getelementptr inbounds %struct.TYPE_10__, ptr %1, i64 0, i32 1\n%18 = load i32, ptr %17, align 8\n%19 = tail call i32 @wCodeEmit(ptr noundef %0, i32 noundef %18)\nbr label %B5\n\nB4:\n%20 = load i32, ptr @W_OP_VARIABLE, align 4\n%21 = tail call i32 @wCodeEmitOp(ptr noundef %0, i32 noundef %20)\n%22 = tail call i32 @wCodeGetVarIndex(ptr noundef nonnull %1)\n%23 = tail call i32 @wCodeEmit(ptr noundef %0, i32 noundef %22)\nbr label %B5\n\nB5:\nret void\n}", "codegemma": "define dso_local void @wCodeEmitVar(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @wMemTest(ptr noundef %0, ptr noundef nonnull @.str)\n%3 = tail call i32 @wMemTest(ptr noundef %1, ptr noundef nonnull @.str.1)\n%4 = load i64, ptr %1, align 8\n%5 = load i64, ptr @wTheClassScope, align 8\n%6 = icmp eq i64 %4, %5\nbr i1 %6, label %B1, label %B3\n\nB1:\n%7 = load i32, ptr @wTheCurrentScope, align 4\n%8 = tail call ptr @wSymbolLookup(i32 noundef %7)\n%9 = load i32, ptr %8, align 4\n%10 = load i32, ptr @W_SYM_ISSHARED, align 4\n%11 = and i32 %10, %9\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B3, label %B2\n\nB2:\n%13 = load i32, ptr @W_ERROR_SYNTAX, align 4\n%14 = tail call i32 @wErrorThrow(i32 noundef %13, ptr noundef nonnull @.str.2)\nbr label %B3\n\nB3:\n%15 = load i32, ptr @W_OP_PROP, align 4\n%16 = tail call i32 @wCodeEmitOp(ptr noundef %0, i32 noundef %15)\n%17 = getelementptr inbounds %struct.TYPE_10__, ptr %1, i64 0, i32 1\n%18 = load i32, ptr %17, align 8\n%19 = tail call i32 @wCodeEmit(ptr noundef %0, i32 noundef %18)\nret void\n}"}, "define dso_local void @ReleaseHashList(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %5, label %6\n\n5:\nbr label %15\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_4__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i64 @Release(i32 noundef %9)\n%11 = icmp eq i64 %10, 0\nbr i1 %11, label %12, label %15\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = call i32 @CleanupHashList(ptr noundef %13)\nbr label %15\n\n15:\nret void\n}": {"base_truth": "define dso_local void @ReleaseHashList(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @Release(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @CleanupHashList(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @ReleaseHashList(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @Release(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @CleanupHashList(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @ReleaseHashList(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B3, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @Release(i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @CleanupHashList(ptr noundef nonnull %0)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca [500 x i32], align 16\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 2000, ptr %6)\n%7 = call i32 @scanf(ptr noundef @.str, ptr noundef %3)\nstore i32 0, ptr %5, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %5, align 4\n%10 = load i32, ptr %3, align 4\n%11 = icmp slt i32 %9, %10\nbr i1 %11, label %12, label %20\n\n12:\n%13 = load i32, ptr %5, align 4\n%14 = sext i32 %13 to i64\n%15 = getelementptr inbounds [500 x i32], ptr %6, i64 0, i64 %14\n%16 = call i32 @scanf(ptr noundef @.str, ptr noundef %15)\nbr label %17\n\n17:\n%18 = load i32, ptr %5, align 4\n%19 = add nsw i32 %18, 1\nstore i32 %19, ptr %5, align 4\nbr label %8\n\n20:\n%21 = getelementptr inbounds [500 x i32], ptr %6, i64 0, i64 0\n%22 = load i32, ptr %3, align 4\n%23 = call i32 @minmax(ptr noundef %21, i32 noundef %22, ptr noundef %4, ptr noundef %2)\n%24 = load i32, ptr %4, align 4\n%25 = load i32, ptr %2, align 4\n%26 = add nsw i32 %24, %25\n%27 = call i32 @printf(ptr noundef @.str, i32 noundef %26)\ncall void @llvm.lifetime.end.p0(i64 2000, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca [500 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 2000, ptr nonnull %3)\n%4 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %1)\n%5 = load i32, ptr %1, align 4\n%6 = icmp sgt i32 %5, 0\nbr i1 %6, label %B1, label %B2\n\nB1:\n%7 = phi i64 [ %10, %B1 ], [ 0, %B ]\n%8 = getelementptr inbounds [500 x i32], ptr %3, i64 0, i64 %7\n%9 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %8)\n%10 = add nuw nsw i64 %7, 1\n%11 = load i32, ptr %1, align 4\n%12 = sext i32 %11 to i64\n%13 = icmp slt i64 %10, %12\nbr i1 %13, label %B1, label %B2\n\nB2:\n%14 = phi i32 [ %5, %B ], [ %11, %B1 ]\n%15 = call i32 @minmax(ptr noundef nonnull %3, i32 noundef %14, ptr noundef nonnull %2, ptr noundef nonnull %0)\n%16 = load i32, ptr %2, align 4\n%17 = load i32, ptr %0, align 4\n%18 = add nsw i32 %17, %16\n%19 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 2000, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\n%2 = alloca [500 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 2000, ptr nonnull %2)\n%3 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%4 = load i32, ptr %0, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = phi i64 [ %10, %B1 ], [ 0, %B ]\n%7 = getelementptr inbounds [500 x i32], ptr %2, i64 0, i64 %6\n%8 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %7)\n%9 = add nuw nsw i64 %6, 1\n%10 = icmp eq i64 %9, %4\nbr i1 %10, label %B2, label %B1\n\nB2:\n%11 = phi i32 [ %4, %B ], [ %4, %B1 ]\n%12 = call i32 @minmax(ptr noundef nonnull %2, i32 noundef %11, ptr noundef nonnull %1, ptr noundef nonnull %0)\n%13 = load i32, ptr %1, align 4\n%14 = load i32, ptr %0, align 4\n%15 = add nsw i32 %14, %13\n%16 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %15)\ncall void @llvm.lifetime.end.p0(i64 2000, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\n%2 = alloca [500 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 2000, ptr nonnull %2)\n%3 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0)\n%4 = load i32, ptr %0, align 4\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = phi i64 [ %9, %B1 ], [ 0, %B ]\n%7 = getelementptr inbounds [500 x i32], ptr %2, i64 0, i64 %6\n%8 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %7)\n%9 = add nuw nsw i64 %6, 1\n%10 = load i32, ptr %0, align 4\n%11 = sext i32 %10 to i64\n%12 = icmp slt i64 %9, %11\nbr i1 %12, label %B1, label %B2\n\nB2:\n%13 = phi i32 [ %4, %B ], [ %10, %B1 ]\n%14 = call i32 @minmax(ptr noundef nonnull %2, i32 noundef %13, ptr noundef nonnull %1, ptr noundef nonnull %0)\n%15 = load i32, ptr %1, align 4\n%16 = load i32, ptr %0, align 4\n%17 = add nsw i32 %16, %15\n%18 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %17)\ncall void @llvm.lifetime.end.p0(i64 2000, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local void @pwm_test_setup() {\n%1 = load i32, ptr @OUTPUT, align 4\n%2 = call i32 @pinMode(i32 noundef 5, i32 noundef %1)\n%3 = call i32 @analogWrite(i32 noundef 5, i32 noundef 128)\nret void\n}": {"base_truth": "define dso_local void @pwm_test_setup() {\nB:\n%0 = load i32, ptr @OUTPUT, align 4\n%1 = tail call i32 @pinMode(i32 noundef 5, i32 noundef %0)\n%2 = tail call i32 @analogWrite(i32 noundef 5, i32 noundef 128)\nret void\n}", "codellama": "define dso_local void @pwm_test_setup() {\nB:\n%0 = load i32, ptr @OUTPUT, align 4\n%1 = tail call i32 @pinMode(i32 noundef 5, i32 noundef %0)\n%2 = tail call i32 @analogWrite(i32 noundef 5, i32 noundef 128)\nret void\n}", "codegemma": "define dso_local void @pwm_test_setup() {\nB:\n%0 = load i32, ptr @OUTPUT, align 4\n%1 = tail call i32 @pinMode(i32 noundef 5, i32 noundef %0)\n%2 = tail call i32 @analogWrite(i32 noundef 5, i32 noundef 128)\nret void\n}"}, "define dso_local void @png_warning_parameter_unsigned(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca [24 x i8], align 16\nstore i32 %0, ptr %5, align 4\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 24, ptr %9)\n%10 = load i32, ptr %5, align 4\n%11 = load i32, ptr %6, align 4\n%12 = getelementptr inbounds [24 x i8], ptr %9, i64 0, i64 0\n%13 = getelementptr inbounds [24 x i8], ptr %9, i64 0, i64 0\n%14 = getelementptr inbounds i8, ptr %13, i64 24\n%15 = load i32, ptr %7, align 4\n%16 = load i32, ptr %8, align 4\n%17 = call i32 @png_format_number(ptr noundef %12, ptr noundef %14, i32 noundef %15, i32 noundef %16)\n%18 = call i32 @png_warning_parameter(i32 noundef %10, i32 noundef %11, i32 noundef %17)\ncall void @llvm.lifetime.end.p0(i64 24, ptr %9)\nret void\n}": {"base_truth": "define dso_local void @png_warning_parameter_unsigned(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = alloca [24 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)\n%5 = getelementptr inbounds i8, ptr %4, i64 24\n%6 = call i32 @png_format_number(ptr noundef nonnull %4, ptr noundef nonnull %5, i32 noundef %2, i32 noundef %3)\n%7 = call i32 @png_warning_parameter(i32 noundef %0, i32 noundef %1, i32 noundef %6)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)\nret void\n}", "codellama": "define dso_local void @png_warning_parameter_unsigned(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = alloca [24 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)\n%5 = getelementptr inbounds i8, ptr %4, i64 24\n%6 = call i32 @png_format_number(ptr noundef nonnull %4, ptr noundef nonnull %5, i32 noundef %2, i32 noundef %3)\n%7 = call i32 @png_warning_parameter(i32 noundef %0, i32 noundef %1, i32 noundef %6)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)\nret void\n}", "codegemma": "define dso_local void @png_warning_parameter_unsigned(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = alloca [24 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)\n%5 = getelementptr inbounds i8, ptr %4, i64 24\n%6 = call i32 @png_format_number(ptr noundef nonnull %4, ptr noundef nonnull %5, i32 noundef %2, i32 noundef %3)\n%7 = call i32 @png_warning_parameter(i32 noundef %0, i32 noundef %1, i32 noundef %6)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)\nret void\n}"}, "define dso_local void @decstbm(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = icmp ne i32 %5, 0\nbr i1 %6, label %10, label %7\n\n7:\n%8 = load i32, ptr %4, align 4\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %10, label %14\n\n10:\n%11 = load i32, ptr %3, align 4\n%12 = load i32, ptr %4, align 4\n%13 = call i32 @brc2(i32 noundef %11, i32 noundef %12, i8 noundef signext 114)\nbr label %16\n\n14:\n%15 = call i32 @esc(ptr noundef @.str)\nbr label %16\n\n16:\nret void\n}": {"base_truth": "define dso_local void @decstbm(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = or i32 %1, %0\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @brc2(i32 noundef %0, i32 noundef %1, i8 noundef signext 114)\nbr label %B3\n\nB2:\n%5 = tail call i32 @esc(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @decstbm(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp ne i32 %0, 0\n%3 = icmp ne i32 %1, 0\n%4 = or i1 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @brc2(i32 noundef %0, i32 noundef %1, i8 noundef signext 114)\nbr label %B3\n\nB2:\n%6 = tail call i32 @esc(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @decstbm(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp ne i32 %0, 0\n%3 = icmp ne i32 %1, 0\n%4 = and i1 %2, %3\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @brc2(i32 noundef %0, i32 noundef %1, i8 noundef signext 114)\nbr label %B3\n\nB2:\n%6 = tail call i32 @esc(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local i32 @git_blame_init_options(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @git_blame_options_init(ptr noundef %5, i32 noundef %6)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @git_blame_init_options(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @git_blame_options_init(ptr noundef %0, i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @git_blame_init_options(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @git_blame_options_init(ptr noundef %0, i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @git_blame_init_options(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @git_blame_options_init(ptr noundef %0, i32 noundef %1)\nret i32 %2\n}"}, "define dso_local void @USBUART_ControlReadDataStage() {\n%1 = call i32 (...) @USBUART_LoadEP0()\nret void\n}": {"base_truth": "define dso_local void @USBUART_ControlReadDataStage() {\nB:\n%0 = tail call i32 (...) @USBUART_LoadEP0()\nret void\n}", "codellama": "define dso_local void @USBUART_ControlReadDataStage() {\nB:\n%0 = tail call i32 (...) @USBUART_LoadEP0()\nret void\n}", "codegemma": "define dso_local void @USBUART_ControlReadDataStage() {\nB:\n%0 = tail call i32 (...) @USBUART_LoadEP0()\nret void\n}"}, "define internal void @nm_free_plut(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @vfree(ptr noundef %3)\nret void\n}": {"base_truth": "define internal void @nm_free_plut(ptr noundef %0) {\nB:\n%1 = tail call i32 @vfree(ptr noundef %0)\nret void\n}", "codellama": "define internal void @nm_free_plut(ptr noundef %0) {\nB:\n%1 = tail call i32 @vfree(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @nm_free_plut(ptr noundef %0) {\nB:\n%1 = tail call i32 @vfree(ptr noundef %0)\nret void\n}"}, "define dso_local void @rxrpc_reject_packet(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.rxrpc_local ptr %5, i32 0, i32 2\n%7 = call i32 @CHECK_SLAB_OKAY(ptr noundef %6)\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.rxrpc_local ptr %8, i32 0, i32 2\n%10 = call i32 @atomic_inc_not_zero(ptr noundef %9)\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %15, label %12\n\n12:\n%13 = call i32 @printk(ptr noundef @.str)\n%14 = call i32 (...) @BUG()\nbr label %15\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = getelementptr inbounds %struct.rxrpc_local ptr %16, i32 0, i32 1\n%18 = load ptr, ptr %4, align 8\n%19 = call i32 @skb_queue_tail(ptr noundef %17, ptr noundef %18)\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.rxrpc_local ptr %20, i32 0, i32 0\n%22 = call i32 @rxrpc_queue_work(ptr noundef %21)\nret void\n}": {"base_truth": "define dso_local void @rxrpc_reject_packet(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.rxrpc_local, ptr %0, i64 0, i32 2\n%3 = tail call i32 @CHECK_SLAB_OKAY(ptr noundef nonnull %2)\n%4 = tail call i32 @atomic_inc_not_zero(ptr noundef nonnull %2)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @printk(ptr noundef nonnull @.str)\n%7 = tail call i32 (...) @BUG()\nbr label %B2\n\nB2:\n%8 = getelementptr inbounds %struct.rxrpc_local, ptr %0, i64 0, i32 1\n%9 = tail call i32 @skb_queue_tail(ptr noundef nonnull %8, ptr noundef %1)\n%10 = tail call i32 @rxrpc_queue_work(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @rxrpc_reject_packet(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.rxrpc_local, ptr %0, i64 0, i32 2\n%3 = tail call i32 @CHECK_SLAB_OKAY(ptr noundef nonnull %2)\n%4 = tail call i32 @atomic_inc_not_zero(ptr noundef nonnull %2)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @printk(ptr noundef nonnull @.str)\n%7 = tail call i32 (...) @BUG()\nbr label %B2\n\nB2:\n%8 = getelementptr inbounds %struct.rxrpc_local, ptr %0, i64 0, i32 1\n%9 = tail call i32 @skb_queue_tail(ptr noundef nonnull %8, ptr noundef %1)\n%10 = tail call i32 @rxrpc_queue_work(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @rxrpc_reject_packet(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.rxrpc_local, ptr %0, i64 0, i32 2\n%3 = tail call i32 @CHECK_SLAB_OKAY(ptr noundef nonnull %2)\n%4 = tail call i32 @atomic_inc_not_zero(ptr noundef nonnull %2)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @printk(ptr noundef nonnull @.str)\n%7 = tail call i32 (...) @BUG()\nbr label %B2\n\nB2:\n%8 = getelementptr inbounds %struct.rxrpc_local, ptr %0, i64 0, i32 1\n%9 = tail call i32 @skb_queue_tail(ptr noundef nonnull %8, ptr noundef %1)\n%10 = tail call i32 @rxrpc_queue_work(ptr noundef %0)\nret void\n}"}, "define dso_local void @close_file(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = call i32 @close(i32 noundef %5)\n%7 = icmp eq i32 %6, -1\nbr i1 %7, label %8, label %15\n\n8:\n%9 = load i32, ptr @LOG_ERR, align 4\n%10 = load ptr, ptr %4, align 8\n%11 = load i32, ptr @errno, align 4\n%12 = call i32 @strerror(i32 noundef %11)\n%13 = call i32 @syslog(i32 noundef %9, ptr noundef @.str, ptr noundef %10, i32 noundef %12)\n%14 = call i32 (...) @cleanup_daemon()\nbr label %15\n\n15:\nret void\n}": {"base_truth": "define dso_local void @close_file(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @close(i32 noundef %0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @LOG_ERR, align 4\n%5 = load i32, ptr @errno, align 4\n%6 = tail call i32 @strerror(i32 noundef %5)\n%7 = tail call i32 @syslog(i32 noundef %4, ptr noundef nonnull @.str, ptr noundef %1, i32 noundef %6)\n%8 = tail call i32 (...) @cleanup_daemon()\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @close_file(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @close(i32 noundef %0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @LOG_ERR, align 4\n%5 = load i32, ptr @errno, align 4\n%6 = tail call i32 @strerror(i32 noundef %5)\n%7 = tail call i32 @syslog(i32 noundef %4, ptr noundef nonnull @.str, ptr noundef %1, i32 noundef %6)\n%8 = tail call i32 (...) @cleanup_daemon()\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @close_file(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @close(i32 noundef %0)\n%3 = icmp eq i32 %2, -1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i32, ptr @LOG_ERR, align 4\n%5 = load i32, ptr @errno, align 4\n%6 = tail call i32 @strerror(i32 noundef %5)\n%7 = tail call i32 @syslog(i32 noundef %4, ptr noundef nonnull @.str, ptr noundef %1, i32 noundef %6)\n%8 = tail call i32 (...) @cleanup_daemon()\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @init_pci() {\n%1 = call i32 (...) @init_grpci()\n%2 = call i32 (...) @pci_allocate_resources()\nret void\n}": {"base_truth": "define dso_local void @init_pci() {\nB:\n%0 = tail call i32 (...) @init_grpci()\n%1 = tail call i32 (...) @pci_allocate_resources()\nret void\n}", "codellama": "define dso_local void @init_pci() {\nB:\n%0 = tail call i32 (...) @init_grpci()\n%1 = tail call i32 (...) @pci_allocate_resources()\nret void\n}", "codegemma": "define dso_local void @init_pci() {\nB:\n%0 = tail call i32 (...) @init_grpci()\n%1 = tail call i32 (...) @pci_allocate_resources()\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\n%2 = call i32 @printArgsNoRet(i8 noundef signext 99, ptr noundef @.str)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printArgsNoRet(i8 noundef signext 99, ptr noundef nonnull @.str)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printArgsNoRet(i8 noundef signext 99, ptr noundef nonnull @.str)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printArgsNoRet(i8 noundef signext 99, ptr noundef nonnull @.str)\nret i32 0\n}"}, "define dso_local i32 @check_if_block(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i64 @strcmp(ptr noundef %3, ptr noundef @.str)\n%5 = icmp eq i64 %4, 0\n%6 = zext i1 %5 to i32\nret i32 %6\n}": {"base_truth": "define dso_local i32 @check_if_block(ptr noundef %0) {\nB:\n%1 = tail call i64 @strcmp(ptr noundef %0, ptr noundef nonnull @.str)\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define dso_local i32 @check_if_block(ptr noundef %0) {\nB:\n%1 = tail call i64 @strcmp(ptr noundef %0, ptr noundef nonnull @.str)\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define dso_local i32 @check_if_block(ptr noundef %0) {\nB:\n%1 = tail call i64 @strcmp(ptr noundef %0, ptr noundef nonnull @.str)\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define dso_local i32 @twopence_buf_ensure_tailroom(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @twopence_buf_tailroom(ptr noundef %6)\nstore i32 %7, ptr %5, align 4\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr %4, align 4\n%10 = icmp ult i32 %8, %9\nbr i1 %10, label %11, label %20\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = load ptr, ptr %3, align 8\n%14 = getelementptr inbounds %struct.TYPE_5__, ptr %13, i32 0, i32 0\n%15 = load i64, ptr %14, align 8\n%16 = load i32, ptr %4, align 4\n%17 = zext i32 %16 to i64\n%18 = add nsw i64 %15, %17\n%19 = call i32 @twopence_buf_resize(ptr noundef %12, i64 noundef %18)\nbr label %20\n\n20:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 1\n}": {"base_truth": "define dso_local i32 @twopence_buf_ensure_tailroom(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @twopence_buf_tailroom(ptr noundef %0)\n%3 = icmp ult i32 %2, %1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = zext i32 %1 to i64\n%5 = load i64, ptr %0, align 8\n%6 = add nsw i64 %5, %4\n%7 = tail call i32 @twopence_buf_resize(ptr noundef nonnull %0, i64 noundef %6)\nbr label %B2\n\nB2:\nret i32 1\n}", "codellama": "define dso_local i32 @twopence_buf_ensure_tailroom(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @twopence_buf_tailroom(ptr noundef %0)\n%3 = icmp ult i32 %2, %1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = zext i32 %1 to i64\n%5 = load i64, ptr %0, align 8\n%6 = add nsw i64 %5, %4\n%7 = tail call i32 @twopence_buf_resize(ptr noundef nonnull %0, i64 noundef %6)\nbr label %B2\n\nB2:\nret i32 1\n}", "codegemma": "define dso_local i32 @twopence_buf_ensure_tailroom(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @twopence_buf_tailroom(ptr noundef %0)\n%3 = icmp ult i32 %2, %1\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = load i64, ptr %0, align 8\n%5 = zext i32 %1 to i64\n%6 = add nsw i64 %4, %5\n%7 = tail call i32 @twopence_buf_resize(ptr noundef nonnull %0, i64 noundef %6)\nbr label %B2\n\nB2:\nret i32 1\n}"}, "define dso_local void @nfa_remove_final(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %4, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = call i64 @nfa_get_states(ptr noundef %6)\n%8 = icmp slt i64 %5, %7\nbr i1 %8, label %11, label %9\n\n9:\n%10 = call i32 @_assert(ptr noundef @.str, ptr noundef @.str.1, i32 noundef 71)\nbr label %11\n\n11:\n%12 = phi i1 [ true, %2 ], [ false, %9 ]\n%13 = zext i1 %12 to i32\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.TYPE_4__, ptr %14, i32 0, i32 0\n%16 = load i64, ptr %4, align 8\n%17 = call i32 @bitset_remove(ptr noundef %15, i64 noundef %16)\nret void\n}": {"base_truth": "define dso_local void @nfa_remove_final(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @nfa_get_states(ptr noundef %0)\n%3 = icmp sgt i64 %2, %1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @_assert(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, i32 noundef 71)\nbr label %B2\n\nB2:\n%5 = tail call i32 @bitset_remove(ptr noundef %0, i64 noundef %1)\nret void\n}", "codellama": "define dso_local void @nfa_remove_final(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @nfa_get_states(ptr noundef %0)\n%3 = icmp sgt i64 %2, %1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @_assert(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, i32 noundef 71)\nbr label %B2\n\nB2:\n%5 = tail call i32 @bitset_remove(ptr noundef %0, i64 noundef %1)\nret void\n}", "codegemma": "define dso_local void @nfa_remove_final(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call i64 @nfa_get_states(ptr noundef %0)\n%3 = icmp sgt i64 %2, %1\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = tail call i32 @_assert(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, i32 noundef 71)\nbr label %B2\n\nB2:\n%5 = tail call i32 @bitset_remove(ptr noundef %0, i64 noundef %1)\nret void\n}"}, "define dso_local void @File_close(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @close(i32 noundef %3)\nret void\n}": {"base_truth": "define dso_local void @File_close(i32 noundef %0) {\nB:\n%1 = tail call i32 @close(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @File_close(i32 noundef %0) {\nB:\n%1 = tail call i32 @close(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @File_close(i32 noundef %0) {\nB:\n%1 = tail call i32 @close(i32 noundef %0)\nret void\n}"}, "define dso_local void @SP_target_autosave(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 @G_Printf(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @SP_target_autosave(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 @G_Printf(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @SP_target_autosave(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 @G_Printf(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @SP_target_autosave(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 @G_Printf(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local i32 @DVD_GetDriveStatus() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @_CPU_ISR_Disable(i32 noundef %3)\n%5 = load i64, ptr @__dvd_fatalerror, align 8\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %7, label %8\n\n7:\nstore i32 -1, ptr %1, align 4\nbr label %24\n\n8:\n%9 = load i64, ptr @__dvd_pausingflag, align 8\n%10 = icmp ne i64 %9, 0\nbr i1 %10, label %11, label %12\n\n11:\nstore i32 8, ptr %1, align 4\nbr label %23\n\n12:\n%13 = load ptr, ptr @__dvd_executing, align 8\n%14 = icmp ne ptr %13, null\nbr i1 %14, label %15, label %18\n\n15:\n%16 = load ptr, ptr @__dvd_executing, align 8\n%17 = icmp eq ptr %16, @__dvd_dummycmdblk\nbr i1 %17, label %18, label %19\n\n18:\nstore i32 0, ptr %1, align 4\nbr label %22\n\n19:\n%20 = load ptr, ptr @__dvd_executing, align 8\n%21 = call i32 @DVD_GetCmdBlockStatus(ptr noundef %20)\nstore i32 %21, ptr %1, align 4\nbr label %22\n\n22:\nbr label %23\n\n23:\nbr label %24\n\n24:\n%25 = load i32, ptr %2, align 4\n%26 = call i32 @_CPU_ISR_Restore(i32 noundef %25)\n%27 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %27\n}": {"base_truth": "define dso_local i32 @DVD_GetDriveStatus() {\nB:\n%0 = tail call i32 @_CPU_ISR_Disable(i32 noundef undef)\n%1 = load i64, ptr @__dvd_fatalerror, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = load i64, ptr @__dvd_pausingflag, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B4\n\nB2:\n%5 = load ptr, ptr @__dvd_executing, align 8\n%6 = icmp eq ptr %5, null\n%7 = icmp eq ptr %5, @__dvd_dummycmdblk\n%8 = or i1 %6, %7\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 @DVD_GetCmdBlockStatus(ptr noundef nonnull %5)\nbr label %B4\n\nB4:\n%10 = phi i32 [ %9, %B3 ], [ -1, %B ], [ 8, %B1 ], [ 0, %B2 ]\n%11 = tail call i32 @_CPU_ISR_Restore(i32 noundef undef)\nret i32 %10\n}", "codellama": "define dso_local i32 @DVD_GetDriveStatus() {\nB:\n%0 = tail call i32 @_CPU_ISR_Disable(i32 noundef undef)\n%1 = load i64, ptr @__dvd_fatalerror, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = load i64, ptr @__dvd_pausingflag, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B4\n\nB2:\n%5 = load ptr, ptr @__dvd_executing, align 8\n%6 = icmp eq ptr %5, null\n%7 = icmp eq ptr %5, @__dvd_dummycmdblk\n%8 = or i1 %6, %7\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = tail call i32 @DVD_GetCmdBlockStatus(ptr noundef nonnull %5)\nbr label %B4\n\nB4:\n%10 = phi i32 [ -1, %B ], [ 8, %B1 ], [ %9, %B3 ], [ 0, %B2 ]\n%11 = tail call i32 @_CPU_ISR_Restore(i32 noundef undef)\nret i32 %10\n}", "codegemma": "define dso_local i32 @DVD_GetDriveStatus() {\nB:\n%0 = tail call i32 @_CPU_ISR_Disable(i32 noundef undef)\n%1 = load i64, ptr @__dvd_fatalerror, align 8\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B4\n\nB1:\n%3 = load i64, ptr @__dvd_pausingflag, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B4\n\nB2:\n%5 = load ptr, ptr @__dvd_executing, align 8\n%6 = icmp eq ptr %5, @__dvd_dummycmdblk\nbr i1 %6, label %B4, label %B3\n\nB3:\n%7 = tail call i32 @DVD_GetCmdBlockStatus(ptr noundef nonnull %5)\nbr label %B4\n\nB4:\n%8 = phi i32 [ %7, %B3 ], [ -1, %B ], [ 8, %B1 ], [ 0, %B2 ]\n%9 = tail call i32 @_CPU_ISR_Restore(i32 noundef undef)\nret i32 %8\n}"}, "define dso_local void @logic_pio_unregister_range(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 @mutex_lock(ptr noundef @io_range_mutex)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.logic_pio_hwaddr ptr %4, i32 0, i32 0\n%6 = call i32 @list_del_rcu(ptr noundef %5)\n%7 = call i32 @mutex_unlock(ptr noundef @io_range_mutex)\n%8 = call i32 (...) @synchronize_rcu()\nret void\n}": {"base_truth": "define dso_local void @logic_pio_unregister_range(ptr noundef %0) {\nB:\n%1 = tail call i32 @mutex_lock(ptr noundef nonnull @io_range_mutex)\n%2 = tail call i32 @list_del_rcu(ptr noundef %0)\n%3 = tail call i32 @mutex_unlock(ptr noundef nonnull @io_range_mutex)\n%4 = tail call i32 (...) @synchronize_rcu()\nret void\n}", "codellama": "define dso_local void @logic_pio_unregister_range(ptr noundef %0) {\nB:\n%1 = tail call i32 @mutex_lock(ptr noundef nonnull @io_range_mutex)\n%2 = tail call i32 @list_del_rcu(ptr noundef %0)\n%3 = tail call i32 @mutex_unlock(ptr noundef nonnull @io_range_mutex)\n%4 = tail call i32 (...) @synchronize_rcu()\nret void\n}", "codegemma": "define dso_local void @logic_pio_unregister_range(ptr noundef %0) {\nB:\n%1 = tail call i32 @mutex_lock(ptr noundef nonnull @io_range_mutex)\n%2 = tail call i32 @list_del_rcu(ptr noundef %0)\n%3 = tail call i32 @mutex_unlock(ptr noundef nonnull @io_range_mutex)\n%4 = tail call i32 (...) @synchronize_rcu()\nret void\n}"}, "define dso_local void @ColorSetup() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = call i32 @InitPolyColorTable(ptr noundef @myPolyColorTable)\n%3 = call i32 @SetPolyColorTable(ptr noundef @myPolyColorTable)\n%4 = call i32 @FindPolyColor(i32 noundef 16777215)\n%5 = call i32 @FindPolyColor(i32 noundef 12632256)\n%6 = call i32 @FindPolyColor(i32 noundef 8421504)\n%7 = call i32 @FindPolyColor(i32 noundef 4210752)\n%8 = call i32 @FindPolyColor(i32 noundef 0)\nstore i32 0, ptr %1, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %1, align 4\n%11 = icmp slt i32 %10, 16\nbr i1 %11, label %12, label %27\n\n12:\n%13 = load i32, ptr %1, align 4\n%14 = sext i32 %13 to i64\n%15 = mul nsw i64 %14, 17\n%16 = shl i64 %15, 16\n%17 = add nsw i64 %16, 255\n%18 = load i32, ptr %1, align 4\n%19 = sext i32 %18 to i64\n%20 = mul nsw i64 %19, 17\n%21 = sub nsw i64 %17, %20\n%22 = trunc i64 %21 to i32\n%23 = call i32 @FindPolyColor(i32 noundef %22)\nbr label %24\n\n24:\n%25 = load i32, ptr %1, align 4\n%26 = add nsw i32 %25, 1\nstore i32 %26, ptr %1, align 4\nbr label %9\n\n27:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @ColorSetup() {\nB:\n%0 = tail call i32 @InitPolyColorTable(ptr noundef nonnull @myPolyColorTable)\n%1 = tail call i32 @SetPolyColorTable(ptr noundef nonnull @myPolyColorTable)\n%2 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%3 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%4 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%5 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%6 = tail call i32 @FindPolyColor(i32 noundef 0)\n%7 = tail call i32 @FindPolyColor(i32 noundef 255)\n%8 = tail call i32 @FindPolyColor(i32 noundef 1114350)\n%9 = tail call i32 @FindPolyColor(i32 noundef 2228445)\n%10 = tail call i32 @FindPolyColor(i32 noundef 3342540)\n%11 = tail call i32 @FindPolyColor(i32 noundef 4456635)\n%12 = tail call i32 @FindPolyColor(i32 noundef 5570730)\n%13 = tail call i32 @FindPolyColor(i32 noundef 6684825)\n%14 = tail call i32 @FindPolyColor(i32 noundef 7798920)\n%15 = tail call i32 @FindPolyColor(i32 noundef 8913015)\n%16 = tail call i32 @FindPolyColor(i32 noundef 10027110)\n%17 = tail call i32 @FindPolyColor(i32 noundef 11141205)\n%18 = tail call i32 @FindPolyColor(i32 noundef 12255300)\n%19 = tail call i32 @FindPolyColor(i32 noundef 13369395)\n%20 = tail call i32 @FindPolyColor(i32 noundef 14483490)\n%21 = tail call i32 @FindPolyColor(i32 noundef 15597585)\n%22 = tail call i32 @FindPolyColor(i32 noundef 16711680)\nret void\n}", "codellama": "define dso_local void @ColorSetup() {\nB:\n%0 = tail call i32 @InitPolyColorTable(ptr noundef nonnull @myPolyColorTable)\n%1 = tail call i32 @SetPolyColorTable(ptr noundef nonnull @myPolyColorTable)\n%2 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%3 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%4 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%5 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%6 = tail call i32 @FindPolyColor(i32 noundef 0)\n%7 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%8 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%9 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%10 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%11 = tail call i32 @FindPolyColor(i32 noundef 0)\n%12 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%13 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%14 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%15 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%16 = tail call i32 @FindPolyColor(i32 noundef 0)\n%17 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%18 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%19 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%20 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%21 = tail call i32 @FindPolyColor(i32 noundef 0)\n%22 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%23 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%24 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%25 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%26 = tail call i32 @FindPolyColor(i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @ColorSetup() {\nB:\n%0 = tail call i32 @InitPolyColorTable(ptr noundef nonnull @myPolyColorTable)\n%1 = tail call i32 @SetPolyColorTable(ptr noundef nonnull @myPolyColorTable)\n%2 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%3 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%4 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%5 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%6 = tail call i32 @FindPolyColor(i32 noundef 0)\n%7 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%8 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%9 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%10 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%11 = tail call i32 @FindPolyColor(i32 noundef 0)\n%12 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%13 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%14 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%15 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%16 = tail call i32 @FindPolyColor(i32 noundef 0)\n%17 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%18 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%19 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%20 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%21 = tail call i32 @FindPolyColor(i32 noundef 0)\n%22 = tail call i32 @FindPolyColor(i32 noundef 16777215)\n%23 = tail call i32 @FindPolyColor(i32 noundef 12632256)\n%24 = tail call i32 @FindPolyColor(i32 noundef 8421504)\n%25 = tail call i32 @FindPolyColor(i32 noundef 4210752)\n%26 = tail call i32 @FindPolyColor(i32 noundef 0)\nret void\n}"}, "define dso_local void @f_gt_rc4(float noundef nofpclass(nan inf) %0) {\n%2 = alloca float, align 4\nstore float %0, ptr %2, align 4\n%3 = load float, ptr %2, align 4\n%4 = fcmp fast ogt float %3, 1.000000e+02\nbr i1 %4, label %5, label %8\n\n5:\n%6 = load i32, ptr @x, align 4\n%7 = add nsw i32 %6, 1\nstore i32 %7, ptr @x, align 4\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @f_gt_rc4(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fcmp fast ogt float %0, 1.000000e+02\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i32, ptr @x, align 4\n%3 = add nsw i32 %2, 1\nstore i32 %3, ptr @x, align 4\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @f_gt_rc4(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fcmp fast ogt float %0, 1.000000e+02\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i32, ptr @x, align 4\n%3 = add nsw i32 %2, 1\nstore i32 %3, ptr @x, align 4\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @f_gt_rc4(float noundef nofpclass(nan inf) %0) {\nB:\n%1 = fcmp fast ogt float %0, 1.000000e+02\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i32, ptr @x, align 4\n%3 = add nsw i32 %2, 1\nstore i32 %3, ptr @x, align 4\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @nfs_expire_all_delegations(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @FMODE_READ, align 4\n%5 = load i32, ptr @FMODE_WRITE, align 4\n%6 = or i32 %4, %5\n%7 = call i32 @nfs_expire_all_delegation_types(ptr noundef %3, i32 noundef %6)\nret void\n}": {"base_truth": "define dso_local void @nfs_expire_all_delegations(ptr noundef %0) {\nB:\n%1 = load i32, ptr @FMODE_READ, align 4\n%2 = load i32, ptr @FMODE_WRITE, align 4\n%3 = or i32 %2, %1\n%4 = tail call i32 @nfs_expire_all_delegation_types(ptr noundef %0, i32 noundef %3)\nret void\n}", "codellama": "define dso_local void @nfs_expire_all_delegations(ptr noundef %0) {\nB:\n%1 = load i32, ptr @FMODE_READ, align 4\n%2 = load i32, ptr @FMODE_WRITE, align 4\n%3 = or i32 %2, %1\n%4 = tail call i32 @nfs_expire_all_delegation_types(ptr noundef %0, i32 noundef %3)\nret void\n}", "codegemma": "define dso_local void @nfs_expire_all_delegations(ptr noundef %0) {\nB:\n%1 = load i32, ptr @FMODE_READ, align 4\n%2 = load i32, ptr @FMODE_WRITE, align 4\n%3 = or i32 %2, %1\n%4 = tail call i32 @nfs_expire_all_delegation_types(ptr noundef %0, i32 noundef %3)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = call i32 @scanf(ptr noundef @.str, ptr noundef %2, ptr noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = load i32, ptr %3, align 4\n%7 = call i32 @calculate_the_maximum(i32 noundef %5, i32 noundef %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr %1, align 4\n%5 = call i32 @calculate_the_maximum(i32 noundef %3, i32 noundef %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr %1, align 4\n%5 = call i32 @calculate_the_maximum(i32 noundef %3, i32 noundef %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @scanf(ptr noundef nonnull @.str, ptr noundef nonnull %0, ptr noundef nonnull %1)\n%3 = load i32, ptr %0, align 4\n%4 = load i32, ptr %1, align 4\n%5 = call i32 @calculate_the_maximum(i32 noundef %3, i32 noundef %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local void @do0x1C() {\n%1 = load i32, ptr @_Reg_E, align 4\n%2 = call i32 @_I8080_INR(i32 noundef %1)\nret void\n}": {"base_truth": "define dso_local void @do0x1C() {\nB:\n%0 = load i32, ptr @_Reg_E, align 4\n%1 = tail call i32 @_I8080_INR(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @do0x1C() {\nB:\n%0 = load i32, ptr @_Reg_E, align 4\n%1 = tail call i32 @_I8080_INR(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @do0x1C() {\nB:\n%0 = load i32, ptr @_Reg_E, align 4\n%1 = tail call i32 @_I8080_INR(i32 noundef %0)\nret void\n}"}, "define dso_local void @spdy_syn_stream_destroy(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = call i32 @spdy_nv_block_destroy(ptr noundef %4)\nret void\n}": {"base_truth": "define dso_local void @spdy_syn_stream_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 @spdy_nv_block_destroy(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @spdy_syn_stream_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 @spdy_nv_block_destroy(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @spdy_syn_stream_destroy(ptr noundef %0) {\nB:\n%1 = tail call i32 @spdy_nv_block_destroy(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @id_ROM_type(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load i32, ptr @LOMEM, align 4\nret i32 %3\n}": {"base_truth": "define dso_local i32 @id_ROM_type(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @LOMEM, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @id_ROM_type(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @LOMEM, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @id_ROM_type(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @LOMEM, align 4\nret i32 %1\n}"}, "define dso_local void @ixgbe_release_swfw_sync(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%7 = load i32, ptr %4, align 4\nstore i32 %7, ptr %6, align 4\n%8 = call i32 @DEBUGFUNC(ptr noundef @.str)\n%9 = load ptr, ptr %3, align 8\n%10 = call i32 @ixgbe_get_eeprom_semaphore(ptr noundef %9)\n%11 = load ptr, ptr %3, align 8\n%12 = load i32, ptr @IXGBE_GSSR, align 4\n%13 = call i32 @IXGBE_READ_REG(ptr noundef %11, i32 noundef %12)\nstore i32 %13, ptr %5, align 4\n%14 = load i32, ptr %6, align 4\n%15 = xor i32 %14, -1\n%16 = load i32, ptr %5, align 4\n%17 = and i32 %16, %15\nstore i32 %17, ptr %5, align 4\n%18 = load ptr, ptr %3, align 8\n%19 = load i32, ptr @IXGBE_GSSR, align 4\n%20 = load i32, ptr %5, align 4\n%21 = call i32 @IXGBE_WRITE_REG(ptr noundef %18, i32 noundef %19, i32 noundef %20)\n%22 = load ptr, ptr %3, align 8\n%23 = call i32 @ixgbe_release_eeprom_semaphore(ptr noundef %22)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @ixgbe_release_swfw_sync(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%3 = tail call i32 @ixgbe_get_eeprom_semaphore(ptr noundef %0)\n%4 = load i32, ptr @IXGBE_GSSR, align 4\n%5 = tail call i32 @IXGBE_READ_REG(ptr noundef %0, i32 noundef %4)\n%6 = xor i32 %1, -1\n%7 = and i32 %5, %6\n%8 = load i32, ptr @IXGBE_GSSR, align 4\n%9 = tail call i32 @IXGBE_WRITE_REG(ptr noundef %0, i32 noundef %8, i32 noundef %7)\n%10 = tail call i32 @ixgbe_release_eeprom_semaphore(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @ixgbe_release_swfw_sync(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%3 = tail call i32 @ixgbe_get_eeprom_semaphore(ptr noundef %0)\n%4 = load i32, ptr @IXGBE_GSSR, align 4\n%5 = tail call i32 @IXGBE_READ_REG(ptr noundef %0, i32 noundef %4)\n%6 = xor i32 %1, -1\n%7 = and i32 %5, %6\n%8 = load i32, ptr @IXGBE_GSSR, align 4\n%9 = tail call i32 @IXGBE_WRITE_REG(ptr noundef %0, i32 noundef %8, i32 noundef %7)\n%10 = tail call i32 @ixgbe_release_eeprom_semaphore(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @ixgbe_release_swfw_sync(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @DEBUGFUNC(ptr noundef nonnull @.str)\n%3 = tail call i32 @ixgbe_get_eeprom_semaphore(ptr noundef %0)\n%4 = load i32, ptr @IXGBE_GSSR, align 4\n%5 = tail call i32 @IXGBE_READ_REG(ptr noundef %0, i32 noundef %4)\n%6 = xor i32 %1, -1\n%7 = and i32 %5, %6\n%8 = load i32, ptr @IXGBE_GSSR, align 4\n%9 = tail call i32 @IXGBE_WRITE_REG(ptr noundef %0, i32 noundef %8, i32 noundef %7)\n%10 = tail call i32 @ixgbe_release_eeprom_semaphore(ptr noundef %0)\nret void\n}"}, "define dso_local signext i8 @regular_char_wildcard_decode(i8 noundef signext %0) {\n%2 = alloca i8, align 1\n%3 = alloca i8, align 1\nstore i8 %0, ptr %3, align 1\n%4 = load i8, ptr %3, align 1\n%5 = call i64 @regular_char_wildcard_encoded_p(i8 noundef signext %4)\n%6 = icmp ne i64 %5, 0\nbr i1 %6, label %7, label %14\n\n7:\n%8 = load i8, ptr %3, align 1\n%9 = sext i8 %8 to i32\n%10 = load i8, ptr @DECODE_MASK, align 1\n%11 = sext i8 %10 to i32\n%12 = and i32 %9, %11\n%13 = trunc i32 %12 to i8\nstore i8 %13, ptr %2, align 1\nbr label %16\n\n14:\n%15 = load i8, ptr %3, align 1\nstore i8 %15, ptr %2, align 1\nbr label %16\n\n16:\n%17 = load i8, ptr %2, align 1\nret i8 %17\n}": {"base_truth": "define dso_local signext i8 @regular_char_wildcard_decode(i8 noundef signext %0) {\nB:\n%1 = tail call i64 @regular_char_wildcard_encoded_p(i8 noundef signext %0)\n%2 = icmp eq i64 %1, 0\n%3 = load i8, ptr @DECODE_MASK, align 1\n%4 = select i1 %2, i8 -1, i8 %3\n%5 = and i8 %4, %0\nret i8 %5\n}", "codellama": "define dso_local signext i8 @regular_char_wildcard_decode(i8 noundef signext %0) {\nB:\n%1 = tail call i64 @regular_char_wildcard_encoded_p(i8 noundef signext %0)\n%2 = icmp eq i64 %1, 0\n%3 = load i8, ptr @DECODE_MASK, align 1\n%4 = and i8 %3, %0\n%5 = select i1 %2, i8 %0, i8 %4\nret i8 %5\n}", "codegemma": "define dso_local signext i8 @regular_char_wildcard_decode(i8 noundef signext %0) {\nB:\n%1 = tail call i64 @regular_char_wildcard_encoded_p(i8 noundef signext %0)\n%2 = icmp eq i64 %1, 0\n%3 = load i8, ptr @DECODE_MASK, align 1\n%4 = select i1 %2, i8 %0, i8 %3\nret i8 %4\n}"}, "define dso_local void @DString_SubString(ptr noundef %0, ptr noundef %1, i64 noundef %2, i64 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i64, align 8\n%8 = alloca i64, align 8\n%9 = alloca i64, align 8\n%10 = alloca i64, align 8\n%11 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i64 %2, ptr %7, align 8\nstore i64 %3, ptr %8, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %10)\n%12 = load ptr, ptr %5, align 8\n%13 = getelementptr inbounds %struct.TYPE_5__, ptr %12, i32 0, i32 0\n%14 = load i64, ptr %13, align 8\nstore i64 %14, ptr %10, align 8\n%15 = load i64, ptr %7, align 8\n%16 = load i64, ptr %10, align 8\n%17 = icmp sge i64 %15, %16\nbr i1 %17, label %18, label %21\n\n18:\n%19 = load ptr, ptr %6, align 8\n%20 = call i32 @DString_Reset(ptr noundef %19, i64 noundef 0)\nstore i32 1, ptr %11, align 4\nbr label %55\n\n21:\n%22 = load i64, ptr %8, align 8\n%23 = icmp slt i64 %22, 0\nbr i1 %23, label %28, label %24\n\n24:\n%25 = load i64, ptr %8, align 8\n%26 = load i64, ptr %10, align 8\n%27 = icmp sgt i64 %25, %26\nbr i1 %27, label %28, label %30\n\n28:\n%29 = load i64, ptr %10, align 8\nstore i64 %29, ptr %8, align 8\nbr label %30\n\n30:\n%31 = load i64, ptr %7, align 8\n%32 = load i64, ptr %8, align 8\n%33 = add nsw i64 %31, %32\n%34 = load i64, ptr %10, align 8\n%35 = icmp sgt i64 %33, %34\nbr i1 %35, label %36, label %40\n\n36:\n%37 = load i64, ptr %10, align 8\n%38 = load i64, ptr %7, align 8\n%39 = sub nsw i64 %37, %38\nstore i64 %39, ptr %8, align 8\nbr label %40\n\n40:\n%41 = load ptr, ptr %6, align 8\n%42 = load i64, ptr %8, align 8\n%43 = call i32 @DString_Reset(ptr noundef %41, i64 noundef %42)\n%44 = load ptr, ptr %6, align 8\n%45 = getelementptr inbounds %struct.TYPE_5__, ptr %44, i32 0, i32 1\n%46 = load i64, ptr %45, align 8\n%47 = load ptr, ptr %5, align 8\n%48 = getelementptr inbounds %struct.TYPE_5__, ptr %47, i32 0, i32 1\n%49 = load i64, ptr %48, align 8\n%50 = load i64, ptr %7, align 8\n%51 = add nsw i64 %49, %50\n%52 = load i64, ptr %8, align 8\n%53 = mul i64 %52, 1\n%54 = call i32 @memcpy(i64 noundef %46, i64 noundef %51, i64 noundef %53)\nstore i32 0, ptr %11, align 4\nbr label %55\n\n55:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %10)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\n%56 = load i32, ptr %11, align 4\nswitch i32 %56, label %58 [\ni32 0, label %57\ni32 1, label %57\n]\n\n57:\nret void\n\n58:\nunreachable\n}": {"base_truth": "define dso_local void @DString_SubString(ptr nocapture noundef readonly %0, ptr noundef %1, i64 noundef %2, i64 noundef %3) {\nB:\n%4 = load i64, ptr %0, align 8\n%5 = icmp sgt i64 %4, %2\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @DString_Reset(ptr noundef %1, i64 noundef 0)\nbr label %B3\n\nB2:\n%7 = icmp slt i64 %3, 0\n%8 = icmp slt i64 %4, %3\n%9 = or i1 %7, %8\n%10 = select i1 %9, i64 %4, i64 %3\n%11 = add nsw i64 %10, %2\n%12 = icmp sgt i64 %11, %4\n%13 = sub nsw i64 %4, %2\n%14 = select i1 %12, i64 %13, i64 %10\n%15 = tail call i32 @DString_Reset(ptr noundef %1, i64 noundef %14)\n%16 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%17 = load i64, ptr %16, align 8\n%18 = getelementptr inbounds %struct.TYPE_5__, ptr %0, i64 0, i32 1\n%19 = load i64, ptr %18, align 8\n%20 = add nsw i64 %19, %2\n%21 = tail call i32 @memcpy(i64 noundef %17, i64 noundef %20, i64 noundef %14)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @DString_SubString(ptr nocapture noundef readonly %0, ptr noundef %1, i64 noundef %2, i64 noundef %3) {\nB:\n%4 = load i64, ptr %0, align 8\n%5 = icmp sgt i64 %4, %2\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @DString_Reset(ptr noundef %1, i64 noundef 0)\nbr label %B3\n\nB2:\n%7 = tail call i64 @llvm.smax.i64(i64 %3, i64 0)\n%8 = tail call i64 @llvm.smin.i64(i64 %7, i64 %4)\n%9 = add nsw i64 %8, %2\n%10 = tail call i32 @DString_Reset(ptr noundef %1, i64 noundef %8)\n%11 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%12 = load i64, ptr %11, align 8\n%13 = getelementptr inbounds %struct.TYPE_5__, ptr %0, i64 0, i32 1\n%14 = load i64, ptr %13, align 8\n%15 = add nsw i64 %14, %2\n%16 = tail call i32 @memcpy(i64 noundef %12, i64 noundef %15, i64 noundef %9)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @DString_SubString(ptr nocapture noundef readonly %0, ptr noundef %1, i64 noundef %2, i64 noundef %3) {\nB:\n%4 = load i64, ptr %0, align 8\n%5 = icmp sgt i64 %4, %2\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @DString_Reset(ptr noundef %1, i64 noundef 0)\nbr label %B5\n\nB2:\n%7 = icmp sgt i64 %4, %3\n%8 = select i1 %7, i64 %4, i64 %3\n%9 = add nsw i64 %8, %2\n%10 = icmp sgt i64 %9, %4\n%11 = sub nsw i64 %4, %2\n%12 = select i1 %10, i64 %11, i64 %8\n%13 = tail call i32 @DString_Reset(ptr noundef %1, i64 noundef %12)\n%14 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%15 = load i64, ptr %14, align 8\n%16 = getelementptr inbounds %struct.TYPE_5__, ptr %0, i64 0, i32 1\n%17 = load i64, ptr %16, align 8\n%18 = add nsw i64 %17, %2\n%19 = tail call i32 @memcpy(i64 noundef %15, i64 noundef %18, i64 noundef %12)\nbr label %B5\n\nB3:\n%20 = tail call i32 @DString_Reset(ptr noundef nonnull %1, i64 noundef 0)\nbr label %B5\n\nB4:\n%21 = tail call i32 @DString_Reset(ptr noundef nonnull %1, i64 noundef 0)\nbr label %B5\n\nB5:\nret void\n}"}, "define internal i32 @get_l2_indirect_reg(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i64, align 8\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load i64, ptr %4, align 8\n%6 = call i32 @raw_spin_lock_irqsave(ptr noundef @l2_access_lock, i64 noundef %5)\n%7 = load i32, ptr %2, align 4\n%8 = load i32, ptr @L2CPUSRSELR_EL1, align 4\n%9 = call i32 @write_sysreg_s(i32 noundef %7, i32 noundef %8)\n%10 = call i32 (...) @isb()\n%11 = load i32, ptr @L2CPUSRDR_EL1, align 4\n%12 = call i32 @read_sysreg_s(i32 noundef %11)\nstore i32 %12, ptr %3, align 4\n%13 = load i64, ptr %4, align 8\n%14 = call i32 @raw_spin_unlock_irqrestore(ptr noundef @l2_access_lock, i64 noundef %13)\n%15 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %15\n}": {"base_truth": "define internal i32 @get_l2_indirect_reg(i32 noundef %0) {\nB:\n%1 = tail call i32 @raw_spin_lock_irqsave(ptr noundef nonnull @l2_access_lock, i64 noundef undef)\n%2 = load i32, ptr @L2CPUSRSELR_EL1, align 4\n%3 = tail call i32 @write_sysreg_s(i32 noundef %0, i32 noundef %2)\n%4 = tail call i32 (...) @isb()\n%5 = load i32, ptr @L2CPUSRDR_EL1, align 4\n%6 = tail call i32 @read_sysreg_s(i32 noundef %5)\n%7 = tail call i32 @raw_spin_unlock_irqrestore(ptr noundef nonnull @l2_access_lock, i64 noundef undef)\nret i32 %6\n}", "codellama": "define internal i32 @get_l2_indirect_reg(i32 noundef %0) {\nB:\n%1 = tail call i32 @raw_spin_lock_irqsave(ptr noundef nonnull @l2_access_lock, i64 noundef undef)\n%2 = load i32, ptr @L2CPUSRSELR_EL1, align 4\n%3 = tail call i32 @write_sysreg_s(i32 noundef %0, i32 noundef %2)\n%4 = tail call i32 (...) @isb()\n%5 = load i32, ptr @L2CPUSRDR_EL1, align 4\n%6 = tail call i32 @read_sysreg_s(i32 noundef %5)\n%7 = tail call i32 @raw_spin_unlock_irqrestore(ptr noundef nonnull @l2_access_lock, i64 noundef undef)\nret i32 %6\n}", "codegemma": "define internal i32 @get_l2_indirect_reg(i32 noundef %0) {\nB:\n%1 = tail call i32 @raw_spin_lock_irqsave(ptr noundef nonnull @l2_access_lock, i64 noundef undef)\n%2 = load i32, ptr @L2CPUSRSELR_EL1, align 4\n%3 = tail call i32 @write_sysreg_s(i32 noundef %0, i32 noundef %2)\n%4 = tail call i32 (...) @isb()\n%5 = load i32, ptr @L2CPUSRDR_EL1, align 4\n%6 = tail call i32 @read_sysreg_s(i32 noundef %5)\n%7 = tail call i32 @raw_spin_unlock_irqrestore(ptr noundef nonnull @l2_access_lock, i64 noundef undef)\nret i32 %6\n}"}, "define dso_local i32 @Curl_ipvalid(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.SessionHandle ptr %4, i32 0, i32 0\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = icmp eq i32 %7, 2\nbr i1 %8, label %9, label %10\n\n9:\nstore i32 0, ptr %2, align 4\nbr label %11\n\n10:\nstore i32 1, ptr %2, align 4\nbr label %11\n\n11:\n%12 = load i32, ptr %2, align 4\nret i32 %12\n}": {"base_truth": "define dso_local i32 @Curl_ipvalid(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp ne i32 %1, 2\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define dso_local i32 @Curl_ipvalid(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp ne i32 %1, 2\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define dso_local i32 @Curl_ipvalid(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp ne i32 %1, 2\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define internal i32 @ccp_des3_decrypt(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @ccp_des3_crypt(ptr noundef %3, i32 noundef 0)\nret i32 %4\n}": {"base_truth": "define internal i32 @ccp_des3_decrypt(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccp_des3_crypt(ptr noundef %0, i32 noundef 0)\nret i32 %1\n}", "codellama": "define internal i32 @ccp_des3_decrypt(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccp_des3_crypt(ptr noundef %0, i32 noundef 0)\nret i32 %1\n}", "codegemma": "define internal i32 @ccp_des3_decrypt(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccp_des3_crypt(ptr noundef %0, i32 noundef 0)\nret i32 %1\n}"}, "define internal i64 @bus_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i64, align 8\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i64 %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load i64, ptr %6, align 8\n%10 = load i32, ptr @BUS_IOCTL, align 4\n%11 = call i64 @nd_ioctl(ptr noundef %7, i32 noundef %8, i64 noundef %9, i32 noundef %10)\nret i64 %11\n}": {"base_truth": "define internal i64 @bus_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2) {\nB:\n%3 = load i32, ptr @BUS_IOCTL, align 4\n%4 = tail call i64 @nd_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2, i32 noundef %3)\nret i64 %4\n}", "codellama": "define internal i64 @bus_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2) {\nB:\n%3 = load i32, ptr @BUS_IOCTL, align 4\n%4 = tail call i64 @nd_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2, i32 noundef %3)\nret i64 %4\n}", "codegemma": "define internal i64 @bus_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2) {\nB:\n%3 = load i32, ptr @BUS_IOCTL, align 4\n%4 = tail call i64 @nd_ioctl(ptr noundef %0, i32 noundef %1, i64 noundef %2, i32 noundef %3)\nret i64 %4\n}"}, "define dso_local void @WINS_Shutdown() {\n%1 = load i32, ptr @net_controlsocket, align 4\n%2 = call i32 @WINS_CloseSocket(i32 noundef %1)\n%3 = call i32 @WinPrint(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @WINS_Shutdown() {\nB:\n%0 = load i32, ptr @net_controlsocket, align 4\n%1 = tail call i32 @WINS_CloseSocket(i32 noundef %0)\n%2 = tail call i32 @WinPrint(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @WINS_Shutdown() {\nB:\n%0 = load i32, ptr @net_controlsocket, align 4\n%1 = tail call i32 @WINS_CloseSocket(i32 noundef %0)\n%2 = tail call i32 @WinPrint(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @WINS_Shutdown() {\nB:\n%0 = load i32, ptr @net_controlsocket, align 4\n%1 = tail call i32 @WINS_CloseSocket(i32 noundef %0)\n%2 = tail call i32 @WinPrint(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local void @nouveau_engctx_put(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %7, label %20\n\n7:\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%8 = load ptr, ptr %2, align 8\n%9 = getelementptr inbounds %struct.nouveau_object ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\n%11 = call ptr @nv_engine(i32 noundef %10)\nstore ptr %11, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%12 = load ptr, ptr %2, align 8\n%13 = call ptr @nv_engctx(ptr noundef %12)\nstore ptr %13, ptr %4, align 8\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.nouveau_engine ptr %14, i32 0, i32 0\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.nouveau_engctx ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = call i32 @spin_unlock_irqrestore(ptr noundef %15, i32 noundef %18)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nbr label %20\n\n20:\nret void\n}": {"base_truth": "define dso_local void @nouveau_engctx_put(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @nv_engine(i32 noundef %2)\n%4 = tail call ptr @nv_engctx(ptr noundef nonnull %0)\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @spin_unlock_irqrestore(ptr noundef %3, i32 noundef %5)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @nouveau_engctx_put(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @nv_engine(i32 noundef %2)\n%4 = tail call ptr @nv_engctx(ptr noundef nonnull %0)\n%5 = load i32, ptr %4, align 4\n%6 = tail call i32 @spin_unlock_irqrestore(ptr noundef %3, i32 noundef %5)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @nouveau_engctx_put(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @nv_engine(i32 noundef %2)\n%4 = tail call ptr @nv_engctx(ptr noundef nonnull %0)\n%5 = tail call i32 @spin_unlock_irqrestore(ptr noundef %3, i32 noundef %4)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @celcon_permute_system() {\n%1 = alloca ptr, align 8\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr %1, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = call i32 @_ada_use_c2phc(i32 noundef 105, ptr noundef %5, ptr noundef %6, ptr noundef %7)\nstore i32 %8, ptr %3, align 4\n%9 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 %9\n}": {"base_truth": "define dso_local i32 @celcon_permute_system() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 105, ptr noundef undef, ptr noundef undef, ptr noundef undef)\nret i32 %0\n}", "codellama": "define dso_local i32 @celcon_permute_system() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 105, ptr noundef undef, ptr noundef undef, ptr noundef undef)\nret i32 %0\n}", "codegemma": "define dso_local i32 @celcon_permute_system() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 105, ptr noundef undef, ptr noundef undef, ptr noundef undef)\nret i32 %0\n}"}, "define dso_local i32 @ft_lst_is_odd(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @ft_is_odd(i32 noundef %5)\nret i32 %6\n}": {"base_truth": "define dso_local i32 @ft_lst_is_odd(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @ft_is_odd(i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @ft_lst_is_odd(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @ft_is_odd(i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @ft_lst_is_odd(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @ft_is_odd(i32 noundef %1)\nret i32 %2\n}"}, "define dso_local ptr @xlss(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call ptr @compare(ptr noundef %3, i8 noundef signext 60)\nret ptr %4\n}": {"base_truth": "define dso_local ptr @xlss(ptr noundef %0) {\nB:\n%1 = tail call ptr @compare(ptr noundef %0, i8 noundef signext 60)\nret ptr %1\n}", "codellama": "define dso_local ptr @xlss(ptr noundef %0) {\nB:\n%1 = tail call ptr @compare(ptr noundef %0, i8 noundef signext 60)\nret ptr %1\n}", "codegemma": "define dso_local ptr @xlss(ptr noundef %0) {\nB:\n%1 = tail call ptr @compare(ptr noundef %0, i8 noundef signext 60)\nret ptr %1\n}"}, "define dso_local void @selector_page_down(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.selector_t ptr %3, i32 0, i32 0\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.selector_t ptr %5, i32 0, i32 0\n%7 = getelementptr inbounds %struct.TYPE_2__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @scroll_down(ptr noundef %4, i32 noundef %8)\nret void\n}": {"base_truth": "define dso_local void @selector_page_down(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @scroll_down(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @selector_page_down(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @scroll_down(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @selector_page_down(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @scroll_down(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}"}, "define internal void @mac2_int_dispatch() {\n%1 = load i32, ptr @MSP_INT_SAR, align 4\n%2 = call i32 @do_IRQ(i32 noundef %1)\nret void\n}": {"base_truth": "define internal void @mac2_int_dispatch() {\nB:\n%0 = load i32, ptr @MSP_INT_SAR, align 4\n%1 = tail call i32 @do_IRQ(i32 noundef %0)\nret void\n}", "codellama": "define internal void @mac2_int_dispatch() {\nB:\n%0 = load i32, ptr @MSP_INT_SAR, align 4\n%1 = tail call i32 @do_IRQ(i32 noundef %0)\nret void\n}", "codegemma": "define internal void @mac2_int_dispatch() {\nB:\n%0 = load i32, ptr @MSP_INT_SAR, align 4\n%1 = tail call i32 @do_IRQ(i32 noundef %0)\nret void\n}"}, "define internal i32 @ltc4306_select_mux(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = call ptr @i2c_mux_priv(ptr noundef %6)\nstore ptr %7, ptr %5, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = getelementptr inbounds %struct.ltc4306 ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\n%11 = load i32, ptr @LTC_REG_SWITCH, align 4\n%12 = load i32, ptr @LTC_SWITCH_MASK, align 4\n%13 = load i64, ptr %4, align 8\n%14 = sub nsw i64 7, %13\n%15 = call i32 @BIT(i64 noundef %14)\n%16 = call i32 @regmap_update_bits(i32 noundef %10, i32 noundef %11, i32 noundef %12, i32 noundef %15)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 %16\n}": {"base_truth": "define internal i32 @ltc4306_select_mux(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call ptr @i2c_mux_priv(ptr noundef %0)\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @LTC_REG_SWITCH, align 4\n%5 = load i32, ptr @LTC_SWITCH_MASK, align 4\n%6 = sub nsw i64 7, %1\n%7 = tail call i32 @BIT(i64 noundef %6)\n%8 = tail call i32 @regmap_update_bits(i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %7)\nret i32 %8\n}", "codellama": "define internal i32 @ltc4306_select_mux(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call ptr @i2c_mux_priv(ptr noundef %0)\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @LTC_REG_SWITCH, align 4\n%5 = load i32, ptr @LTC_SWITCH_MASK, align 4\n%6 = sub nsw i64 7, %1\n%7 = tail call i32 @BIT(i64 noundef %6)\n%8 = tail call i32 @regmap_update_bits(i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %7)\nret i32 %8\n}", "codegemma": "define internal i32 @ltc4306_select_mux(ptr noundef %0, i64 noundef %1) {\nB:\n%2 = tail call ptr @i2c_mux_priv(ptr noundef %0)\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @LTC_REG_SWITCH, align 4\n%5 = load i32, ptr @LTC_SWITCH_MASK, align 4\n%6 = sub nsw i64 7, %1\n%7 = tail call i32 @BIT(i64 noundef %6)\n%8 = tail call i32 @regmap_update_bits(i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %7)\nret i32 %8\n}"}, "define dso_local i32 @eol(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @crlf(ptr noundef %3)\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds i8, ptr %5, i64 0\n%7 = load i8, ptr %6, align 1\n%8 = call i32 @nl(i8 noundef signext %7)\n%9 = or i32 %4, %8\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds i8, ptr %10, i64 0\n%12 = load i8, ptr %11, align 1\n%13 = icmp ne i8 %12, 0\n%14 = xor i1 %13, true\n%15 = zext i1 %14 to i32\n%16 = or i32 %9, %15\nret i32 %16\n}": {"base_truth": "define dso_local i32 @eol(ptr noundef %0) {\nB:\n%1 = tail call i32 @crlf(ptr noundef %0)\n%2 = load i8, ptr %0, align 1\n%3 = tail call i32 @nl(i8 noundef signext %2)\n%4 = or i32 %3, %1\n%5 = load i8, ptr %0, align 1\n%6 = icmp eq i8 %5, 0\n%7 = zext i1 %6 to i32\n%8 = or i32 %4, %7\nret i32 %8\n}", "codellama": "define dso_local i32 @eol(ptr noundef %0) {\nB:\n%1 = tail call i32 @crlf(ptr noundef %0)\n%2 = load i8, ptr %0, align 1\n%3 = tail call i32 @nl(i8 noundef signext %2)\n%4 = load i8, ptr %0, align 1\n%5 = icmp eq i8 %4, 0\n%6 = zext i1 %5 to i32\n%7 = or i32 %1, %6\nret i32 %7\n}", "codegemma": "define dso_local i32 @eol(ptr noundef %0) {\nB:\n%1 = tail call i32 @crlf(ptr noundef %0)\n%2 = load i8, ptr %0, align 1\n%3 = tail call i32 @nl(i8 noundef signext %2)\n%4 = or i32 %3, %1\n%5 = load i8, ptr %0, align 1\n%6 = icmp eq i8 %5, 0\n%7 = zext i1 %6 to i32\n%8 = or i32 %4, %7\nret i32 %8\n}"}, "define internal void @vic_writel(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load i32, ptr %5, align 4\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.vic ptr %8, i32 0, i32 0\n%10 = load i64, ptr %9, align 8\n%11 = load i32, ptr %6, align 4\n%12 = zext i32 %11 to i64\n%13 = add nsw i64 %10, %12\n%14 = call i32 @writel(i32 noundef %7, i64 noundef %13)\nret void\n}": {"base_truth": "define internal void @vic_writel(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr %0, align 8\n%4 = zext i32 %2 to i64\n%5 = add nsw i64 %3, %4\n%6 = tail call i32 @writel(i32 noundef %1, i64 noundef %5)\nret void\n}", "codellama": "define internal void @vic_writel(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr %0, align 8\n%4 = zext i32 %2 to i64\n%5 = add nsw i64 %3, %4\n%6 = tail call i32 @writel(i32 noundef %1, i64 noundef %5)\nret void\n}", "codegemma": "define internal void @vic_writel(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i64, ptr %0, align 8\n%4 = zext i32 %2 to i64\n%5 = add nsw i64 %3, %4\n%6 = tail call i32 @writel(i32 noundef %1, i64 noundef %5)\nret void\n}"}, "define dso_local i64 @xyi(i32 noundef %0, i32 noundef %1) {\n%3 = alloca %struct.TYPE_3__, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %4, align 4\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\nstore i32 %6, ptr %7, align 4\n%8 = load i32, ptr %5, align 4\n%9 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 1\nstore i32 %8, ptr %9, align 4\n%10 = load i64, ptr %3, align 4\nret i64 %10\n}": {"base_truth": "define dso_local i64 @xyi(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = zext i32 %1 to i64\n%3 = shl nuw i64 %2, 32\n%4 = zext i32 %0 to i64\n%5 = or i64 %3, %4\nret i64 %5\n}", "codellama": "define dso_local i64 @xyi(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = zext i32 %1 to i64\n%3 = shl nuw i64 %2, 32\n%4 = zext i32 %0 to i64\n%5 = or i64 %3, %4\nret i64 %5\n}", "codegemma": "define dso_local i64 @xyi(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = zext i32 %1 to i64\n%3 = shl nuw i64 %2, 32\n%4 = zext i32 %0 to i64\n%5 = or i64 %3, %4\nret i64 %5\n}"}, "define dso_local ptr @fb_StrAllocTempDescV(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = call ptr (...) @fb_hStrAllocTmpDesc()\nstore ptr %6, ptr %4, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %9, label %10\n\n9:\nstore ptr @__fb_ctx, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %30\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.TYPE_6__, ptr %11, i32 0, i32 2\n%13 = load i32, ptr %12, align 4\n%14 = load ptr, ptr %4, align 8\n%15 = getelementptr inbounds %struct.TYPE_6__, ptr %14, i32 0, i32 2\nstore i32 %13, ptr %15, align 4\n%16 = load ptr, ptr %3, align 8\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = sext i32 %18 to i64\n%20 = and i64 %19, -2147483649\n%21 = trunc i64 %20 to i32\n%22 = load ptr, ptr %4, align 8\n%23 = getelementptr inbounds %struct.TYPE_6__, ptr %22, i32 0, i32 0\nstore i32 %21, ptr %23, align 4\n%24 = load ptr, ptr %3, align 8\n%25 = getelementptr inbounds %struct.TYPE_6__, ptr %24, i32 0, i32 1\n%26 = load i32, ptr %25, align 4\n%27 = load ptr, ptr %4, align 8\n%28 = getelementptr inbounds %struct.TYPE_6__, ptr %27, i32 0, i32 1\nstore i32 %26, ptr %28, align 4\n%29 = load ptr, ptr %4, align 8\nstore ptr %29, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%31 = load ptr, ptr %2, align 8\nret ptr %31\n}": {"base_truth": "define dso_local ptr @fb_StrAllocTempDescV(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call ptr (...) @fb_hStrAllocTmpDesc()\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 4\n%4 = and i32 %3, 2147483647\nstore i32 %4, ptr %1, align 4\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 1\n%7 = load <2 x i32>, ptr %5, align 4\nstore <2 x i32> %7, ptr %6, align 4\nbr label %B2\n\nB2:\n%8 = phi ptr [ %1, %B1 ], [ @__fb_ctx, %B ]\nret ptr %8\n}", "codellama": "define dso_local ptr @fb_StrAllocTempDescV(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call ptr (...) @fb_hStrAllocTmpDesc()\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 2\n%4 = load i32, ptr %3, align 4\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 2\nstore i32 %4, ptr %5, align 4\n%6 = load i32, ptr %0, align 4\n%7 = and i32 %6, -2147483649\nstore i32 %7, ptr %1, align 4\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 1\nstore i32 %9, ptr %10, align 4\nbr label %B2\n\nB2:\n%11 = phi ptr [ %1, %B1 ], [ @__fb_ctx, %B ]\nret ptr %11\n}", "codegemma": "define dso_local ptr @fb_StrAllocTempDescV(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call ptr (...) @fb_hStrAllocTmpDesc()\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 2\n%4 = load i32, ptr %3, align 4\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 2\nstore i32 %4, ptr %5, align 4\n%6 = load i32, ptr %0, align 4\n%7 = and i32 %6, -2147483649\nstore i32 %7, ptr %1, align 4\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%9 = load i32, ptr %8, align 4\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 1\nstore i32 %9, ptr %10, align 4\nbr label %B2\n\nB2:\nret ptr %1\n}"}, "define internal void @inc_io_migrations(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.cache ptr %3, i32 0, i32 0\n%5 = call i32 @atomic_inc(ptr noundef %4)\nret void\n}": {"base_truth": "define internal void @inc_io_migrations(ptr noundef %0) {\nB:\n%1 = tail call i32 @atomic_inc(ptr noundef %0)\nret void\n}", "codellama": "define internal void @inc_io_migrations(ptr noundef %0) {\nB:\n%1 = tail call i32 @atomic_inc(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @inc_io_migrations(ptr noundef %0) {\nB:\n%1 = tail call i32 @atomic_inc(ptr noundef %0)\nret void\n}"}, "define dso_local void @indicator_initialize() {\n%1 = call i32 (...) @indicator_clr()\nret void\n}": {"base_truth": "define dso_local void @indicator_initialize() {\nB:\n%0 = tail call i32 (...) @indicator_clr()\nret void\n}", "codellama": "define dso_local void @indicator_initialize() {\nB:\n%0 = tail call i32 (...) @indicator_clr()\nret void\n}", "codegemma": "define dso_local void @indicator_initialize() {\nB:\n%0 = tail call i32 (...) @indicator_clr()\nret void\n}"}, "define internal i32 @btc_hf_client_query_current_operator_name() {\n%1 = call i32 (...) @CHECK_HF_CLIENT_SLC_CONNECTED()\n%2 = load i32, ptr @hf_client_local_param, align 4\n%3 = load i32, ptr @BTA_HF_CLIENT_AT_CMD_COPS, align 4\n%4 = call i32 @BTA_HfClientSendAT(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef 0, ptr noundef null)\n%5 = load i32, ptr @BT_STATUS_SUCCESS, align 4\nret i32 %5\n}": {"base_truth": "define internal i32 @btc_hf_client_query_current_operator_name() {\nB:\n%0 = tail call i32 (...) @CHECK_HF_CLIENT_SLC_CONNECTED()\n%1 = load i32, ptr @hf_client_local_param, align 4\n%2 = load i32, ptr @BTA_HF_CLIENT_AT_CMD_COPS, align 4\n%3 = tail call i32 @BTA_HfClientSendAT(i32 noundef %1, i32 noundef %2, i32 noundef 0, i32 noundef 0, ptr noundef null)\n%4 = load i32, ptr @BT_STATUS_SUCCESS, align 4\nret i32 %4\n}", "codellama": "define internal i32 @btc_hf_client_query_current_operator_name() {\nB:\n%0 = tail call i32 (...) @CHECK_HF_CLIENT_SLC_CONNECTED()\n%1 = load i32, ptr @hf_client_local_param, align 4\n%2 = load i32, ptr @BTA_HF_CLIENT_AT_CMD_COPS, align 4\n%3 = tail call i32 @BTA_HfClientSendAT(i32 noundef %1, i32 noundef %2, i32 noundef 0, i32 noundef 0, ptr noundef null)\n%4 = load i32, ptr @BT_STATUS_SUCCESS, align 4\nret i32 %4\n}", "codegemma": "define internal i32 @btc_hf_client_query_current_operator_name() {\nB:\n%0 = tail call i32 (...) @CHECK_HF_CLIENT_SLC_CONNECTED()\n%1 = load i32, ptr @hf_client_local_param, align 4\n%2 = load i32, ptr @BTA_HF_CLIENT_AT_CMD_COPS, align 4\n%3 = tail call i32 @BTA_HfClientSendAT(i32 noundef %1, i32 noundef %2, i32 noundef 0, i32 noundef 0, ptr noundef null)\n%4 = load i32, ptr @BT_STATUS_SUCCESS, align 4\nret i32 %4\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca [1000 x i8], align 16\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 1000, ptr %3)\nstore i64 0, ptr @max, align 8\n%4 = call i32 @printf(ptr noundef @.str)\ncall void @llvm.lifetime.end.p0(i64 1000, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\nstore i64 0, ptr @max, align 8\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\nstore i64 0, ptr @max, align 8\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}"}, "define internal i32 @musb_has_gadget(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.musb ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = load i64, ptr @MUSB_HOST, align 8\n%7 = icmp eq i64 %5, %6\n%8 = zext i1 %7 to i32\nret i32 %8\n}": {"base_truth": "define internal i32 @musb_has_gadget(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @MUSB_HOST, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codellama": "define internal i32 @musb_has_gadget(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @MUSB_HOST, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codegemma": "define internal i32 @musb_has_gadget(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @MUSB_HOST, align 8\n%3 = icmp eq i64 %1, %2\n%4 = zext i1 %3 to i32\nret i32 %4\n}"}, "define internal i32 @statsd_algorithm_for_metric(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nswitch i32 %6, label %7 [\ni32 132, label %8\ni32 129, label %8\ni32 128, label %8\ni32 131, label %8\ni32 130, label %10\ni32 133, label %10\n]\n\n7:\nbr label %8\n\n8:\n%9 = load i32, ptr @RRD_ALGORITHM_ABSOLUTE, align 4\nstore i32 %9, ptr %2, align 4\nbr label %12\n\n10:\n%11 = load i32, ptr @RRD_ALGORITHM_INCREMENTAL, align 4\nstore i32 %11, ptr %2, align 4\nbr label %12\n\n12:\n%13 = load i32, ptr %2, align 4\nret i32 %13\n}": {"base_truth": "define internal i32 @statsd_algorithm_for_metric(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, 133\n%3 = icmp eq i32 %1, 130\n%4 = or i1 %2, %3\n%5 = load i32, ptr @RRD_ALGORITHM_INCREMENTAL, align 4\n%6 = load i32, ptr @RRD_ALGORITHM_ABSOLUTE, align 4\n%7 = select i1 %4, i32 %5, i32 %6\nret i32 %7\n}", "codellama": "define internal i32 @statsd_algorithm_for_metric(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = add i32 %1, -128\n%3 = icmp ult i32 %2, 6\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds [6 x ptr], ptr @switch.table.statsd_algorithm_for_metric, i64 0, i64 %4\n%6 = load ptr, ptr %5, align 8\nbr label %B2\n\nB2:\n%7 = phi ptr [ @RRD_ALGORITHM_ABSOLUTE, %B ], [ %6, %B1 ]\n%8 = load i32, ptr %7, align 4\nret i32 %8\n}", "codegemma": "define internal i32 @statsd_algorithm_for_metric(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = add i32 %1, -128\n%3 = icmp ult i32 %2, 6\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = sext i32 %2 to i64\n%5 = getelementptr inbounds [6 x ptr], ptr @switch.table.statsd_algorithm_for_metric, i64 0, i64 %4\n%6 = load ptr, ptr %5, align 8\nbr label %B2\n\nB2:\n%7 = phi ptr [ @RRD_ALGORITHM_ABSOLUTE, %B ], [ %6, %B1 ]\n%8 = load i32, ptr %7, align 4\nret i32 %8\n}"}, "define dso_local ptr @OPENSSL_sk_new(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call ptr @OPENSSL_sk_new_reserve(i32 noundef %3, i32 noundef 0)\nret ptr %4\n}": {"base_truth": "define dso_local ptr @OPENSSL_sk_new(i32 noundef %0) {\nB:\n%1 = tail call ptr @OPENSSL_sk_new_reserve(i32 noundef %0, i32 noundef 0)\nret ptr %1\n}", "codellama": "define dso_local ptr @OPENSSL_sk_new(i32 noundef %0) {\nB:\n%1 = tail call ptr @OPENSSL_sk_new_reserve(i32 noundef %0, i32 noundef 0)\nret ptr %1\n}", "codegemma": "define dso_local ptr @OPENSSL_sk_new(i32 noundef %0) {\nB:\n%1 = tail call ptr @OPENSSL_sk_new_reserve(i32 noundef %0, i32 noundef 0)\nret ptr %1\n}"}, "define dso_local ptr @is_interger(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = call i32 @car(ptr noundef %4)\n%6 = call i64 @gettype(i32 noundef %5)\n%7 = load i64, ptr @INT, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %9, label %11\n\n9:\n%10 = load ptr, ptr @tee, align 8\nstore ptr %10, ptr %2, align 8\nbr label %13\n\n11:\n%12 = load ptr, ptr @fee, align 8\nstore ptr %12, ptr %2, align 8\nbr label %13\n\n13:\n%14 = load ptr, ptr %2, align 8\nret ptr %14\n}": {"base_truth": "define dso_local ptr @is_interger(ptr noundef %0) {\nB:\n%1 = tail call i32 @car(ptr noundef %0)\n%2 = tail call i64 @gettype(i32 noundef %1)\n%3 = load i64, ptr @INT, align 8\n%4 = icmp eq i64 %2, %3\n%5 = load ptr, ptr @tee, align 8\n%6 = load ptr, ptr @fee, align 8\n%7 = select i1 %4, ptr %5, ptr %6\nret ptr %7\n}", "codellama": "define dso_local ptr @is_interger(ptr noundef %0) {\nB:\n%1 = tail call i32 @car(ptr noundef %0)\n%2 = tail call i64 @gettype(i32 noundef %1)\n%3 = load i64, ptr @INT, align 8\n%4 = icmp eq i64 %2, %3\n%5 = load ptr, ptr @tee, align 8\n%6 = load ptr, ptr @fee, align 8\n%7 = select i1 %4, ptr %5, ptr %6\nret ptr %7\n}", "codegemma": "define dso_local ptr @is_interger(ptr noundef %0) {\nB:\n%1 = tail call i32 @car(ptr noundef %0)\n%2 = tail call i64 @gettype(i32 noundef %1)\n%3 = load i64, ptr @INT, align 8\n%4 = icmp eq i64 %2, %3\n%5 = load ptr, ptr @tee, align 8\n%6 = load ptr, ptr @fee, align 8\n%7 = select i1 %4, ptr %5, ptr %6\nret ptr %7\n}"}, "define internal ptr @d_unnamed_type(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%7 = load ptr, ptr %3, align 8\n%8 = call i32 @d_check_char(ptr noundef %7, i8 noundef signext 85)\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %11, label %10\n\n10:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %44\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = call i32 @d_check_char(ptr noundef %12, i8 noundef signext 116)\n%14 = icmp ne i32 %13, 0\nbr i1 %14, label %16, label %15\n\n15:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %44\n\n16:\n%17 = load ptr, ptr %3, align 8\n%18 = call i32 @d_compact_number(ptr noundef %17)\nstore i32 %18, ptr %5, align 4\n%19 = load i32, ptr %5, align 4\n%20 = icmp slt i32 %19, 0\nbr i1 %20, label %21, label %22\n\n21:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %44\n\n22:\n%23 = load ptr, ptr %3, align 8\n%24 = call ptr @d_make_empty(ptr noundef %23)\nstore ptr %24, ptr %4, align 8\n%25 = load ptr, ptr %4, align 8\n%26 = icmp ne ptr %25, null\nbr i1 %26, label %27, label %36\n\n27:\n%28 = load i32, ptr @DEMANGLE_COMPONENT_UNNAMED_TYPE, align 4\n%29 = load ptr, ptr %4, align 8\n%30 = getelementptr inbounds %struct.demangle_component ptr %29, i32 0, i32 1\nstore i32 %28, ptr %30, align 4\n%31 = load i32, ptr %5, align 4\n%32 = load ptr, ptr %4, align 8\n%33 = getelementptr inbounds %struct.demangle_component ptr %32, i32 0, i32 0\n%34 = getelementptr inbounds %struct.TYPE_4__, ptr %33, i32 0, i32 0\n%35 = getelementptr inbounds %struct.TYPE_3__, ptr %34, i32 0, i32 0\nstore i32 %31, ptr %35, align 4\nbr label %36\n\n36:\n%37 = load ptr, ptr %3, align 8\n%38 = load ptr, ptr %4, align 8\n%39 = call i32 @d_add_substitution(ptr noundef %37, ptr noundef %38)\n%40 = icmp ne i32 %39, 0\nbr i1 %40, label %42, label %41\n\n41:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %44\n\n42:\n%43 = load ptr, ptr %4, align 8\nstore ptr %43, ptr %2, align 8\nstore i32 1, ptr %6, align 4\nbr label %44\n\n44:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%45 = load ptr, ptr %2, align 8\nret ptr %45\n}": {"base_truth": "define internal ptr @d_unnamed_type(ptr noundef %0) {\nB:\n%1 = tail call i32 @d_check_char(ptr noundef %0, i8 noundef signext 85)\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B6, label %B1\n\nB1:\n%3 = tail call i32 @d_check_char(ptr noundef %0, i8 noundef signext 116)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B6, label %B2\n\nB2:\n%5 = tail call i32 @d_compact_number(ptr noundef %0)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B6, label %B3\n\nB3:\n%7 = tail call ptr @d_make_empty(ptr noundef %0)\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %B5, label %B4\n\nB4:\n%9 = getelementptr inbounds %struct.demangle_component, ptr %7, i64 0, i32 1\n%10 = load i32, ptr @DEMANGLE_COMPONENT_UNNAMED_TYPE, align 4\nstore i32 %10, ptr %9, align 4\nstore i32 %5, ptr %7, align 4\nbr label %B5\n\nB5:\n%11 = tail call i32 @d_add_substitution(ptr noundef %0, ptr noundef %7)\n%12 = icmp eq i32 %11, 0\n%13 = select i1 %12, ptr null, ptr %7\nbr label %B6\n\nB6:\n%14 = phi ptr [ null, %B ], [ null, %B1 ], [ null, %B2 ], [ %13, %B5 ]\nret ptr %14\n}", "codellama": "define internal ptr @d_unnamed_type(ptr noundef %0) {\nB:\n%1 = tail call i32 @d_check_char(ptr noundef %0, i8 noundef signext 85)\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B6, label %B1\n\nB1:\n%3 = tail call i32 @d_check_char(ptr noundef %0, i8 noundef signext 116)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B6, label %B2\n\nB2:\n%5 = tail call i32 @d_compact_number(ptr noundef %0)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B6, label %B3\n\nB3:\n%7 = tail call ptr @d_make_empty(ptr noundef %0)\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %B5, label %B4\n\nB4:\n%9 = load i32, ptr @DEMANGLE_COMPONENT_UNNAMED_TYPE, align 4\n%10 = getelementptr inbounds %struct.demangle_component, ptr %7, i64 0, i32 1\nstore i32 %9, ptr %10, align 4\nstore i32 %5, ptr %7, align 4\nbr label %B5\n\nB5:\n%11 = tail call i32 @d_add_substitution(ptr noundef %0, ptr noundef %7)\n%12 = icmp eq i32 %11, 0\n%13 = select i1 %12, ptr null, ptr %7\nbr label %B6\n\nB6:\n%14 = phi ptr [ null, %B ], [ null, %B1 ], [ null, %B2 ], [ null, %B5 ], [ %7, %B4 ], [ null, %B3 ]\nret ptr %14\n}", "codegemma": "define internal ptr @d_unnamed_type(ptr noundef %0) {\nB:\n%1 = tail call i32 @d_check_char(ptr noundef %0, i8 noundef signext 85)\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B5, label %B1\n\nB1:\n%3 = tail call i32 @d_check_char(ptr noundef %0, i8 noundef signext 116)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B5, label %B2\n\nB2:\n%5 = tail call i32 @d_compact_number(ptr noundef %0)\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %B5, label %B3\n\nB3:\n%7 = tail call ptr @d_make_empty(ptr noundef %0)\n%8 = icmp eq ptr %7, null\nbr i1 %8, label %B5, label %B4\n\nB4:\n%9 = load i32, ptr @DEMANGLE_COMPONENT_UNNAMED_TYPE, align 4\n%10 = getelementptr inbounds %struct.demangle_component, ptr %7, i64 0, i32 1\nstore i32 %9, ptr %10, align 4\nstore i32 %5, ptr %7, align 4\nbr label %B3\n\nB5:\n%11 = phi ptr [ null, %B ], [ null, %B1 ], [ null, %B2 ], [ %7, %B4 ], [ null, %B3 ]\nret ptr %11\n}"}, "define dso_local void @lisp_State_dealloc(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = load ptr, ptr %4, align 8\n%9 = call i32 @lisp_GC_dealloc(i32 noundef %7, ptr noundef %8)\nret void\n}": {"base_truth": "define dso_local void @lisp_State_dealloc(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @lisp_GC_dealloc(i32 noundef %2, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @lisp_State_dealloc(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @lisp_GC_dealloc(i32 noundef %2, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @lisp_State_dealloc(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @lisp_GC_dealloc(i32 noundef %2, ptr noundef %1)\nret void\n}"}, "define internal signext i8 @l2e_state(ptr noundef %0) {\n%2 = alloca i8, align 1\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.l2t_entry ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nswitch i32 %6, label %19 [\ni32 128, label %7\ni32 131, label %8\ni32 129, label %9\ni32 132, label %10\ni32 130, label %18\n]\n\n7:\nstore i8 86, ptr %2, align 1\nbr label %20\n\n8:\nstore i8 83, ptr %2, align 1\nbr label %20\n\n9:\nstore i8 87, ptr %2, align 1\nbr label %20\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.l2t_entry ptr %11, i32 0, i32 1\n%13 = call i32 @STAILQ_EMPTY(ptr noundef %12)\n%14 = icmp ne i32 %13, 0\n%15 = zext i1 %14 to i64\n%16 = select i1 %14, i32 82, i32 65\n%17 = trunc i32 %16 to i8\nstore i8 %17, ptr %2, align 1\nbr label %20\n\n18:\nstore i8 88, ptr %2, align 1\nbr label %20\n\n19:\nstore i8 85, ptr %2, align 1\nbr label %20\n\n20:\n%21 = load i8, ptr %2, align 1\nret i8 %21\n}": {"base_truth": "define internal signext i8 @l2e_state(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B5 [\ni32 128, label %B6\ni32 131, label %B1\ni32 129, label %B2\ni32 132, label %B3\ni32 130, label %B4\n]\n\nB1:\nbr label %B6\n\nB2:\nbr label %B6\n\nB3:\n%2 = getelementptr inbounds %struct.l2t_entry, ptr %0, i64 0, i32 1\n%3 = tail call i32 @STAILQ_EMPTY(ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\n%5 = select i1 %4, i8 65, i8 82\nbr label %B6\n\nB4:\nbr label %B6\n\nB5:\nbr label %B6\n\nB6:\n%6 = phi i8 [ 85, %B5 ], [ 88, %B4 ], [ %5, %B3 ], [ 87, %B2 ], [ 83, %B1 ], [ 86, %B ]\nret i8 %6\n}", "codellama": "define internal signext i8 @l2e_state(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 128, label %B5\ni32 131, label %B1\ni32 129, label %B2\ni32 132, label %B3\ni32 130, label %B4\n]\n\nB1:\nbr label %B5\n\nB2:\nbr label %B5\n\nB3:\n%2 = getelementptr inbounds %struct.l2t_entry, ptr %0, i64 0, i32 1\n%3 = tail call i32 @STAILQ_EMPTY(ptr noundef nonnull %2)\n%4 = icmp eq i32 %3, 0\n%5 = select i1 %4, i8 65, i8 82\nbr label %B5\n\nB4:\nbr label %B5\n\nB5:\n%6 = phi i8 [ 85, %B4 ], [ %5, %B3 ], [ 88, %B ], [ 83, %B1 ], [ 87, %B2 ]\nret i8 %6\n}", "codegemma": "define internal signext i8 @l2e_state(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B3 [\ni32 128, label %B4\ni32 131, label %B1\ni32 129, label %B2\ni32 132, label %B3\n]\n\nB1:\nbr label %B4\n\nB2:\nbr label %B4\n\nB3:\nbr label %B4\n\nB4:\n%2 = phi i8 [ 85, %B3 ], [ 87, %B2 ], [ 83, %B1 ], [ 86, %B ]\nret i8 %2\n}"}, "define dso_local i32 @XwcDrawString() {\n%1 = call i32 @printf(ptr noundef @.str)\nret i32 0\n}": {"base_truth": "define dso_local i32 @XwcDrawString() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}", "codellama": "define dso_local i32 @XwcDrawString() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}", "codegemma": "define dso_local i32 @XwcDrawString() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}"}, "define internal i32 @cdns3_gadget_set_selfpowered(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @gadget_to_cdns3_device(ptr noundef %7)\nstore ptr %8, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%9 = load ptr, ptr %5, align 8\n%10 = getelementptr inbounds %struct.cdns3_device ptr %9, i32 0, i32 1\n%11 = load i64, ptr %6, align 8\n%12 = call i32 @spin_lock_irqsave(ptr noundef %10, i64 noundef %11)\n%13 = load i32, ptr %4, align 4\n%14 = icmp ne i32 %13, 0\n%15 = xor i1 %14, true\n%16 = xor i1 %15, true\n%17 = zext i1 %16 to i32\n%18 = load ptr, ptr %5, align 8\n%19 = getelementptr inbounds %struct.cdns3_device ptr %18, i32 0, i32 0\nstore i32 %17, ptr %19, align 4\n%20 = load ptr, ptr %5, align 8\n%21 = getelementptr inbounds %struct.cdns3_device ptr %20, i32 0, i32 1\n%22 = load i64, ptr %6, align 8\n%23 = call i32 @spin_unlock_irqrestore(ptr noundef %21, i64 noundef %22)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 0\n}": {"base_truth": "define internal i32 @cdns3_gadget_set_selfpowered(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @gadget_to_cdns3_device(ptr noundef %0)\n%3 = getelementptr inbounds %struct.cdns3_device, ptr %2, i64 0, i32 1\n%4 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull %3, i64 noundef undef)\n%5 = icmp ne i32 %1, 0\n%6 = zext i1 %5 to i32\nstore i32 %6, ptr %2, align 4\n%7 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull %3, i64 noundef undef)\nret i32 0\n}", "codellama": "define internal i32 @cdns3_gadget_set_selfpowered(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @gadget_to_cdns3_device(ptr noundef %0)\n%3 = getelementptr inbounds %struct.cdns3_device, ptr %2, i64 0, i32 1\n%4 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull %3, i64 noundef undef)\n%5 = icmp ne i32 %1, 0\n%6 = zext i1 %5 to i32\nstore i32 %6, ptr %2, align 4\n%7 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull %3, i64 noundef undef)\nret i32 0\n}", "codegemma": "define internal i32 @cdns3_gadget_set_selfpowered(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @gadget_to_cdns3_device(ptr noundef %0)\n%3 = getelementptr inbounds %struct.cdns3_device, ptr %2, i64 0, i32 1\n%4 = tail call i32 @spin_lock_irqsave(ptr noundef nonnull %3, i64 noundef undef)\n%5 = icmp ne i32 %1, 0\n%6 = zext i1 %5 to i32\nstore i32 %6, ptr %2, align 4\n%7 = tail call i32 @spin_unlock_irqrestore(ptr noundef nonnull %3, i64 noundef undef)\nret i32 0\n}"}, "define dso_local void @hclgevf_cmd_uninit(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.hclgevf_dev ptr %3, i32 0, i32 0\n%5 = getelementptr inbounds %struct.TYPE_6__, ptr %4, i32 0, i32 0\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 1\n%7 = getelementptr inbounds %struct.TYPE_5__, ptr %6, i32 0, i32 0\n%8 = call i32 @spin_lock_bh(ptr noundef %7)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.hclgevf_dev ptr %9, i32 0, i32 0\n%11 = getelementptr inbounds %struct.TYPE_6__, ptr %10, i32 0, i32 0\n%12 = getelementptr inbounds %struct.TYPE_4__, ptr %11, i32 0, i32 0\n%13 = getelementptr inbounds %struct.TYPE_5__, ptr %12, i32 0, i32 0\n%14 = call i32 @spin_lock(ptr noundef %13)\n%15 = load i32, ptr @HCLGEVF_STATE_CMD_DISABLE, align 4\n%16 = load ptr, ptr %2, align 8\n%17 = getelementptr inbounds %struct.hclgevf_dev ptr %16, i32 0, i32 1\n%18 = call i32 @clear_bit(i32 noundef %15, ptr noundef %17)\n%19 = load ptr, ptr %2, align 8\n%20 = getelementptr inbounds %struct.hclgevf_dev ptr %19, i32 0, i32 0\n%21 = call i32 @hclgevf_cmd_uninit_regs(ptr noundef %20)\n%22 = load ptr, ptr %2, align 8\n%23 = getelementptr inbounds %struct.hclgevf_dev ptr %22, i32 0, i32 0\n%24 = getelementptr inbounds %struct.TYPE_6__, ptr %23, i32 0, i32 0\n%25 = getelementptr inbounds %struct.TYPE_4__, ptr %24, i32 0, i32 0\n%26 = getelementptr inbounds %struct.TYPE_5__, ptr %25, i32 0, i32 0\n%27 = call i32 @spin_unlock(ptr noundef %26)\n%28 = load ptr, ptr %2, align 8\n%29 = getelementptr inbounds %struct.hclgevf_dev ptr %28, i32 0, i32 0\n%30 = getelementptr inbounds %struct.TYPE_6__, ptr %29, i32 0, i32 0\n%31 = getelementptr inbounds %struct.TYPE_4__, ptr %30, i32 0, i32 1\n%32 = getelementptr inbounds %struct.TYPE_5__, ptr %31, i32 0, i32 0\n%33 = call i32 @spin_unlock_bh(ptr noundef %32)\n%34 = load ptr, ptr %2, align 8\n%35 = getelementptr inbounds %struct.hclgevf_dev ptr %34, i32 0, i32 0\n%36 = getelementptr inbounds %struct.TYPE_6__, ptr %35, i32 0, i32 0\n%37 = getelementptr inbounds %struct.TYPE_4__, ptr %36, i32 0, i32 1\n%38 = call i32 @hclgevf_free_cmd_desc(ptr noundef %37)\n%39 = load ptr, ptr %2, align 8\n%40 = getelementptr inbounds %struct.hclgevf_dev ptr %39, i32 0, i32 0\n%41 = getelementptr inbounds %struct.TYPE_6__, ptr %40, i32 0, i32 0\n%42 = getelementptr inbounds %struct.TYPE_4__, ptr %41, i32 0, i32 0\n%43 = call i32 @hclgevf_free_cmd_desc(ptr noundef %42)\nret void\n}": {"base_truth": "define dso_local void @hclgevf_cmd_uninit(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%2 = tail call i32 @spin_lock_bh(ptr noundef nonnull %1)\n%3 = tail call i32 @spin_lock(ptr noundef %0)\n%4 = load i32, ptr @HCLGEVF_STATE_CMD_DISABLE, align 4\n%5 = getelementptr inbounds %struct.hclgevf_dev, ptr %0, i64 0, i32 1\n%6 = tail call i32 @clear_bit(i32 noundef %4, ptr noundef nonnull %5)\n%7 = tail call i32 @hclgevf_cmd_uninit_regs(ptr noundef %0)\n%8 = tail call i32 @spin_unlock(ptr noundef %0)\n%9 = tail call i32 @spin_unlock_bh(ptr noundef nonnull %1)\n%10 = tail call i32 @hclgevf_free_cmd_desc(ptr noundef nonnull %1)\n%11 = tail call i32 @hclgevf_free_cmd_desc(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @hclgevf_cmd_uninit(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%2 = tail call i32 @spin_lock_bh(ptr noundef nonnull %1)\n%3 = tail call i32 @spin_lock(ptr noundef %0)\n%4 = load i32, ptr @HCLGEVF_STATE_CMD_DISABLE, align 4\n%5 = getelementptr inbounds %struct.hclgevf_dev, ptr %0, i64 0, i32 1\n%6 = tail call i32 @clear_bit(i32 noundef %4, ptr noundef nonnull %5)\n%7 = tail call i32 @hclgevf_cmd_uninit_regs(ptr noundef %0)\n%8 = tail call i32 @spin_unlock(ptr noundef %0)\n%9 = tail call i32 @spin_unlock_bh(ptr noundef nonnull %1)\n%10 = tail call i32 @hclgevf_free_cmd_desc(ptr noundef nonnull %1)\n%11 = tail call i32 @hclgevf_free_cmd_desc(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @hclgevf_cmd_uninit(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%2 = tail call i32 @spin_lock_bh(ptr noundef nonnull %1)\n%3 = tail call i32 @spin_lock(ptr noundef %0)\n%4 = load i32, ptr @HCLGEVF_STATE_CMD_DISABLE, align 4\n%5 = getelementptr inbounds %struct.hclgevf_dev, ptr %0, i64 0, i32 1\n%6 = tail call i32 @clear_bit(i32 noundef %4, ptr noundef nonnull %5)\n%7 = tail call i32 @hclgevf_cmd_uninit_regs(ptr noundef %0)\n%8 = tail call i32 @spin_unlock(ptr noundef %0)\n%9 = tail call i32 @spin_unlock_bh(ptr noundef nonnull %1)\n%10 = tail call i32 @hclgevf_free_cmd_desc(ptr noundef %0)\n%11 = tail call i32 @hclgevf_free_cmd_desc(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @init_connection_unircvfr(i64 %0, i32 %1, i32 noundef %2, ptr noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca %struct.sockaddr_in, align 4\n%7 = alloca { i64, i32 }, align 4\n%8 = alloca i32, align 4\n%9 = alloca ptr, align 8\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\n%12 = getelementptr inbounds { i64, i32 }, ptr %7, i32 0, i32 0\nstore i64 %0, ptr %12, align 4\n%13 = getelementptr inbounds { i64, i32 }, ptr %7, i32 0, i32 1\nstore i32 %1, ptr %13, align 4\ncall void @llvm.memcpy.p0.p0.i64(ptr align 4 %6, ptr align 4 %7, i64 12, i1 false)\nstore i32 %2, ptr %8, align 4\nstore ptr %3, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\n%14 = load i32, ptr @AF_INET, align 4\n%15 = load i32, ptr @SOCK_DGRAM, align 4\n%16 = call i32 @socket(i32 noundef %14, i32 noundef %15, i32 noundef 0)\nstore i32 %16, ptr %10, align 4\n%17 = load i32, ptr %10, align 4\n%18 = icmp eq i32 %17, -1\nbr i1 %18, label %19, label %23\n\n19:\n%20 = load i32, ptr @errno, align 4\n%21 = call i32 @printf(ptr noundef @.str, i32 noundef %20)\n%22 = load i32, ptr @errno, align 4\nstore i32 %22, ptr %5, align 4\nstore i32 1, ptr %11, align 4\nbr label %42\n\n23:\n%24 = load i32, ptr @AF_INET, align 4\n%25 = getelementptr inbounds %struct.sockaddr_in, ptr %6, i32 0, i32 2\nstore i32 %24, ptr %25, align 4\n%26 = load i32, ptr %8, align 4\n%27 = call i32 @htons(i32 noundef %26)\n%28 = getelementptr inbounds %struct.sockaddr_in, ptr %6, i32 0, i32 1\nstore i32 %27, ptr %28, align 4\n%29 = load ptr, ptr %9, align 8\n%30 = call i32 @inet_addr(ptr noundef %29)\n%31 = getelementptr inbounds %struct.sockaddr_in, ptr %6, i32 0, i32 0\n%32 = getelementptr inbounds %struct.TYPE_2__, ptr %31, i32 0, i32 0\nstore i32 %30, ptr %32, align 4\n%33 = load i32, ptr %10, align 4\n%34 = call i64 @bind(i32 noundef %33, ptr noundef %6, i32 noundef 12)\n%35 = icmp slt i64 %34, 0\nbr i1 %35, label %36, label %40\n\n36:\n%37 = load i32, ptr @errno, align 4\n%38 = call i32 @printf(ptr noundef @.str.1, i32 noundef %37)\n%39 = load i32, ptr @errno, align 4\nstore i32 %39, ptr %5, align 4\nstore i32 1, ptr %11, align 4\nbr label %42\n\n40:\n%41 = load i32, ptr %10, align 4\nstore i32 %41, ptr %5, align 4\nstore i32 1, ptr %11, align 4\nbr label %42\n\n42:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\n%43 = load i32, ptr %5, align 4\nret i32 %43\n}": {"base_truth": "define dso_local i32 @init_connection_unircvfr(i64 %0, i32 %1, i32 noundef %2, ptr noundef %3) {\nB:\n%4 = alloca %struct.sockaddr_in, align 8\n%5 = load i32, ptr @AF_INET, align 4\n%6 = load i32, ptr @SOCK_DGRAM, align 4\n%7 = tail call i32 @socket(i32 noundef %5, i32 noundef %6, i32 noundef 0)\n%8 = icmp eq i32 %7, -1\nbr i1 %8, label %B1, label %B2\n\nB1:\n%9 = load i32, ptr @errno, align 4\n%10 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %9)\n%11 = load i32, ptr @errno, align 4\nbr label %B4\n\nB2:\n%12 = getelementptr inbounds i8, ptr %4, i64 8\n%13 = load i32, ptr @AF_INET, align 4\nstore i32 %13, ptr %12, align 8\n%14 = tail call i32 @htons(i32 noundef %2)\n%15 = getelementptr inbounds %struct.sockaddr_in, ptr %4, i64 0, i32 1\nstore i32 %14, ptr %15, align 4\n%16 = tail call i32 @inet_addr(ptr noundef %3)\nstore i32 %16, ptr %4, align 8\n%17 = call i64 @bind(i32 noundef %7, ptr noundef nonnull %4, i32 noundef 12)\n%18 = icmp slt i64 %17, 0\nbr i1 %18, label %B3, label %B4\n\nB3:\n%19 = load i32, ptr @errno, align 4\n%20 = call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %19)\n%21 = load i32, ptr @errno, align 4\nbr label %B4\n\nB4:\n%22 = phi i32 [ %11, %B1 ], [ %21, %B3 ], [ %7, %B2 ]\nret i32 %22\n}", "codellama": "define dso_local i32 @init_connection_unircvfr(i64 %0, i32 %1, i32 noundef %2, ptr noundef %3) {\nB:\n%4 = alloca %struct.sockaddr_in, align 8\nstore i64 %0, ptr %4, align 8\n%5 = getelementptr inbounds %struct.sockaddr_in, ptr %4, i64 0, i32 1\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr @AF_INET, align 4\n%7 = load i32, ptr @SOCK_DGRAM, align 4\n%8 = tail call i32 @socket(i32 noundef %6, i32 noundef %7, i32 noundef 0)\n%9 = icmp eq i32 %8, -1\nbr i1 %9, label %B1, label %B2\n\nB1:\n%10 = load i32, ptr @errno, align 4\n%11 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %10)\nbr label %B4\n\nB2:\n%12 = load i32, ptr @AF_INET, align 4\n%13 = getelementptr inbounds %struct.sockaddr_in, ptr %4, i64 0, i32 2\nstore i32 %12, ptr %13, align 8\n%14 = tail call i32 @htons(i32 noundef %2)\nstore i32 %14, ptr %5, align 4\n%15 = tail call i32 @inet_addr(ptr noundef %3)\nstore i32 %15, ptr %4, align 8\n%16 = call i64 @bind(i32 noundef %8, ptr noundef nonnull %4, i32 noundef 12)\n%17 = icmp slt i64 %16, 0\nbr i1 %17, label %B3, label %B4\n\nB3:\n%18 = load i32, ptr @errno, align 4\n%19 = call i32 @printf(ptr noundef nonnull @.str.1, i32 noundef %18)\nbr label %B4\n\nB4:\n%20 = phi ptr [ @errno, %B1 ], [ @errno, %B3 ], [ %8, %B2 ]\n%21 = load i32, ptr %20, align 4\nret i32 %21\n}", "codegemma": "define dso_local i32 @init_connection_unircvfr(i64 %0, i32 %1, i32 noundef %2, ptr noundef %3) {\nB:\n%4 = alloca %struct.sockaddr_in, align 4\n%5 = alloca i64, align 8\nstore i64 %0, ptr %5, align 8\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(12) %4, ptr noundef nonnull align 4 dereferenceable(12) %5, i64 12, i1 false)\n%6 = load i32, ptr @AF_INET, align 4\n%7 = load i32, ptr @SOCK_DGRAM, align 4\n%8 = tail call i32 @socket(i32 noundef %6, i32 noundef %7, i32 noundef 0)\n%9 = icmp eq i32 %8, -1\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = load i32, ptr @AF_INET, align 4\n%11 = getelementptr inbounds %struct.sockaddr_in, ptr %4, i64 0, i32 2\nstore i32 %10, ptr %11, align 4\n%12 = tail call i32 @htons(i32 noundef %2)\n%13 = getelementptr inbounds %struct.sockaddr_in, ptr %4, i64 0, i32 1\nstore i32 %12, ptr %13, align 4\n%14 = tail call i32 @inet_addr(ptr noundef %3)\nstore i32 %14, ptr %4, align 4\n%15 = call i64 @bind(i32 noundef %8, ptr noundef nonnull %4, i32 noundef 12)\n%16 = icmp slt i64 %15, 0\nbr i1 %16, label %B2, label %B3\n\nB2:\n%17 = phi ptr [ @.str, %B ], [ @.str.1, %B1 ]\n%18 = load i32, ptr @errno, align 4\n%19 = call i32 @printf(ptr noundef nonnull %17, i32 noundef %18)\nbr label %B3\n\nB3:\n%20 = phi i32 [ %8, %B1 ], [ -1, %B2 ]\nret i32 %20\n}"}, "define dso_local void @event_remove_source(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%8 = load i64, ptr @_event_sources, align 8\n%9 = sub nsw i64 %8, 1\n%10 = load i32, ptr %3, align 4\n%11 = load i32, ptr %4, align 4\n%12 = call ptr @event_find_source(i64 noundef %9, i32 noundef -1, i32 noundef %10, i32 noundef %11, ptr noundef %5)\nstore ptr %12, ptr %6, align 8\n%13 = load ptr, ptr %6, align 8\n%14 = icmp eq ptr %13, null\nbr i1 %14, label %15, label %16\n\n15:\nstore i32 1, ptr %7, align 4\nbr label %30\n\n16:\n%17 = load ptr, ptr %6, align 8\n%18 = getelementptr inbounds %struct.TYPE_5__, ptr %17, i32 0, i32 0\n%19 = load i64, ptr %18, align 8\n%20 = load i64, ptr @EVENT_SOURCE_STATE_REMOVED, align 8\n%21 = icmp eq i64 %19, %20\nbr i1 %21, label %22, label %23\n\n22:\nbr label %29\n\n23:\n%24 = load i64, ptr @EVENT_SOURCE_STATE_REMOVED, align 8\n%25 = load ptr, ptr %6, align 8\n%26 = getelementptr inbounds %struct.TYPE_5__, ptr %25, i32 0, i32 0\nstore i64 %24, ptr %26, align 8\n%27 = load ptr, ptr %6, align 8\n%28 = call i32 @event_source_removed_platform(ptr noundef %27)\nbr label %29\n\n29:\nstore i32 0, ptr %7, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\n%31 = load i32, ptr %7, align 4\nswitch i32 %31, label %33 [\ni32 0, label %32\ni32 1, label %32\n]\n\n32:\nret void\n\n33:\nunreachable\n}": {"base_truth": "define dso_local void @event_remove_source(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @_event_sources, align 8\n%4 = add nsw i64 %3, -1\n%5 = call ptr @event_find_source(i64 noundef %4, i32 noundef -1, i32 noundef %0, i32 noundef %1, ptr noundef nonnull %2)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = load i64, ptr %5, align 8\n%8 = load i64, ptr @EVENT_SOURCE_STATE_REMOVED, align 8\n%9 = icmp eq i64 %7, %8\nbr i1 %9, label %B3, label %B2\n\nB2:\nstore i64 %8, ptr %5, align 8\n%10 = call i32 @event_source_removed_platform(ptr noundef nonnull %5)\nbr label %B3\n\nB3:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret void\n}", "codellama": "define dso_local void @event_remove_source(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @_event_sources, align 8\n%4 = add nsw i64 %3, -1\n%5 = call ptr @event_find_source(i64 noundef %4, i32 noundef -1, i32 noundef %0, i32 noundef %1, ptr noundef nonnull %2)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = load i64, ptr %5, align 8\n%8 = load i64, ptr @EVENT_SOURCE_STATE_REMOVED, align 8\n%9 = icmp eq i64 %7, %8\nbr i1 %9, label %B3, label %B2\n\nB2:\nstore i64 %8, ptr %5, align 8\n%10 = call i32 @event_source_removed_platform(ptr noundef nonnull %5)\nbr label %B3\n\nB3:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret void\n}", "codegemma": "define dso_local void @event_remove_source(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = load i64, ptr @_event_sources, align 8\n%4 = add nsw i64 %3, -1\n%5 = call ptr @event_find_source(i64 noundef %4, i32 noundef -1, i32 noundef %0, i32 noundef %1, ptr noundef nonnull %2)\n%6 = icmp eq ptr %5, null\nbr i1 %6, label %B3, label %B1\n\nB1:\n%7 = load i64, ptr %5, align 8\n%8 = load i64, ptr @EVENT_SOURCE_STATE_REMOVED, align 8\n%9 = icmp eq i64 %7, %8\nbr i1 %9, label %B3, label %B2\n\nB2:\nstore i64 %8, ptr %5, align 8\n%10 = call i32 @event_source_removed_platform(ptr noundef nonnull %5)\nbr label %B3\n\nB3:\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret void\n}"}, "define dso_local void @stage_draw_fg(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr @this_stage, align 8\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr %3, align 4\n%9 = load i32, ptr %4, align 4\n%10 = call i32 @draw_tiles(i32 noundef %7, float noundef nofpclass(nan inf) 1.020000e+02, i32 noundef %8, i32 noundef %9)\nret void\n}": {"base_truth": "define dso_local void @stage_draw_fg(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load ptr, ptr @this_stage, align 8\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @draw_tiles(i32 noundef %3, float noundef nofpclass(nan inf) 1.020000e+02, i32 noundef %0, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @stage_draw_fg(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load ptr, ptr @this_stage, align 8\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @draw_tiles(i32 noundef %3, float noundef nofpclass(nan inf) 1.020000e+02, i32 noundef %0, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @stage_draw_fg(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load ptr, ptr @this_stage, align 8\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @draw_tiles(i32 noundef %3, float noundef nofpclass(nan inf) 1.020000e+02, i32 noundef %0, i32 noundef %1)\nret void\n}"}, "define dso_local void @int_vector_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 2\nstore i64 0, ptr %4, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 0\nstore i32 100, ptr %6, align 8\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 8\n%10 = sext i32 %9 to i64\n%11 = mul i64 4, %10\n%12 = trunc i64 %11 to i32\n%13 = call i32 @malloc(i32 noundef %12)\n%14 = load ptr, ptr %2, align 8\n%15 = getelementptr inbounds %struct.TYPE_3__, ptr %14, i32 0, i32 1\nstore i32 %13, ptr %15, align 4\nret void\n}": {"base_truth": "define dso_local void @int_vector_init(ptr nocapture noundef writeonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\nstore i64 0, ptr %1, align 8\nstore i32 100, ptr %0, align 8\n%2 = tail call i32 @malloc(i32 noundef 400)\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\nstore i32 %2, ptr %3, align 4\nret void\n}", "codellama": "define dso_local void @int_vector_init(ptr nocapture noundef writeonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\nstore i64 0, ptr %1, align 8\nstore i32 100, ptr %0, align 8\n%2 = tail call i32 @malloc(i32 noundef 400)\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\nstore i32 %2, ptr %3, align 4\nret void\n}", "codegemma": "define dso_local void @int_vector_init(ptr nocapture noundef writeonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\nstore i64 0, ptr %1, align 8\nstore i32 100, ptr %0, align 8\n%2 = tail call i32 @malloc(i32 noundef 400)\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\nstore i32 %2, ptr %3, align 4\nret void\n}"}, "define internal i32 @mv643xx_eth_get_link(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @netif_carrier_ok(ptr noundef %3)\n%5 = icmp ne i32 %4, 0\n%6 = xor i1 %5, true\n%7 = xor i1 %6, true\n%8 = zext i1 %7 to i32\nret i32 %8\n}": {"base_truth": "define internal i32 @mv643xx_eth_get_link(ptr noundef %0) {\nB:\n%1 = tail call i32 @netif_carrier_ok(ptr noundef %0)\n%2 = icmp ne i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define internal i32 @mv643xx_eth_get_link(ptr noundef %0) {\nB:\n%1 = tail call i32 @netif_carrier_ok(ptr noundef %0)\n%2 = icmp ne i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define internal i32 @mv643xx_eth_get_link(ptr noundef %0) {\nB:\n%1 = tail call i32 @netif_carrier_ok(ptr noundef %0)\n%2 = icmp ne i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define dso_local void @test_core_link__lstat_junction() {\nret void\n}": {"base_truth": "define dso_local void @test_core_link__lstat_junction() {\nB:\nret void\n}", "codellama": "define dso_local void @test_core_link__lstat_junction() {\nB:\nret void\n}", "codegemma": "define dso_local void @test_core_link__lstat_junction() {\nB:\nret void\n}"}, "define dso_local i32 @query_ra_short_GI(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 0, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.sta_info ptr %7, i32 0, i32 1\n%9 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\nstore i32 %10, ptr %4, align 4\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds %struct.sta_info ptr %11, i32 0, i32 1\n%13 = getelementptr inbounds %struct.TYPE_2__, ptr %12, i32 0, i32 1\n%14 = load i32, ptr %13, align 4\nstore i32 %14, ptr %5, align 4\n%15 = load ptr, ptr %2, align 8\n%16 = getelementptr inbounds %struct.sta_info ptr %15, i32 0, i32 0\n%17 = load i32, ptr %16, align 4\nswitch i32 %17, label %23 [\ni32 128, label %18\ni32 129, label %20\ni32 130, label %22\n]\n\n18:\n%19 = load i32, ptr %6, align 4\nstore i32 %19, ptr %3, align 4\nbr label %25\n\n20:\n%21 = load i32, ptr %5, align 4\nstore i32 %21, ptr %3, align 4\nbr label %25\n\n22:\nbr label %23\n\n23:\n%24 = load i32, ptr %4, align 4\nstore i32 %24, ptr %3, align 4\nbr label %25\n\n25:\n%26 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %26\n}": {"base_truth": "define dso_local i32 @query_ra_short_GI(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B2 [\ni32 128, label %B4\ni32 129, label %B1\n]\n\nB1:\n%2 = getelementptr inbounds %struct.sta_info, ptr %0, i64 0, i32 1, i32 1\nbr label %B3\n\nB2:\n%3 = getelementptr inbounds %struct.sta_info, ptr %0, i64 0, i32 1\nbr label %B3\n\nB3:\n%4 = phi ptr [ %3, %B2 ], [ %2, %B1 ]\n%5 = load i32, ptr %4, align 4\nbr label %B4\n\nB4:\n%6 = phi i32 [ 0, %B ], [ %5, %B3 ]\nret i32 %6\n}", "codellama": "define dso_local i32 @query_ra_short_GI(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @query_ra_short_GI(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.sta_info, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds %struct.sta_info, ptr %0, i64 0, i32 1, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr %0, align 4\n%6 = add i32 %5, -128\n%7 = icmp ult i32 %6, 3\n%8 = select i1 %7, i32 %4, i32 %2\nret i32 %8\n}"}, "define dso_local void @Freeaddrinfo(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @freeaddrinfo(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @Freeaddrinfo(ptr noundef %0) {\nB:\n%1 = tail call i32 @freeaddrinfo(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @Freeaddrinfo(ptr noundef %0) {\nB:\n%1 = tail call i32 @freeaddrinfo(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @Freeaddrinfo(ptr noundef %0) {\nB:\n%1 = tail call i32 @freeaddrinfo(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @pdf_annot_has_icon_name(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load i32, ptr @Name, align 4\n%8 = call i32 @PDF_NAME(i32 noundef %7)\n%9 = load i32, ptr @icon_name_subtypes, align 4\n%10 = call i32 @is_allowed_subtype(ptr noundef %5, ptr noundef %6, i32 noundef %8, i32 noundef %9)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @pdf_annot_has_icon_name(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @Name, align 4\n%3 = tail call i32 @PDF_NAME(i32 noundef %2)\n%4 = load i32, ptr @icon_name_subtypes, align 4\n%5 = tail call i32 @is_allowed_subtype(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}", "codellama": "define dso_local i32 @pdf_annot_has_icon_name(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @Name, align 4\n%3 = tail call i32 @PDF_NAME(i32 noundef %2)\n%4 = load i32, ptr @icon_name_subtypes, align 4\n%5 = tail call i32 @is_allowed_subtype(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}", "codegemma": "define dso_local i32 @pdf_annot_has_icon_name(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @Name, align 4\n%3 = tail call i32 @PDF_NAME(i32 noundef %2)\n%4 = load i32, ptr @icon_name_subtypes, align 4\n%5 = tail call i32 @is_allowed_subtype(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}"}, "define dso_local void @stb_compress_hashsize(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 1024, ptr %3, align 4\nbr label %4\n\n4:\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %2, align 4\n%7 = icmp ult i32 %5, %6\nbr i1 %7, label %8, label %11\n\n8:\n%9 = load i32, ptr %3, align 4\n%10 = shl i32 %9, 1\nstore i32 %10, ptr %3, align 4\nbr label %4\n\n11:\n%12 = load i32, ptr %3, align 4\n%13 = lshr i32 %12, 2\nstore i32 %13, ptr @stb__hashsize, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @stb_compress_hashsize(i32 noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi i32 [ 1024, %B ], [ %3, %B1 ]\n%2 = icmp ult i32 %1, %0\n%3 = shl i32 %1, 1\nbr i1 %2, label %B1, label %B2\n\nB2:\n%4 = lshr exact i32 %1, 2\nstore i32 %4, ptr @stb__hashsize, align 4\nret void\n}", "codellama": "define dso_local void @stb_compress_hashsize(i32 noundef %0) {\nB:\n%1 = icmp ult i32 %0, 1024\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 1024, %B ]\n%3 = shl i32 %2, 1\n%4 = icmp ult i32 %3, %0\nbr i1 %4, label %B1, label %B2\n\nB2:\n%5 = phi i32 [ 1024, %B ], [ %3, %B1 ]\n%6 = lshr i32 %5, 2\nstore i32 %6, ptr @stb__hashsize, align 4\nret void\n}", "codegemma": "define dso_local void @stb_compress_hashsize(i32 noundef %0) {\nB:\n%1 = icmp ult i32 %0, 1024\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = phi i32 [ %4, %B1 ], [ 1024, %B ]\n%3 = icmp ult i32 %2, %0\n%4 = shl i32 %2, 1\nbr i1 %3, label %B1, label %B2\n\nB2:\n%5 = phi i32 [ 1024, %B ], [ %2, %B1 ]\n%6 = lshr i32 %5, 2\nstore i32 %6, ptr @stb__hashsize, align 4\nret void\n}"}, "define dso_local void @destroy_per_frame_init_eqn_tree_shape(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %6, label %5\n\n5:\nbr label %12\n\n6:\n%7 = load i32, ptr @free_init_cond, align 4\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @splay_traverse(i32 noundef %7, ptr noundef %8)\n%10 = load ptr, ptr %2, align 8\n%11 = call i32 @destroy_splaytree(ptr noundef %10)\nbr label %12\n\n12:\nret void\n}": {"base_truth": "define dso_local void @destroy_per_frame_init_eqn_tree_shape(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr @free_init_cond, align 4\n%3 = tail call i32 @splay_traverse(i32 noundef %2, ptr noundef nonnull %0)\n%4 = tail call i32 @destroy_splaytree(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @destroy_per_frame_init_eqn_tree_shape(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr @free_init_cond, align 4\n%3 = tail call i32 @splay_traverse(i32 noundef %2, ptr noundef nonnull %0)\n%4 = tail call i32 @destroy_splaytree(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @destroy_per_frame_init_eqn_tree_shape(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr @free_init_cond, align 4\n%3 = tail call i32 @splay_traverse(i32 noundef %2, ptr noundef nonnull %0)\n%4 = tail call i32 @destroy_splaytree(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @Acn_Enc_SInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load i32, ptr %5, align 4\n%8 = icmp slt i32 %7, 0\nbr i1 %8, label %9, label %14\n\n9:\n%10 = load i32, ptr %5, align 4\n%11 = sub nsw i32 0, %10\nstore i32 %11, ptr %5, align 4\n%12 = load ptr, ptr %4, align 8\n%13 = call i32 @BitStream_AppendByte0(ptr noundef %12, i8 noundef signext 45)\nbr label %17\n\n14:\n%15 = load ptr, ptr %4, align 8\n%16 = call i32 @BitStream_AppendByte0(ptr noundef %15, i8 noundef signext 43)\nbr label %17\n\n17:\n%18 = load i32, ptr %6, align 4\n%19 = add nsw i32 %18, -1\nstore i32 %19, ptr %6, align 4\n%20 = load i32, ptr %5, align 4\n%21 = icmp sge i32 %20, 0\n%22 = zext i1 %21 to i32\n%23 = call i32 @assert(i32 noundef %22)\n%24 = load ptr, ptr %4, align 8\n%25 = load i32, ptr %5, align 4\n%26 = load i32, ptr %6, align 4\n%27 = call i32 @Acn_Enc_UInt_ASCII_ConstSize(ptr noundef %24, i32 noundef %25, i32 noundef %26)\nret void\n}": {"base_truth": "define dso_local void @Acn_Enc_SInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %1, 0\n%4 = select i1 %3, i8 45, i8 43\n%5 = tail call i32 @llvm.abs.i32(i32 %1, i1 true)\n%6 = tail call i32 @BitStream_AppendByte0(ptr noundef %0, i8 noundef signext %4)\n%7 = add nsw i32 %2, -1\n%8 = tail call i32 @assert(i32 noundef 1)\n%9 = tail call i32 @Acn_Enc_UInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %5, i32 noundef %7)\nret void\n}", "codellama": "define dso_local void @Acn_Enc_SInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %1, 0\nbr i1 %3, label %B1, label %B2\n\nB1:\n%4 = sub nsw i32 0, %1\n%5 = tail call i32 @BitStream_AppendByte0(ptr noundef %0, i8 noundef signext 45)\nbr label %B3\n\nB2:\n%6 = tail call i32 @BitStream_AppendByte0(ptr noundef %0, i8 noundef signext 43)\nbr label %B3\n\nB3:\n%7 = phi i32 [ %2, %B2 ], [ %2, %B1 ]\n%8 = phi i32 [ %1, %B2 ], [ %4, %B1 ]\n%9 = icmp sgt i32 %8, -1\n%10 = zext i1 %9 to i32\n%11 = tail call i32 @assert(i32 noundef %10)\n%12 = tail call i32 @Acn_Enc_UInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %8, i32 noundef %7)\nret void\n}", "codegemma": "define dso_local void @Acn_Enc_SInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = icmp slt i32 %1, 0\n%4 = sub nsw i32 0, %1\n%5 = select i1 %3, i32 %4, i32 %1\n%6 = tail call i32 @BitStream_AppendByte0(ptr noundef %0, i8 noundef signext 45)\n%7 = tail call i32 @BitStream_AppendByte0(ptr noundef %0, i8 noundef signext 43)\n%8 = add nsw i32 %2, -1\n%9 = icmp sgt i32 %5, -1\n%10 = zext i1 %9 to i32\n%11 = tail call i32 @assert(i32 noundef %10)\n%12 = tail call i32 @Acn_Enc_UInt_ASCII_ConstSize(ptr noundef %0, i32 noundef %5, i32 noundef %8)\nret void\n}"}, "define internal i32 @bcm63xx_internal_irq_startup(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @bcm63xx_internal_irq_unmask(i32 noundef %3)\nret i32 0\n}": {"base_truth": "define internal i32 @bcm63xx_internal_irq_startup(i32 noundef %0) {\nB:\n%1 = tail call i32 @bcm63xx_internal_irq_unmask(i32 noundef %0)\nret i32 0\n}", "codellama": "define internal i32 @bcm63xx_internal_irq_startup(i32 noundef %0) {\nB:\n%1 = tail call i32 @bcm63xx_internal_irq_unmask(i32 noundef %0)\nret i32 0\n}", "codegemma": "define internal i32 @bcm63xx_internal_irq_startup(i32 noundef %0) {\nB:\n%1 = tail call i32 @bcm63xx_internal_irq_unmask(i32 noundef %0)\nret i32 0\n}"}, "define dso_local i64 @THFile_readChar(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = call i64 @THFile_readCharRaw(ptr noundef %5, i32 noundef %8, i32 noundef %11)\nret i64 %12\n}": {"base_truth": "define dso_local i64 @THFile_readChar(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr %1, align 4\n%5 = tail call i64 @THFile_readCharRaw(ptr noundef %0, i32 noundef %3, i32 noundef %4)\nret i64 %5\n}", "codellama": "define dso_local i64 @THFile_readChar(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr %1, align 4\n%5 = tail call i64 @THFile_readCharRaw(ptr noundef %0, i32 noundef %3, i32 noundef %4)\nret i64 %5\n}", "codegemma": "define dso_local i64 @THFile_readChar(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr %1, align 4\n%5 = tail call i64 @THFile_readCharRaw(ptr noundef %0, i32 noundef %3, i32 noundef %4)\nret i64 %5\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%3 = call i32 @printf(ptr noundef @.str)\n%4 = call i32 @scanf(ptr noundef @.str.1, ptr noundef %2)\n%5 = call i32 @printf(ptr noundef @.str.2)\n%6 = load i32, ptr %2, align 4\n%7 = call i32 @Conversion(i32 noundef %6)\n%8 = call i32 @printf(ptr noundef @.str.3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str)\n%2 = call i32 @scanf(ptr noundef nonnull @.str.1, ptr noundef nonnull %0)\n%3 = call i32 @printf(ptr noundef nonnull @.str.2)\n%4 = load i32, ptr %0, align 4\n%5 = call i32 @Conversion(i32 noundef %4)\n%6 = call i32 @printf(ptr noundef nonnull @.str.3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str)\n%2 = call i32 @scanf(ptr noundef nonnull @.str.1, ptr noundef nonnull %0)\n%3 = call i32 @printf(ptr noundef nonnull @.str.2)\n%4 = load i32, ptr %0, align 4\n%5 = call i32 @Conversion(i32 noundef %4)\n%6 = call i32 @printf(ptr noundef nonnull @.str.3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str)\n%2 = call i32 @scanf(ptr noundef nonnull @.str.1, ptr noundef nonnull %0)\n%3 = call i32 @printf(ptr noundef nonnull @.str.2)\n%4 = load i32, ptr %0, align 4\n%5 = call i32 @Conversion(i32 noundef %4)\n%6 = call i32 @printf(ptr noundef nonnull @.str.3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local i32 @create_tcp_socket() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = load i32, ptr @AF_INET, align 4\n%3 = load i32, ptr @SOCK_STREAM, align 4\n%4 = load i32, ptr @IPPROTO_TCP, align 4\n%5 = call i32 @socket(i32 noundef %2, i32 noundef %3, i32 noundef %4)\nstore i32 %5, ptr %1, align 4\n%6 = icmp slt i32 %5, 0\nbr i1 %6, label %7, label %10\n\n7:\n%8 = call i32 @perror(ptr noundef @.str)\n%9 = call i32 @exit(i32 noundef 1)\nunreachable\n\n10:\n%11 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %11\n}": {"base_truth": "define dso_local i32 @create_tcp_socket() {\nB:\n%0 = load i32, ptr @AF_INET, align 4\n%1 = load i32, ptr @SOCK_STREAM, align 4\n%2 = load i32, ptr @IPPROTO_TCP, align 4\n%3 = tail call i32 @socket(i32 noundef %0, i32 noundef %1, i32 noundef %2)\n%4 = icmp slt i32 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @perror(ptr noundef nonnull @.str)\n%6 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\nret i32 %3\n}", "codellama": "define dso_local i32 @create_tcp_socket() {\nB:\n%0 = load i32, ptr @AF_INET, align 4\n%1 = load i32, ptr @SOCK_STREAM, align 4\n%2 = load i32, ptr @IPPROTO_TCP, align 4\n%3 = tail call i32 @socket(i32 noundef %0, i32 noundef %1, i32 noundef %2)\n%4 = icmp slt i32 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @perror(ptr noundef nonnull @.str)\n%6 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\nret i32 %3\n}", "codegemma": "define dso_local i32 @create_tcp_socket() {\nB:\n%0 = load i32, ptr @AF_INET, align 4\n%1 = load i32, ptr @SOCK_STREAM, align 4\n%2 = load i32, ptr @IPPROTO_TCP, align 4\n%3 = tail call i32 @socket(i32 noundef %0, i32 noundef %1, i32 noundef %2)\n%4 = icmp slt i32 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = tail call i32 @perror(ptr noundef nonnull @.str)\n%6 = tail call i32 @exit(i32 noundef 1)\nunreachable\n\nB2:\nret i32 %3\n}"}, "define dso_local void @initDisplay() {\n%1 = call i32 @printf(ptr noundef @.str)\n%2 = call i32 @exportGPIOPin(i32 noundef 61)\n%3 = call i32 @exportGPIOPin(i32 noundef 44)\n%4 = call i32 @writeToFile(ptr noundef @.str.1, ptr noundef @.str.2)\n%5 = call i32 @writeToFile(ptr noundef @.str.3, ptr noundef @.str.2)\nret void\n}": {"base_truth": "define dso_local void @initDisplay() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 @exportGPIOPin(i32 noundef 61)\n%2 = tail call i32 @exportGPIOPin(i32 noundef 44)\n%3 = tail call i32 @writeToFile(ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2)\n%4 = tail call i32 @writeToFile(ptr noundef nonnull @.str.3, ptr noundef nonnull @.str.2)\nret void\n}", "codellama": "define dso_local void @initDisplay() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 @exportGPIOPin(i32 noundef 61)\n%2 = tail call i32 @exportGPIOPin(i32 noundef 44)\n%3 = tail call i32 @writeToFile(ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2)\n%4 = tail call i32 @writeToFile(ptr noundef nonnull @.str.3, ptr noundef nonnull @.str.2)\nret void\n}", "codegemma": "define dso_local void @initDisplay() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\n%1 = tail call i32 @exportGPIOPin(i32 noundef 61)\n%2 = tail call i32 @exportGPIOPin(i32 noundef 44)\n%3 = tail call i32 @writeToFile(ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2)\n%4 = tail call i32 @writeToFile(ptr noundef nonnull @.str.3, ptr noundef nonnull @.str.2)\nret void\n}"}, "define internal i32 @rtl821x_ack_interrupt(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = load i32, ptr @RTL821x_INSR, align 4\n%6 = call i32 @phy_read(ptr noundef %4, i32 noundef %5)\nstore i32 %6, ptr %3, align 4\n%7 = load i32, ptr %3, align 4\n%8 = icmp slt i32 %7, 0\nbr i1 %8, label %9, label %11\n\n9:\n%10 = load i32, ptr %3, align 4\nbr label %12\n\n11:\nbr label %12\n\n12:\n%13 = phi i32 [ %10, %9 ], [ 0, %11 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %13\n}": {"base_truth": "define internal i32 @rtl821x_ack_interrupt(ptr noundef %0) {\nB:\n%1 = load i32, ptr @RTL821x_INSR, align 4\n%2 = tail call i32 @phy_read(ptr noundef %0, i32 noundef %1)\n%3 = tail call i32 @llvm.smin.i32(i32 %2, i32 0)\nret i32 %3\n}", "codellama": "define internal i32 @rtl821x_ack_interrupt(ptr noundef %0) {\nB:\n%1 = load i32, ptr @RTL821x_INSR, align 4\n%2 = tail call i32 @phy_read(ptr noundef %0, i32 noundef %1)\n%3 = tail call i32 @llvm.smin.i32(i32 %2, i32 0)\nret i32 %3\n}", "codegemma": "define internal i32 @rtl821x_ack_interrupt(ptr noundef %0) {\nB:\n%1 = load i32, ptr @RTL821x_INSR, align 4\n%2 = tail call i32 @phy_read(ptr noundef %0, i32 noundef %1)\n%3 = tail call i32 @llvm.smin.i32(i32 %2, i32 0)\nret i32 %3\n}"}, "define internal i32 @xgbe_phy_i2c_mii_read(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%10 = load ptr, ptr %4, align 8\n%11 = call i32 @xgbe_phy_sfp_get_mux(ptr noundef %10)\nstore i32 %11, ptr %8, align 4\n%12 = load i32, ptr %8, align 4\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %14, label %16\n\n14:\n%15 = load i32, ptr %8, align 4\nstore i32 %15, ptr %3, align 4\nstore i32 1, ptr %9, align 4\nbr label %30\n\n16:\n%17 = load i32, ptr %5, align 4\nstore i32 %17, ptr %7, align 4\n%18 = load ptr, ptr %4, align 8\n%19 = load i32, ptr @XGBE_SFP_PHY_ADDRESS, align 4\n%20 = call i32 @xgbe_phy_i2c_read(ptr noundef %18, i32 noundef %19, ptr noundef %7, i32 noundef 4, ptr noundef %6, i32 noundef 4)\nstore i32 %20, ptr %8, align 4\n%21 = load i32, ptr %8, align 4\n%22 = icmp ne i32 %21, 0\nbr i1 %22, label %26, label %23\n\n23:\n%24 = load i32, ptr %6, align 4\n%25 = call i32 @be16_to_cpu(i32 noundef %24)\nstore i32 %25, ptr %8, align 4\nbr label %26\n\n26:\n%27 = load ptr, ptr %4, align 8\n%28 = call i32 @xgbe_phy_sfp_put_mux(ptr noundef %27)\n%29 = load i32, ptr %8, align 4\nstore i32 %29, ptr %3, align 4\nstore i32 1, ptr %9, align 4\nbr label %30\n\n30:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%31 = load i32, ptr %3, align 4\nret i32 %31\n}": {"base_truth": "define internal i32 @xgbe_phy_i2c_mii_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = tail call i32 @xgbe_phy_sfp_get_mux(ptr noundef %0)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B4\n\nB1:\nstore i32 %1, ptr %3, align 4\n%6 = load i32, ptr @XGBE_SFP_PHY_ADDRESS, align 4\n%7 = call i32 @xgbe_phy_i2c_read(ptr noundef %0, i32 noundef %6, ptr noundef nonnull %3, i32 noundef 4, ptr noundef nonnull %2, i32 noundef 4)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = load i32, ptr %2, align 4\n%10 = call i32 @be16_to_cpu(i32 noundef %9)\nbr label %B3\n\nB3:\n%11 = phi i32 [ %7, %B1 ], [ %10, %B2 ]\n%12 = call i32 @xgbe_phy_sfp_put_mux(ptr noundef %0)\nbr label %B4\n\nB4:\n%13 = phi i32 [ %11, %B3 ], [ %4, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %13\n}", "codellama": "define internal i32 @xgbe_phy_i2c_mii_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = tail call i32 @xgbe_phy_sfp_get_mux(ptr noundef %0)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B4\n\nB1:\nstore i32 %1, ptr %3, align 4\n%6 = load i32, ptr @XGBE_SFP_PHY_ADDRESS, align 4\n%7 = call i32 @xgbe_phy_i2c_read(ptr noundef %0, i32 noundef %6, ptr noundef nonnull %3, i32 noundef 4, ptr noundef nonnull %2, i32 noundef 4)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = load i32, ptr %2, align 4\n%10 = call i32 @be16_to_cpu(i32 noundef %9)\nbr label %B3\n\nB3:\n%11 = phi i32 [ %7, %B1 ], [ %10, %B2 ]\n%12 = call i32 @xgbe_phy_sfp_put_mux(ptr noundef %0)\nbr label %B4\n\nB4:\n%13 = phi i32 [ %11, %B3 ], [ %4, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %13\n}", "codegemma": "define internal i32 @xgbe_phy_i2c_mii_read(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\n%4 = tail call i32 @xgbe_phy_sfp_get_mux(ptr noundef %0)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B4\n\nB1:\nstore i32 %1, ptr %3, align 4\n%6 = load i32, ptr @XGBE_SFP_PHY_ADDRESS, align 4\n%7 = call i32 @xgbe_phy_i2c_read(ptr noundef %0, i32 noundef %6, ptr noundef nonnull %3, i32 noundef 4, ptr noundef nonnull %2, i32 noundef 4)\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = load i32, ptr %2, align 4\n%10 = call i32 @be16_to_cpu(i32 noundef %9)\nbr label %B3\n\nB3:\n%11 = phi i32 [ %10, %B2 ], [ %7, %B1 ]\n%12 = call i32 @xgbe_phy_sfp_put_mux(ptr noundef %0)\nbr label %B4\n\nB4:\n%13 = phi i32 [ %11, %B3 ], [ %4, %B ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %13\n}"}, "define dso_local ptr @r647error_handler() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i32, ptr @fBC32error_handler, align 4\n%3 = icmp eq i32 %2, 0\nbr i1 %3, label %4, label %12\n\n4:\nstore i32 1, ptr @fBC32error_handler, align 4\n%5 = call i64 @se_malloc(i32 noundef 4)\n%6 = inttoptr i64 %5 to ptr\nstore ptr %6, ptr %1, align 8\n%7 = load i32, ptr @M293, align 4\n%8 = load ptr, ptr %1, align 8\nstore i32 %7, ptr %8, align 4\n%9 = load ptr, ptr %1, align 8\n%10 = call i32 @r293default_create(ptr noundef %9)\n%11 = load ptr, ptr %1, align 8\nstore ptr %11, ptr @oBC32error_handler, align 8\nbr label %12\n\n12:\n%13 = load ptr, ptr @oBC32error_handler, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @r647error_handler() {\nB:\n%0 = load i32, ptr @fBC32error_handler, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32error_handler, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32error_handler, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M293, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r293default_create(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32error_handler, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}", "codellama": "define dso_local ptr @r647error_handler() {\nB:\n%0 = load i32, ptr @fBC32error_handler, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32error_handler, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32error_handler, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M293, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r293default_create(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32error_handler, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}", "codegemma": "define dso_local ptr @r647error_handler() {\nB:\n%0 = load i32, ptr @fBC32error_handler, align 4\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load ptr, ptr @oBC32error_handler, align 8\nbr label %B3\n\nB2:\nstore i32 1, ptr @fBC32error_handler, align 4\n%3 = tail call i64 @se_malloc(i32 noundef 4)\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @M293, align 4\nstore i32 %5, ptr %4, align 4\n%6 = tail call i32 @r293default_create(ptr noundef nonnull %4)\nstore ptr %4, ptr @oBC32error_handler, align 8\nbr label %B3\n\nB3:\n%7 = phi ptr [ %2, %B1 ], [ %4, %B2 ]\nret ptr %7\n}"}, "define dso_local ptr @cp_string_dup(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = call ptr @calloc(i32 noundef 1, i32 noundef 16)\nstore ptr %4, ptr %3, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %7, label %43\n\n7:\n%8 = load ptr, ptr %3, align 8\n%9 = load ptr, ptr %2, align 8\ncall void @llvm.memcpy.p0.p0.i64(ptr align 8 %8, ptr align 8 %9, i64 16, i1 false)\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.TYPE_6__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 8\n%13 = add nsw i32 %12, 1\n%14 = sext i32 %13 to i64\n%15 = mul i64 %14, 1\n%16 = trunc i64 %15 to i32\n%17 = call i64 @malloc(i32 noundef %16)\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.TYPE_6__, ptr %18, i32 0, i32 1\nstore i64 %17, ptr %19, align 8\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.TYPE_6__, ptr %20, i32 0, i32 1\n%22 = load i64, ptr %21, align 8\n%23 = icmp ne i64 %22, 0\nbr i1 %23, label %24, label %39\n\n24:\n%25 = load ptr, ptr %3, align 8\n%26 = getelementptr inbounds %struct.TYPE_6__, ptr %25, i32 0, i32 1\n%27 = load i64, ptr %26, align 8\n%28 = load ptr, ptr %2, align 8\n%29 = getelementptr inbounds %struct.TYPE_6__, ptr %28, i32 0, i32 1\n%30 = load i64, ptr %29, align 8\n%31 = load ptr, ptr %3, align 8\n%32 = getelementptr inbounds %struct.TYPE_6__, ptr %31, i32 0, i32 0\n%33 = load i32, ptr %32, align 8\n%34 = add nsw i32 %33, 1\n%35 = sext i32 %34 to i64\n%36 = mul i64 %35, 1\n%37 = trunc i64 %36 to i32\n%38 = call i32 @memcpy(i64 noundef %27, i64 noundef %30, i32 noundef %37)\nbr label %42\n\n39:\n%40 = load ptr, ptr %3, align 8\n%41 = call i32 @free(ptr noundef %40)\nstore ptr null, ptr %3, align 8\nbr label %42\n\n42:\nbr label %43\n\n43:\n%44 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %44\n}": {"base_truth": "define dso_local ptr @cp_string_dup(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call ptr @calloc(i32 noundef 1, i32 noundef 16)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B4, label %B1\n\nB1:\ntail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, ptr noundef nonnull align 8 dereferenceable(16) %0, i64 16, i1 false)\n%3 = load i32, ptr %1, align 8\n%4 = add nsw i32 %3, 1\n%5 = tail call i64 @malloc(i32 noundef %4)\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 1\nstore i64 %5, ptr %6, align 8\n%7 = icmp eq i64 %5, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = load i32, ptr %1, align 8\n%11 = add nsw i32 %10, 1\n%12 = tail call i32 @memcpy(i64 noundef %5, i64 noundef %9, i32 noundef %11)\nbr label %B4\n\nB3:\n%13 = tail call i32 @free(ptr noundef nonnull %1)\nbr label %B4\n\nB4:\n%14 = phi ptr [ %1, %B2 ], [ null, %B3 ], [ null, %B ]\nret ptr %14\n}", "codellama": "define dso_local ptr @cp_string_dup(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call ptr @calloc(i32 noundef 1, i32 noundef 16)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B4, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 8\n%4 = add nsw i32 %3, 1\n%5 = tail call i64 @malloc(i32 noundef %4)\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 1\nstore i64 %5, ptr %6, align 8\n%7 = icmp eq i64 %5, 0\nbr i1 %7, label %B3, label %B2\n\nB2:\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%9 = load i64, ptr %8, align 8\n%10 = tail call i32 @memcpy(i64 noundef %5, i64 noundef %9, i32 noundef %4)\nbr label %B4\n\nB3:\n%11 = tail call i32 @free(ptr noundef nonnull %1)\nbr label %B4\n\nB4:\n%12 = phi ptr [ null, %B3 ], [ %1, %B2 ], [ null, %B ]\nret ptr %12\n}", "codegemma": "define dso_local ptr @cp_string_dup(ptr nocapture noundef readonly %0) {\nB:\n%1 = tail call ptr @calloc(i32 noundef 1, i32 noundef 16)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B3, label %B1\n\nB1:\n%3 = tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, ptr noundef nonnull align 8 dereferenceable(16) %0, i64 16, i1 false)\n%4 = load i32, ptr %1, align 8\n%5 = add nsw i32 %4, 1\n%6 = sext i32 %5 to i64\n%7 = tail call i64 @malloc(i32 noundef %6)\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %1, i64 0, i32 1\nstore i64 %7, ptr %8, align 8\n%9 = icmp eq i64 %7, 0\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = getelementptr inbounds %struct.TYPE_6__, ptr %0, i64 0, i32 1\n%11 = load i64, ptr %10, align 8\n%12 = tail call i32 @memcpy(i64 noundef %7, i64 noundef %11, i32 noundef %5)\nbr label %B3\n\nB3:\n%13 = phi ptr [ null, %B1 ], [ %1, %B2 ], [ null, %B ]\nret ptr %13\n}"}, "define internal void @free_mc_sibling_devs(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.amd64_pvt ptr %3, i32 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @pci_dev_put(i32 noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.amd64_pvt ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i32 @pci_dev_put(i32 noundef %9)\nret void\n}": {"base_truth": "define internal void @free_mc_sibling_devs(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.amd64_pvt, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @pci_dev_put(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @pci_dev_put(i32 noundef %4)\nret void\n}", "codellama": "define internal void @free_mc_sibling_devs(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.amd64_pvt, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @pci_dev_put(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @pci_dev_put(i32 noundef %4)\nret void\n}", "codegemma": "define internal void @free_mc_sibling_devs(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.amd64_pvt, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @pci_dev_put(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @pci_dev_put(i32 noundef %4)\nret void\n}"}, "define dso_local ptr @ILLutil_allocrus(i64 noundef %0) {\n%2 = alloca i64, align 8\n%3 = alloca ptr, align 8\nstore i64 %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore ptr null, ptr %3, align 8\n%4 = load i64, ptr %2, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %6, label %7\n\n6:\nbr label %7\n\n7:\n%8 = load i64, ptr %2, align 8\n%9 = call i64 @malloc(i64 noundef %8)\n%10 = inttoptr i64 %9 to ptr\nstore ptr %10, ptr %3, align 8\n%11 = load ptr, ptr %3, align 8\n%12 = icmp eq ptr %11, null\nbr i1 %12, label %13, label %17\n\n13:\n%14 = load i64, ptr %2, align 8\n%15 = trunc i64 %14 to i32\n%16 = call i32 @QSlog(ptr noundef @.str, i32 noundef %15)\nbr label %17\n\n17:\n%18 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %18\n}": {"base_truth": "define dso_local ptr @ILLutil_allocrus(i64 noundef %0) {\nB:\n%1 = tail call i64 @malloc(i64 noundef %0)\n%2 = icmp eq i64 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = trunc i64 %0 to i32\n%4 = tail call i32 @QSlog(ptr noundef nonnull @.str, i32 noundef %3)\nbr label %B2\n\nB2:\n%5 = inttoptr i64 %1 to ptr\nret ptr %5\n}", "codellama": "define dso_local ptr @ILLutil_allocrus(i64 noundef %0) {\nB:\n%1 = tail call i64 @malloc(i64 noundef %0)\n%2 = inttoptr i64 %1 to ptr\n%3 = icmp eq i64 %1, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\nret ptr %2\n\nB2:\n%4 = trunc i64 %0 to i32\n%5 = tail call i32 @QSlog(ptr noundef nonnull @.str, i32 noundef %4)\nret ptr null\n}", "codegemma": "define dso_local ptr @ILLutil_allocrus(i64 noundef %0) {\nB:\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i64 @malloc(i64 noundef %0)\n%3 = inttoptr i64 %2 to ptr\n%4 = icmp eq i64 %2, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = trunc i64 %0 to i32\n%6 = tail call i32 @QSlog(ptr noundef nonnull @.str, i32 noundef %5)\nbr label %B3\n\nB3:\n%7 = phi ptr [ %3, %B1 ], [ null, %B2 ]\nret ptr %7\n}"}, "define dso_local void @CK_ShowTitleScreen() {\n%1 = load i32, ptr @PIC_TITLESCREEN, align 4\n%2 = call i32 @CA_CacheGrChunk(i32 noundef %1)\n%3 = load i32, ptr @PIC_TITLESCREEN, align 4\n%4 = call i32 @VH_DrawBitmap(i32 noundef 0, i32 noundef 0, i32 noundef %3)\n%5 = call i32 @VL_SetScrollCoords(i32 noundef 0, i32 noundef 0)\n%6 = call i32 (...) @VL_Present()\n%7 = call i32 @IN_UserInput(i32 noundef 420, i32 noundef 0)\n%8 = call i32 (...) @CA_ClearMarks()\n%9 = call i32 (...) @CK_HandleDemoKeys()\n%10 = call i32 (...) @VL_Present()\nret void\n}": {"base_truth": "define dso_local void @CK_ShowTitleScreen() {\nB:\n%0 = load i32, ptr @PIC_TITLESCREEN, align 4\n%1 = tail call i32 @CA_CacheGrChunk(i32 noundef %0)\n%2 = load i32, ptr @PIC_TITLESCREEN, align 4\n%3 = tail call i32 @VH_DrawBitmap(i32 noundef 0, i32 noundef 0, i32 noundef %2)\n%4 = tail call i32 @VL_SetScrollCoords(i32 noundef 0, i32 noundef 0)\n%5 = tail call i32 (...) @VL_Present()\n%6 = tail call i32 @IN_UserInput(i32 noundef 420, i32 noundef 0)\n%7 = tail call i32 (...) @CA_ClearMarks()\n%8 = tail call i32 (...) @CK_HandleDemoKeys()\n%9 = tail call i32 (...) @VL_Present()\nret void\n}", "codellama": "define dso_local void @CK_ShowTitleScreen() {\nB:\n%0 = load i32, ptr @PIC_TITLESCREEN, align 4\n%1 = tail call i32 @CA_CacheGrChunk(i32 noundef %0)\n%2 = load i32, ptr @PIC_TITLESCREEN, align 4\n%3 = tail call i32 @VH_DrawBitmap(i32 noundef 0, i32 noundef 0, i32 noundef %2)\n%4 = tail call i32 @VL_SetScrollCoords(i32 noundef 0, i32 noundef 0)\n%5 = tail call i32 (...) @VL_Present()\n%6 = tail call i32 @IN_UserInput(i32 noundef 420, i32 noundef 0)\n%7 = tail call i32 (...) @CA_ClearMarks()\n%8 = tail call i32 (...) @CK_HandleDemoKeys()\n%9 = tail call i32 (...) @VL_Present()\nret void\n}", "codegemma": "define dso_local void @CK_ShowTitleScreen() {\nB:\n%0 = load i32, ptr @PIC_TITLESCREEN, align 4\n%1 = tail call i32 @CA_CacheGrChunk(i32 noundef %0)\n%2 = load i32, ptr @PIC_TITLESCREEN, align 4\n%3 = tail call i32 @VH_DrawBitmap(i32 noundef 0, i32 noundef 0, i32 noundef %2)\n%4 = tail call i32 @VL_SetScrollCoords(i32 noundef 0, i32 noundef 0)\n%5 = tail call i32 (...) @VL_Present()\n%6 = tail call i32 @IN_UserInput(i32 noundef 420, i32 noundef 0)\n%7 = tail call i32 (...) @CA_ClearMarks()\n%8 = tail call i32 (...) @CK_HandleDemoKeys()\n%9 = tail call i32 (...) @VL_Present()\nret void\n}"}, "define dso_local i32 @term() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = call i32 (...) @factor()\nstore i32 %2, ptr %1, align 4\nbr label %3\n\n3:\n%4 = load i8, ptr @token, align 1\n%5 = sext i8 %4 to i32\n%6 = icmp eq i32 %5, 42\nbr i1 %6, label %7, label %12\n\n7:\n%8 = call i32 @match(i8 noundef signext 42)\n%9 = load i32, ptr %1, align 4\n%10 = call i32 (...) @factor()\n%11 = mul nsw i32 %9, %10\nstore i32 %11, ptr %1, align 4\nbr label %3\n\n12:\n%13 = load i32, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %13\n}": {"base_truth": "define dso_local i32 @term() {\nB:\n%0 = tail call i32 (...) @factor()\n%1 = load i8, ptr @token, align 1\n%2 = icmp eq i8 %1, 42\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi i32 [ %6, %B1 ], [ %0, %B ]\n%4 = tail call i32 @match(i8 noundef signext 42)\n%5 = tail call i32 (...) @factor()\n%6 = mul nsw i32 %5, %3\n%7 = load i8, ptr @token, align 1\n%8 = icmp eq i8 %7, 42\nbr i1 %8, label %B1, label %B2\n\nB2:\n%9 = phi i32 [ %0, %B ], [ %6, %B1 ]\nret i32 %9\n}", "codellama": "define dso_local i32 @term() {\nB:\n%0 = tail call i32 (...) @factor()\n%1 = load i8, ptr @token, align 1\n%2 = icmp eq i8 %1, 42\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi i32 [ %6, %B1 ], [ %0, %B ]\n%4 = tail call i32 @match(i8 noundef signext 42)\n%5 = tail call i32 (...) @factor()\n%6 = mul nsw i32 %5, %3\n%7 = load i8, ptr @token, align 1\n%8 = icmp eq i8 %7, 42\nbr i1 %8, label %B1, label %B2\n\nB2:\n%9 = phi i32 [ %0, %B ], [ %6, %B1 ]\nret i32 %9\n}", "codegemma": "define dso_local i32 @term() {\nB:\n%0 = tail call i32 (...) @factor()\n%1 = load i8, ptr @token, align 1\n%2 = icmp eq i8 %1, 42\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = phi i32 [ %6, %B1 ], [ %0, %B ]\n%4 = tail call i32 @match(i8 noundef signext 42)\n%5 = tail call i32 (...) @factor()\n%6 = mul nsw i32 %5, %3\n%7 = load i8, ptr @token, align 1\n%8 = icmp eq i8 %7, 42\nbr i1 %8, label %B1, label %B2\n\nB2:\n%9 = phi i32 [ %0, %B ], [ %6, %B1 ]\nret i32 %9\n}"}, "define internal void @outputerr() {\n%1 = call i32 @sysfail(ptr noundef @.str)\nret void\n}": {"base_truth": "define internal void @outputerr() {\nB:\n%0 = tail call i32 @sysfail(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define internal void @outputerr() {\nB:\n%0 = tail call i32 @sysfail(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define internal void @outputerr() {\nB:\n%0 = tail call i32 @sysfail(ptr noundef nonnull @.str)\nret void\n}"}, "define internal void @ehci_device_bulk_close(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @USB_ERR_CANCELLED, align 4\n%5 = call i32 @ehci_device_done(ptr noundef %3, i32 noundef %4)\nret void\n}": {"base_truth": "define internal void @ehci_device_bulk_close(ptr noundef %0) {\nB:\n%1 = load i32, ptr @USB_ERR_CANCELLED, align 4\n%2 = tail call i32 @ehci_device_done(ptr noundef %0, i32 noundef %1)\nret void\n}", "codellama": "define internal void @ehci_device_bulk_close(ptr noundef %0) {\nB:\n%1 = load i32, ptr @USB_ERR_CANCELLED, align 4\n%2 = tail call i32 @ehci_device_done(ptr noundef %0, i32 noundef %1)\nret void\n}", "codegemma": "define internal void @ehci_device_bulk_close(ptr noundef %0) {\nB:\n%1 = load i32, ptr @USB_ERR_CANCELLED, align 4\n%2 = tail call i32 @ehci_device_done(ptr noundef %0, i32 noundef %1)\nret void\n}"}, "define dso_local void @se_vv_free_force(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %8, label %7\n\n7:\nbr label %14\n\n8:\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.TYPE_4__, ptr %9, i32 0, i32 0\nstore i64 0, ptr %10, align 8\n%11 = load ptr, ptr %3, align 8\n%12 = load ptr, ptr %4, align 8\n%13 = call i32 @se_vv_free_r(ptr noundef %11, ptr noundef %12, ptr noundef @.str, i32 noundef 426)\nbr label %14\n\n14:\nret void\n}": {"base_truth": "define dso_local void @se_vv_free_force(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\nstore i64 0, ptr %1, align 8\n%3 = tail call i32 @se_vv_free_r(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef 426)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @se_vv_free_force(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\nstore i64 0, ptr %1, align 8\n%3 = tail call i32 @se_vv_free_r(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef 426)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @se_vv_free_force(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\nstore i64 0, ptr %1, align 8\n%3 = tail call i32 @se_vv_free_r(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef 426)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @nn_msg_mv(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.nn_msg ptr %5, i32 0, i32 1\n%7 = load ptr, ptr %4, align 8\n%8 = getelementptr inbounds %struct.nn_msg ptr %7, i32 0, i32 1\n%9 = call i32 @nn_chunkref_mv(ptr noundef %6, ptr noundef %8)\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.nn_msg ptr %10, i32 0, i32 0\n%12 = load ptr, ptr %4, align 8\n%13 = getelementptr inbounds %struct.nn_msg ptr %12, i32 0, i32 0\n%14 = call i32 @nn_chunkref_mv(ptr noundef %11, ptr noundef %13)\nret void\n}": {"base_truth": "define dso_local void @nn_msg_mv(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.nn_msg, ptr %0, i64 0, i32 1\n%3 = getelementptr inbounds %struct.nn_msg, ptr %1, i64 0, i32 1\n%4 = tail call i32 @nn_chunkref_mv(ptr noundef nonnull %2, ptr noundef nonnull %3)\n%5 = tail call i32 @nn_chunkref_mv(ptr noundef %0, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @nn_msg_mv(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.nn_msg, ptr %0, i64 0, i32 1\n%3 = getelementptr inbounds %struct.nn_msg, ptr %1, i64 0, i32 1\n%4 = tail call i32 @nn_chunkref_mv(ptr noundef nonnull %2, ptr noundef nonnull %3)\n%5 = tail call i32 @nn_chunkref_mv(ptr noundef %0, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @nn_msg_mv(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.nn_msg, ptr %0, i64 0, i32 1\n%3 = getelementptr inbounds %struct.nn_msg, ptr %1, i64 0, i32 1\n%4 = tail call i32 @nn_chunkref_mv(ptr noundef nonnull %2, ptr noundef nonnull %3)\n%5 = tail call i32 @nn_chunkref_mv(ptr noundef %0, ptr noundef %1)\nret void\n}"}, "define internal i32 @pcan_usb_pro_get_device_id(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca %struct.pcan_usb_pro_msg align 4\n%8 = alloca i32, align 4\n%9 = alloca ptr, align 8\n%10 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.peak_usb_device ptr %11, i32 0, i32 1\n%13 = load i32, ptr %12, align 4\n%14 = load i32, ptr @PCAN_USB_MAX_CMD_LEN, align 4\n%15 = call ptr @pcan_msg_init_empty(ptr noundef %7, i32 noundef %13, i32 noundef %14)\nstore ptr %15, ptr %9, align 8\n%16 = load i32, ptr @PCAN_USBPRO_GETDEVID, align 4\n%17 = load ptr, ptr %4, align 8\n%18 = getelementptr inbounds %struct.peak_usb_device ptr %17, i32 0, i32 0\n%19 = load i32, ptr %18, align 4\n%20 = call i32 @pcan_msg_add_rec(ptr noundef %7, i32 noundef %16, i32 noundef %19)\n%21 = load ptr, ptr %4, align 8\n%22 = call i32 @pcan_usb_pro_send_cmd(ptr noundef %21, ptr noundef %7)\nstore i32 %22, ptr %8, align 4\n%23 = load i32, ptr %8, align 4\n%24 = icmp ne i32 %23, 0\nbr i1 %24, label %25, label %27\n\n25:\n%26 = load i32, ptr %8, align 4\nstore i32 %26, ptr %3, align 4\nstore i32 1, ptr %10, align 4\nbr label %46\n\n27:\n%28 = load ptr, ptr %4, align 8\n%29 = call i32 @pcan_usb_pro_wait_rsp(ptr noundef %28, ptr noundef %7)\nstore i32 %29, ptr %8, align 4\n%30 = load i32, ptr %8, align 4\n%31 = icmp ne i32 %30, 0\nbr i1 %31, label %32, label %34\n\n32:\n%33 = load i32, ptr %8, align 4\nstore i32 %33, ptr %3, align 4\nstore i32 1, ptr %10, align 4\nbr label %46\n\n34:\n%35 = load ptr, ptr %9, align 8\nstore ptr %35, ptr %6, align 8\n%36 = load ptr, ptr %5, align 8\n%37 = icmp ne ptr %36, null\nbr i1 %37, label %38, label %44\n\n38:\n%39 = load ptr, ptr %6, align 8\n%40 = getelementptr inbounds %struct.pcan_usb_pro_devid ptr %39, i32 0, i32 0\n%41 = load i32, ptr %40, align 4\n%42 = call i32 @le32_to_cpu(i32 noundef %41)\n%43 = load ptr, ptr %5, align 8\nstore i32 %42, ptr %43, align 4\nbr label %44\n\n44:\n%45 = load i32, ptr %8, align 4\nstore i32 %45, ptr %3, align 4\nstore i32 1, ptr %10, align 4\nbr label %46\n\n46:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%47 = load i32, ptr %3, align 4\nret i32 %47\n}": {"base_truth": "define internal i32 @pcan_usb_pro_get_device_id(ptr noundef %0, ptr noundef writeonly %1) {\nB:\n%2 = alloca %struct.pcan_usb_pro_msg, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = getelementptr inbounds %struct.peak_usb_device, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @PCAN_USB_MAX_CMD_LEN, align 4\n%6 = call ptr @pcan_msg_init_empty(ptr noundef nonnull %2, i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr @PCAN_USBPRO_GETDEVID, align 4\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @pcan_msg_add_rec(ptr noundef nonnull %2, i32 noundef %7, i32 noundef %8)\n%10 = call i32 @pcan_usb_pro_send_cmd(ptr noundef nonnull %0, ptr noundef nonnull %2)\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B1, label %B3\n\nB1:\n%12 = call i32 @pcan_usb_pro_wait_rsp(ptr noundef nonnull %0, ptr noundef nonnull %2)\n%13 = icmp ne i32 %12, 0\n%14 = icmp eq ptr %1, null\n%15 = or i1 %14, %13\nbr i1 %15, label %B3, label %B2\n\nB2:\n%16 = load i32, ptr %6, align 4\n%17 = call i32 @le32_to_cpu(i32 noundef %16)\nstore i32 %17, ptr %1, align 4\nbr label %B3\n\nB3:\n%18 = phi i32 [ %10, %B ], [ %12, %B1 ], [ 0, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %18\n}", "codellama": "define internal i32 @pcan_usb_pro_get_device_id(ptr noundef %0, ptr noundef writeonly %1) {\nB:\n%2 = alloca %struct.pcan_usb_pro_msg, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = getelementptr inbounds %struct.peak_usb_device, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @PCAN_USB_MAX_CMD_LEN, align 4\n%6 = call ptr @pcan_msg_init_empty(ptr noundef nonnull %2, i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr @PCAN_USBPRO_GETDEVID, align 4\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @pcan_msg_add_rec(ptr noundef nonnull %2, i32 noundef %7, i32 noundef %8)\n%10 = call i32 @pcan_usb_pro_send_cmd(ptr noundef nonnull %0, ptr noundef nonnull %2)\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B1, label %B4\n\nB1:\n%12 = call i32 @pcan_usb_pro_wait_rsp(ptr noundef nonnull %0, ptr noundef nonnull %2)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B2, label %B4\n\nB2:\n%14 = icmp eq ptr %1, null\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = load i32, ptr %6, align 4\n%16 = call i32 @le32_to_cpu(i32 noundef %15)\nstore i32 %16, ptr %1, align 4\nbr label %B4\n\nB4:\n%17 = phi i32 [ %10, %B ], [ %12, %B1 ], [ 0, %B3 ], [ 0, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %17\n}", "codegemma": "define internal i32 @pcan_usb_pro_get_device_id(ptr noundef %0, ptr noundef writeonly %1) {\nB:\n%2 = alloca %struct.pcan_usb_pro_msg, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\n%3 = getelementptr inbounds %struct.peak_usb_device, ptr %0, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @PCAN_USB_MAX_CMD_LEN, align 4\n%6 = call ptr @pcan_msg_init_empty(ptr noundef nonnull %2, i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr @PCAN_USBPRO_GETDEVID, align 4\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @pcan_msg_add_rec(ptr noundef nonnull %2, i32 noundef %7, i32 noundef %8)\n%10 = call i32 @pcan_usb_pro_send_cmd(ptr noundef nonnull %0, ptr noundef nonnull %2)\n%11 = icmp eq i32 %10, 0\nbr i1 %11, label %B1, label %B4\n\nB1:\n%12 = call i32 @pcan_usb_pro_wait_rsp(ptr noundef nonnull %0, ptr noundef nonnull %2)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B2, label %B4\n\nB2:\n%14 = icmp eq ptr %1, null\nbr i1 %14, label %B4, label %B3\n\nB3:\n%15 = load i32, ptr %6, align 4\n%16 = call i32 @le32_to_cpu(i32 noundef %15)\nstore i32 %16, ptr %1, align 4\nbr label %B4\n\nB4:\n%17 = phi i32 [ %10, %B ], [ %12, %B1 ], [ 0, %B3 ], [ 0, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\nret i32 %17\n}"}, "define internal i32 @ImageView_LoadSettings() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%5 = load i32, ptr @HKEY_CURRENT_USER, align 4\n%6 = call i32 @_T(ptr noundef @.str)\n%7 = load i32, ptr @KEY_READ, align 4\n%8 = call i64 @RegOpenKeyEx(i32 noundef %5, i32 noundef %6, i32 noundef 0, i32 noundef %7, ptr noundef %2)\n%9 = load i64, ptr @ERROR_SUCCESS, align 8\n%10 = icmp eq i64 %8, %9\nbr i1 %10, label %11, label %24\n\n11:\nstore i32 4, ptr %3, align 4\n%12 = load i32, ptr %2, align 4\n%13 = call i32 @_T(ptr noundef @.str.1)\n%14 = call i64 @RegQueryValueEx(i32 noundef %12, i32 noundef %13, ptr noundef null, ptr noundef null, i32 noundef ptrtoint (ptr @shiSettings to i32), ptr noundef %3)\n%15 = load i64, ptr @ERROR_SUCCESS, align 8\n%16 = icmp eq i64 %14, %15\nbr i1 %16, label %17, label %21\n\n17:\n%18 = load i32, ptr %2, align 4\n%19 = call i32 @RegCloseKey(i32 noundef %18)\n%20 = load i32, ptr @TRUE, align 4\nstore i32 %20, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %26\n\n21:\n%22 = load i32, ptr %2, align 4\n%23 = call i32 @RegCloseKey(i32 noundef %22)\nbr label %24\n\n24:\n%25 = load i32, ptr @FALSE, align 4\nstore i32 %25, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %26\n\n26:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%27 = load i32, ptr %1, align 4\nret i32 %27\n}": {"base_truth": "define internal i32 @ImageView_LoadSettings() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr @HKEY_CURRENT_USER, align 4\n%3 = tail call i32 @_T(ptr noundef nonnull @.str)\n%4 = load i32, ptr @KEY_READ, align 4\n%5 = call i64 @RegOpenKeyEx(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %4, ptr noundef nonnull %0)\n%6 = load i64, ptr @ERROR_SUCCESS, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B1, label %B2\n\nB1:\nstore i32 4, ptr %1, align 4\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @_T(ptr noundef nonnull @.str.1)\n%10 = call i64 @RegQueryValueEx(i32 noundef %8, i32 noundef %9, ptr noundef null, ptr noundef null, i32 noundef ptrtoint (ptr @shiSettings to i32), ptr noundef nonnull %1)\n%11 = load i64, ptr @ERROR_SUCCESS, align 8\n%12 = icmp eq i64 %10, %11\n%13 = load i32, ptr %0, align 4\n%14 = call i32 @RegCloseKey(i32 noundef %13)\n%15 = select i1 %12, ptr @TRUE, ptr @FALSE\nbr label %B2\n\nB2:\n%16 = phi ptr [ @FALSE, %B ], [ %15, %B1 ]\n%17 = load i32, ptr %16, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %17\n}", "codellama": "define internal i32 @ImageView_LoadSettings() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr @HKEY_CURRENT_USER, align 4\n%3 = tail call i32 @_T(ptr noundef nonnull @.str)\n%4 = load i32, ptr @KEY_READ, align 4\n%5 = call i64 @RegOpenKeyEx(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %4, ptr noundef nonnull %0)\n%6 = load i64, ptr @ERROR_SUCCESS, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B1, label %B4\n\nB1:\nstore i32 4, ptr %1, align 4\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @_T(ptr noundef nonnull @.str.1)\n%10 = call i64 @RegQueryValueEx(i32 noundef %8, i32 noundef %9, ptr noundef null, ptr noundef null, i32 noundef ptrtoint (ptr @shiSettings to i32), ptr noundef nonnull %1)\n%11 = load i64, ptr @ERROR_SUCCESS, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = load i32, ptr %0, align 4\n%14 = call i32 @RegCloseKey(i32 noundef %13)\nbr label %B4\n\nB3:\n%15 = load i32, ptr %0, align 4\n%16 = call i32 @RegCloseKey(i32 noundef %15)\nbr label %B4\n\nB4:\n%17 = phi ptr [ @TRUE, %B2 ], [ @FALSE, %B3 ], [ @FALSE, %B ]\n%18 = load i32, ptr %17, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %18\n}", "codegemma": "define internal i32 @ImageView_LoadSettings() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr @HKEY_CURRENT_USER, align 4\n%3 = tail call i32 @_T(ptr noundef nonnull @.str)\n%4 = load i32, ptr @KEY_READ, align 4\n%5 = call i64 @RegOpenKeyEx(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %4, ptr noundef nonnull %0)\n%6 = load i64, ptr @ERROR_SUCCESS, align 8\n%7 = icmp eq i64 %5, %6\nbr i1 %7, label %B1, label %B3\n\nB1:\nstore i32 4, ptr %1, align 4\n%8 = load i32, ptr %0, align 4\n%9 = call i32 @_T(ptr noundef nonnull @.str.1)\n%10 = call i64 @RegQueryValueEx(i32 noundef %8, i32 noundef %9, ptr noundef null, ptr noundef null, i32 noundef ptrtoint (ptr @shiSettings to i32), ptr noundef nonnull %1)\n%11 = load i64, ptr @ERROR_SUCCESS, align 8\n%12 = icmp eq i64 %10, %11\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = load i32, ptr %0, align 4\n%14 = call i32 @RegCloseKey(i32 noundef %13)\nbr label %B3\n\nB3:\n%15 = phi ptr [ @TRUE, %B2 ], [ @FALSE, %B1 ], [ @FALSE, %B ]\n%16 = load i32, ptr %15, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %16\n}"}, "define dso_local void @VIRTUAL_parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @parser__ReduceAction785__action(ptr noundef %5, ptr noundef %6)\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @VIRTUAL_parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @VIRTUAL_parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @VIRTUAL_parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction785__action(ptr noundef %0, ptr noundef %1)\nret void\n}"}, "define dso_local void @glPixelStoref(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @next_glPixelStoref(i32 noundef %5, i32 noundef %6)\n%8 = call i32 (...) @printGLError()\n%9 = load i32, ptr %3, align 4\n%10 = call i32 @getEnumString(i32 noundef %9)\n%11 = load i32, ptr %4, align 4\n%12 = call i32 @debugPrint(ptr noundef @.str, i32 noundef %10, i32 noundef %11)\nret void\n}": {"base_truth": "define dso_local void @glPixelStoref(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @next_glPixelStoref(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @printGLError()\n%4 = tail call i32 @getEnumString(i32 noundef %0)\n%5 = tail call i32 @debugPrint(ptr noundef nonnull @.str, i32 noundef %4, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @glPixelStoref(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @next_glPixelStoref(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @printGLError()\n%4 = tail call i32 @getEnumString(i32 noundef %0)\n%5 = tail call i32 @debugPrint(ptr noundef nonnull @.str, i32 noundef %4, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @glPixelStoref(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @next_glPixelStoref(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @printGLError()\n%4 = tail call i32 @getEnumString(i32 noundef %0)\n%5 = tail call i32 @debugPrint(ptr noundef nonnull @.str, i32 noundef %4, i32 noundef %1)\nret void\n}"}, "define dso_local void @modify_room() {\n%1 = call i32 @printf(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @modify_room() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @modify_room() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @modify_room() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local void @dmlab_spawn_inventory(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr @DEEPMIND_SPAWN_INVENTORY, align 4\n%6 = load ptr, ptr %3, align 8\n%7 = ptrtoint ptr %6 to i64\n%8 = load i32, ptr %4, align 4\n%9 = call i32 @trap_DeepmindCallback(i32 noundef %5, i64 noundef %7, i32 noundef %8, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\nret void\n}": {"base_truth": "define dso_local void @dmlab_spawn_inventory(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @DEEPMIND_SPAWN_INVENTORY, align 4\n%3 = ptrtoint ptr %0 to i64\n%4 = tail call i32 @trap_DeepmindCallback(i32 noundef %2, i64 noundef %3, i32 noundef %1, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @dmlab_spawn_inventory(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @DEEPMIND_SPAWN_INVENTORY, align 4\n%3 = ptrtoint ptr %0 to i64\n%4 = tail call i32 @trap_DeepmindCallback(i32 noundef %2, i64 noundef %3, i32 noundef %1, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @dmlab_spawn_inventory(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @DEEPMIND_SPAWN_INVENTORY, align 4\n%3 = ptrtoint ptr %0 to i64\n%4 = tail call i32 @trap_DeepmindCallback(i32 noundef %2, i64 noundef %3, i32 noundef %1, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\nret void\n}"}, "define internal i32 @m5mols_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @i2c_get_clientdata(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @v4l2_device_unregister_subdev(ptr noundef %6)\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.v4l2_subdev, ptr %8, i32 0, i32 1\n%10 = load i32, ptr %9, align 4\n%11 = call i32 @v4l2_ctrl_handler_free(i32 noundef %10)\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.v4l2_subdev, ptr %12, i32 0, i32 0\n%14 = call i32 @media_entity_cleanup(ptr noundef %13)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @m5mols_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @i2c_get_clientdata(ptr noundef %0)\n%2 = tail call i32 @v4l2_device_unregister_subdev(ptr noundef %1)\n%3 = getelementptr inbounds %struct.v4l2_subdev, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = tail call i32 @v4l2_ctrl_handler_free(i32 noundef %4)\n%6 = tail call i32 @media_entity_cleanup(ptr noundef %1)\nret i32 0\n}", "codellama": "define internal i32 @m5mols_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @i2c_get_clientdata(ptr noundef %0)\n%2 = tail call i32 @v4l2_device_unregister_subdev(ptr noundef %1)\n%3 = getelementptr inbounds %struct.v4l2_subdev, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = tail call i32 @v4l2_ctrl_handler_free(i32 noundef %4)\n%6 = tail call i32 @media_entity_cleanup(ptr noundef %1)\nret i32 0\n}", "codegemma": "define internal i32 @m5mols_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @i2c_get_clientdata(ptr noundef %0)\n%2 = tail call i32 @v4l2_device_unregister_subdev(ptr noundef %1)\n%3 = getelementptr inbounds %struct.v4l2_subdev, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = tail call i32 @v4l2_ctrl_handler_free(i32 noundef %4)\n%6 = tail call i32 @media_entity_cleanup(ptr noundef %1)\nret i32 0\n}"}, "define internal i32 @dsp_dma_start(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\nstore i32 0, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\nstore i32 0, ptr %9, align 4\n%11 = load ptr, ptr %5, align 8\n%12 = call i32 @codec_dbg(ptr noundef %11, ptr noundef @.str)\n%13 = load i32, ptr %7, align 4\n%14 = icmp ne i32 %13, 0\nbr i1 %14, label %15, label %34\n\n15:\n%16 = load ptr, ptr %5, align 8\n%17 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%18 = call i32 @chipio_read(ptr noundef %16, i32 noundef %17, ptr noundef %8)\nstore i32 %18, ptr %9, align 4\n%19 = load i32, ptr %9, align 4\n%20 = icmp slt i32 %19, 0\nbr i1 %20, label %21, label %25\n\n21:\n%22 = load ptr, ptr %5, align 8\n%23 = call i32 @codec_dbg(ptr noundef %22, ptr noundef @.str.1)\n%24 = load i32, ptr %9, align 4\nstore i32 %24, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %54\n\n25:\n%26 = load ptr, ptr %5, align 8\n%27 = call i32 @codec_dbg(ptr noundef %26, ptr noundef @.str.2)\n%28 = load i32, ptr @DSPDMAC_CHNLSTART_EN_MASK, align 4\n%29 = load i32, ptr @DSPDMAC_CHNLSTART_DIS_MASK, align 4\n%30 = or i32 %28, %29\n%31 = xor i32 %30, -1\n%32 = load i32, ptr %8, align 4\n%33 = and i32 %32, %31\nstore i32 %33, ptr %8, align 4\nbr label %34\n\n34:\n%35 = load ptr, ptr %5, align 8\n%36 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%37 = load i32, ptr %8, align 4\n%38 = load i32, ptr %6, align 4\n%39 = load i32, ptr @DSPDMAC_CHNLSTART_EN_LOBIT, align 4\n%40 = add i32 %38, %39\n%41 = shl i32 1, %40\n%42 = or i32 %37, %41\n%43 = call i32 @chipio_write(ptr noundef %35, i32 noundef %36, i32 noundef %42)\nstore i32 %43, ptr %9, align 4\n%44 = load i32, ptr %9, align 4\n%45 = icmp slt i32 %44, 0\nbr i1 %45, label %46, label %50\n\n46:\n%47 = load ptr, ptr %5, align 8\n%48 = call i32 @codec_dbg(ptr noundef %47, ptr noundef @.str.3)\n%49 = load i32, ptr %9, align 4\nstore i32 %49, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %54\n\n50:\n%51 = load ptr, ptr %5, align 8\n%52 = call i32 @codec_dbg(ptr noundef %51, ptr noundef @.str.4)\n%53 = load i32, ptr %9, align 4\nstore i32 %53, ptr %4, align 4\nstore i32 1, ptr %10, align 4\nbr label %54\n\n54:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\n%55 = load i32, ptr %4, align 4\nret i32 %55\n}": {"base_truth": "define internal i32 @dsp_dma_start(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\nstore i32 0, ptr %3, align 4\n%4 = tail call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str)\n%5 = icmp eq i32 %2, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%7 = call i32 @chipio_read(ptr noundef %0, i32 noundef %6, ptr noundef nonnull %3)\n%8 = icmp slt i32 %7, 0\nbr i1 %8, label %B4, label %B2\n\nB2:\n%9 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.2)\n%10 = load i32, ptr @DSPDMAC_CHNLSTART_EN_MASK, align 4\n%11 = load i32, ptr @DSPDMAC_CHNLSTART_DIS_MASK, align 4\n%12 = or i32 %11, %10\n%13 = xor i32 %12, -1\n%14 = load i32, ptr %3, align 4\n%15 = and i32 %14, %13\nstore i32 %15, ptr %3, align 4\nbr label %B3\n\nB3:\n%16 = phi i32 [ %15, %B2 ], [ 0, %B ]\n%17 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%18 = load i32, ptr @DSPDMAC_CHNLSTART_EN_LOBIT, align 4\n%19 = add i32 %18, %1\n%20 = shl nuw i32 1, %19\n%21 = or i32 %20, %16\n%22 = call i32 @chipio_write(ptr noundef %0, i32 noundef %17, i32 noundef %21)\n%23 = icmp slt i32 %22, 0\n%24 = select i1 %23, ptr @.str.3, ptr @.str.4\nbr label %B4\n\nB4:\n%25 = phi ptr [ @.str.1, %B1 ], [ %24, %B3 ]\n%26 = phi i32 [ %7, %B1 ], [ %22, %B3 ]\n%27 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull %25)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret i32 %26\n}", "codellama": "define internal i32 @dsp_dma_start(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\nstore i32 0, ptr %3, align 4\n%4 = tail call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str)\n%5 = icmp eq i32 %2, 0\nbr i1 %5, label %B4, label %B1\n\nB1:\n%6 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%7 = call i32 @chipio_read(ptr noundef %0, i32 noundef %6, ptr noundef nonnull %3)\n%8 = icmp slt i32 %7, 0\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.1)\nbr label %B7\n\nB3:\n%10 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.2)\n%11 = load i32, ptr @DSPDMAC_CHNLSTART_EN_MASK, align 4\n%12 = load i32, ptr @DSPDMAC_CHNLSTART_DIS_MASK, align 4\n%13 = or i32 %12, %11\n%14 = xor i32 %13, -1\n%15 = load i32, ptr %3, align 4\n%16 = and i32 %15, %14\nstore i32 %16, ptr %3, align 4\nbr label %B4\n\nB4:\n%17 = phi i32 [ %7, %B2 ], [ %16, %B3 ]\n%18 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%19 = load i32, ptr @DSPDMAC_CHNLSTART_EN_LOBIT, align 4\n%20 = add i32 %19, %1\n%21 = shl nuw i32 1, %20\n%22 = or i32 %21, %17\n%23 = call i32 @chipio_write(ptr noundef %0, i32 noundef %18, i32 noundef %22)\n%24 = icmp slt i32 %23, 0\nbr i1 %24, label %B5, label %B6\n\nB5:\n%25 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.3)\nbr label %B7\n\nB6:\n%26 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.4)\nbr label %B7\n\nB7:\n%27 = phi i32 [ %23, %B5 ], [ %23, %B6 ], [ %7, %B2 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret i32 %27\n}", "codegemma": "define internal i32 @dsp_dma_start(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\nstore i32 0, ptr %3, align 4\n%4 = tail call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str)\n%5 = icmp eq i32 %2, 0\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%7 = call i32 @chipio_read(ptr noundef %0, i32 noundef %6, ptr noundef nonnull %3)\n%8 = icmp slt i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.2)\n%10 = load i32, ptr @DSPDMAC_CHNLSTART_EN_MASK, align 4\n%11 = load i32, ptr @DSPDMAC_CHNLSTART_DIS_MASK, align 4\n%12 = or i32 %11, %10\n%13 = xor i32 %12, -1\n%14 = load i32, ptr %3, align 4\n%15 = and i32 %14, %13\nstore i32 %15, ptr %3, align 4\nbr label %B3\n\nB3:\n%16 = phi i32 [ %14, %B2 ], [ %7, %B1 ]\n%17 = load i32, ptr @DSPDMAC_CHNLSTART_INST_OFFSET, align 4\n%18 = load i32, ptr @DSPDMAC_CHNLSTART_EN_LOBIT, align 4\n%19 = add i32 %18, %1\n%20 = shl nuw i32 1, %19\n%21 = or i32 %20, %16\n%22 = call i32 @chipio_write(ptr noundef %0, i32 noundef %17, i32 noundef %21)\n%23 = icmp slt i32 %22, 0\nbr i1 %23, label %B4, label %B5\n\nB4:\n%24 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.3)\nbr label %B6\n\nB5:\n%25 = call i32 @codec_dbg(ptr noundef %0, ptr noundef nonnull @.str.4)\nbr label %B6\n\nB6:\n%26 = phi i32 [ %22, %B5 ], [ %22, %B4 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret i32 %26\n}"}, "define dso_local i32 @lwes_net_get_rcvbuf(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = icmp ne ptr %7, null\nbr i1 %8, label %9, label %21\n\n9:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 4, ptr %5, align 4\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.lwes_net_connection ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = load i32, ptr @SOL_SOCKET, align 4\n%14 = load i32, ptr @SO_RCVBUF, align 4\n%15 = call i64 @my_getsockopt(i32 noundef %12, i32 noundef %13, i32 noundef %14, ptr noundef %4, ptr noundef %5)\n%16 = icmp slt i64 %15, 0\nbr i1 %16, label %17, label %18\n\n17:\nstore i32 -2, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %20\n\n18:\n%19 = load i32, ptr %4, align 4\nstore i32 %19, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %20\n\n20:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\nbr label %22\n\n21:\nstore i32 -1, ptr %2, align 4\nbr label %22\n\n22:\n%23 = load i32, ptr %2, align 4\nret i32 %23\n}": {"base_truth": "define dso_local i32 @lwes_net_get_rcvbuf(ptr noundef readonly %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = icmp eq ptr %0, null\nbr i1 %3, label %B2, label %B1\n\nB1:\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\nstore i32 4, ptr %2, align 4\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @SOL_SOCKET, align 4\n%6 = load i32, ptr @SO_RCVBUF, align 4\n%7 = call i64 @my_getsockopt(i32 noundef %4, i32 noundef %5, i32 noundef %6, ptr noundef nonnull %1, ptr noundef nonnull %2)\n%8 = icmp slt i64 %7, 0\n%9 = load i32, ptr %1, align 4\n%10 = select i1 %8, i32 -2, i32 %9\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nbr label %B2\n\nB2:\n%11 = phi i32 [ %10, %B1 ], [ -1, %B ]\nret i32 %11\n}", "codellama": "define dso_local i32 @lwes_net_get_rcvbuf(ptr noundef readonly %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = icmp eq ptr %0, null\nbr i1 %3, label %B2, label %B1\n\nB1:\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\nstore i32 4, ptr %2, align 4\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @SOL_SOCKET, align 4\n%6 = load i32, ptr @SO_RCVBUF, align 4\n%7 = call i64 @my_getsockopt(i32 noundef %4, i32 noundef %5, i32 noundef %6, ptr noundef nonnull %1, ptr noundef nonnull %2)\n%8 = icmp slt i64 %7, 0\n%9 = load i32, ptr %1, align 4\n%10 = select i1 %8, i32 -2, i32 %9\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nbr label %B2\n\nB2:\n%11 = phi i32 [ %10, %B1 ], [ -1, %B ]\nret i32 %11\n}", "codegemma": "define dso_local i32 @lwes_net_get_rcvbuf(ptr noundef readonly %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = icmp eq ptr %0, null\nbr i1 %3, label %B2, label %B1\n\nB1:\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\nstore i32 4, ptr %2, align 4\n%4 = load i32, ptr %0, align 4\n%5 = load i32, ptr @SOL_SOCKET, align 4\n%6 = load i32, ptr @SO_RCVBUF, align 4\n%7 = call i64 @my_getsockopt(i32 noundef %4, i32 noundef %5, i32 noundef %6, ptr noundef nonnull %1, ptr noundef nonnull %2)\n%8 = icmp slt i64 %7, 0\n%9 = load i32, ptr %1, align 4\n%10 = select i1 %8, i32 -2, i32 %9\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nbr label %B2\n\nB2:\n%11 = phi i32 [ %10, %B1 ], [ -1, %B ]\nret i32 %11\n}"}, "define dso_local void @processConstValueNode(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @processConstValueNode(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @processConstValueNode(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @processConstValueNode(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define internal void @alc_auto_init_amp(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = call i32 @alc_auto_setup_eapd(ptr noundef %5, i32 noundef 1)\n%7 = load ptr, ptr %3, align 8\n%8 = call i32 @alc_write_gpio(ptr noundef %7)\n%9 = load i32, ptr %4, align 4\nswitch i32 %9, label %25 [\ni32 128, label %10\n]\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.hda_codec, ptr %11, i32 0, i32 0\n%13 = getelementptr inbounds %struct.TYPE_2__, ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 4\nswitch i32 %14, label %24 [\ni32 283902560, label %15\ni32 283904128, label %18\ni32 283904130, label %18\ni32 283904131, label %18\ni32 283904133, label %18\ni32 283904136, label %21\n]\n\n15:\n%16 = load ptr, ptr %3, align 8\n%17 = call i32 @alc_update_coefex_idx(ptr noundef %16, i32 noundef 26, i32 noundef 7, i32 noundef 0, i32 noundef 8208)\nbr label %24\n\n18:\n%19 = load ptr, ptr %3, align 8\n%20 = call i32 @alc_update_coef_idx(ptr noundef %19, i32 noundef 7, i32 noundef 0, i32 noundef 8240)\nbr label %24\n\n21:\n%22 = load ptr, ptr %3, align 8\n%23 = call i32 @alc888_coef_init(ptr noundef %22)\nbr label %24\n\n24:\nbr label %25\n\n25:\nret void\n}": {"base_truth": "define internal void @alc_auto_init_amp(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @alc_auto_setup_eapd(ptr noundef %0, i32 noundef 1)\n%3 = tail call i32 @alc_write_gpio(ptr noundef %0)\n%4 = icmp eq i32 %1, 128\nbr i1 %4, label %B1, label %B5\n\nB1:\n%5 = load i32, ptr %0, align 4\nswitch i32 %5, label %B5 [\ni32 283902560, label %B2\ni32 283904128, label %B3\ni32 283904130, label %B3\ni32 283904131, label %B3\ni32 283904133, label %B3\ni32 283904136, label %B4\n]\n\nB2:\n%6 = tail call i32 @alc_update_coefex_idx(ptr noundef nonnull %0, i32 noundef 26, i32 noundef 7, i32 noundef 0, i32 noundef 8208)\nbr label %B5\n\nB3:\n%7 = tail call i32 @alc_update_coef_idx(ptr noundef nonnull %0, i32 noundef 7, i32 noundef 0, i32 noundef 8240)\nbr label %B5\n\nB4:\n%8 = tail call i32 @alc888_coef_init(ptr noundef nonnull %0)\nbr label %B5\n\nB5:\nret void\n}", "codellama": "define internal void @alc_auto_init_amp(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @alc_auto_setup_eapd(ptr noundef %0, i32 noundef 1)\n%3 = tail call i32 @alc_write_gpio(ptr noundef %0)\n%4 = icmp eq i32 %1, 128\nbr i1 %4, label %B1, label %B5\n\nB1:\n%5 = load i32, ptr %0, align 4\nswitch i32 %5, label %B5 [\ni32 283902560, label %B2\ni32 283904128, label %B3\ni32 283904130, label %B3\ni32 283904131, label %B3\ni32 283904133, label %B3\ni32 283904136, label %B4\n]\n\nB2:\n%6 = tail call i32 @alc_update_coefex_idx(ptr noundef nonnull %0, i32 noundef 26, i32 noundef 7, i32 noundef 0, i32 noundef 8208)\nbr label %B5\n\nB3:\n%7 = tail call i32 @alc_update_coef_idx(ptr noundef nonnull %0, i32 noundef 7, i32 noundef 0, i32 noundef 8240)\nbr label %B5\n\nB4:\n%8 = tail call i32 @alc888_coef_init(ptr noundef nonnull %0)\nbr label %B5\n\nB5:\nret void\n}", "codegemma": "define internal void @alc_auto_init_amp(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @alc_auto_setup_eapd(ptr noundef %0, i32 noundef 1)\n%3 = tail call i32 @alc_write_gpio(ptr noundef %0)\n%4 = icmp eq i32 %1, 128\nbr i1 %4, label %B1, label %B4\n\nB1:\n%5 = load i32, ptr %0, align 4\nswitch i32 %5, label %B4 [\ni32 283902560, label %B2\ni32 283904128, label %B3\ni32 283904130, label %B3\ni32 283904131, label %B3\ni32 283904133, label %B3\ni32 283904136, label %B3\n]\n\nB2:\n%6 = tail call i32 @alc_update_coefex_idx(ptr noundef nonnull %0, i32 noundef 26, i32 noundef 7, i32 noundef 0, i32 noundef 8208)\nbr label %B4\n\nB3:\n%7 = tail call i32 @alc_update_coef_idx(ptr noundef nonnull %0, i32 noundef 7, i32 noundef 0, i32 noundef 8240)\nbr label %B4\n\nB4:\n%8 = tail call i32 @alc888_coef_init(ptr noundef %0)\nret void\n}"}, "define internal void @epat_write_regr(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\n%10 = load i32, ptr %7, align 4\n%11 = load ptr, ptr @cont_map, align 8\n%12 = load i32, ptr %6, align 4\n%13 = sext i32 %12 to i64\n%14 = getelementptr inbounds i32, ptr %11, i64 %13\n%15 = load i32, ptr %14, align 4\n%16 = add nsw i32 %10, %15\nstore i32 %16, ptr %9, align 4\n%17 = load ptr, ptr %5, align 8\n%18 = getelementptr inbounds %struct.TYPE_3__, ptr %17, i32 0, i32 0\n%19 = load i32, ptr %18, align 4\nswitch i32 %19, label %34 [\ni32 0, label %20\ni32 1, label %20\ni32 2, label %20\ni32 3, label %28\ni32 4, label %28\ni32 5, label %28\n]\n\n20:\n%21 = load i32, ptr %9, align 4\n%22 = add nsw i32 96, %21\n%23 = call i32 @w0(i32 noundef %22)\n%24 = call i32 @w2(i32 noundef 1)\n%25 = load i32, ptr %8, align 4\n%26 = call i32 @w0(i32 noundef %25)\n%27 = call i32 @w2(i32 noundef 4)\nbr label %34\n\n28:\n%29 = load i32, ptr %9, align 4\n%30 = add nsw i32 64, %29\n%31 = call i32 @w3(i32 noundef %30)\n%32 = load i32, ptr %8, align 4\n%33 = call i32 @w4(i32 noundef %32)\nbr label %34\n\n34:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\nret void\n}": {"base_truth": "define internal void @epat_write_regr(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load ptr, ptr @cont_map, align 8\n%5 = sext i32 %1 to i64\n%6 = getelementptr inbounds i32, ptr %4, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = add nsw i32 %7, %2\n%9 = load i32, ptr %0, align 4\nswitch i32 %9, label %B3 [\ni32 0, label %B1\ni32 1, label %B1\ni32 2, label %B1\ni32 3, label %B2\ni32 4, label %B2\ni32 5, label %B2\n]\n\nB1:\n%10 = add nsw i32 %8, 96\n%11 = tail call i32 @w0(i32 noundef %10)\n%12 = tail call i32 @w2(i32 noundef 1)\n%13 = tail call i32 @w0(i32 noundef %3)\n%14 = tail call i32 @w2(i32 noundef 4)\nbr label %B3\n\nB2:\n%15 = add nsw i32 %8, 64\n%16 = tail call i32 @w3(i32 noundef %15)\n%17 = tail call i32 @w4(i32 noundef %3)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @epat_write_regr(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load ptr, ptr @cont_map, align 8\n%5 = sext i32 %1 to i64\n%6 = getelementptr inbounds i32, ptr %4, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = add nsw i32 %7, %2\n%9 = load i32, ptr %0, align 4\nswitch i32 %9, label %B3 [\ni32 0, label %B1\ni32 1, label %B1\ni32 2, label %B1\ni32 3, label %B2\ni32 4, label %B2\ni32 5, label %B2\n]\n\nB1:\n%10 = add nsw i32 %8, 96\n%11 = tail call i32 @w0(i32 noundef %10)\n%12 = tail call i32 @w2(i32 noundef 1)\n%13 = tail call i32 @w0(i32 noundef %3)\n%14 = tail call i32 @w2(i32 noundef 4)\nbr label %B3\n\nB2:\n%15 = add nsw i32 %8, 64\n%16 = tail call i32 @w3(i32 noundef %15)\n%17 = tail call i32 @w4(i32 noundef %3)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define internal void @epat_write_regr(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load ptr, ptr @cont_map, align 8\n%5 = sext i32 %1 to i64\n%6 = getelementptr inbounds i32, ptr %4, i64 %5\n%7 = load i32, ptr %6, align 4\n%8 = add nsw i32 %7, %2\n%9 = load i32, ptr %0, align 4\nswitch i32 %9, label %B3 [\ni32 0, label %B1\ni32 1, label %B1\ni32 2, label %B1\ni32 3, label %B2\ni32 4, label %B2\ni32 5, label %B2\n]\n\nB1:\n%10 = add nsw i32 %8, 96\n%11 = tail call i32 @w0(i32 noundef %10)\n%12 = tail call i32 @w2(i32 noundef 1)\n%13 = tail call i32 @w0(i32 noundef %3)\n%14 = tail call i32 @w2(i32 noundef 4)\nbr label %B3\n\nB2:\n%15 = add nsw i32 %8, 64\n%16 = tail call i32 @w3(i32 noundef %15)\n%17 = tail call i32 @w4(i32 noundef %3)\nbr label %B3\n\nB3:\nret void\n}"}, "define dso_local void @mergesort(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%10 = load i32, ptr %4, align 4\n%11 = icmp sle i32 %10, 1\nbr i1 %11, label %12, label %13\n\n12:\nstore i32 1, ptr %9, align 4\nbr label %33\n\n13:\n%14 = load i32, ptr %4, align 4\n%15 = sdiv i32 %14, 2\nstore i32 %15, ptr %5, align 4\n%16 = load i32, ptr %4, align 4\n%17 = load i32, ptr %5, align 4\n%18 = sub nsw i32 %16, %17\nstore i32 %18, ptr %8, align 4\n%19 = load ptr, ptr %3, align 8\nstore ptr %19, ptr %6, align 8\n%20 = load ptr, ptr %3, align 8\n%21 = load i32, ptr %8, align 4\n%22 = sext i32 %21 to i64\n%23 = getelementptr inbounds i32, ptr %20, i64 %22\nstore ptr %23, ptr %7, align 8\n%24 = load ptr, ptr %6, align 8\n%25 = load i32, ptr %8, align 4\ncall void @mergesort(ptr noundef %24, i32 noundef %25)\n%26 = load ptr, ptr %7, align 8\n%27 = load i32, ptr %5, align 4\ncall void @mergesort(ptr noundef %26, i32 noundef %27)\n%28 = load ptr, ptr %6, align 8\n%29 = load i32, ptr %8, align 4\n%30 = load ptr, ptr %7, align 8\n%31 = load i32, ptr %5, align 4\n%32 = call i32 @merge(ptr noundef %28, i32 noundef %29, ptr noundef %30, i32 noundef %31)\nstore i32 0, ptr %9, align 4\nbr label %33\n\n33:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\n%34 = load i32, ptr %9, align 4\nswitch i32 %34, label %36 [\ni32 0, label %35\ni32 1, label %35\n]\n\n35:\nret void\n\n36:\nunreachable\n}": {"base_truth": "define dso_local void @mergesort(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %1, 2\nbr i1 %2, label %B1, label %B2\n\nB1:\nret void\n\nB2:\n%3 = lshr i32 %1, 1\n%4 = sub nsw i32 %1, %3\n%5 = sext i32 %4 to i64\n%6 = getelementptr inbounds i32, ptr %0, i64 %5\ntail call void @mergesort(ptr noundef %0, i32 noundef %4)\ntail call void @mergesort(ptr noundef %6, i32 noundef %3)\n%7 = tail call i32 @merge(ptr noundef %0, i32 noundef %4, ptr noundef %6, i32 noundef %3)\nbr label %B1\n}", "codellama": "define dso_local void @mergesort(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %1, 2\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = phi ptr [ %11, %B1 ], [ %0, %B ]\n%4 = phi i32 [ %10, %B1 ], [ %1, %B ]\n%5 = phi ptr [ %12, %B1 ], [ %0, %B ]\n%6 = lshr i32 %4, 1\n%7 = sub nsw i32 %4, %6\n%8 = sext i32 %7 to i64\n%9 = getelementptr inbounds i32, ptr %5, i64 %8\ntail call void @mergesort(ptr noundef %3, i32 noundef %7)\ntail call void @mergesort(ptr noundef %9, i32 noundef %6)\n%10 = add i32 %4, -1\n%11 = getelementptr inbounds i32, ptr %3, i64 %10\n%12 = getelementptr inbounds i32, ptr %5, i64 %10\n%13 = icmp ult i32 %10, 2\nbr i1 %13, label %B2, label %B1\n\nB2:\nret void\n}", "codegemma": "define dso_local void @mergesort(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %1, 2\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = sdiv i32 %1, 2\n%4 = sub nsw i32 %1, %3\n%5 = sext i32 %4 to i64\n%6 = getelementptr inbounds i32, ptr %0, i64 %5\ntail call void @mergesort(ptr noundef %0, i32 noundef %3)\ntail call void @mergesort(ptr noundef %6, i32 noundef %3)\n%7 = tail call i32 @merge(ptr noundef %0, i32 noundef %4, ptr noundef %6, i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @help() {\n%1 = load ptr, ptr @version, align 8\n%2 = call i32 @printf(ptr noundef @.str, ptr noundef %1)\n%3 = call i32 @error(ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @help() {\nB:\n%0 = load ptr, ptr @version, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\n%2 = tail call i32 @error(ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @help() {\nB:\n%0 = load ptr, ptr @version, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\n%2 = tail call i32 @error(ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @help() {\nB:\n%0 = load ptr, ptr @version, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\n%2 = tail call i32 @error(ptr noundef nonnull @.str.1)\nret void\n}"}, "define internal i64 @owl_comp_fact_round_rate(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%8 = load ptr, ptr %4, align 8\n%9 = call ptr @hw_to_owl_comp(ptr noundef %8)\nstore ptr %9, ptr %7, align 8\n%10 = load ptr, ptr %7, align 8\n%11 = getelementptr inbounds %struct.owl_composite ptr %10, i32 0, i32 1\n%12 = load ptr, ptr %7, align 8\n%13 = getelementptr inbounds %struct.owl_composite ptr %12, i32 0, i32 0\n%14 = getelementptr inbounds %struct.TYPE_2__, ptr %13, i32 0, i32 0\n%15 = load i64, ptr %5, align 8\n%16 = load ptr, ptr %6, align 8\n%17 = call i64 @owl_factor_helper_round_rate(ptr noundef %11, ptr noundef %14, i64 noundef %15, ptr noundef %16)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret i64 %17\n}": {"base_truth": "define internal i64 @owl_comp_fact_round_rate(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @hw_to_owl_comp(ptr noundef %0)\n%4 = getelementptr inbounds %struct.owl_composite, ptr %3, i64 0, i32 1\n%5 = tail call i64 @owl_factor_helper_round_rate(ptr noundef nonnull %4, ptr noundef %3, i64 noundef %1, ptr noundef %2)\nret i64 %5\n}", "codellama": "define internal i64 @owl_comp_fact_round_rate(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @hw_to_owl_comp(ptr noundef %0)\n%4 = getelementptr inbounds %struct.owl_composite, ptr %3, i64 0, i32 1\n%5 = tail call i64 @owl_factor_helper_round_rate(ptr noundef nonnull %4, ptr noundef %3, i64 noundef %1, ptr noundef %2)\nret i64 %5\n}", "codegemma": "define internal i64 @owl_comp_fact_round_rate(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call ptr @hw_to_owl_comp(ptr noundef %0)\n%4 = getelementptr inbounds %struct.owl_composite, ptr %3, i64 0, i32 1\n%5 = tail call i64 @owl_factor_helper_round_rate(ptr noundef nonnull %4, ptr noundef %3, i64 noundef %1, ptr noundef %2)\nret i64 %5\n}"}, "define internal i64 @fman_muram_vbase_to_offset(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %4, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.muram_info ptr %6, i32 0, i32 0\n%8 = load i64, ptr %7, align 8\n%9 = sub i64 %5, %8\nret i64 %9\n}": {"base_truth": "define internal i64 @fman_muram_vbase_to_offset(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = sub i64 %1, %2\nret i64 %3\n}", "codellama": "define internal i64 @fman_muram_vbase_to_offset(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = sub i64 %1, %2\nret i64 %3\n}", "codegemma": "define internal i64 @fman_muram_vbase_to_offset(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = sub i64 %1, %2\nret i64 %3\n}"}, "define internal void @ess_extended(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @sb_dsp_command(ptr noundef %3, i32 noundef 198)\nret void\n}": {"base_truth": "define internal void @ess_extended(ptr noundef %0) {\nB:\n%1 = tail call i32 @sb_dsp_command(ptr noundef %0, i32 noundef 198)\nret void\n}", "codellama": "define internal void @ess_extended(ptr noundef %0) {\nB:\n%1 = tail call i32 @sb_dsp_command(ptr noundef %0, i32 noundef 198)\nret void\n}", "codegemma": "define internal void @ess_extended(ptr noundef %0) {\nB:\n%1 = tail call i32 @sb_dsp_command(ptr noundef %0, i32 noundef 198)\nret void\n}"}, "define dso_local i32 @LedDriver_IsOff(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @LedDriver_IsOn(i32 noundef %3)\n%5 = icmp ne i32 %4, 0\n%6 = xor i1 %5, true\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define dso_local i32 @LedDriver_IsOff(i32 noundef %0) {\nB:\n%1 = tail call i32 @LedDriver_IsOn(i32 noundef %0)\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define dso_local i32 @LedDriver_IsOff(i32 noundef %0) {\nB:\n%1 = tail call i32 @LedDriver_IsOn(i32 noundef %0)\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define dso_local i32 @LedDriver_IsOff(i32 noundef %0) {\nB:\n%1 = tail call i32 @LedDriver_IsOn(i32 noundef %0)\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define internal ptr @reiserfs_alloc_inode(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load i32, ptr @reiserfs_inode_cachep, align 4\n%7 = load i32, ptr @GFP_KERNEL, align 4\n%8 = call ptr @kmem_cache_alloc(i32 noundef %6, i32 noundef %7)\nstore ptr %8, ptr %4, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = icmp ne ptr %9, null\nbr i1 %10, label %12, label %11\n\n11:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %21\n\n12:\n%13 = load ptr, ptr %4, align 8\n%14 = getelementptr inbounds %struct.reiserfs_inode_info ptr %13, i32 0, i32 3\n%15 = call i32 @atomic_set(ptr noundef %14, i32 noundef 0)\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.reiserfs_inode_info ptr %16, i32 0, i32 2\n%18 = call i32 @mutex_init(ptr noundef %17)\n%19 = load ptr, ptr %4, align 8\n%20 = getelementptr inbounds %struct.reiserfs_inode_info ptr %19, i32 0, i32 0\nstore ptr %20, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %21\n\n21:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%22 = load ptr, ptr %2, align 8\nret ptr %22\n}": {"base_truth": "define internal ptr @reiserfs_alloc_inode(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @reiserfs_inode_cachep, align 4\n%2 = load i32, ptr @GFP_KERNEL, align 4\n%3 = tail call ptr @kmem_cache_alloc(i32 noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.reiserfs_inode_info, ptr %3, i64 0, i32 2\n%6 = getelementptr inbounds %struct.reiserfs_inode_info, ptr %3, i64 0, i32 3\n%7 = tail call i32 @atomic_set(ptr noundef nonnull %6, i32 noundef 0)\n%8 = tail call i32 @mutex_init(ptr noundef nonnull %5)\nbr label %B2\n\nB2:\nret ptr %3\n}", "codellama": "define internal ptr @reiserfs_alloc_inode(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @reiserfs_inode_cachep, align 4\n%2 = load i32, ptr @GFP_KERNEL, align 4\n%3 = tail call ptr @kmem_cache_alloc(i32 noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.reiserfs_inode_info, ptr %3, i64 0, i32 3\n%6 = tail call i32 @atomic_set(ptr noundef nonnull %5, i32 noundef 0)\n%7 = getelementptr inbounds %struct.reiserfs_inode_info, ptr %3, i64 0, i32 2\n%8 = tail call i32 @mutex_init(ptr noundef nonnull %7)\nbr label %B2\n\nB2:\nret ptr %3\n}", "codegemma": "define internal ptr @reiserfs_alloc_inode(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @reiserfs_inode_cachep, align 4\n%2 = load i32, ptr @GFP_KERNEL, align 4\n%3 = tail call ptr @kmem_cache_alloc(i32 noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = getelementptr inbounds %struct.reiserfs_inode_info, ptr %3, i64 0, i32 2\n%6 = getelementptr inbounds %struct.reiserfs_inode_info, ptr %3, i64 0, i32 3\n%7 = tail call i32 @atomic_set(ptr noundef nonnull %6, i32 noundef 0)\n%8 = tail call i32 @mutex_init(ptr noundef nonnull %5)\nbr label %B2\n\nB2:\nret ptr %3\n}"}, "define dso_local void @test29_Led_off__E() {\n%1 = call i32 (...) @test29_AvrPin_clear__E()\nret void\n}": {"base_truth": "define dso_local void @test29_Led_off__E() {\nB:\n%0 = tail call i32 (...) @test29_AvrPin_clear__E()\nret void\n}", "codellama": "define dso_local void @test29_Led_off__E() {\nB:\n%0 = tail call i32 (...) @test29_AvrPin_clear__E()\nret void\n}", "codegemma": "define dso_local void @test29_Led_off__E() {\nB:\n%0 = tail call i32 (...) @test29_AvrPin_clear__E()\nret void\n}"}, "define dso_local ptr @req_get(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @msg_get(ptr noundef %4, i32 noundef 1)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = icmp eq ptr %6, null\nbr i1 %7, label %8, label %12\n\n8:\n%9 = load i32, ptr @errno, align 4\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds %struct.conn ptr %10, i32 0, i32 0\nstore i32 %9, ptr %11, align 4\nbr label %12\n\n12:\n%13 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @req_get(ptr noundef %0) {\nB:\n%1 = tail call ptr @msg_get(ptr noundef %0, i32 noundef 1)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @errno, align 4\nstore i32 %3, ptr %0, align 4\nbr label %B2\n\nB2:\nret ptr %1\n}", "codellama": "define dso_local ptr @req_get(ptr noundef %0) {\nB:\n%1 = tail call ptr @msg_get(ptr noundef %0, i32 noundef 1)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @errno, align 4\nstore i32 %3, ptr %0, align 4\nbr label %B2\n\nB2:\nret ptr %1\n}", "codegemma": "define dso_local ptr @req_get(ptr noundef %0) {\nB:\n%1 = tail call ptr @msg_get(ptr noundef %0, i32 noundef 1)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @errno, align 4\nstore i32 %3, ptr %0, align 4\nbr label %B2\n\nB2:\nret ptr %1\n}"}, "define dso_local void @DpsTrcStart(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca [240 x i32], align 16\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 960, ptr %5)\n%6 = load i64, ptr @DpsTrcIndex, align 8\n%7 = icmp ne i64 %6, 0\nbr i1 %7, label %8, label %20\n\n8:\n%9 = getelementptr inbounds [240 x i32], ptr %5, i64 0, i64 0\n%10 = call i32 @strcpy(ptr noundef %9, ptr noundef @.str)\n%11 = getelementptr inbounds [240 x i32], ptr %5, i64 0, i64 0\n%12 = load i32, ptr %3, align 4\n%13 = call i32 @DpsTrcGetVal(ptr noundef %11, ptr noundef @.str.1, i32 noundef %12)\n%14 = getelementptr inbounds [240 x i32], ptr %5, i64 0, i64 0\n%15 = load ptr, ptr %4, align 8\n%16 = call i32 @DpsTrcGetErrVal(ptr noundef %14, ptr noundef %15)\n%17 = load i64, ptr @DpsTrcIndex, align 8\n%18 = getelementptr inbounds [240 x i32], ptr %5, i64 0, i64 0\n%19 = call i32 @X_Trc_write_txt(i64 noundef %17, i32 noundef 1, i32 noundef 1073741824, ptr noundef %18)\nbr label %20\n\n20:\ncall void @llvm.lifetime.end.p0(i64 960, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @DpsTrcStart(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = alloca [240 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 960, ptr nonnull %2)\n%3 = load i64, ptr @DpsTrcIndex, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = call i32 @strcpy(ptr noundef nonnull %2, ptr noundef nonnull @.str)\n%6 = call i32 @DpsTrcGetVal(ptr noundef nonnull %2, ptr noundef nonnull @.str.1, i32 noundef %0)\n%7 = call i32 @DpsTrcGetErrVal(ptr noundef nonnull %2, ptr noundef %1)\n%8 = load i64, ptr @DpsTrcIndex, align 8\n%9 = call i32 @X_Trc_write_txt(i64 noundef %8, i32 noundef 1, i32 noundef 1073741824, ptr noundef nonnull %2)\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 960, ptr nonnull %2)\nret void\n}", "codellama": "define dso_local void @DpsTrcStart(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = alloca [240 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 960, ptr nonnull %2)\n%3 = load i64, ptr @DpsTrcIndex, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = call i32 @strcpy(ptr noundef nonnull %2, ptr noundef nonnull @.str)\n%6 = call i32 @DpsTrcGetVal(ptr noundef nonnull %2, ptr noundef nonnull @.str.1, i32 noundef %0)\n%7 = call i32 @DpsTrcGetErrVal(ptr noundef nonnull %2, ptr noundef %1)\n%8 = load i64, ptr @DpsTrcIndex, align 8\n%9 = call i32 @X_Trc_write_txt(i64 noundef %8, i32 noundef 1, i32 noundef 1073741824, ptr noundef nonnull %2)\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 960, ptr nonnull %2)\nret void\n}", "codegemma": "define dso_local void @DpsTrcStart(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = alloca [240 x i32], align 16\ncall void @llvm.lifetime.start.p0(i64 960, ptr nonnull %2)\n%3 = load i64, ptr @DpsTrcIndex, align 8\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = call i32 @strcpy(ptr noundef nonnull %2, ptr noundef nonnull @.str)\n%6 = call i32 @DpsTrcGetVal(ptr noundef nonnull %2, ptr noundef nonnull @.str.1, i32 noundef %0)\n%7 = call i32 @DpsTrcGetErrVal(ptr noundef nonnull %2, ptr noundef %1)\n%8 = load i64, ptr @DpsTrcIndex, align 8\n%9 = call i32 @X_Trc_write_txt(i64 noundef %8, i32 noundef 1, i32 noundef 1073741824, ptr noundef nonnull %2)\nbr label %B2\n\nB2:\ncall void @llvm.lifetime.end.p0(i64 960, ptr nonnull %2)\nret void\n}"}, "define dso_local void @eraseCenteredPowerstacker() {\n%1 = call i32 @erasePowerstacker(i32 noundef 20, i32 noundef 4)\nret void\n}": {"base_truth": "define dso_local void @eraseCenteredPowerstacker() {\nB:\n%0 = tail call i32 @erasePowerstacker(i32 noundef 20, i32 noundef 4)\nret void\n}", "codellama": "define dso_local void @eraseCenteredPowerstacker() {\nB:\n%0 = tail call i32 @erasePowerstacker(i32 noundef 20, i32 noundef 4)\nret void\n}", "codegemma": "define dso_local void @eraseCenteredPowerstacker() {\nB:\n%0 = tail call i32 @erasePowerstacker(i32 noundef 20, i32 noundef 4)\nret void\n}"}, "define dso_local i32 @vneg4(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @vsub4(i32 noundef 0, i32 noundef %3)\nret i32 %4\n}": {"base_truth": "define dso_local i32 @vneg4(i32 noundef %0) {\nB:\n%1 = tail call i32 @vsub4(i32 noundef 0, i32 noundef %0)\nret i32 %1\n}", "codellama": "define dso_local i32 @vneg4(i32 noundef %0) {\nB:\n%1 = tail call i32 @vsub4(i32 noundef 0, i32 noundef %0)\nret i32 %1\n}", "codegemma": "define dso_local i32 @vneg4(i32 noundef %0) {\nB:\n%1 = tail call i32 @vsub4(i32 noundef 0, i32 noundef %0)\nret i32 %1\n}"}, "define dso_local void @CALC_add9() {\n%1 = call i32 @CALC_appendString(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @CALC_add9() {\nB:\n%0 = tail call i32 @CALC_appendString(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @CALC_add9() {\nB:\n%0 = tail call i32 @CALC_appendString(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @CALC_add9() {\nB:\n%0 = tail call i32 @CALC_appendString(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local void @devm_phy_put(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%7 = load ptr, ptr %4, align 8\n%8 = icmp ne ptr %7, null\nbr i1 %8, label %10, label %9\n\n9:\nstore i32 1, ptr %6, align 4\nbr label %19\n\n10:\n%11 = load ptr, ptr %3, align 8\n%12 = load i32, ptr @devm_phy_release, align 4\n%13 = load i32, ptr @devm_phy_match, align 4\n%14 = load ptr, ptr %4, align 8\n%15 = call i32 @devres_destroy(ptr noundef %11, i32 noundef %12, i32 noundef %13, ptr noundef %14)\nstore i32 %15, ptr %5, align 4\n%16 = load ptr, ptr %3, align 8\n%17 = load i32, ptr %5, align 4\n%18 = call i32 @dev_WARN_ONCE(ptr noundef %16, i32 noundef %17, ptr noundef @.str)\nstore i32 0, ptr %6, align 4\nbr label %19\n\n19:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\n%20 = load i32, ptr %6, align 4\nswitch i32 %20, label %22 [\ni32 0, label %21\ni32 1, label %21\n]\n\n21:\nret void\n\n22:\nunreachable\n}": {"base_truth": "define dso_local void @devm_phy_put(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @devm_phy_release, align 4\n%4 = load i32, ptr @devm_phy_match, align 4\n%5 = tail call i32 @devres_destroy(ptr noundef %0, i32 noundef %3, i32 noundef %4, ptr noundef nonnull %1)\n%6 = tail call i32 @dev_WARN_ONCE(ptr noundef %0, i32 noundef %5, ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @devm_phy_put(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @devm_phy_release, align 4\n%4 = load i32, ptr @devm_phy_match, align 4\n%5 = tail call i32 @devres_destroy(ptr noundef %0, i32 noundef %3, i32 noundef %4, ptr noundef nonnull %1)\n%6 = tail call i32 @dev_WARN_ONCE(ptr noundef %0, i32 noundef %5, ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @devm_phy_put(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @devm_phy_release, align 4\n%4 = load i32, ptr @devm_phy_match, align 4\n%5 = tail call i32 @devres_destroy(ptr noundef %0, i32 noundef %3, i32 noundef %4, ptr noundef nonnull %1)\n%6 = tail call i32 @dev_WARN_ONCE(ptr noundef %0, i32 noundef %5, ptr noundef nonnull @.str)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @rottDB_moveall(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i32 %2, ptr %7, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%10 = load ptr, ptr %5, align 8\n%11 = load ptr, ptr %6, align 8\n%12 = load i32, ptr %7, align 4\n%13 = call i32 @rottDB_copyall(ptr noundef %10, ptr noundef %11, i32 noundef %12)\nstore i32 %13, ptr %8, align 4\n%14 = load i32, ptr %8, align 4\n%15 = icmp slt i32 %14, 0\nbr i1 %15, label %16, label %18\n\n16:\n%17 = load i32, ptr %8, align 4\nstore i32 %17, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %21\n\n18:\n%19 = load ptr, ptr %5, align 8\n%20 = call i32 @rottDB_delall(ptr noundef %19)\nstore i32 0, ptr %4, align 4\nstore i32 1, ptr %9, align 4\nbr label %21\n\n21:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\n%22 = load i32, ptr %4, align 4\nret i32 %22\n}": {"base_truth": "define dso_local i32 @rottDB_moveall(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @rottDB_copyall(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp slt i32 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @rottDB_delall(ptr noundef %0)\nbr label %B2\n\nB2:\n%6 = phi i32 [ 0, %B1 ], [ %3, %B ]\nret i32 %6\n}", "codellama": "define dso_local i32 @rottDB_moveall(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @rottDB_copyall(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp slt i32 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @rottDB_delall(ptr noundef %0)\nbr label %B2\n\nB2:\n%6 = phi i32 [ 0, %B1 ], [ %3, %B ]\nret i32 %6\n}", "codegemma": "define dso_local i32 @rottDB_moveall(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @rottDB_copyall(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp slt i32 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @rottDB_delall(ptr noundef %0)\nbr label %B2\n\nB2:\n%6 = phi i32 [ 0, %B1 ], [ %3, %B ]\nret i32 %6\n}"}, "define dso_local void @Z80_ADDAE(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\n%7 = call i32 @Z80_AddHelp(ptr noundef %3, i32 noundef %6)\nret void\n}": {"base_truth": "define dso_local void @Z80_ADDAE(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_AddHelp(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @Z80_ADDAE(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_AddHelp(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @Z80_ADDAE(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_AddHelp(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca [5 x i32], align 16\n%3 = alloca [101 x i8], align 16\n%4 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 20, ptr %2)\n%5 = getelementptr inbounds [5 x i32], ptr %2, i64 0, i64 0\n%6 = load i32, ptr @INT_MIN, align 4\nstore i32 %6, ptr %5, align 4\n%7 = getelementptr inbounds i32, ptr %5, i64 1\n%8 = load i32, ptr @INT_MAX, align 4\nstore i32 %8, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %7, i64 1\nstore i32 -300, ptr %9, align 4\n%10 = getelementptr inbounds i32, ptr %9, i64 1\nstore i32 172, ptr %10, align 4\n%11 = getelementptr inbounds i32, ptr %10, i64 1\nstore i32 38478235, ptr %11, align 4\ncall void @llvm.lifetime.start.p0(i64 101, ptr %3)\ncall void @llvm.memset.p0.i64(ptr align 16 %3, i8 0, i64 101, i1 false)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\nbr label %12\n\n12:\n%13 = load i32, ptr %4, align 4\n%14 = icmp slt i32 %13, 5\nbr i1 %14, label %15, label %31\n\n15:\n%16 = load i32, ptr %4, align 4\n%17 = sext i32 %16 to i64\n%18 = getelementptr inbounds [5 x i32], ptr %2, i64 0, i64 %17\n%19 = load i32, ptr %18, align 4\n%20 = getelementptr inbounds [101 x i8], ptr %3, i64 0, i64 0\n%21 = call i32 @itob(i32 noundef %19, ptr noundef %20, i32 noundef 16)\n%22 = load i32, ptr %4, align 4\n%23 = sext i32 %22 to i64\n%24 = getelementptr inbounds [5 x i32], ptr %2, i64 0, i64 %23\n%25 = load i32, ptr %24, align 4\n%26 = getelementptr inbounds [101 x i8], ptr %3, i64 0, i64 0\n%27 = call i32 @printf(ptr noundef @.str, i32 noundef %25, ptr noundef %26)\nbr label %28\n\n28:\n%29 = load i32, ptr %4, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %4, align 4\nbr label %12\n\n31:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 101, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 20, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca [101 x i8], align 16\n%1 = load i32, ptr @INT_MIN, align 4\n%2 = load i32, ptr @INT_MAX, align 4\ncall void @llvm.lifetime.start.p0(i64 101, ptr nonnull %0)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(101) %0, i8 0, i64 101, i1 false)\n%3 = call i32 @itob(i32 noundef %1, ptr noundef nonnull %0, i32 noundef 16)\n%4 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull %0)\n%5 = call i32 @itob(i32 noundef %2, ptr noundef nonnull %0, i32 noundef 16)\n%6 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %2, ptr noundef nonnull %0)\n%7 = call i32 @itob(i32 noundef -300, ptr noundef nonnull %0, i32 noundef 16)\n%8 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef -300, ptr noundef nonnull %0)\n%9 = call i32 @itob(i32 noundef 172, ptr noundef nonnull %0, i32 noundef 16)\n%10 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef 172, ptr noundef nonnull %0)\n%11 = call i32 @itob(i32 noundef 38478235, ptr noundef nonnull %0, i32 noundef 16)\n%12 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef 38478235, ptr noundef nonnull %0)\ncall void @llvm.lifetime.end.p0(i64 101, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca [5 x i32], align 16\n%1 = alloca [101 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 20, ptr nonnull %0)\n%2 = load i32, ptr @INT_MIN, align 4\nstore i32 %2, ptr %0, align 16\n%3 = getelementptr inbounds i32, ptr %0, i64 1\n%4 = load i32, ptr @INT_MAX, align 4\nstore i32 %4, ptr %3, align 4\n%5 = getelementptr inbounds i32, ptr %0, i64 2\nstore i32 -300, ptr %5, align 8\n%6 = getelementptr inbounds i32, ptr %0, i64 3\nstore i32 172, ptr %6, align 4\n%7 = getelementptr inbounds i32, ptr %0, i64 4\nstore i32 38478235, ptr %7, align 16\ncall void @llvm.lifetime.start.p0(i64 101, ptr nonnull %1)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(101) %1, i8 0, i64 101, i1 false)\n%8 = load i32, ptr %0, align 16\n%9 = call i32 @itob(i32 noundef %8, ptr noundef nonnull %1, i32 noundef 16)\n%10 = load i32, ptr %0, align 16\n%11 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %10, ptr noundef nonnull %1)\n%12 = load i32, ptr %3, align 4\n%13 = call i32 @itob(i32 noundef %12, ptr noundef nonnull %1, i32 noundef 16)\n%14 = load i32, ptr %3, align 4\n%15 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %14, ptr noundef nonnull %1)\n%16 = load i32, ptr %5, align 8\n%17 = call i32 @itob(i32 noundef %16, ptr noundef nonnull %1, i32 noundef 16)\n%18 = load i32, ptr %5, align 8\n%19 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %18, ptr noundef nonnull %1)\n%20 = load i32, ptr %7, align 16\n%21 = call i32 @itob(i32 noundef %20, ptr noundef nonnull %1, i32 noundef 16)\n%22 = load i32, ptr %7, align 16\n%23 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %22, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 101, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 20, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca [5 x i32], align 16\n%1 = alloca [101 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 20, ptr nonnull %0)\n%2 = load i32, ptr @INT_MIN, align 4\nstore i32 %2, ptr %0, align 16\n%3 = getelementptr inbounds i32, ptr %0, i64 1\n%4 = load i32, ptr @INT_MAX, align 4\nstore i32 %4, ptr %3, align 4\n%5 = getelementptr inbounds i32, ptr %0, i64 2\nstore i32 -300, ptr %5, align 8\n%6 = getelementptr inbounds i32, ptr %0, i64 3\nstore i32 172, ptr %6, align 4\n%7 = getelementptr inbounds i32, ptr %0, i64 4\nstore i32 38478235, ptr %7, align 16\ncall void @llvm.lifetime.start.p0(i64 101, ptr nonnull %1)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(101) %1, i8 0, i64 101, i1 false)\n%8 = load i32, ptr %0, align 16\n%9 = call i32 @itob(i32 noundef %8, ptr noundef nonnull %1, i32 noundef 16)\n%10 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %8, ptr noundef nonnull %1)\n%11 = load i32, ptr %3, align 4\n%12 = call i32 @itob(i32 noundef %11, ptr noundef nonnull %1, i32 noundef 16)\n%13 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %11, ptr noundef nonnull %1)\n%14 = load i32, ptr %5, align 8\n%15 = call i32 @itob(i32 noundef %14, ptr noundef nonnull %1, i32 noundef 16)\n%16 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %14, ptr noundef nonnull %1)\n%17 = load i32, ptr %7, align 4\n%18 = call i32 @itob(i32 noundef %17, ptr noundef nonnull %1, i32 noundef 16)\n%19 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %17, ptr noundef nonnull %1)\n%20 = load i32, ptr %6, align 4\n%21 = call i32 @itob(i32 noundef %20, ptr noundef nonnull %1, i32 noundef 16)\n%22 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %20, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 101, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 20, ptr nonnull %0)\nret i32 0\n}"}, "define dso_local ptr @new_trie() {\n%1 = call ptr @new_node(i32 noundef 0, ptr noundef null)\nret ptr %1\n}": {"base_truth": "define dso_local ptr @new_trie() {\nB:\n%0 = tail call ptr @new_node(i32 noundef 0, ptr noundef null)\nret ptr %0\n}", "codellama": "define dso_local ptr @new_trie() {\nB:\n%0 = tail call ptr @new_node(i32 noundef 0, ptr noundef null)\nret ptr %0\n}", "codegemma": "define dso_local ptr @new_trie() {\nB:\n%0 = tail call ptr @new_node(i32 noundef 0, ptr noundef null)\nret ptr %0\n}"}, "define dso_local i32 @lag_fsm_admin_on_ev(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca %struct.lag_fsm_admin_on_ev_t align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr %3)\n%4 = load i32, ptr @admin_on_ev, align 4\n%5 = getelementptr inbounds %struct.lag_fsm_admin_on_ev_t ptr %3, i32 0, i32 1\nstore i32 %4, ptr %5, align 8\n%6 = getelementptr inbounds %struct.lag_fsm_admin_on_ev_t ptr %3, i32 0, i32 0\nstore ptr @.str, ptr %6, align 8\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.lag_fsm ptr %7, i32 0, i32 0\n%9 = call i32 @fsm_handle_event(ptr noundef %8, ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 16, ptr %3)\nret i32 %9\n}": {"base_truth": "define dso_local i32 @lag_fsm_admin_on_ev(ptr noundef %0) {\nB:\n%1 = alloca %struct.lag_fsm_admin_on_ev_t, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %1)\n%2 = load i32, ptr @admin_on_ev, align 4\n%3 = getelementptr inbounds %struct.lag_fsm_admin_on_ev_t, ptr %1, i64 0, i32 1\nstore i32 %2, ptr %3, align 8\nstore ptr @.str, ptr %1, align 8\n%4 = call i32 @fsm_handle_event(ptr noundef %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %1)\nret i32 %4\n}", "codellama": "define dso_local i32 @lag_fsm_admin_on_ev(ptr noundef %0) {\nB:\n%1 = alloca %struct.lag_fsm_admin_on_ev_t, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %1)\n%2 = load i32, ptr @admin_on_ev, align 4\n%3 = getelementptr inbounds %struct.lag_fsm_admin_on_ev_t, ptr %1, i64 0, i32 1\nstore i32 %2, ptr %3, align 8\nstore ptr @.str, ptr %1, align 8\n%4 = call i32 @fsm_handle_event(ptr noundef %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %1)\nret i32 %4\n}", "codegemma": "define dso_local i32 @lag_fsm_admin_on_ev(ptr noundef %0) {\nB:\n%1 = alloca %struct.lag_fsm_admin_on_ev_t, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %1)\n%2 = load i32, ptr @admin_on_ev, align 4\n%3 = getelementptr inbounds %struct.lag_fsm_admin_on_ev_t, ptr %1, i64 0, i32 1\nstore i32 %2, ptr %3, align 8\nstore ptr @.str, ptr %1, align 8\n%4 = call i32 @fsm_handle_event(ptr noundef %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %1)\nret i32 %4\n}"}, "define internal void @r3081_wait() {\n%1 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call i64 (...) @read_c0_conf()\nstore i64 %2, ptr %1, align 8\n%3 = load i64, ptr %1, align 8\n%4 = load i64, ptr @R30XX_CONF_HALT, align 8\n%5 = or i64 %3, %4\n%6 = call i32 @write_c0_conf(i64 noundef %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret void\n}": {"base_truth": "define internal void @r3081_wait() {\nB:\n%0 = tail call i64 (...) @read_c0_conf()\n%1 = load i64, ptr @R30XX_CONF_HALT, align 8\n%2 = or i64 %1, %0\n%3 = tail call i32 @write_c0_conf(i64 noundef %2)\nret void\n}", "codellama": "define internal void @r3081_wait() {\nB:\n%0 = tail call i64 (...) @read_c0_conf()\n%1 = load i64, ptr @R30XX_CONF_HALT, align 8\n%2 = or i64 %1, %0\n%3 = tail call i32 @write_c0_conf(i64 noundef %2)\nret void\n}", "codegemma": "define internal void @r3081_wait() {\nB:\n%0 = tail call i64 (...) @read_c0_conf()\n%1 = load i64, ptr @R30XX_CONF_HALT, align 8\n%2 = or i64 %1, %0\n%3 = tail call i32 @write_c0_conf(i64 noundef %2)\nret void\n}"}, "define internal signext i8 @tohex(i8 noundef signext %0) {\n%2 = alloca i8, align 1\nstore i8 %0, ptr %2, align 1\n%3 = load i8, ptr %2, align 1\n%4 = sext i8 %3 to i32\n%5 = icmp sgt i32 %4, 9\nbr i1 %5, label %6, label %11\n\n6:\n%7 = load i8, ptr %2, align 1\n%8 = sext i8 %7 to i32\n%9 = add nsw i32 %8, 97\n%10 = sub nsw i32 %9, 10\nbr label %15\n\n11:\n%12 = load i8, ptr %2, align 1\n%13 = sext i8 %12 to i32\n%14 = add nsw i32 %13, 48\nbr label %15\n\n15:\n%16 = phi i32 [ %10, %6 ], [ %14, %11 ]\n%17 = trunc i32 %16 to i8\nret i8 %17\n}": {"base_truth": "define internal signext i8 @tohex(i8 noundef signext %0) {\nB:\n%1 = icmp sgt i8 %0, 9\n%2 = select i1 %1, i8 87, i8 48\n%3 = add i8 %2, %0\nret i8 %3\n}", "codellama": "define internal signext i8 @tohex(i8 noundef signext %0) {\nB:\n%1 = icmp sgt i8 %0, 9\n%2 = select i1 %1, i8 87, i8 48\n%3 = add i8 %2, %0\nret i8 %3\n}", "codegemma": "define internal signext i8 @tohex(i8 noundef signext %0) {\nB:\n%1 = icmp sgt i8 %0, 9\n%2 = add i8 %0, -97\n%3 = add i8 %0, 48\n%4 = select i1 %1, i8 %2, i8 %3\nret i8 %4\n}"}, "define dso_local void @scamper_addr2mac_cleanup() {\n%1 = load i32, ptr @tree, align 4\n%2 = load i64, ptr @addr2mac_free, align 8\n%3 = trunc i64 %2 to i32\n%4 = call i32 @splaytree_free(i32 noundef %1, i32 noundef %3)\nret void\n}": {"base_truth": "define dso_local void @scamper_addr2mac_cleanup() {\nB:\n%0 = load i32, ptr @tree, align 4\n%1 = load i64, ptr @addr2mac_free, align 8\n%2 = trunc i64 %1 to i32\n%3 = tail call i32 @splaytree_free(i32 noundef %0, i32 noundef %2)\nret void\n}", "codellama": "define dso_local void @scamper_addr2mac_cleanup() {\nB:\n%0 = load i32, ptr @tree, align 4\n%1 = load i64, ptr @addr2mac_free, align 8\n%2 = trunc i64 %1 to i32\n%3 = tail call i32 @splaytree_free(i32 noundef %0, i32 noundef %2)\nret void\n}", "codegemma": "define dso_local void @scamper_addr2mac_cleanup() {\nB:\n%0 = load i32, ptr @tree, align 4\n%1 = load i64, ptr @addr2mac_free, align 8\n%2 = trunc i64 %1 to i32\n%3 = tail call i32 @splaytree_free(i32 noundef %0, i32 noundef %2)\nret void\n}"}, "define dso_local i32 @radix_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @memset(ptr noundef %3, i32 noundef 0, i32 noundef 4)\nret i32 0\n}": {"base_truth": "define dso_local i32 @radix_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret i32 0\n}", "codellama": "define dso_local i32 @radix_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret i32 0\n}", "codegemma": "define dso_local i32 @radix_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret i32 0\n}"}, "define dso_local void @phy_set_rf8256_cck_tx_power(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\nstore i32 0, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @ieee80211_priv(ptr noundef %7)\nstore ptr %8, ptr %6, align 8\n%9 = load i32, ptr %4, align 4\nstore i32 %9, ptr %5, align 4\n%10 = load ptr, ptr %6, align 8\n%11 = getelementptr inbounds %struct.r8192_priv, ptr %10, i32 0, i32 2\n%12 = load i64, ptr %11, align 8\n%13 = icmp ne i64 %12, 0\nbr i1 %13, label %14, label %30\n\n14:\n%15 = load ptr, ptr %6, align 8\n%16 = getelementptr inbounds %struct.r8192_priv, ptr %15, i32 0, i32 0\n%17 = load i64, ptr %16, align 8\n%18 = load i64, ptr @RT_CID_819x_Netcore, align 8\n%19 = icmp eq i64 %17, %18\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 34, ptr %5, align 4\nbr label %29\n\n21:\n%22 = load ptr, ptr %6, align 8\n%23 = getelementptr inbounds %struct.r8192_priv, ptr %22, i32 0, i32 1\n%24 = load i64, ptr %23, align 8\n%25 = load i32, ptr %5, align 4\n%26 = sext i32 %25 to i64\n%27 = add nsw i64 %26, %24\n%28 = trunc i64 %27 to i32\nstore i32 %28, ptr %5, align 4\nbr label %29\n\n29:\nbr label %30\n\n30:\n%31 = load i32, ptr %5, align 4\n%32 = icmp sgt i32 %31, 36\nbr i1 %32, label %33, label %34\n\n33:\nstore i32 36, ptr %5, align 4\nbr label %34\n\n34:\n%35 = load ptr, ptr %3, align 8\n%36 = load i32, ptr @rTxAGC_CCK_Mcs32, align 4\n%37 = load i32, ptr @bTxAGCRateCCK, align 4\n%38 = load i32, ptr %5, align 4\n%39 = call i32 @rtl8192_setBBreg(ptr noundef %35, i32 noundef %36, i32 noundef %37, i32 noundef %38)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @phy_set_rf8256_cck_tx_power(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @ieee80211_priv(ptr noundef %0)\n%3 = getelementptr inbounds %struct.r8192_priv, ptr %2, i64 0, i32 2\n%4 = load i64, ptr %3, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = load i64, ptr %2, align 8\n%7 = load i64, ptr @RT_CID_819x_Netcore, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = getelementptr inbounds %struct.r8192_priv, ptr %2, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = trunc i64 %10 to i32\n%12 = add i32 %11, %1\nbr label %B3\n\nB3:\n%13 = phi i32 [ %12, %B2 ], [ %1, %B ], [ 34, %B1 ]\n%14 = tail call i32 @llvm.smin.i32(i32 %13, i32 36)\n%15 = load i32, ptr @rTxAGC_CCK_Mcs32, align 4\n%16 = load i32, ptr @bTxAGCRateCCK, align 4\n%17 = tail call i32 @rtl8192_setBBreg(ptr noundef %0, i32 noundef %15, i32 noundef %16, i32 noundef %14)\nret void\n}", "codellama": "define dso_local void @phy_set_rf8256_cck_tx_power(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @ieee80211_priv(ptr noundef %0)\n%3 = getelementptr inbounds %struct.r8192_priv, ptr %2, i64 0, i32 2\n%4 = load i64, ptr %3, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = load i64, ptr %2, align 8\n%7 = load i64, ptr @RT_CID_819x_Netcore, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %B2, label %B3\n\nB2:\n%9 = getelementptr inbounds %struct.r8192_priv, ptr %2, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = trunc i64 %10 to i32\n%12 = add i32 %11, 34\nbr label %B3\n\nB3:\n%13 = phi i32 [ %12, %B2 ], [ %1, %B ], [ 34, %B1 ]\n%14 = tail call i32 @llvm.smin.i32(i32 %13, i32 36)\n%15 = load i32, ptr @rTxAGC_CCK_Mcs32, align 4\n%16 = load i32, ptr @bTxAGCRateCCK, align 4\n%17 = tail call i32 @rtl8192_setBBreg(ptr noundef %0, i32 noundef %15, i32 noundef %16, i32 noundef %14)\nret void\n}", "codegemma": "define dso_local void @phy_set_rf8256_cck_tx_power(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @ieee80211_priv(ptr noundef %0)\n%3 = getelementptr inbounds %struct.r8192_priv, ptr %2, i64 0, i32 2\n%4 = load i64, ptr %3, align 8\n%5 = icmp eq i64 %4, 0\nbr i1 %5, label %B3, label %B1\n\nB1:\n%6 = load i64, ptr %2, align 8\n%7 = load i64, ptr @RT_CID_819x_Netcore, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = getelementptr inbounds %struct.r8192_priv, ptr %2, i64 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = trunc i64 %10 to i32\n%12 = add i32 %11, %1\nbr label %B3\n\nB3:\n%13 = phi i32 [ %12, %B2 ], [ 34, %B1 ], [ 0, %B ]\n%14 = tail call i32 @llvm.smin.i32(i32 %13, i32 36)\n%15 = load i32, ptr @rTxAGC_CCK_Mcs32, align 4\n%16 = load i32, ptr @bTxAGCRateCCK, align 4\n%17 = tail call i32 @rtl8192_setBBreg(ptr noundef %0, i32 noundef %15, i32 noundef %16, i32 noundef %14)\nret void\n}"}, "define dso_local i32 @table_lp_size(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @table_lp_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @table_lp_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @table_lp_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local i32 @f2() {\n%1 = load i32, ptr @bar, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @f2() {\nB:\n%0 = load i32, ptr @bar, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @f2() {\nB:\n%0 = load i32, ptr @bar, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @f2() {\nB:\n%0 = load i32, ptr @bar, align 4\nret i32 %0\n}"}, "define internal void @ida_v3_submit(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr @R_CMD_FIFO, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = getelementptr inbounds %struct.ida_qcb ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i32 @ida_outl(ptr noundef %5, i32 noundef %6, i32 noundef %9)\nret void\n}": {"base_truth": "define internal void @ida_v3_submit(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr @R_CMD_FIFO, align 4\n%3 = load i32, ptr %1, align 4\n%4 = tail call i32 @ida_outl(ptr noundef %0, i32 noundef %2, i32 noundef %3)\nret void\n}", "codellama": "define internal void @ida_v3_submit(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr @R_CMD_FIFO, align 4\n%3 = load i32, ptr %1, align 4\n%4 = tail call i32 @ida_outl(ptr noundef %0, i32 noundef %2, i32 noundef %3)\nret void\n}", "codegemma": "define internal void @ida_v3_submit(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr @R_CMD_FIFO, align 4\n%3 = load i32, ptr %1, align 4\n%4 = tail call i32 @ida_outl(ptr noundef %0, i32 noundef %2, i32 noundef %3)\nret void\n}"}, "define dso_local void @print_shader_info_log(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca [2048 x i8], align 16\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 2048, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 2048, ptr %5)\n%6 = load i32, ptr %2, align 4\n%7 = load i32, ptr %3, align 4\n%8 = getelementptr inbounds [2048 x i8], ptr %5, i64 0, i64 0\n%9 = call i32 @glGetShaderInfoLog(i32 noundef %6, i32 noundef %7, ptr noundef %4, ptr noundef %8)\n%10 = load i32, ptr %2, align 4\n%11 = getelementptr inbounds [2048 x i8], ptr %5, i64 0, i64 0\n%12 = call i32 @printf(ptr noundef @.str, i32 noundef %10, ptr noundef %11)\ncall void @llvm.lifetime.end.p0(i64 2048, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @print_shader_info_log(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca [2048 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %2)\n%3 = call i32 @glGetShaderInfoLog(i32 noundef %0, i32 noundef 2048, ptr noundef nonnull %1, ptr noundef nonnull %2)\n%4 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @print_shader_info_log(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = alloca [2048 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %2)\n%3 = call i32 @glGetShaderInfoLog(i32 noundef %0, i32 noundef 2048, ptr noundef nonnull %1, ptr noundef nonnull %2)\n%4 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, ptr noundef nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @print_shader_info_log(i32 noundef %0) {\nB:\n%1 = alloca [2048 x i8], align 16\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)\nstore i32 0, ptr %2, align 4\n%3 = call i32 @glGetShaderInfoLog(i32 noundef %0, i32 noundef 2048, ptr noundef nonnull %2, ptr noundef nonnull %1)\n%4 = call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %1)\nret void\n}"}, "define dso_local i32 @msgget(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr @MSGGET, align 4\n%6 = load i32, ptr %3, align 4\n%7 = load i32, ptr %4, align 4\n%8 = call i32 @ipc(i32 noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef 0, i32 noundef 0)\nret i32 %8\n}": {"base_truth": "define dso_local i32 @msgget(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MSGGET, align 4\n%3 = tail call i32 @ipc(i32 noundef %2, i32 noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 0)\nret i32 %3\n}", "codellama": "define dso_local i32 @msgget(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MSGGET, align 4\n%3 = tail call i32 @ipc(i32 noundef %2, i32 noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 0)\nret i32 %3\n}", "codegemma": "define dso_local i32 @msgget(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MSGGET, align 4\n%3 = tail call i32 @ipc(i32 noundef %2, i32 noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 0)\nret i32 %3\n}"}, "define dso_local nofpclass(nan inf) double @libm_exp(double noundef nofpclass(nan inf) %0) {\n%2 = alloca double, align 8\nstore double %0, ptr %2, align 8\n%3 = load double, ptr %2, align 8\n%4 = call fast double @llvm.exp.f64(double %3)\nret double %4\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @libm_exp(double noundef nofpclass(nan inf) %0) {\nB:\n%1 = tail call fast double @llvm.exp.f64(double %0)\nret double %1\n}", "codellama": "define dso_local nofpclass(nan inf) double @libm_exp(double noundef nofpclass(nan inf) %0) {\nB:\n%1 = tail call fast double @llvm.exp.f64(double %0)\nret double %1\n}", "codegemma": "define dso_local nofpclass(nan inf) double @libm_exp(double noundef nofpclass(nan inf) %0) {\nB:\n%1 = tail call fast double @llvm.exp.f64(double %0)\nret double %1\n}"}, "define internal void @dpu_hw_set_limit_conf(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca ptr, align 8\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\n%12 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %9)\n%13 = load ptr, ptr %5, align 8\n%14 = getelementptr inbounds %struct.dpu_hw_vbif ptr %13, i32 0, i32 0\nstore ptr %14, ptr %9, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %12)\n%15 = load i32, ptr %7, align 4\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %17, label %19\n\n17:\n%18 = load i32, ptr @VBIF_IN_RD_LIM_CONF0, align 4\nstore i32 %18, ptr %11, align 4\nbr label %21\n\n19:\n%20 = load i32, ptr @VBIF_IN_WR_LIM_CONF0, align 4\nstore i32 %20, ptr %11, align 4\nbr label %21\n\n21:\n%22 = load i32, ptr %6, align 4\n%23 = sdiv i32 %22, 4\n%24 = mul nsw i32 %23, 4\n%25 = load i32, ptr %11, align 4\n%26 = add nsw i32 %25, %24\nstore i32 %26, ptr %11, align 4\n%27 = load i32, ptr %6, align 4\n%28 = srem i32 %27, 4\n%29 = mul nsw i32 %28, 8\nstore i32 %29, ptr %12, align 4\n%30 = load ptr, ptr %9, align 8\n%31 = load i32, ptr %11, align 4\n%32 = call i32 @DPU_REG_READ(ptr noundef %30, i32 noundef %31)\nstore i32 %32, ptr %10, align 4\n%33 = load i32, ptr %12, align 4\n%34 = shl i32 255, %33\n%35 = xor i32 %34, -1\n%36 = load i32, ptr %10, align 4\n%37 = and i32 %36, %35\nstore i32 %37, ptr %10, align 4\n%38 = load i32, ptr %8, align 4\n%39 = load i32, ptr %12, align 4\n%40 = shl i32 %38, %39\n%41 = load i32, ptr %10, align 4\n%42 = or i32 %41, %40\nstore i32 %42, ptr %10, align 4\n%43 = load ptr, ptr %9, align 8\n%44 = load i32, ptr %11, align 4\n%45 = load i32, ptr %10, align 4\n%46 = call i32 @DPU_REG_WRITE(ptr noundef %43, i32 noundef %44, i32 noundef %45)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %12)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %10)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %9)\nret void\n}": {"base_truth": "define internal void @dpu_hw_set_limit_conf(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = icmp eq i32 %2, 0\n%5 = load i32, ptr @VBIF_IN_WR_LIM_CONF0, align 4\n%6 = load i32, ptr @VBIF_IN_RD_LIM_CONF0, align 4\n%7 = select i1 %4, i32 %5, i32 %6\n%8 = sdiv i32 %1, 4\n%9 = shl nsw i32 %8, 2\n%10 = add nsw i32 %7, %9\n%11 = srem i32 %1, 4\n%12 = shl nsw i32 %11, 3\n%13 = tail call i32 @DPU_REG_READ(ptr noundef %0, i32 noundef %10)\n%14 = shl i32 255, %12\n%15 = xor i32 %14, -1\n%16 = and i32 %13, %15\n%17 = shl i32 %3, %12\n%18 = or i32 %16, %17\n%19 = tail call i32 @DPU_REG_WRITE(ptr noundef %0, i32 noundef %10, i32 noundef %18)\nret void\n}", "codellama": "define internal void @dpu_hw_set_limit_conf(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = icmp eq i32 %2, 0\n%5 = load i32, ptr @VBIF_IN_WR_LIM_CONF0, align 4\n%6 = load i32, ptr @VBIF_IN_RD_LIM_CONF0, align 4\n%7 = select i1 %4, i32 %5, i32 %6\n%8 = sdiv i32 %1, 4\n%9 = shl i32 %8, 2\n%10 = add i32 %9, %7\n%11 = and i32 %1, 3\n%12 = shl nuw nsw i32 %11, 3\n%13 = tail call i32 @DPU_REG_READ(ptr noundef %0, i32 noundef %10)\n%14 = shl nuw i32 255, %12\n%15 = xor i32 %14, -1\n%16 = and i32 %13, %15\n%17 = shl i32 %3, %12\n%18 = or i32 %16, %17\n%19 = tail call i32 @DPU_REG_WRITE(ptr noundef %0, i32 noundef %10, i32 noundef %18)\nret void\n}", "codegemma": "define internal void @dpu_hw_set_limit_conf(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = icmp eq i32 %2, 0\n%5 = load i32, ptr @VBIF_IN_WR_LIM_CONF0, align 4\n%6 = load i32, ptr @VBIF_IN_RD_LIM_CONF0, align 4\n%7 = select i1 %4, i32 %6, i32 %5\n%8 = sdiv i32 %1, 4\n%9 = mul nsw i32 %8, 4\n%10 = add nsw i32 %9, %3\n%11 = srem i32 %1, 4\n%12 = shl nsw i32 %11, 3\n%13 = shl nuw i32 255, %12\n%14 = xor i32 %13, -1\n%15 = and i32 %10, %14\n%16 = shl i32 %3, %12\n%17 = or i32 %16, %15\n%18 = tail call i32 @DPU_REG_WRITE(ptr noundef %0, i32 noundef %7, i32 noundef %17)\nret void\n}"}, "define dso_local void @pemu_sound_stop() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = load i64, ptr @samples_done, align 8\n%3 = icmp eq i64 %2, 0\nbr i1 %3, label %4, label %15\n\n4:\n%5 = load i64, ptr @sndBuffer, align 8\n%6 = inttoptr i64 %5 to ptr\n%7 = load i32, ptr @samples_block, align 4\n%8 = mul nsw i32 %7, 4\n%9 = sdiv i32 %8, 4\n%10 = call i32 @memset32(ptr noundef %6, i32 noundef 0, i32 noundef %9)\n%11 = load i32, ptr @samples_block, align 4\n%12 = mul nsw i32 %11, 3\nstore i32 %12, ptr @samples_made, align 4\n%13 = load i32, ptr @sound_sem, align 4\n%14 = call i32 @sceKernelSignalSema(i32 noundef %13, i32 noundef 1)\nbr label %15\n\n15:\n%16 = call i32 @sceKernelDelayThread(i32 noundef 100000)\nstore i64 0, ptr @samples_done, align 8\nstore i32 0, ptr @samples_made, align 4\nstore i32 0, ptr %1, align 4\nbr label %17\n\n17:\n%18 = call i64 (...) @sceAudioOutput2GetRestSample()\n%19 = icmp sgt i64 %18, 0\nbr i1 %19, label %20, label %23\n\n20:\n%21 = load i32, ptr %1, align 4\n%22 = icmp slt i32 %21, 16\nbr label %23\n\n23:\n%24 = phi i1 [ false, %17 ], [ %22, %20 ]\nbr i1 %24, label %25, label %30\n\n25:\n%26 = call i32 @psp_msleep(i32 noundef 100)\nbr label %27\n\n27:\n%28 = load i32, ptr %1, align 4\n%29 = add nsw i32 %28, 1\nstore i32 %29, ptr %1, align 4\nbr label %17\n\n30:\n%31 = call i32 (...) @sceAudio_5C37C0AE()\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @pemu_sound_stop() {\nB:\n%0 = load i64, ptr @samples_done, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i64, ptr @sndBuffer, align 8\n%3 = inttoptr i64 %2 to ptr\n%4 = load i32, ptr @samples_block, align 4\n%5 = tail call i32 @memset32(ptr noundef %3, i32 noundef 0, i32 noundef %4)\n%6 = load i32, ptr @samples_block, align 4\n%7 = mul nsw i32 %6, 3\nstore i32 %7, ptr @samples_made, align 4\n%8 = load i32, ptr @sound_sem, align 4\n%9 = tail call i32 @sceKernelSignalSema(i32 noundef %8, i32 noundef 1)\nbr label %B2\n\nB2:\n%10 = tail call i32 @sceKernelDelayThread(i32 noundef 100000)\nstore i64 0, ptr @samples_done, align 8\nstore i32 0, ptr @samples_made, align 4\n%11 = tail call i64 (...) @sceAudioOutput2GetRestSample()\n%12 = icmp sgt i64 %11, 0\nbr i1 %12, label %B3, label %B4\n\nB3:\n%13 = phi i32 [ %15, %B3 ], [ 0, %B2 ]\n%14 = tail call i32 @psp_msleep(i32 noundef 100)\n%15 = add nuw nsw i32 %13, 1\n%16 = tail call i64 (...) @sceAudioOutput2GetRestSample()\n%17 = icmp sgt i64 %16, 0\n%18 = icmp ult i32 %13, 15\n%19 = select i1 %17, i1 %18, i1 false\nbr i1 %19, label %B3, label %B4\n\nB4:\n%20 = tail call i32 (...) @sceAudio_5C37C0AE()\nret void\n}", "codellama": "define dso_local void @pemu_sound_stop() {\nB:\n%0 = load i64, ptr @samples_done, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i64, ptr @sndBuffer, align 8\n%3 = inttoptr i64 %2 to ptr\n%4 = load i32, ptr @samples_block, align 4\n%5 = shl nsw i32 %4, 2\n%6 = sdiv i32 %5, 4\n%7 = tail call i32 @memset32(ptr noundef %3, i32 noundef 0, i32 noundef %6)\n%8 = load i32, ptr @samples_block, align 4\n%9 = mul nsw i32 %8, 3\nstore i32 %9, ptr @samples_made, align 4\n%10 = load i32, ptr @sound_sem, align 4\n%11 = tail call i32 @sceKernelSignalSema(i32 noundef %10, i32 noundef 1)\nbr label %B2\n\nB2:\n%12 = tail call i32 @sceKernelDelayThread(i32 noundef 100000)\nstore i64 0, ptr @samples_done, align 8\nstore i32 0, ptr @samples_made, align 4\nbr label %B3\n\nB3:\n%13 = phi i32 [ 0, %B2 ], [ %17, %B3 ]\n%14 = tail call i64 (...) @sceAudioOutput2GetRestSample()\n%15 = icmp sgt i64 %14, 0\n%16 = icmp ult i32 %13, 16\n%17 = add nuw nsw i32 %13, 1\nbr i1 %15, label %B3, label %B4\n\nB4:\n%18 = tail call i32 @psp_msleep(i32 noundef 100)\n%19 = tail call i64 (...) @sceAudioOutput2GetRestSample()\n%20 = icmp sgt i64 %19, 0\n%21 = icmp ult i32 %13, 15\n%22 = select i1 %20, i1 %21, i1 false\nbr i1 %22, label %B3, label %B5\n\nB5:\n%23 = tail call i32 (...) @sceAudio_5C37C0AE()\nret void\n}", "codegemma": "define dso_local void @pemu_sound_stop() {\nB:\n%0 = load i64, ptr @samples_done, align 8\n%1 = icmp eq i64 %0, 0\nbr i1 %1, label %B1, label %B2\n\nB1:\n%2 = load i64, ptr @sndBuffer, align 8\n%3 = inttoptr i64 %2 to ptr\n%4 = load i32, ptr @samples_block, align 4\n%5 = shl nsw i32 %4, 2\n%6 = sdiv i32 %5, 4\n%7 = tail call i32 @memset32(ptr noundef %3, i32 noundef 0, i32 noundef %6)\n%8 = load i32, ptr @samples_block, align 4\n%9 = mul nsw i32 %8, 3\nstore i32 %9, ptr @samples_made, align 4\n%10 = load i32, ptr @sound_sem, align 4\n%11 = tail call i32 @sceKernelSignalSema(i32 noundef %10, i32 noundef 1)\nbr label %B2\n\nB2:\n%12 = tail call i32 @sceKernelDelayThread(i32 noundef 100000)\nstore i64 0, ptr @samples_done, align 8\nstore i32 0, ptr @samples_made, align 4\nbr label %B3\n\nB3:\n%13 = tail call i64 (...) @sceAudioOutput2GetRestSample()\n%14 = icmp sgt i64 %13, 0\nbr i1 %14, label %B4, label %B5\n\nB4:\n%15 = tail call i32 @psp_msleep(i32 noundef 100)\nbr label %B3\n\nB5:\n%16 = tail call i32 (...) @sceAudio_5C37C0AE()\nret void\n}"}, "define dso_local nofpclass(nan inf) float @baz(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1) {\n%3 = alloca float, align 4\n%4 = alloca double, align 8\nstore float %0, ptr %3, align 4\nstore double %1, ptr %4, align 8\n%5 = load float, ptr %3, align 4\n%6 = load double, ptr %4, align 8\n%7 = call i64 @bar(float noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6)\n%8 = sitofp i64 %7 to float\nret float %8\n}": {"base_truth": "define dso_local nofpclass(nan inf) float @baz(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = tail call i64 @bar(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1)\n%3 = sitofp i64 %2 to float\nret float %3\n}", "codellama": "define dso_local nofpclass(nan inf) float @baz(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = tail call i64 @bar(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1)\n%3 = sitofp i64 %2 to float\nret float %3\n}", "codegemma": "define dso_local nofpclass(nan inf) float @baz(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = tail call i64 @bar(float noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1)\n%3 = sitofp i64 %2 to float\nret float %3\n}"}, "define dso_local i32 @IsHubIpAddress32(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load i32, ptr %2, align 4\n%5 = call i32 @UINTToIP(ptr noundef %3, i32 noundef %4)\n%6 = call i32 @IsHubIpAddress(ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %6\n}": {"base_truth": "define dso_local i32 @IsHubIpAddress32(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @UINTToIP(ptr noundef nonnull %1, i32 noundef %0)\n%3 = call i32 @IsHubIpAddress(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %3\n}", "codellama": "define dso_local i32 @IsHubIpAddress32(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @UINTToIP(ptr noundef nonnull %1, i32 noundef %0)\n%3 = call i32 @IsHubIpAddress(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %3\n}", "codegemma": "define dso_local i32 @IsHubIpAddress32(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @UINTToIP(ptr noundef nonnull %1, i32 noundef %0)\n%3 = call i32 @IsHubIpAddress(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %3\n}"}, "define dso_local nofpclass(nan inf) double @ln_get_hyp_radius_vector(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2) {\n%4 = alloca double, align 8\n%5 = alloca double, align 8\n%6 = alloca double, align 8\nstore double %0, ptr %4, align 8\nstore double %1, ptr %5, align 8\nstore double %2, ptr %6, align 8\n%7 = load double, ptr %4, align 8\n%8 = load double, ptr %5, align 8\n%9 = fadd fast double 1.000000e+00, %8\n%10 = fmul fast double %7, %9\n%11 = load double, ptr %5, align 8\n%12 = load double, ptr %4, align 8\n%13 = load double, ptr %5, align 8\n%14 = load double, ptr %6, align 8\n%15 = call i32 @ln_get_hyp_true_anomaly(double noundef nofpclass(nan inf) %12, double noundef nofpclass(nan inf) %13, double noundef nofpclass(nan inf) %14)\n%16 = call i32 @ln_deg_to_rad(i32 noundef %15)\n%17 = call fast nofpclass(nan inf) double @cos(i32 noundef %16)\n%18 = fmul fast double %11, %17\n%19 = fadd fast double 1.000000e+00, %18\n%20 = fdiv fast double %10, %19\nret double %20\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @ln_get_hyp_radius_vector(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = fadd fast double %1, 1.000000e+00\n%4 = fmul fast double %3, %0\n%5 = tail call i32 @ln_get_hyp_true_anomaly(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2)\n%6 = tail call i32 @ln_deg_to_rad(i32 noundef %5)\n%7 = tail call fast nofpclass(nan inf) double @cos(i32 noundef %6)\n%8 = fmul fast double %7, %1\n%9 = fadd fast double %8, 1.000000e+00\n%10 = fdiv fast double %4, %9\nret double %10\n}", "codellama": "define dso_local nofpclass(nan inf) double @ln_get_hyp_radius_vector(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = fadd fast double %1, 1.000000e+00\n%4 = fmul fast double %3, %0\n%5 = tail call i32 @ln_get_hyp_true_anomaly(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2)\n%6 = tail call i32 @ln_deg_to_rad(i32 noundef %5)\n%7 = tail call fast nofpclass(nan inf) double @cos(i32 noundef %6)\n%8 = fmul fast double %7, %1\n%9 = fadd fast double %8, 1.000000e+00\n%10 = fdiv fast double %4, %9\nret double %10\n}", "codegemma": "define dso_local nofpclass(nan inf) double @ln_get_hyp_radius_vector(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = fadd fast double %1, 1.000000e+00\n%4 = fmul fast double %3, %0\n%5 = tail call i32 @ln_get_hyp_true_anomaly(double noundef nofpclass(nan inf) %0, double noundef nofpclass(nan inf) %1, double noundef nofpclass(nan inf) %2)\n%6 = tail call i32 @ln_deg_to_rad(i32 noundef %5)\n%7 = tail call fast nofpclass(nan inf) double @cos(i32 noundef %6)\n%8 = fmul fast double %7, %1\n%9 = fadd fast double %8, 1.000000e+00\n%10 = fdiv fast double %4, %9\nret double %10\n}"}, "define dso_local void @serio_reconnect(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @SERIO_RECONNECT_CHAIN, align 4\n%5 = call i32 @serio_queue_event(ptr noundef %3, ptr noundef null, i32 noundef %4)\nret void\n}": {"base_truth": "define dso_local void @serio_reconnect(ptr noundef %0) {\nB:\n%1 = load i32, ptr @SERIO_RECONNECT_CHAIN, align 4\n%2 = tail call i32 @serio_queue_event(ptr noundef %0, ptr noundef null, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @serio_reconnect(ptr noundef %0) {\nB:\n%1 = load i32, ptr @SERIO_RECONNECT_CHAIN, align 4\n%2 = tail call i32 @serio_queue_event(ptr noundef %0, ptr noundef null, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @serio_reconnect(ptr noundef %0) {\nB:\n%1 = load i32, ptr @SERIO_RECONNECT_CHAIN, align 4\n%2 = tail call i32 @serio_queue_event(ptr noundef %0, ptr noundef null, i32 noundef %1)\nret void\n}"}, "define dso_local i64 @crypto_aead_aes256gcm_messagebytes_max() {\n%1 = load i64, ptr @crypto_aead_aes256gcm_MESSAGEBYTES_MAX, align 8\nret i64 %1\n}": {"base_truth": "define dso_local i64 @crypto_aead_aes256gcm_messagebytes_max() {\nB:\n%0 = load i64, ptr @crypto_aead_aes256gcm_MESSAGEBYTES_MAX, align 8\nret i64 %0\n}", "codellama": "define dso_local i64 @crypto_aead_aes256gcm_messagebytes_max() {\nB:\n%0 = load i64, ptr @crypto_aead_aes256gcm_MESSAGEBYTES_MAX, align 8\nret i64 %0\n}", "codegemma": "define dso_local i64 @crypto_aead_aes256gcm_messagebytes_max() {\nB:\n%0 = load i64, ptr @crypto_aead_aes256gcm_MESSAGEBYTES_MAX, align 8\nret i64 %0\n}"}, "define dso_local ptr @MIStackListAllArguments(i64 noundef %0) {\n%2 = alloca i64, align 8\n%3 = alloca ptr, align 8\nstore i64 %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = call ptr @MICommandNew(ptr noundef @.str, i32 noundef 1)\nstore ptr %4, ptr %3, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load i64, ptr %2, align 8\n%7 = trunc i64 %6 to i32\n%8 = call i32 @MIIntToCString(i32 noundef %7)\n%9 = call i32 @MICommandAddOption(ptr noundef %5, i32 noundef %8, ptr noundef null)\n%10 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %10\n}": {"base_truth": "define dso_local ptr @MIStackListAllArguments(i64 noundef %0) {\nB:\n%1 = tail call ptr @MICommandNew(ptr noundef nonnull @.str, i32 noundef 1)\n%2 = trunc i64 %0 to i32\n%3 = tail call i32 @MIIntToCString(i32 noundef %2)\n%4 = tail call i32 @MICommandAddOption(ptr noundef %1, i32 noundef %3, ptr noundef null)\nret ptr %1\n}", "codellama": "define dso_local ptr @MIStackListAllArguments(i64 noundef %0) {\nB:\n%1 = tail call ptr @MICommandNew(ptr noundef nonnull @.str, i32 noundef 1)\n%2 = trunc i64 %0 to i32\n%3 = tail call i32 @MIIntToCString(i32 noundef %2)\n%4 = tail call i32 @MICommandAddOption(ptr noundef %1, i32 noundef %3, ptr noundef null)\nret ptr %1\n}", "codegemma": "define dso_local ptr @MIStackListAllArguments(i64 noundef %0) {\nB:\n%1 = tail call ptr @MICommandNew(ptr noundef nonnull @.str, i32 noundef 1)\n%2 = trunc i64 %0 to i32\n%3 = tail call i32 @MIIntToCString(i32 noundef %2)\n%4 = tail call i32 @MICommandAddOption(ptr noundef %1, i32 noundef %3, ptr noundef null)\nret ptr %1\n}"}, "define internal void @r3k_dma_cache_wback_inv(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %4, align 8\n%6 = icmp eq i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = call i32 @BUG_ON(i32 noundef %7)\n%9 = call i32 (...) @iob()\n%10 = load i64, ptr %3, align 8\n%11 = load i64, ptr %3, align 8\n%12 = load i64, ptr %4, align 8\n%13 = add i64 %11, %12\n%14 = call i32 @r3k_flush_dcache_range(i64 noundef %10, i64 noundef %13)\nret void\n}": {"base_truth": "define internal void @r3k_dma_cache_wback_inv(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\n%4 = tail call i32 @BUG_ON(i32 noundef %3)\n%5 = tail call i32 (...) @iob()\n%6 = add i64 %1, %0\n%7 = tail call i32 @r3k_flush_dcache_range(i64 noundef %0, i64 noundef %6)\nret void\n}", "codellama": "define internal void @r3k_dma_cache_wback_inv(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\n%4 = tail call i32 @BUG_ON(i32 noundef %3)\n%5 = tail call i32 (...) @iob()\n%6 = add i64 %1, %0\n%7 = tail call i32 @r3k_flush_dcache_range(i64 noundef %0, i64 noundef %6)\nret void\n}", "codegemma": "define internal void @r3k_dma_cache_wback_inv(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = icmp eq i64 %1, 0\n%3 = zext i1 %2 to i32\n%4 = tail call i32 @BUG_ON(i32 noundef %3)\n%5 = tail call i32 (...) @iob()\n%6 = add i64 %1, %0\n%7 = tail call i32 @r3k_flush_dcache_range(i64 noundef %0, i64 noundef %6)\nret void\n}"}, "define internal i32 @mei_me_cl_ver(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.mei_me_client ptr %3, i32 0, i32 0\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nret i32 %6\n}": {"base_truth": "define internal i32 @mei_me_cl_ver(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define internal i32 @mei_me_cl_ver(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define internal i32 @mei_me_cl_ver(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local void @game_exit_cleanup() {\n%1 = call i32 (...) @player_exit_cleanup()\nret void\n}": {"base_truth": "define dso_local void @game_exit_cleanup() {\nB:\n%0 = tail call i32 (...) @player_exit_cleanup()\nret void\n}", "codellama": "define dso_local void @game_exit_cleanup() {\nB:\n%0 = tail call i32 (...) @player_exit_cleanup()\nret void\n}", "codegemma": "define dso_local void @game_exit_cleanup() {\nB:\n%0 = tail call i32 (...) @player_exit_cleanup()\nret void\n}"}, "define dso_local void @signal_handler(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\nswitch i32 %3, label %5 [\ni32 129, label %5\ni32 128, label %4\n]\n\n4:\nstore i32 1, ptr @_signal_handler, align 4\nbr label %5\n\n5:\nret void\n}": {"base_truth": "define dso_local void @signal_handler(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 128\nbr i1 %1, label %B1, label %B2\n\nB1:\nstore i32 1, ptr @_signal_handler, align 4\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @signal_handler(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 128\nbr i1 %1, label %B1, label %B2\n\nB1:\nstore i32 1, ptr @_signal_handler, align 4\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @signal_handler(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 128\nbr i1 %1, label %B1, label %B2\n\nB1:\nstore i32 1, ptr @_signal_handler, align 4\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i32 @is_kmsg_output(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @EXEC_OUTPUT_KMSG, align 4\n%5 = load i32, ptr @EXEC_OUTPUT_KMSG_AND_CONSOLE, align 4\n%6 = call i32 @IN_SET(i32 noundef %3, i32 noundef %4, i32 noundef %5)\nret i32 %6\n}": {"base_truth": "define internal i32 @is_kmsg_output(i32 noundef %0) {\nB:\n%1 = load i32, ptr @EXEC_OUTPUT_KMSG, align 4\n%2 = load i32, ptr @EXEC_OUTPUT_KMSG_AND_CONSOLE, align 4\n%3 = tail call i32 @IN_SET(i32 noundef %0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codellama": "define internal i32 @is_kmsg_output(i32 noundef %0) {\nB:\n%1 = load i32, ptr @EXEC_OUTPUT_KMSG, align 4\n%2 = load i32, ptr @EXEC_OUTPUT_KMSG_AND_CONSOLE, align 4\n%3 = tail call i32 @IN_SET(i32 noundef %0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define internal i32 @is_kmsg_output(i32 noundef %0) {\nB:\n%1 = load i32, ptr @EXEC_OUTPUT_KMSG, align 4\n%2 = load i32, ptr @EXEC_OUTPUT_KMSG_AND_CONSOLE, align 4\n%3 = tail call i32 @IN_SET(i32 noundef %0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}"}, "define dso_local void @FF_sub(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore ptr %2, ptr %7, align 8\nstore i32 %3, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\nstore i32 0, ptr %9, align 4\nbr label %10\n\n10:\n%11 = load i32, ptr %9, align 4\n%12 = load i32, ptr %8, align 4\n%13 = icmp slt i32 %11, %12\nbr i1 %13, label %14, label %34\n\n14:\n%15 = load ptr, ptr %5, align 8\n%16 = load i32, ptr %9, align 4\n%17 = sext i32 %16 to i64\n%18 = getelementptr inbounds i32, ptr %15, i64 %17\n%19 = load i32, ptr %18, align 4\n%20 = load ptr, ptr %6, align 8\n%21 = load i32, ptr %9, align 4\n%22 = sext i32 %21 to i64\n%23 = getelementptr inbounds i32, ptr %20, i64 %22\n%24 = load i32, ptr %23, align 4\n%25 = load ptr, ptr %7, align 8\n%26 = load i32, ptr %9, align 4\n%27 = sext i32 %26 to i64\n%28 = getelementptr inbounds i32, ptr %25, i64 %27\n%29 = load i32, ptr %28, align 4\n%30 = call i32 @BIG_sub(i32 noundef %19, i32 noundef %24, i32 noundef %29)\nbr label %31\n\n31:\n%32 = load i32, ptr %9, align 4\n%33 = add nsw i32 %32, 1\nstore i32 %33, ptr %9, align 4\nbr label %10\n\n34:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\nret void\n}": {"base_truth": "define dso_local void @FF_sub(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2, i32 noundef %3) {\nB:\n%4 = icmp sgt i32 %3, 0\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = zext i32 %3 to i64\nbr label %B2\n\nB2:\n%6 = phi i64 [ 0, %B1 ], [ %14, %B2 ]\n%7 = getelementptr inbounds i32, ptr %0, i64 %6\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %1, i64 %6\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds i32, ptr %2, i64 %6\n%12 = load i32, ptr %11, align 4\n%13 = tail call i32 @BIG_sub(i32 noundef %8, i32 noundef %10, i32 noundef %12)\n%14 = add nuw nsw i64 %6, 1\n%15 = icmp eq i64 %14, %5\nbr i1 %15, label %B3, label %B2\n\nB3:\nret void\n}", "codellama": "define dso_local void @FF_sub(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2, i32 noundef %3) {\nB:\n%4 = icmp sgt i32 %3, 0\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = zext i32 %3 to i64\nbr label %B2\n\nB2:\n%6 = phi i64 [ 0, %B1 ], [ %13, %B2 ]\n%7 = getelementptr inbounds i32, ptr %0, i64 %6\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %1, i64 %6\n%10 = load i32, ptr %9, align 4\n%11 = getelementptr inbounds i32, ptr %2, i64 %6\n%12 = load i32, ptr %11, align 4\n%13 = add nuw nsw i64 %6, 1\n%14 = icmp eq i64 %13, %5\nbr i1 %14, label %B3, label %B2\n\nB3:\nret void\n}", "codegemma": "define dso_local void @FF_sub(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2, i32 noundef %3) {\nB:\n%4 = icmp sgt i32 %3, 0\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = zext i32 %3 to i64\nbr label %B2\n\nB2:\n%6 = phi i64 [ 0, %B1 ], [ %11, %B2 ]\n%7 = getelementptr inbounds i32, ptr %0, i64 %6\n%8 = load i32, ptr %7, align 4\n%9 = getelementptr inbounds i32, ptr %1, i64 %6\n%10 = load i32, ptr %9, align 4\n%11 = add nuw nsw i64 %6, 1\n%12 = getelementptr inbounds i32, ptr %2, i64 %6\n%13 = load i32, ptr %12, align 4\n%14 = tail call i32 @BIG_sub(i32 noundef %8, i32 noundef %10, i32 noundef %13)\n%15 = icmp eq i64 %11, %5\nbr i1 %15, label %B3, label %B2\n\nB3:\nret void\n}"}, "define internal i32 @prefixesEof(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\nstore ptr %4, ptr %3, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.TYPE_2__, ptr %5, i32 0, i32 0\n%7 = load i64, ptr %6, align 8\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i32 0, i32 1\n%10 = load i64, ptr %9, align 8\n%11 = icmp sgt i64 %7, %10\n%12 = zext i1 %11 to i32\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %12\n}": {"base_truth": "define internal i32 @prefixesEof(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp sgt i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define internal i32 @prefixesEof(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp sgt i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codegemma": "define internal i32 @prefixesEof(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.TYPE_2__, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = icmp sgt i64 %1, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 0, ptr %2, align 4\nbr label %3\n\n3:\n%4 = load i32, ptr %2, align 4\n%5 = icmp slt i32 %4, 5\nbr i1 %5, label %6, label %11\n\n6:\n%7 = call i32 @rysuj_gwiazdki(ptr noundef @.str)\n%8 = call i32 @rysuj_gwiazdki(ptr noundef @.str.1)\n%9 = load i32, ptr %2, align 4\n%10 = add nsw i32 %9, 1\nstore i32 %10, ptr %2, align 4\nbr label %3\n\n11:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%1 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%2 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%3 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%5 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%6 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%7 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%8 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%9 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%1 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%2 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%3 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%5 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%6 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%7 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%1 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%2 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%3 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%5 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%6 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%7 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%8 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%9 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\n%10 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str)\n%11 = tail call i32 @rysuj_gwiazdki(ptr noundef nonnull @.str.1)\nret i32 0\n}"}, "define dso_local void @tx_wcoloreol(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca [10 x i8], align 1\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 10, ptr %7)\n%8 = load ptr, ptr %2, align 8\n%9 = load i32, ptr %5, align 4\n%10 = load i32, ptr %6, align 4\n%11 = call i32 @getyx(ptr noundef %8, i32 noundef %9, i32 noundef %10)\n%12 = load ptr, ptr %2, align 8\n%13 = load i32, ptr %3, align 4\n%14 = load i32, ptr %4, align 4\n%15 = call i32 @getmaxyx(ptr noundef %12, i32 noundef %13, i32 noundef %14)\n%16 = getelementptr inbounds [10 x i8], ptr %7, i64 0, i64 0\n%17 = load i32, ptr %4, align 4\n%18 = load i32, ptr %6, align 4\n%19 = sub nsw i32 %17, %18\n%20 = sub nsw i32 %19, 1\n%21 = call i32 @sprintf(ptr noundef %16, ptr noundef @.str, i32 noundef %20)\n%22 = load ptr, ptr %2, align 8\n%23 = call i32 @scrollok(ptr noundef %22, i32 noundef 0)\n%24 = load ptr, ptr %2, align 8\n%25 = getelementptr inbounds [10 x i8], ptr %7, i64 0, i64 0\n%26 = call i32 @wprintw(ptr noundef %24, ptr noundef %25, i8 noundef signext 32)\ncall void @llvm.lifetime.end.p0(i64 10, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @tx_wcoloreol(ptr noundef %0) {\nB:\n%1 = alloca [10 x i8], align 1\ncall void @llvm.lifetime.start.p0(i64 10, ptr nonnull %1)\n%2 = tail call i32 @getyx(ptr noundef %0, i32 noundef undef, i32 noundef undef)\n%3 = tail call i32 @getmaxyx(ptr noundef %0, i32 noundef undef, i32 noundef undef)\n%4 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef undef)\n%5 = call i32 @scrollok(ptr noundef %0, i32 noundef 0)\n%6 = call i32 @wprintw(ptr noundef %0, ptr noundef nonnull %1, i8 noundef signext 32)\ncall void @llvm.lifetime.end.p0(i64 10, ptr nonnull %1)\nret void\n}", "codellama": "define dso_local void @tx_wcoloreol(ptr noundef %0) {\nB:\n%1 = alloca [10 x i8], align 1\ncall void @llvm.lifetime.start.p0(i64 10, ptr nonnull %1)\n%2 = tail call i32 @getyx(ptr noundef %0, i32 noundef undef, i32 noundef undef)\n%3 = tail call i32 @getmaxyx(ptr noundef %0, i32 noundef undef, i32 noundef undef)\n%4 = tail call i32 @scrollok(ptr noundef %0, i32 noundef 0)\n%5 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef -1)\n%6 = call i32 @wprintw(ptr noundef %0, ptr noundef nonnull %1, i8 noundef signext 32)\ncall void @llvm.lifetime.end.p0(i64 10, ptr nonnull %1)\nret void\n}", "codegemma": "define dso_local void @tx_wcoloreol(ptr noundef %0) {\nB:\n%1 = alloca [10 x i8], align 1\ncall void @llvm.lifetime.start.p0(i64 10, ptr nonnull %1)\n%2 = tail call i32 @getyx(ptr noundef %0, i32 noundef undef, i32 noundef undef)\n%3 = tail call i32 @getmaxyx(ptr noundef %0, i32 noundef undef, i32 noundef undef)\n%4 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef undef)\n%5 = call i32 @scrollok(ptr noundef %0, i32 noundef 0)\n%6 = call i32 @wprintw(ptr noundef %0, ptr noundef nonnull %1, i8 noundef signext 32)\ncall void @llvm.lifetime.end.p0(i64 10, ptr nonnull %1)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\n%2 = call ptr (...) @hello()\n%3 = call ptr (...) @world()\n%4 = call i32 @printf(ptr noundef @.str, ptr noundef %2, ptr noundef %3)\nret i32 %4\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr (...) @hello()\n%1 = tail call ptr (...) @world()\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0, ptr noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr (...) @hello()\n%1 = tail call ptr (...) @world()\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0, ptr noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr (...) @hello()\n%1 = tail call ptr (...) @world()\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0, ptr noundef %1)\nret i32 %2\n}"}, "define dso_local i32 @c_float_float_ge(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 0\n%7 = load i64, ptr %6, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.TYPE_4__, ptr %8, i32 0, i32 0\n%10 = load i64, ptr %9, align 8\n%11 = icmp sge i64 %7, %10\n%12 = zext i1 %11 to i64\n%13 = select i1 %11, i32 14, i32 0\nret i32 %13\n}": {"base_truth": "define dso_local i32 @c_float_float_ge(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr %1, align 8\n%4 = icmp slt i64 %2, %3\n%5 = select i1 %4, i32 0, i32 14\nret i32 %5\n}", "codellama": "define dso_local i32 @c_float_float_ge(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr %1, align 8\n%4 = icmp slt i64 %2, %3\n%5 = select i1 %4, i32 0, i32 14\nret i32 %5\n}", "codegemma": "define dso_local i32 @c_float_float_ge(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr %1, align 8\n%4 = icmp slt i64 %2, %3\n%5 = select i1 %4, i32 0, i32 14\nret i32 %5\n}"}, "define dso_local void @edit_locker2(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%4 = load i32, ptr %2, align 4\n%5 = icmp ne i32 %4, 0\nbr i1 %5, label %6, label %10\n\n6:\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%7 = call i32 @creat(ptr noundef @.str, i32 noundef 438)\nstore i32 %7, ptr %3, align 4\n%8 = load i32, ptr %3, align 4\n%9 = call i32 @close(i32 noundef %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nbr label %12\n\n10:\n%11 = call i32 @remove(ptr noundef @.str)\nbr label %12\n\n12:\nret void\n}": {"base_truth": "define dso_local void @edit_locker2(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @creat(ptr noundef nonnull @.str, i32 noundef 438)\n%3 = tail call i32 @close(i32 noundef %2)\nbr label %B3\n\nB2:\n%4 = tail call i32 @remove(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define dso_local void @edit_locker2(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @creat(ptr noundef nonnull @.str, i32 noundef 438)\n%3 = tail call i32 @close(i32 noundef %2)\nbr label %B3\n\nB2:\n%4 = tail call i32 @remove(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\nret void\n}", "codegemma": "define dso_local void @edit_locker2(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = tail call i32 @creat(ptr noundef nonnull @.str, i32 noundef 438)\n%3 = tail call i32 @close(i32 noundef %2)\nbr label %B3\n\nB2:\n%4 = tail call i32 @remove(ptr noundef nonnull @.str)\nbr label %B3\n\nB3:\nret void\n}"}, "define internal void @ucma_lock_files(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = icmp ult ptr %5, %6\nbr i1 %7, label %8, label %15\n\n8:\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.ucma_file ptr %9, i32 0, i32 0\n%11 = call i32 @mutex_lock(ptr noundef %10)\n%12 = load ptr, ptr %4, align 8\n%13 = getelementptr inbounds %struct.ucma_file ptr %12, i32 0, i32 0\n%14 = call i32 @mutex_lock(ptr noundef %13)\nbr label %22\n\n15:\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.ucma_file ptr %16, i32 0, i32 0\n%18 = call i32 @mutex_lock(ptr noundef %17)\n%19 = load ptr, ptr %3, align 8\n%20 = getelementptr inbounds %struct.ucma_file ptr %19, i32 0, i32 0\n%21 = call i32 @mutex_lock(ptr noundef %20)\nbr label %22\n\n22:\nret void\n}": {"base_truth": "define internal void @ucma_lock_files(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ult ptr %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @mutex_lock(ptr noundef %0)\n%4 = tail call i32 @mutex_lock(ptr noundef nonnull %1)\nbr label %B3\n\nB2:\n%5 = tail call i32 @mutex_lock(ptr noundef %1)\n%6 = tail call i32 @mutex_lock(ptr noundef %0)\nbr label %B3\n\nB3:\nret void\n}", "codellama": "define internal void @ucma_lock_files(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ult ptr %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @mutex_lock(ptr noundef %0)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %1, %B1 ], [ %0, %B ]\n%5 = tail call i32 @mutex_lock(ptr noundef %4)\nret void\n}", "codegemma": "define internal void @ucma_lock_files(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = icmp ult ptr %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @mutex_lock(ptr noundef %0)\nbr label %B3\n\nB2:\n%4 = tail call i32 @mutex_lock(ptr noundef %1)\nbr label %B3\n\nB3:\n%5 = phi ptr [ %1, %B2 ], [ %0, %B1 ]\n%6 = tail call i32 @mutex_lock(ptr noundef %5)\nret void\n}"}, "define dso_local i32 @UART_SetBaud(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\nret i32 0\n}": {"base_truth": "define dso_local i32 @UART_SetBaud(i32 noundef %0, i32 noundef %1) {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @UART_SetBaud(i32 noundef %0, i32 noundef %1) {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @UART_SetBaud(i32 noundef %0, i32 noundef %1) {\nB:\nret i32 0\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore ptr %3, ptr %2, align 8\nstore i32 0, ptr %3, align 4\n%4 = load ptr, ptr %2, align 8\nstore i32 1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = icmp eq i32 %5, 1\n%7 = zext i1 %6 to i32\n%8 = call i32 @assert(i32 noundef %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @assert(i32 noundef 1)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\nstore i32 1, ptr %0, align 4\n%1 = tail call i32 @assert(i32 noundef 1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @assert(i32 noundef 1)\nret i32 0\n}"}, "define dso_local i32 @FS460_reset() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%4 = call i32 (...) @FS460_powerdown()\nstore i32 %4, ptr %2, align 4\n%5 = load i32, ptr %2, align 4\n%6 = icmp ne i32 %5, 0\nbr i1 %6, label %7, label %9\n\n7:\n%8 = load i32, ptr %2, align 4\nstore i32 %8, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %18\n\n9:\n%10 = call i32 (...) @initialize_device_settings()\n%11 = call i32 (...) @set_defaults()\nstore i32 %11, ptr %2, align 4\n%12 = load i32, ptr %2, align 4\n%13 = icmp ne i32 %12, 0\nbr i1 %13, label %14, label %16\n\n14:\n%15 = load i32, ptr %2, align 4\nstore i32 %15, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %18\n\n16:\n%17 = call i32 @isr_enable_interrupts(i32 noundef 1)\nstore i32 0, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %18\n\n18:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%19 = load i32, ptr %1, align 4\nret i32 %19\n}": {"base_truth": "define dso_local i32 @FS460_reset() {\nB:\n%0 = tail call i32 (...) @FS460_powerdown()\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\n%2 = tail call i32 (...) @initialize_device_settings()\n%3 = tail call i32 (...) @set_defaults()\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @isr_enable_interrupts(i32 noundef 1)\nbr label %B3\n\nB3:\n%6 = phi i32 [ 0, %B2 ], [ %0, %B ], [ %3, %B1 ]\nret i32 %6\n}", "codellama": "define dso_local i32 @FS460_reset() {\nB:\n%0 = tail call i32 (...) @FS460_powerdown()\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\n%2 = tail call i32 (...) @initialize_device_settings()\n%3 = tail call i32 (...) @set_defaults()\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @isr_enable_interrupts(i32 noundef 1)\nbr label %B3\n\nB3:\n%6 = phi i32 [ 0, %B2 ], [ %0, %B ], [ %3, %B1 ]\nret i32 %6\n}", "codegemma": "define dso_local i32 @FS460_reset() {\nB:\n%0 = tail call i32 (...) @FS460_powerdown()\n%1 = icmp eq i32 %0, 0\nbr i1 %1, label %B1, label %B3\n\nB1:\n%2 = tail call i32 (...) @initialize_device_settings()\n%3 = tail call i32 (...) @set_defaults()\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B2, label %B3\n\nB2:\n%5 = tail call i32 @isr_enable_interrupts(i32 noundef 1)\nbr label %B3\n\nB3:\n%6 = phi i32 [ 0, %B2 ], [ %0, %B ], [ %3, %B1 ]\nret i32 %6\n}"}, "define dso_local i32 @pte_young(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @pte_val(i32 noundef %3)\n%5 = and i32 %4, 33554432\nret i32 %5\n}": {"base_truth": "define dso_local i32 @pte_young(i32 noundef %0) {\nB:\n%1 = tail call i32 @pte_val(i32 noundef %0)\n%2 = and i32 %1, 33554432\nret i32 %2\n}", "codellama": "define dso_local i32 @pte_young(i32 noundef %0) {\nB:\n%1 = tail call i32 @pte_val(i32 noundef %0)\n%2 = and i32 %1, 33554432\nret i32 %2\n}", "codegemma": "define dso_local i32 @pte_young(i32 noundef %0) {\nB:\n%1 = tail call i32 @pte_val(i32 noundef %0)\n%2 = and i32 %1, 33554432\nret i32 %2\n}"}, "define internal i32 @ads7871_write_reg8(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca [2 x i32], align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%8 = getelementptr inbounds [2 x i32], ptr %7, i64 0, i64 0\n%9 = load i32, ptr %5, align 4\nstore i32 %9, ptr %8, align 4\n%10 = getelementptr inbounds i32, ptr %8, i64 1\n%11 = load i32, ptr %6, align 4\nstore i32 %11, ptr %10, align 4\n%12 = load ptr, ptr %4, align 8\n%13 = getelementptr inbounds [2 x i32], ptr %7, i64 0, i64 0\n%14 = call i32 @spi_write(ptr noundef %12, ptr noundef %13, i32 noundef 8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret i32 %14\n}": {"base_truth": "define internal i32 @ads7871_write_reg8(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca [2 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\nstore i32 %1, ptr %3, align 4\n%4 = getelementptr inbounds i32, ptr %3, i64 1\nstore i32 %2, ptr %4, align 4\n%5 = call i32 @spi_write(ptr noundef %0, ptr noundef nonnull %3, i32 noundef 8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %5\n}", "codellama": "define internal i32 @ads7871_write_reg8(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca [2 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\nstore i32 %1, ptr %3, align 4\n%4 = getelementptr inbounds i32, ptr %3, i64 1\nstore i32 %2, ptr %4, align 4\n%5 = call i32 @spi_write(ptr noundef %0, ptr noundef nonnull %3, i32 noundef 8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %5\n}", "codegemma": "define internal i32 @ads7871_write_reg8(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca [2 x i32], align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)\nstore i32 %1, ptr %3, align 4\n%4 = getelementptr inbounds i32, ptr %3, i64 1\nstore i32 %2, ptr %4, align 4\n%5 = call i32 @spi_write(ptr noundef %0, ptr noundef nonnull %3, i32 noundef 8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)\nret i32 %5\n}"}, "define dso_local void @toggle_bell_level(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nswitch i32 %5, label %15 [\ni32 2, label %6\ni32 8, label %9\ni32 128, label %12\n]\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\nstore i32 8, ptr %8, align 4\nbr label %15\n\n9:\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 0\nstore i32 128, ptr %11, align 4\nbr label %15\n\n12:\n%13 = load ptr, ptr %2, align 8\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %13, i32 0, i32 0\nstore i32 2, ptr %14, align 4\nbr label %15\n\n15:\nret void\n}": {"base_truth": "define dso_local void @toggle_bell_level(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 2, label %B3\ni32 8, label %B1\ni32 128, label %B2\n]\n\nB1:\nbr label %B3\n\nB2:\nbr label %B3\n\nB3:\n%2 = phi i32 [ 2, %B2 ], [ 128, %B1 ], [ 8, %B ]\nstore i32 %2, ptr %0, align 4\nbr label %B4\n\nB4:\nret void\n}", "codellama": "define dso_local void @toggle_bell_level(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 2, label %B3\ni32 8, label %B1\ni32 128, label %B2\n]\n\nB1:\nbr label %B3\n\nB2:\nbr label %B3\n\nB3:\n%2 = phi i32 [ 2, %B2 ], [ 128, %B1 ], [ 8, %B ]\nstore i32 %2, ptr %0, align 4\nbr label %B4\n\nB4:\nret void\n}", "codegemma": "define dso_local void @toggle_bell_level(ptr nocapture noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\nswitch i32 %1, label %B4 [\ni32 2, label %B3\ni32 8, label %B1\ni32 128, label %B2\n]\n\nB1:\nbr label %B3\n\nB2:\nbr label %B3\n\nB3:\n%2 = phi i32 [ 128, %B2 ], [ 8, %B1 ], [ 2, %B ]\nstore i32 %2, ptr %0, align 4\nbr label %B4\n\nB4:\nret void\n}"}, "define dso_local void @push(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr %4, align 4\n%9 = call i32 @list_insert(i32 noundef %7, i32 noundef %8)\nret void\n}": {"base_truth": "define dso_local void @push(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @list_insert(i32 noundef %2, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @push(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @list_insert(i32 noundef %2, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @push(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @list_insert(i32 noundef %2, i32 noundef %1)\nret void\n}"}, "define dso_local void @CAN_SetBitRate(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\nret void\n}": {"base_truth": "define dso_local void @CAN_SetBitRate(i32 noundef %0, i32 noundef %1) {\nB:\nret void\n}", "codellama": "define dso_local void @CAN_SetBitRate(i32 noundef %0, i32 noundef %1) {\nB:\nret void\n}", "codegemma": "define dso_local void @CAN_SetBitRate(i32 noundef %0, i32 noundef %1) {\nB:\nret void\n}"}, "define dso_local void @ps_exit(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr @rd, align 4\n%4 = call i32 @ps_test_close(i32 noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = call i32 @exit(i32 noundef %5)\nunreachable\n}": {"base_truth": "define dso_local void @ps_exit(i32 noundef %0) {\nB:\n%1 = load i32, ptr @rd, align 4\n%2 = tail call i32 @ps_test_close(i32 noundef %1)\n%3 = tail call i32 @exit(i32 noundef %0)\nunreachable\n}", "codellama": "define dso_local void @ps_exit(i32 noundef %0) {\nB:\n%1 = load i32, ptr @rd, align 4\n%2 = tail call i32 @ps_test_close(i32 noundef %1)\n%3 = tail call i32 @exit(i32 noundef %0)\nunreachable\n}", "codegemma": "define dso_local void @ps_exit(i32 noundef %0) {\nB:\n%1 = load i32, ptr @rd, align 4\n%2 = tail call i32 @ps_test_close(i32 noundef %1)\n%3 = tail call i32 @exit(i32 noundef %0)\nunreachable\n}"}, "define internal i32 @calc_stride(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = zext i32 %3 to i64\n%5 = add i64 %4, 4\n%6 = trunc i64 %5 to i32\nstore i32 %6, ptr %2, align 4\n%7 = load i32, ptr %2, align 4\n%8 = zext i32 %7 to i64\n%9 = add i64 %8, 4\n%10 = sub i64 %9, 1\n%11 = and i64 %10, -4\n%12 = trunc i64 %11 to i32\nret i32 %12\n}": {"base_truth": "define internal i32 @calc_stride(i32 noundef %0) {\nB:\n%1 = add i32 %0, 7\n%2 = and i32 %1, -4\nret i32 %2\n}", "codellama": "define internal i32 @calc_stride(i32 noundef %0) {\nB:\n%1 = add i32 %0, 8\n%2 = and i32 %1, -4\nret i32 %2\n}", "codegemma": "define internal i32 @calc_stride(i32 noundef %0) {\nB:\n%1 = add i32 %0, 4\n%2 = and i32 %1, -4\nret i32 %2\n}"}, "define dso_local ptr @fn66() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call i32 (...) @rand()\n%3 = srem i32 %2, 20\n%4 = add nsw i32 20, %3\n%5 = call ptr @malloc(i32 noundef %4)\nstore ptr %5, ptr %1, align 8\n%6 = load ptr, ptr %1, align 8\n%7 = call i32 (...) @rand()\n%8 = srem i32 %7, 20\n%9 = add nsw i32 30, %8\n%10 = call ptr @realloc(ptr noundef %6, i32 noundef %9)\nstore ptr %10, ptr %1, align 8\n%11 = load ptr, ptr %1, align 8\n%12 = call i32 @strcpy(ptr noundef %11, ptr noundef @.str)\n%13 = load ptr, ptr %1, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @fn66() {\nB:\n%0 = tail call i32 (...) @rand()\n%1 = srem i32 %0, 20\n%2 = add nsw i32 %1, 20\n%3 = tail call ptr @malloc(i32 noundef %2)\n%4 = tail call i32 (...) @rand()\n%5 = srem i32 %4, 20\n%6 = add nsw i32 %5, 30\n%7 = tail call ptr @realloc(ptr noundef %3, i32 noundef %6)\n%8 = tail call i32 @strcpy(ptr noundef %7, ptr noundef nonnull @.str)\nret ptr %7\n}", "codellama": "define dso_local ptr @fn66() {\nB:\n%0 = tail call i32 (...) @rand()\n%1 = srem i32 %0, 20\n%2 = add nsw i32 %1, 20\n%3 = tail call ptr @malloc(i32 noundef %2)\n%4 = tail call i32 (...) @rand()\n%5 = srem i32 %4, 20\n%6 = add nsw i32 %5, 30\n%7 = tail call ptr @realloc(ptr noundef %3, i32 noundef %6)\n%8 = tail call i32 @strcpy(ptr noundef %7, ptr noundef nonnull @.str)\nret ptr %7\n}", "codegemma": "define dso_local ptr @fn66() {\nB:\n%0 = tail call i32 (...) @rand()\n%1 = srem i32 %0, 20\n%2 = add nsw i32 %1, 20\n%3 = tail call ptr @malloc(i32 noundef %2)\n%4 = tail call i32 (...) @rand()\n%5 = srem i32 %4, 20\n%6 = add nsw i32 %5, 30\n%7 = tail call ptr @realloc(ptr noundef %3, i32 noundef %6)\n%8 = tail call i32 @strcpy(ptr noundef %7, ptr noundef nonnull @.str)\nret ptr %7\n}"}, "define dso_local i32 @debug() {\n%1 = call i32 @printf(ptr noundef @.str)\nret i32 0\n}": {"base_truth": "define dso_local i32 @debug() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}", "codellama": "define dso_local i32 @debug() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}", "codegemma": "define dso_local i32 @debug() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 0\n}"}, "define internal i32 @haswell_get_node_id(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.sbridge_pvt ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\n%7 = load i32, ptr @SAD_CONTROL, align 4\n%8 = call i32 @pci_read_config_dword(i32 noundef %6, i32 noundef %7, ptr noundef %3)\n%9 = load i32, ptr %3, align 4\n%10 = call i32 @GET_BITFIELD(i32 noundef %9, i32 noundef 0, i32 noundef 3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %10\n}": {"base_truth": "define internal i32 @haswell_get_node_id(ptr nocapture noundef readonly %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr @SAD_CONTROL, align 4\n%4 = call i32 @pci_read_config_dword(i32 noundef %2, i32 noundef %3, ptr noundef nonnull %1)\n%5 = load i32, ptr %1, align 4\n%6 = call i32 @GET_BITFIELD(i32 noundef %5, i32 noundef 0, i32 noundef 3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %6\n}", "codellama": "define internal i32 @haswell_get_node_id(ptr nocapture noundef readonly %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr @SAD_CONTROL, align 4\n%4 = call i32 @pci_read_config_dword(i32 noundef %2, i32 noundef %3, ptr noundef nonnull %1)\n%5 = load i32, ptr %1, align 4\n%6 = call i32 @GET_BITFIELD(i32 noundef %5, i32 noundef 0, i32 noundef 3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %6\n}", "codegemma": "define internal i32 @haswell_get_node_id(ptr nocapture noundef readonly %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr @SAD_CONTROL, align 4\n%4 = call i32 @pci_read_config_dword(i32 noundef %2, i32 noundef %3, ptr noundef nonnull %1)\n%5 = load i32, ptr %1, align 4\n%6 = call i32 @GET_BITFIELD(i32 noundef %5, i32 noundef 0, i32 noundef 3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %6\n}"}, "define internal i32 @sunfire_fhc_led_probe(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @fhc_led_types, align 4\n%5 = call i32 @sunfire_led_generic_probe(ptr noundef %3, i32 noundef %4)\nret i32 %5\n}": {"base_truth": "define internal i32 @sunfire_fhc_led_probe(ptr noundef %0) {\nB:\n%1 = load i32, ptr @fhc_led_types, align 4\n%2 = tail call i32 @sunfire_led_generic_probe(ptr noundef %0, i32 noundef %1)\nret i32 %2\n}", "codellama": "define internal i32 @sunfire_fhc_led_probe(ptr noundef %0) {\nB:\n%1 = load i32, ptr @fhc_led_types, align 4\n%2 = tail call i32 @sunfire_led_generic_probe(ptr noundef %0, i32 noundef %1)\nret i32 %2\n}", "codegemma": "define internal i32 @sunfire_fhc_led_probe(ptr noundef %0) {\nB:\n%1 = load i32, ptr @fhc_led_types, align 4\n%2 = tail call i32 @sunfire_led_generic_probe(ptr noundef %0, i32 noundef %1)\nret i32 %2\n}"}, "define internal void @rv6xx_generate_low_step(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%7 = load ptr, ptr %4, align 8\n%8 = call ptr @rv6xx_get_ps(ptr noundef %7)\nstore ptr %8, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%9 = load ptr, ptr %3, align 8\n%10 = call ptr @rv6xx_get_pi(ptr noundef %9)\nstore ptr %10, ptr %6, align 8\n%11 = load ptr, ptr %6, align 8\n%12 = getelementptr inbounds %struct.rv6xx_power_info ptr %11, i32 0, i32 0\n%13 = getelementptr inbounds %struct.TYPE_3__, ptr %12, i32 0, i32 0\nstore i64 0, ptr %13, align 8\n%14 = load ptr, ptr %3, align 8\n%15 = load ptr, ptr %5, align 8\n%16 = getelementptr inbounds %struct.rv6xx_ps ptr %15, i32 0, i32 0\n%17 = getelementptr inbounds %struct.TYPE_4__, ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = call i32 @rv6xx_generate_single_step(ptr noundef %14, i32 noundef %18, i32 noundef 0)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret void\n}": {"base_truth": "define internal void @rv6xx_generate_low_step(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @rv6xx_get_ps(ptr noundef %1)\n%3 = tail call ptr @rv6xx_get_pi(ptr noundef %0)\nstore i64 0, ptr %3, align 8\n%4 = load i32, ptr %2, align 4\n%5 = tail call i32 @rv6xx_generate_single_step(ptr noundef %0, i32 noundef %4, i32 noundef 0)\nret void\n}", "codellama": "define internal void @rv6xx_generate_low_step(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @rv6xx_get_ps(ptr noundef %1)\n%3 = tail call ptr @rv6xx_get_pi(ptr noundef %0)\nstore i64 0, ptr %3, align 8\n%4 = load i32, ptr %2, align 4\n%5 = tail call i32 @rv6xx_generate_single_step(ptr noundef %0, i32 noundef %4, i32 noundef 0)\nret void\n}", "codegemma": "define internal void @rv6xx_generate_low_step(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @rv6xx_get_ps(ptr noundef %1)\n%3 = tail call ptr @rv6xx_get_pi(ptr noundef %0)\nstore i64 0, ptr %3, align 8\n%4 = load i32, ptr %2, align 4\n%5 = tail call i32 @rv6xx_generate_single_step(ptr noundef %0, i32 noundef %4, i32 noundef 0)\nret void\n}"}, "define dso_local i32 @lwes_event_set_DOUBLE(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr @LWES_TYPE_DOUBLE, align 4\n%10 = call i32 @lwes_event_set_generic(ptr noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef 4, ptr noundef %6)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @lwes_event_set_DOUBLE(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %2, ptr %3, align 4\n%4 = load i32, ptr @LWES_TYPE_DOUBLE, align 4\n%5 = call i32 @lwes_event_set_generic(ptr noundef %0, i32 noundef %1, i32 noundef %4, i32 noundef 4, ptr noundef nonnull %3)\nret i32 %5\n}", "codellama": "define dso_local i32 @lwes_event_set_DOUBLE(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %2, ptr %3, align 4\n%4 = load i32, ptr @LWES_TYPE_DOUBLE, align 4\n%5 = call i32 @lwes_event_set_generic(ptr noundef %0, i32 noundef %1, i32 noundef %4, i32 noundef 4, ptr noundef nonnull %3)\nret i32 %5\n}", "codegemma": "define dso_local i32 @lwes_event_set_DOUBLE(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %2, ptr %3, align 4\n%4 = load i32, ptr @LWES_TYPE_DOUBLE, align 4\n%5 = call i32 @lwes_event_set_generic(ptr noundef %0, i32 noundef %1, i32 noundef %4, i32 noundef 4, ptr noundef nonnull %3)\nret i32 %5\n}"}, "define dso_local i32 @os_sysfs_node_enum(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load ptr, ptr %6, align 8\n%10 = call i32 @file_int_extract(ptr noundef @.str, ptr noundef %7, i32 noundef %8, ptr noundef %9)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @os_sysfs_node_enum(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @file_int_extract(ptr noundef nonnull @.str, ptr noundef %0, i32 noundef %1, ptr noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @os_sysfs_node_enum(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @file_int_extract(ptr noundef nonnull @.str, ptr noundef %0, i32 noundef %1, ptr noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @os_sysfs_node_enum(ptr noundef %0, i32 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @file_int_extract(ptr noundef nonnull @.str, ptr noundef %0, i32 noundef %1, ptr noundef %2)\nret i32 %3\n}"}, "define dso_local void @end_group() {\n%1 = call i32 @write_test(ptr noundef @.str, ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @end_group() {\nB:\n%0 = tail call i32 @write_test(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @end_group() {\nB:\n%0 = tail call i32 @write_test(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @end_group() {\nB:\n%0 = tail call i32 @write_test(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}"}, "define dso_local i32 @inp_isedit(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @k_enter, align 4\n%6 = icmp eq i32 %4, %5\nbr i1 %6, label %19, label %7\n\n7:\n%8 = load i32, ptr %3, align 4\n%9 = load i32, ptr @k_backspace, align 4\n%10 = icmp eq i32 %8, %9\nbr i1 %10, label %19, label %11\n\n11:\n%12 = load i32, ptr %3, align 4\n%13 = load i32, ptr @k_del, align 4\n%14 = icmp eq i32 %12, %13\nbr i1 %14, label %19, label %15\n\n15:\n%16 = load i32, ptr %3, align 4\n%17 = load i32, ptr @k_insert, align 4\n%18 = icmp eq i32 %16, %17\nbr i1 %18, label %19, label %20\n\n19:\nstore i32 1, ptr %2, align 4\nbr label %21\n\n20:\nstore i32 0, ptr %2, align 4\nbr label %21\n\n21:\n%22 = load i32, ptr %2, align 4\nret i32 %22\n}": {"base_truth": "define dso_local i32 @inp_isedit(i32 noundef %0) {\nB:\n%1 = load i32, ptr @k_enter, align 4\n%2 = icmp eq i32 %1, %0\n%3 = load i32, ptr @k_backspace, align 4\n%4 = icmp eq i32 %3, %0\n%5 = select i1 %2, i1 true, i1 %4\n%6 = load i32, ptr @k_del, align 4\n%7 = icmp eq i32 %6, %0\n%8 = select i1 %5, i1 true, i1 %7\n%9 = load i32, ptr @k_insert, align 4\n%10 = icmp eq i32 %9, %0\n%11 = select i1 %8, i1 true, i1 %10\n%12 = zext i1 %11 to i32\nret i32 %12\n}", "codellama": "define dso_local i32 @inp_isedit(i32 noundef %0) {\nB:\n%1 = load i32, ptr @k_enter, align 4\n%2 = icmp eq i32 %1, %0\n%3 = load i32, ptr @k_backspace, align 4\n%4 = icmp eq i32 %3, %0\n%5 = select i1 %2, i1 true, i1 %4\n%6 = load i32, ptr @k_del, align 4\n%7 = icmp eq i32 %6, %0\n%8 = select i1 %5, i1 true, i1 %7\n%9 = load i32, ptr @k_insert, align 4\n%10 = icmp eq i32 %9, %0\n%11 = select i1 %8, i1 true, i1 %10\n%12 = zext i1 %11 to i32\nret i32 %12\n}", "codegemma": "define dso_local i32 @inp_isedit(i32 noundef %0) {\nB:\n%1 = load i32, ptr @k_enter, align 4\n%2 = icmp eq i32 %1, %0\n%3 = load i32, ptr @k_backspace, align 4\n%4 = icmp eq i32 %3, %0\n%5 = select i1 %2, i1 true, i1 %4\n%6 = load i32, ptr @k_del, align 4\n%7 = icmp eq i32 %6, %0\n%8 = select i1 %5, i1 true, i1 %7\n%9 = load i32, ptr @k_insert, align 4\n%10 = icmp eq i32 %9, %0\n%11 = select i1 %8, i1 true, i1 %10\n%12 = zext i1 %11 to i32\nret i32 %12\n}"}, "define internal void @fmt_puts(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\nbr label %7\n\n7:\n%8 = load ptr, ptr %6, align 8\n%9 = load i8, ptr %8, align 1\n%10 = icmp ne i8 %9, 0\nbr i1 %10, label %11, label %19\n\n11:\n%12 = load ptr, ptr %4, align 8\n%13 = load ptr, ptr %5, align 8\n%14 = load ptr, ptr %6, align 8\n%15 = getelementptr inbounds i8, ptr %14, i32 1\nstore ptr %15, ptr %6, align 8\n%16 = load i8, ptr %14, align 1\n%17 = sext i8 %16 to i32\n%18 = call i32 @fmt_putc(ptr noundef %12, ptr noundef %13, i32 noundef %17)\nbr label %7\n\n19:\nret void\n}": {"base_truth": "define internal void @fmt_puts(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = load i8, ptr %2, align 1\n%4 = icmp eq i8 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = phi i8 [ %10, %B1 ], [ %3, %B ]\n%6 = phi ptr [ %7, %B1 ], [ %2, %B ]\n%7 = getelementptr inbounds i8, ptr %6, i64 1\n%8 = sext i8 %5 to i32\n%9 = tail call i32 @fmt_putc(ptr noundef %0, ptr noundef %1, i32 noundef %8)\n%10 = load i8, ptr %7, align 1\n%11 = icmp eq i8 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB2:\nret void\n}", "codellama": "define internal void @fmt_puts(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = load i8, ptr %2, align 1\n%4 = icmp eq i8 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = phi i8 [ %11, %B1 ], [ %3, %B ]\n%6 = phi ptr [ %7, %B1 ], [ %2, %B ]\n%7 = getelementptr inbounds i8, ptr %6, i64 1\n%8 = sext i8 %5 to i32\n%9 = tail call i32 @fmt_putc(ptr noundef %0, ptr noundef %1, i32 noundef %8)\n%10 = load i8, ptr %7, align 1\n%11 = icmp eq i8 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB2:\nret void\n}", "codegemma": "define internal void @fmt_puts(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = load i8, ptr %2, align 1\n%4 = icmp eq i8 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = phi i8 [ %9, %B1 ], [ %3, %B ]\n%6 = phi ptr [ %7, %B1 ], [ %2, %B ]\n%7 = getelementptr inbounds i8, ptr %6, i64 1\n%8 = sext i8 %5 to i32\n%9 = tail call i32 @fmt_putc(ptr noundef %0, ptr noundef %1, i32 noundef %8)\n%10 = load i8, ptr %7, align 1\n%11 = icmp eq i8 %10, 0\nbr i1 %11, label %B2, label %B1\n\nB2:\nret void\n}"}, "define dso_local void @DynaBuf_add_value(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%7 = load i32, ptr %4, align 4\n%8 = sdiv i32 %7, 10\nstore i32 %8, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%9 = load i32, ptr %4, align 4\n%10 = srem i32 %9, 10\nstore i32 %10, ptr %6, align 4\n%11 = load i32, ptr %4, align 4\n%12 = icmp slt i32 %11, 0\nbr i1 %12, label %13, label %20\n\n13:\n%14 = load ptr, ptr %3, align 8\n%15 = call i32 @DynaBuf_append(ptr noundef %14, i8 noundef signext 45)\n%16 = load i32, ptr %5, align 4\n%17 = sub nsw i32 0, %16\nstore i32 %17, ptr %5, align 4\n%18 = load i32, ptr %6, align 4\n%19 = sub nsw i32 0, %18\nstore i32 %19, ptr %6, align 4\nbr label %20\n\n20:\n%21 = load i32, ptr %6, align 4\n%22 = icmp slt i32 %21, 0\nbr i1 %22, label %23, label %28\n\n23:\n%24 = load i32, ptr %6, align 4\n%25 = add nsw i32 %24, 10\nstore i32 %25, ptr %6, align 4\n%26 = load i32, ptr %5, align 4\n%27 = add nsw i32 %26, -1\nstore i32 %27, ptr %5, align 4\nbr label %28\n\n28:\n%29 = load i32, ptr %5, align 4\n%30 = icmp ne i32 %29, 0\nbr i1 %30, label %31, label %34\n\n31:\n%32 = load ptr, ptr %3, align 8\n%33 = load i32, ptr %5, align 4\ncall void @DynaBuf_add_value(ptr noundef %32, i32 noundef %33)\nbr label %34\n\n34:\n%35 = load ptr, ptr %3, align 8\n%36 = load i32, ptr %6, align 4\n%37 = sext i32 %36 to i64\n%38 = getelementptr inbounds [11 x i8], ptr @.str, i64 0, i64 %37\n%39 = load i8, ptr %38, align 1\n%40 = call i32 @DynaBuf_append(ptr noundef %35, i8 noundef signext %39)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @DynaBuf_add_value(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = sdiv i32 %1, 10\n%3 = srem i32 %1, 10\n%4 = icmp slt i32 %1, 0\nbr i1 %4, label %B1, label %B2\n\nB1:\n%5 = sub nsw i32 0, %3\n%6 = sub nsw i32 0, %2\n%7 = tail call i32 @DynaBuf_append(ptr noundef %0, i8 noundef signext 45)\nbr label %B2\n\nB2:\n%8 = phi i32 [ %6, %B1 ], [ %2, %B ]\n%9 = phi i32 [ %5, %B1 ], [ %3, %B ]\n%10 = ashr i32 %9, 31\n%11 = add nsw i32 %10, %8\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B4, label %B3\n\nB3:\ntail call void @DynaBuf_add_value(ptr noundef %0, i32 noundef %11)\nbr label %B4\n\nB4:\n%13 = icmp slt i32 %9, 0\n%14 = add nsw i32 %9, 10\n%15 = select i1 %13, i32 %14, i32 %9\n%16 = sext i32 %15 to i64\n%17 = getelementptr inbounds [11 x i8], ptr @.str, i64 0, i64 %16\n%18 = load i8, ptr %17, align 1\n%19 = tail call i32 @DynaBuf_append(ptr noundef %0, i8 noundef signext %18)\nret void\n}", "codellama": "define dso_local void @DynaBuf_add_value(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @DynaBuf_append(ptr noundef %0, i8 noundef signext 45)\n%4 = tail call i32 @llvm.sdiv.i32(i32 %1, i32 10)\n%5 = tail call i32 @llvm.srem.i32(i32 %1, i32 10)\n%6 = sub nsw i32 0, %4\n%7 = sub nsw i32 0, %5\n%8 = icmp eq i32 %7, 0\nbr i1 %8, label %B3, label %B2\n\nB2:\n%9 = phi i32 [ %1, %B ], [ %6, %B1 ]\n%10 = phi i32 [ %1, %B ], [ %7, %B1 ]\n%11 = icmp ult i32 %9, 10\nbr i1 %11, label %B4, label %B3\n\nB3:\n%12 = phi i32 [ %9, %B2 ], [ %6, %B1 ]\n%13 = phi i32 [ %10, %B2 ], [ %7, %B1 ]\n%14 = tail call i32 @DynaBuf_add_value(ptr noundef %0, i32 noundef %12)\nbr label %B4\n\nB4:\n%15 = phi i32 [ %13, %B3 ], [ %10, %B2 ]\n%16 = phi i32 [ %12, %B3 ], [ %13, %B2 ]\n%17 = icmp ult i32 %15, 10\nbr i1 %17, label %B6, label %B5\n\nB5:\n%18 = tail call i32 @DynaBuf_add_value(ptr noundef %0, i32 noundef %16)\nbr label %B6\n\nB6:\n%19 = sext i32 %15 to i64\n%20 = getelementptr inbounds [11 x i8], ptr @.str, i64 0, i64 %19\n%21 = load i8, ptr %20, align 1\n%22 = tail call i32 @DynaBuf_append(ptr noundef %0, i8 noundef signext %21)\nret void\n}", "codegemma": "define dso_local void @DynaBuf_add_value(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = icmp slt i32 %1, 0\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call i32 @DynaBuf_append(ptr noundef %0, i8 noundef signext 45)\nbr label %B2\n\nB2:\n%4 = phi i32 [ %1, %B ], [ -%1, %B1 ]\n%5 = icmp slt i32 %4, 0\nbr i1 %5, label %B3, label %B4\n\nB3:\n%6 = add nsw i32 %4, 10\n%7 = add nsw i32 %4, -1\nbr label %B4\n\nB4:\n%8 = phi i32 [ %6, %B3 ], [ %4, %B2 ]\n%9 = phi i32 [ %7, %B3 ], [ %4, %B2 ]\n%10 = icmp eq i32 %9, 0\nbr i1 %10, label %B6, label %B5\n\nB5:\ntail call void @DynaBuf_add_value(ptr noundef %0, i32 noundef %9)\nbr label %B6\n\nB6:\n%11 = sext i32 %8 to i64\n%12 = getelementptr inbounds [11 x i8], ptr @.str, i64 0, i64 %11\n%13 = load i8, ptr %12, align 1\n%14 = tail call i32 @DynaBuf_append(ptr noundef %0, i8 noundef signext %13)\nret void\n}"}, "define internal i32 @IFX_MEI_DMAWrite(ptr noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca i32, align 4\n%10 = alloca ptr, align 8\n%11 = alloca i32, align 4\n%12 = alloca i32, align 4\nstore ptr %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore ptr %2, ptr %8, align 8\nstore i32 %3, ptr %9, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %10)\n%13 = load ptr, ptr %8, align 8\nstore ptr %13, ptr %10, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\n%14 = load i32, ptr %7, align 4\n%15 = and i32 %14, 3\n%16 = icmp ne i32 %15, 0\nbr i1 %16, label %17, label %19\n\n17:\n%18 = load i32, ptr @DSL_DEV_MEI_ERR_FAILURE, align 4\nstore i32 %18, ptr %5, align 4\nstore i32 1, ptr %12, align 4\nbr label %47\n\n19:\n%20 = load ptr, ptr %6, align 8\n%21 = load i32, ptr @ME_DX_AD, align 4\n%22 = load i32, ptr %7, align 4\n%23 = call i32 @IFX_MEI_LongWordWriteOffset(ptr noundef %20, i32 noundef %21, i32 noundef %22)\nbr label %24\n\n24:\n%25 = load i32, ptr %9, align 4\n%26 = add nsw i32 %25, -1\nstore i32 %26, ptr %9, align 4\n%27 = icmp ne i32 %25, 0\nbr i1 %27, label %28, label %45\n\n28:\n%29 = load ptr, ptr %10, align 8\n%30 = load i32, ptr %29, align 4\nstore i32 %30, ptr %11, align 4\n%31 = load i32, ptr %7, align 4\n%32 = load i32, ptr @MEI_TO_ARC_MAILBOX, align 4\n%33 = icmp eq i32 %31, %32\nbr i1 %33, label %34, label %37\n\n34:\n%35 = load i32, ptr %11, align 4\n%36 = call i32 @MEI_HALF_WORD_SWAP(i32 noundef %35)\nbr label %37\n\n37:\n%38 = load ptr, ptr %6, align 8\n%39 = load i64, ptr @ME_DX_DATA, align 8\n%40 = trunc i64 %39 to i32\n%41 = load i32, ptr %11, align 4\n%42 = call i32 @IFX_MEI_LongWordWriteOffset(ptr noundef %38, i32 noundef %40, i32 noundef %41)\n%43 = load ptr, ptr %10, align 8\n%44 = getelementptr inbounds i32, ptr %43, i32 1\nstore ptr %44, ptr %10, align 8\nbr label %24\n\n45:\n%46 = load i32, ptr @DSL_DEV_MEI_ERR_SUCCESS, align 4\nstore i32 %46, ptr %5, align 4\nstore i32 1, ptr %12, align 4\nbr label %47\n\n47:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %10)\n%48 = load i32, ptr %5, align 4\nret i32 %48\n}": {"base_truth": "define internal i32 @IFX_MEI_DMAWrite(ptr noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2, i32 noundef %3) {\nB:\n%4 = and i32 %1, 3\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B5\n\nB1:\n%6 = load i32, ptr @ME_DX_AD, align 4\n%7 = tail call i32 @IFX_MEI_LongWordWriteOffset(ptr noundef %0, i32 noundef %6, i32 noundef %1)\n%8 = icmp eq i32 %3, 0\nbr i1 %8, label %B5, label %B2\n\nB2:\n%9 = phi i32 [ %11, %B4 ], [ %3, %B1 ]\n%10 = phi ptr [ %19, %B4 ], [ %2, %B1 ]\n%11 = add nsw i32 %9, -1\n%12 = load i32, ptr %10, align 4\n%13 = load i32, ptr @MEI_TO_ARC_MAILBOX, align 4\n%14 = icmp eq i32 %13, %1\nbr i1 %14, label %B3, label %B4\n\nB3:\n%15 = tail call i32 @MEI_HALF_WORD_SWAP(i32 noundef %12)\nbr label %B4\n\nB4:\n%16 = load i64, ptr @ME_DX_DATA, align 8\n%17 = trunc i64 %16 to i32\n%18 = tail call i32 @IFX_MEI_LongWordWriteOffset(ptr noundef %0, i32 noundef %17, i32 noundef %12)\n%19 = getelementptr inbounds i32, ptr %10, i64 1\n%20 = icmp eq i32 %11, 0\nbr i1 %20, label %B5, label %B2\n\nB5:\n%21 = phi ptr [ @DSL_DEV_MEI_ERR_FAILURE, %B ], [ @DSL_DEV_MEI_ERR_SUCCESS, %B1 ], [ @DSL_DEV_MEI_ERR_SUCCESS, %B4 ]\n%22 = load i32, ptr %21, align 4\nret i32 %22\n}", "codellama": "define internal i32 @IFX_MEI_DMAWrite(ptr noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2, i32 noundef %3) {\nB:\n%4 = and i32 %1, 3\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B5\n\nB1:\n%6 = load i32, ptr @ME_DX_AD, align 4\n%7 = tail call i32 @IFX_MEI_LongWordWriteOffset(ptr noundef %0, i32 noundef %6, i32 noundef %1)\n%8 = icmp eq i32 %3, 0\nbr i1 %8, label %B5, label %B2\n\nB2:\n%9 = phi i32 [ %17, %B4 ], [ %3, %B1 ]\n%10 = phi ptr [ %18, %B4 ], [ %2, %B1 ]\n%11 = load i32, ptr %10, align 4\n%12 = load i32, ptr @MEI_TO_ARC_MAILBOX, align 4\n%13 = icmp eq i32 %12, %1\nbr i1 %13, label %B3, label %B4\n\nB3:\n%14 = tail call i32 @MEI_HALF_WORD_SWAP(i32 noundef %11)\nbr label %B4\n\nB4:\n%15 = phi i32 [ %11, %B3 ], [ %11, %B2 ]\n%16 = load i64, ptr @MEI_TO_ARC_MAILBOX, align 8\n%17 = add nsw i32 %9, -1\n%18 = getelementptr inbounds i32, ptr %10, i64 1\n%19 = icmp eq i32 %9, 1\n%20 = select i1 %19, ptr @DSL_DEV_MEI_ERR_SUCCESS, ptr @DSL_DEV_MEI_ERR_FAILURE\nbr label %B2\n\nB5:\n%21 = phi ptr [ @DSL_DEV_MEI_ERR_SUCCESS, %B1 ], [ @DSL_DEV_MEI_ERR_FAILURE, %B ]\n%22 = load i32, ptr %21, align 4\nret i32 %22\n}", "codegemma": "define internal i32 @IFX_MEI_DMAWrite(ptr noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2, i32 noundef %3) {\nB:\n%4 = and i32 %1, 3\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B4\n\nB1:\n%6 = load i32, ptr @ME_DX_AD, align 4\n%7 = tail call i32 @IFX_MEI_LongWordWriteOffset(ptr noundef %0, i32 noundef %6, i32 noundef %1)\n%8 = icmp eq i32 %3, 0\nbr i1 %8, label %B4, label %B2\n\nB2:\n%9 = phi i32 [ %11, %B3 ], [ %3, %B1 ]\n%10 = phi ptr [ %13, %B3 ], [ %2, %B1 ]\n%11 = add nsw i32 %9, -1\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B4, label %B3\n\nB3:\n%13 = getelementptr inbounds i32, ptr %10, i64 1\n%14 = load i32, ptr %13, align 4\n%15 = load i32, ptr @MEI_TO_ARC_MAILBOX, align 4\n%16 = icmp eq i32 %15, %1\nbr i1 %16, label %B4, label %B2\n\nB4:\n%17 = phi ptr [ @DSL_DEV_MEI_ERR_FAILURE, %B ], [ @DSL_DEV_MEI_ERR_SUCCESS, %B1 ], [ @DSL_DEV_MEI_ERR_SUCCESS, %B3 ], [ @DSL_DEV_MEI_ERR_SUCCESS, %B2 ]\n%18 = load i32, ptr %17, align 4\nret i32 %18\n}"}, "define dso_local i32 @tidyAttrGetUSEMAP(i64 noundef %0) {\n%2 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\n%3 = load i64, ptr %2, align 8\n%4 = inttoptr i64 %3 to ptr\n%5 = load i32, ptr @TidyAttr_USEMAP, align 4\n%6 = call i64 @prvTidyAttrGetById(ptr noundef %4, i32 noundef %5)\n%7 = trunc i64 %6 to i32\nret i32 %7\n}": {"base_truth": "define dso_local i32 @tidyAttrGetUSEMAP(i64 noundef %0) {\nB:\n%1 = inttoptr i64 %0 to ptr\n%2 = load i32, ptr @TidyAttr_USEMAP, align 4\n%3 = tail call i64 @prvTidyAttrGetById(ptr noundef %1, i32 noundef %2)\n%4 = trunc i64 %3 to i32\nret i32 %4\n}", "codellama": "define dso_local i32 @tidyAttrGetUSEMAP(i64 noundef %0) {\nB:\n%1 = inttoptr i64 %0 to ptr\n%2 = load i32, ptr @TidyAttr_USEMAP, align 4\n%3 = tail call i64 @prvTidyAttrGetById(ptr noundef %1, i32 noundef %2)\n%4 = trunc i64 %3 to i32\nret i32 %4\n}", "codegemma": "define dso_local i32 @tidyAttrGetUSEMAP(i64 noundef %0) {\nB:\n%1 = inttoptr i64 %0 to ptr\n%2 = load i32, ptr @TidyAttr_USEMAP, align 4\n%3 = tail call i64 @prvTidyAttrGetById(ptr noundef %1, i32 noundef %2)\n%4 = trunc i64 %3 to i32\nret i32 %4\n}"}, "define internal i32 @queue_work(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = call i32 (...) @BUG()\nret i32 1\n}": {"base_truth": "define internal i32 @queue_work(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 (...) @BUG()\nret i32 1\n}", "codellama": "define internal i32 @queue_work(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 (...) @BUG()\nret i32 1\n}", "codegemma": "define internal i32 @queue_work(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 (...) @BUG()\nret i32 1\n}"}, "define internal void @edid_strchomp(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nbr label %3\n\n3:\n%4 = load ptr, ptr %2, align 8\n%5 = load i8, ptr %4, align 1\n%6 = sext i8 %5 to i32\nswitch i32 %6, label %10 [\ni32 0, label %7\ni32 13, label %8\ni32 10, label %8\n]\n\n7:\nbr label %13\n\n8:\n%9 = load ptr, ptr %2, align 8\nstore i8 0, ptr %9, align 1\nbr label %13\n\n10:\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds i8, ptr %11, i32 1\nstore ptr %12, ptr %2, align 8\nbr label %3\n\n13:\nret void\n}": {"base_truth": "define internal void @edid_strchomp(ptr nocapture noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi ptr [ %0, %B ], [ %4, %B3 ]\n%2 = load i8, ptr %1, align 1\n%3 = sext i8 %2 to i32\nswitch i32 %3, label %B3 [\ni32 0, label %B4\ni32 13, label %B2\ni32 10, label %B2\n]\n\nB2:\nstore i8 0, ptr %1, align 1\nbr label %B4\n\nB3:\n%4 = getelementptr inbounds i8, ptr %1, i64 1\nbr label %B1\n\nB4:\nret void\n}", "codellama": "define internal void @edid_strchomp(ptr nocapture noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi ptr [ %0, %B ], [ %4, %B3 ]\n%2 = load i8, ptr %1, align 1\n%3 = sext i8 %2 to i32\nswitch i32 %3, label %B3 [\ni32 0, label %B4\ni32 13, label %B2\ni32 10, label %B2\n]\n\nB2:\nstore i8 0, ptr %1, align 1\nbr label %B4\n\nB3:\n%4 = getelementptr inbounds i8, ptr %1, i64 1\nbr label %B1\n\nB4:\nret void\n}", "codegemma": "define internal void @edid_strchomp(ptr nocapture noundef %0) {\nB:\nbr label %B1\n\nB1:\n%1 = phi ptr [ %0, %B ], [ %4, %B3 ]\n%2 = load i8, ptr %1, align 1\nswitch i8 %2, label %B3 [\ni8 0, label %B4\ni8 13, label %B2\ni8 10, label %B2\n]\n\nB2:\nstore i8 0, ptr %1, align 1\nbr label %B4\n\nB3:\n%3 = getelementptr inbounds i8, ptr %1, i64 1\nbr label %B1\n\nB4:\nret void\n}"}, "define dso_local i32 @plpgsql_token_is_unreserved_keyword(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 0, ptr %4, align 4\nbr label %6\n\n6:\n%7 = load i32, ptr %4, align 4\n%8 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%9 = call i32 @lengthof(ptr noundef %8)\n%10 = icmp slt i32 %7, %9\nbr i1 %10, label %11, label %24\n\n11:\n%12 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%13 = load i32, ptr %4, align 4\n%14 = sext i32 %13 to i64\n%15 = getelementptr inbounds i32, ptr %12, i64 %14\n%16 = load i32, ptr %15, align 4\n%17 = load i32, ptr %3, align 4\n%18 = icmp eq i32 %16, %17\nbr i1 %18, label %19, label %20\n\n19:\nstore i32 1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %25\n\n20:\nbr label %21\n\n21:\n%22 = load i32, ptr %4, align 4\n%23 = add nsw i32 %22, 1\nstore i32 %23, ptr %4, align 4\nbr label %6\n\n24:\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %25\n\n25:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%26 = load i32, ptr %2, align 4\nret i32 %26\n}": {"base_truth": "define dso_local i32 @plpgsql_token_is_unreserved_keyword(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%2 = tail call i32 @lengthof(ptr noundef %1)\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B2, label %B3\n\nB1:\n%4 = add nuw nsw i64 %8, 1\n%5 = tail call i32 @lengthof(ptr noundef nonnull %9)\n%6 = sext i32 %5 to i64\n%7 = icmp slt i64 %4, %6\nbr i1 %7, label %B2, label %B3\n\nB2:\n%8 = phi i64 [ %4, %B1 ], [ 0, %B ]\n%9 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%10 = getelementptr inbounds i32, ptr %9, i64 %8\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, %0\nbr i1 %12, label %B3, label %B1\n\nB3:\n%13 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 1, %B2 ]\nret i32 %13\n}", "codellama": "define dso_local i32 @plpgsql_token_is_unreserved_keyword(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%2 = tail call i32 @lengthof(ptr noundef %1)\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B2, label %B3\n\nB1:\n%4 = add nuw nsw i64 %8, 1\n%5 = tail call i32 @lengthof(ptr noundef nonnull %9)\n%6 = sext i32 %5 to i64\n%7 = icmp slt i64 %4, %6\nbr i1 %7, label %B2, label %B3\n\nB2:\n%8 = phi i64 [ %4, %B1 ], [ 0, %B ]\n%9 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%10 = getelementptr inbounds i32, ptr %9, i64 %8\n%11 = load i32, ptr %10, align 4\n%12 = icmp eq i32 %11, %0\nbr i1 %12, label %B3, label %B1\n\nB3:\n%13 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 1, %B2 ]\nret i32 %13\n}", "codegemma": "define dso_local i32 @plpgsql_token_is_unreserved_keyword(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%2 = tail call i32 @lengthof(ptr noundef %1)\n%3 = icmp sgt i32 %2, 0\nbr i1 %3, label %B1, label %B3\n\nB1:\n%4 = phi i64 [ %8, %B2 ], [ 0, %B ]\n%5 = load ptr, ptr @UnreservedPLKeywordTokens, align 8\n%6 = getelementptr inbounds i32, ptr %5, i64 %4\n%7 = load i32, ptr %6, align 4\n%8 = add nuw nsw i64 %4, 1\n%9 = icmp eq i32 %7, %0\nbr i1 %9, label %B3, label %B2\n\nB2:\n%10 = icmp eq i64 %8, %2\nbr i1 %10, label %B3, label %B1\n\nB3:\n%11 = phi i32 [ 0, %B ], [ 0, %B2 ], [ 1, %B1 ]\nret i32 %11\n}"}, "define dso_local i32 @main() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call ptr @create(i32 noundef 10)\nstore ptr %2, ptr %1, align 8\n%3 = load ptr, ptr %1, align 8\n%4 = call i32 @print(ptr noundef %3)\n%5 = load ptr, ptr %1, align 8\n%6 = call i32 @exchange(ptr noundef %5, i32 noundef 2, i32 noundef 2)\n%7 = load ptr, ptr %1, align 8\n%8 = call i32 @print(ptr noundef %7)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr @create(i32 noundef 10)\n%1 = tail call i32 @print(ptr noundef %0)\n%2 = tail call i32 @exchange(ptr noundef %0, i32 noundef 2, i32 noundef 2)\n%3 = tail call i32 @print(ptr noundef %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr @create(i32 noundef 10)\n%1 = tail call i32 @print(ptr noundef %0)\n%2 = tail call i32 @exchange(ptr noundef %0, i32 noundef 2, i32 noundef 2)\n%3 = tail call i32 @print(ptr noundef %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr @create(i32 noundef 10)\n%1 = tail call i32 @print(ptr noundef %0)\n%2 = tail call i32 @exchange(ptr noundef %0, i32 noundef 2, i32 noundef 2)\n%3 = tail call i32 @print(ptr noundef %0)\nret i32 0\n}"}, "define dso_local void @trap_EA_Action(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr @BOTLIB_EA_ACTION, align 4\n%6 = load i32, ptr %3, align 4\n%7 = load i32, ptr %4, align 4\n%8 = call i32 @syscall(i32 noundef %5, i32 noundef %6, i32 noundef %7)\nret void\n}": {"base_truth": "define dso_local void @trap_EA_Action(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @BOTLIB_EA_ACTION, align 4\n%3 = tail call i32 @syscall(i32 noundef %2, i32 noundef %0, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @trap_EA_Action(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @BOTLIB_EA_ACTION, align 4\n%3 = tail call i32 @syscall(i32 noundef %2, i32 noundef %0, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @trap_EA_Action(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @BOTLIB_EA_ACTION, align 4\n%3 = tail call i32 @syscall(i32 noundef %2, i32 noundef %0, i32 noundef %1)\nret void\n}"}, "define dso_local i32 @s_equal(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %3, align 8\n%6 = load i64, ptr %4, align 8\n%7 = sub nsw i64 %5, %6\n%8 = call i64 @fabs(i64 noundef %7)\n%9 = load i64, ptr @epsilon, align 8\n%10 = icmp slt i64 %8, %9\n%11 = zext i1 %10 to i32\nret i32 %11\n}": {"base_truth": "define dso_local i32 @s_equal(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = sub nsw i64 %0, %1\n%3 = tail call i64 @fabs(i64 noundef %2)\n%4 = load i64, ptr @epsilon, align 8\n%5 = icmp slt i64 %3, %4\n%6 = zext i1 %5 to i32\nret i32 %6\n}", "codellama": "define dso_local i32 @s_equal(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = sub nsw i64 %0, %1\n%3 = tail call i64 @fabs(i64 noundef %2)\n%4 = load i64, ptr @epsilon, align 8\n%5 = icmp slt i64 %3, %4\n%6 = zext i1 %5 to i32\nret i32 %6\n}", "codegemma": "define dso_local i32 @s_equal(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = sub nsw i64 %0, %1\n%3 = tail call i64 @fabs(i64 noundef %2)\n%4 = load i64, ptr @epsilon, align 8\n%5 = icmp slt i64 %3, %4\n%6 = zext i1 %5 to i32\nret i32 %6\n}"}, "define dso_local i32 @KParser_port(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.TYPE_9__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call ptr @KToken_new_(i32 noundef 267, i32 noundef %8, ptr noundef @.str, i32 noundef 2048)\nstore ptr %9, ptr %5, align 8\n%10 = load ptr, ptr %3, align 8\n%11 = load ptr, ptr %4, align 8\n%12 = call i32 @KParser_readValueList(ptr noundef %10, ptr noundef %11)\n%13 = load ptr, ptr %5, align 8\n%14 = getelementptr inbounds %struct.TYPE_8__, ptr %13, i32 0, i32 0\nstore i32 %12, ptr %14, align 4\n%15 = load ptr, ptr %4, align 8\n%16 = load ptr, ptr %5, align 8\n%17 = call i32 @KFile_appendToken(ptr noundef %15, ptr noundef %16)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 1\n}": {"base_truth": "define dso_local i32 @KParser_port(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @KToken_new_(i32 noundef 267, i32 noundef %2, ptr noundef nonnull @.str, i32 noundef 2048)\n%4 = tail call i32 @KParser_readValueList(ptr noundef %0, ptr noundef nonnull %1)\nstore i32 %4, ptr %3, align 4\n%5 = tail call i32 @KFile_appendToken(ptr noundef nonnull %1, ptr noundef nonnull %3)\nret i32 1\n}", "codellama": "define dso_local i32 @KParser_port(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @KToken_new_(i32 noundef 267, i32 noundef %2, ptr noundef nonnull @.str, i32 noundef 2048)\n%4 = tail call i32 @KParser_readValueList(ptr noundef %0, ptr noundef nonnull %1)\nstore i32 %4, ptr %3, align 4\n%5 = tail call i32 @KFile_appendToken(ptr noundef nonnull %1, ptr noundef nonnull %3)\nret i32 1\n}", "codegemma": "define dso_local i32 @KParser_port(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @KToken_new_(i32 noundef 267, i32 noundef %2, ptr noundef nonnull @.str, i32 noundef 2048)\n%4 = tail call i32 @KParser_readValueList(ptr noundef %0, ptr noundef nonnull %1)\nstore i32 %4, ptr %3, align 4\n%5 = tail call i32 @KFile_appendToken(ptr noundef nonnull %1, ptr noundef nonnull %3)\nret i32 1\n}"}, "define dso_local i32 @is_allergic_to(i64 noundef %0, i32 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i32, align 4\n%5 = alloca %struct.TYPE_3__, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore i64 %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 16, ptr %5)\n%9 = load i32, ptr %4, align 4\n%10 = call i32 @get_allergens(i32 noundef %9, ptr noundef %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\nstore i32 0, ptr %7, align 4\nbr label %11\n\n11:\n%12 = load i32, ptr %7, align 4\n%13 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 0\n%14 = load i32, ptr %13, align 8\n%15 = icmp slt i32 %12, %14\nbr i1 %15, label %17, label %16\n\n16:\nstore i32 2, ptr %8, align 4\nbr label %31\n\n17:\n%18 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 1\n%19 = load ptr, ptr %18, align 8\n%20 = load i32, ptr %7, align 4\n%21 = sext i32 %20 to i64\n%22 = getelementptr inbounds i64, ptr %19, i64 %21\n%23 = load i64, ptr %22, align 8\n%24 = load i64, ptr %3, align 8\n%25 = icmp eq i64 %23, %24\nbr i1 %25, label %26, label %27\n\n26:\nstore i32 1, ptr %6, align 4\nstore i32 2, ptr %8, align 4\nbr label %31\n\n27:\nbr label %28\n\n28:\n%29 = load i32, ptr %7, align 4\n%30 = add nsw i32 %29, 1\nstore i32 %30, ptr %7, align 4\nbr label %11\n\n31:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nbr label %32\n\n32:\n%33 = getelementptr inbounds %struct.TYPE_3__, ptr %5, i32 0, i32 1\n%34 = load ptr, ptr %33, align 8\n%35 = call i32 @free(ptr noundef %34)\n%36 = load i32, ptr %6, align 4\nstore i32 1, ptr %8, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 16, ptr %5)\nret i32 %36\n}": {"base_truth": "define dso_local i32 @is_allergic_to(i64 noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %2)\n%3 = call i32 @get_allergens(i32 noundef %1, ptr noundef nonnull %2)\n%4 = load i32, ptr %2, align 8\n%5 = icmp sgt i32 %4, 0\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\n%7 = load ptr, ptr %6, align 8\nbr i1 %5, label %B1, label %B4\n\nB1:\n%8 = zext i32 %4 to i64\nbr label %B3\n\nB2:\n%9 = add nuw nsw i64 %11, 1\n%10 = icmp eq i64 %9, %8\nbr i1 %10, label %B4, label %B3\n\nB3:\n%11 = phi i64 [ 0, %B1 ], [ %9, %B2 ]\n%12 = getelementptr inbounds i64, ptr %7, i64 %11\n%13 = load i64, ptr %12, align 8\n%14 = icmp eq i64 %13, %0\nbr i1 %14, label %B4, label %B2\n\nB4:\n%15 = phi i32 [ 0, %B ], [ 1, %B3 ], [ 0, %B2 ]\n%16 = call i32 @free(ptr noundef %7)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %2)\nret i32 %15\n}", "codellama": "define dso_local i32 @is_allergic_to(i64 noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %2)\n%3 = call i32 @get_allergens(i32 noundef %1, ptr noundef nonnull %2)\n%4 = load i32, ptr %2, align 8\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B2, label %B3\n\nB1:\n%6 = add nuw nsw i64 %10, 1\n%7 = load i32, ptr %2, align 8\n%8 = sext i32 %7 to i64\n%9 = icmp slt i64 %6, %8\nbr i1 %9, label %B2, label %B3\n\nB2:\n%10 = phi i64 [ %6, %B1 ], [ 0, %B ]\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\n%12 = load ptr, ptr %11, align 8\n%13 = getelementptr inbounds i64, ptr %12, i64 %10\n%14 = load i64, ptr %13, align 8\n%15 = icmp eq i64 %14, %0\nbr i1 %15, label %B3, label %B1\n\nB3:\n%16 = phi i32 [ 0, %B ], [ 0, %B1 ], [ 1, %B2 ]\n%17 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\n%18 = load ptr, ptr %17, align 8\n%19 = call i32 @free(ptr noundef %18)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %2)\nret i32 %16\n}", "codegemma": "define dso_local i32 @is_allergic_to(i64 noundef %0, i32 noundef %1) {\nB:\n%2 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 16, ptr nonnull %2)\n%3 = call i32 @get_allergens(i32 noundef %1, ptr noundef nonnull %2)\n%4 = load i32, ptr %2, align 8\n%5 = icmp sgt i32 %4, 0\nbr i1 %5, label %B1, label %B4\n\nB1:\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\nbr label %B3\n\nB2:\n%7 = add nuw nsw i64 %11, 1\n%8 = icmp eq i64 %7, %11\nbr i1 %8, label %B4, label %B3\n\nB3:\n%9 = phi i64 [ 0, %B1 ], [ %7, %B2 ]\n%10 = load ptr, ptr %6, align 8\n%11 = getelementptr inbounds i64, ptr %10, i64 %9\n%12 = load i64, ptr %11, align 8\n%13 = icmp eq i64 %12, %0\nbr i1 %13, label %B4, label %B2\n\nB4:\n%14 = phi i32 [ 0, %B ], [ 1, %B3 ], [ 0, %B2 ]\n%15 = call i32 @free(ptr noundef nonnull %6)\ncall void @llvm.lifetime.end.p0(i64 16, ptr nonnull %2)\nret i32 %14\n}"}, "define internal void @ksz8795_w_table(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\n%10 = load i32, ptr %6, align 4\n%11 = call i32 @IND_ACC_TABLE(i32 noundef %10)\n%12 = load i32, ptr %7, align 4\n%13 = or i32 %11, %12\nstore i32 %13, ptr %9, align 4\n%14 = load ptr, ptr %5, align 8\n%15 = getelementptr inbounds %struct.ksz_device ptr %14, i32 0, i32 0\n%16 = call i32 @mutex_lock(ptr noundef %15)\n%17 = load ptr, ptr %5, align 8\n%18 = load i32, ptr @REG_IND_DATA_HI, align 4\n%19 = load i32, ptr %8, align 4\n%20 = call i32 @ksz_write64(ptr noundef %17, i32 noundef %18, i32 noundef %19)\n%21 = load ptr, ptr %5, align 8\n%22 = load i32, ptr @REG_IND_CTRL_0, align 4\n%23 = load i32, ptr %9, align 4\n%24 = call i32 @ksz_write16(ptr noundef %21, i32 noundef %22, i32 noundef %23)\n%25 = load ptr, ptr %5, align 8\n%26 = getelementptr inbounds %struct.ksz_device ptr %25, i32 0, i32 0\n%27 = call i32 @mutex_unlock(ptr noundef %26)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\nret void\n}": {"base_truth": "define internal void @ksz8795_w_table(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i32 @IND_ACC_TABLE(i32 noundef %1)\n%5 = or i32 %4, %2\n%6 = tail call i32 @mutex_lock(ptr noundef %0)\n%7 = load i32, ptr @REG_IND_DATA_HI, align 4\n%8 = tail call i32 @ksz_write64(ptr noundef %0, i32 noundef %7, i32 noundef %3)\n%9 = load i32, ptr @REG_IND_CTRL_0, align 4\n%10 = tail call i32 @ksz_write16(ptr noundef %0, i32 noundef %9, i32 noundef %5)\n%11 = tail call i32 @mutex_unlock(ptr noundef %0)\nret void\n}", "codellama": "define internal void @ksz8795_w_table(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i32 @IND_ACC_TABLE(i32 noundef %1)\n%5 = or i32 %4, %2\n%6 = tail call i32 @mutex_lock(ptr noundef %0)\n%7 = load i32, ptr @REG_IND_DATA_HI, align 4\n%8 = tail call i32 @ksz_write64(ptr noundef %0, i32 noundef %7, i32 noundef %3)\n%9 = load i32, ptr @REG_IND_CTRL_0, align 4\n%10 = tail call i32 @ksz_write16(ptr noundef %0, i32 noundef %9, i32 noundef %5)\n%11 = tail call i32 @mutex_unlock(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @ksz8795_w_table(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i32 @IND_ACC_TABLE(i32 noundef %1)\n%5 = or i32 %4, %2\n%6 = tail call i32 @mutex_lock(ptr noundef %0)\n%7 = load i32, ptr @REG_IND_DATA_HI, align 4\n%8 = tail call i32 @ksz_write64(ptr noundef %0, i32 noundef %7, i32 noundef %3)\n%9 = load i32, ptr @REG_IND_CTRL_0, align 4\n%10 = tail call i32 @ksz_write16(ptr noundef %0, i32 noundef %9, i32 noundef %5)\n%11 = tail call i32 @mutex_unlock(ptr noundef %0)\nret void\n}"}, "define dso_local void @show_asm_rules_alloc() {\n%1 = call i32 @show_allocations(ptr noundef @asm_rules_allocator)\nret void\n}": {"base_truth": "define dso_local void @show_asm_rules_alloc() {\nB:\n%0 = tail call i32 @show_allocations(ptr noundef nonnull @asm_rules_allocator)\nret void\n}", "codellama": "define dso_local void @show_asm_rules_alloc() {\nB:\n%0 = tail call i32 @show_allocations(ptr noundef nonnull @asm_rules_allocator)\nret void\n}", "codegemma": "define dso_local void @show_asm_rules_alloc() {\nB:\n%0 = tail call i32 @show_allocations(ptr noundef nonnull @asm_rules_allocator)\nret void\n}"}, "define internal i32 @mlxsw_sib_port_module_info_get(ptr noundef %0, i32 noundef %1, ptr noundef %2, ptr noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca ptr, align 8\n%10 = alloca ptr, align 8\n%11 = alloca i64, align 8\n%12 = alloca i32, align 4\n%13 = alloca i32, align 4\nstore ptr %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore ptr %2, ptr %8, align 8\nstore ptr %3, ptr %9, align 8\n%14 = load i32, ptr @MLXSW_REG_PMLP_LEN, align 4\n%15 = zext i32 %14 to i64\n%16 = call ptr @llvm.stacksave()\nstore ptr %16, ptr %10, align 8\n%17 = alloca i8, i64 %15, align 16\nstore i64 %15, ptr %11, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %12)\n%18 = load i32, ptr %7, align 4\n%19 = call i32 @mlxsw_reg_pmlp_pack(ptr noundef %17, i32 noundef %18)\n%20 = load ptr, ptr %6, align 8\n%21 = getelementptr inbounds %struct.mlxsw_sib ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = load i32, ptr @pmlp, align 4\n%24 = call i32 @MLXSW_REG(i32 noundef %23)\n%25 = call i32 @mlxsw_reg_query(i32 noundef %22, i32 noundef %24, ptr noundef %17)\nstore i32 %25, ptr %12, align 4\n%26 = load i32, ptr %12, align 4\n%27 = icmp ne i32 %26, 0\nbr i1 %27, label %28, label %30\n\n28:\n%29 = load i32, ptr %12, align 4\nstore i32 %29, ptr %5, align 4\nstore i32 1, ptr %13, align 4\nbr label %35\n\n30:\n%31 = call i32 @mlxsw_reg_pmlp_module_get(ptr noundef %17, i32 noundef 0)\n%32 = load ptr, ptr %8, align 8\nstore i32 %31, ptr %32, align 4\n%33 = call i32 @mlxsw_reg_pmlp_width_get(ptr noundef %17)\n%34 = load ptr, ptr %9, align 8\nstore i32 %33, ptr %34, align 4\nstore i32 0, ptr %5, align 4\nstore i32 1, ptr %13, align 4\nbr label %35\n\n35:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %12)\n%36 = load ptr, ptr %10, align 8\ncall void @llvm.stackrestore(ptr %36)\n%37 = load i32, ptr %5, align 4\nret i32 %37\n}": {"base_truth": "define internal i32 @mlxsw_sib_port_module_info_get(ptr nocapture noundef readonly %0, i32 noundef %1, ptr nocapture noundef writeonly %2, ptr nocapture noundef writeonly %3) {\nB:\n%4 = load i32, ptr @MLXSW_REG_PMLP_LEN, align 4\n%5 = zext i32 %4 to i64\n%6 = alloca i8, i64 %5, align 16\n%7 = call i32 @mlxsw_reg_pmlp_pack(ptr noundef nonnull %6, i32 noundef %1)\n%8 = load i32, ptr %0, align 4\n%9 = load i32, ptr @pmlp, align 4\n%10 = call i32 @MLXSW_REG(i32 noundef %9)\n%11 = call i32 @mlxsw_reg_query(i32 noundef %8, i32 noundef %10, ptr noundef nonnull %6)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = call i32 @mlxsw_reg_pmlp_module_get(ptr noundef nonnull %6, i32 noundef 0)\nstore i32 %13, ptr %2, align 4\n%14 = call i32 @mlxsw_reg_pmlp_width_get(ptr noundef nonnull %6)\nstore i32 %14, ptr %3, align 4\nbr label %B2\n\nB2:\nret i32 %11\n}", "codellama": "define internal i32 @mlxsw_sib_port_module_info_get(ptr nocapture noundef readonly %0, i32 noundef %1, ptr nocapture noundef writeonly %2, ptr nocapture noundef writeonly %3) {\nB:\n%4 = load i32, ptr @MLXSW_REG_PMLP_LEN, align 4\n%5 = zext i32 %4 to i64\n%6 = alloca i8, i64 %5, align 16\n%7 = call i32 @mlxsw_reg_pmlp_pack(ptr noundef nonnull %6, i32 noundef %1)\n%8 = load i32, ptr %0, align 4\n%9 = load i32, ptr @pmlp, align 4\n%10 = call i32 @MLXSW_REG(i32 noundef %9)\n%11 = call i32 @mlxsw_reg_query(i32 noundef %8, i32 noundef %10, ptr noundef nonnull %6)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = call i32 @mlxsw_reg_pmlp_module_get(ptr noundef nonnull %6, i32 noundef 0)\nstore i32 %13, ptr %2, align 4\n%14 = call i32 @mlxsw_reg_pmlp_width_get(ptr noundef nonnull %6)\nstore i32 %14, ptr %3, align 4\nbr label %B2\n\nB2:\nret i32 %11\n}", "codegemma": "define internal i32 @mlxsw_sib_port_module_info_get(ptr nocapture noundef readonly %0, i32 noundef %1, ptr nocapture noundef writeonly %2, ptr nocapture noundef writeonly %3) {\nB:\n%4 = load i32, ptr @MLXSW_REG_PMLP_LEN, align 4\n%5 = zext i32 %4 to i64\n%6 = alloca i8, i64 %5, align 16\n%7 = call i32 @mlxsw_reg_pmlp_pack(ptr noundef nonnull %6, i32 noundef %1)\n%8 = load i32, ptr %0, align 4\n%9 = load i32, ptr @pmlp, align 4\n%10 = call i32 @MLXSW_REG(i32 noundef %9)\n%11 = call i32 @mlxsw_reg_query(i32 noundef %8, i32 noundef %10, ptr noundef nonnull %6)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B1, label %B2\n\nB1:\n%13 = call i32 @mlxsw_reg_pmlp_module_get(ptr noundef nonnull %6, i32 noundef 0)\nstore i32 %13, ptr %2, align 4\n%14 = call i32 @mlxsw_reg_pmlp_width_get(ptr noundef nonnull %6)\nstore i32 %14, ptr %3, align 4\nbr label %B2\n\nB2:\nret i32 %11\n}"}, "define dso_local void @kdb_iter_del(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @xfree(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @kdb_iter_del(ptr noundef %0) {\nB:\n%1 = tail call i32 @xfree(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @kdb_iter_del(ptr noundef %0) {\nB:\n%1 = tail call i32 @xfree(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @kdb_iter_del(ptr noundef %0) {\nB:\n%1 = tail call i32 @xfree(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @bdw_get_pipemisc_bpp(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.intel_crtc ptr %7, i32 0, i32 1\n%9 = getelementptr inbounds %struct.TYPE_2__, ptr %8, i32 0, i32 0\n%10 = load i32, ptr %9, align 4\n%11 = call ptr @to_i915(i32 noundef %10)\nstore ptr %11, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.intel_crtc ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 4\n%15 = call i32 @PIPEMISC(i32 noundef %14)\n%16 = call i32 @I915_READ(i32 noundef %15)\nstore i32 %16, ptr %5, align 4\n%17 = load i32, ptr %5, align 4\n%18 = load i32, ptr @PIPEMISC_DITHER_BPC_MASK, align 4\n%19 = and i32 %17, %18\nswitch i32 %19, label %24 [\ni32 129, label %20\ni32 128, label %21\ni32 131, label %22\ni32 130, label %23\n]\n\n20:\nstore i32 18, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %27\n\n21:\nstore i32 24, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %27\n\n22:\nstore i32 30, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %27\n\n23:\nstore i32 36, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %27\n\n24:\n%25 = load i32, ptr %5, align 4\n%26 = call i32 @MISSING_CASE(i32 noundef %25)\nstore i32 0, ptr %2, align 4\nstore i32 1, ptr %6, align 4\nbr label %27\n\n27:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%28 = load i32, ptr %2, align 4\nret i32 %28\n}": {"base_truth": "define dso_local i32 @bdw_get_pipemisc_bpp(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.intel_crtc, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @to_i915(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @PIPEMISC(i32 noundef %4)\n%6 = tail call i32 @I915_READ(i32 noundef %5)\n%7 = load i32, ptr @PIPEMISC_DITHER_BPC_MASK, align 4\n%8 = and i32 %7, %6\n%9 = add i32 %8, -128\n%10 = icmp ult i32 %9, 4\nbr i1 %10, label %B2, label %B1\n\nB1:\n%11 = tail call i32 @MISSING_CASE(i32 noundef %6)\nbr label %B3\n\nB2:\n%12 = sext i32 %9 to i64\n%13 = getelementptr inbounds [4 x i32], ptr @switch.table.bdw_get_pipemisc_bpp, i64 0, i64 %12\n%14 = load i32, ptr %13, align 4\nbr label %B3\n\nB3:\n%15 = phi i32 [ 0, %B1 ], [ %14, %B2 ]\nret i32 %15\n}", "codellama": "define dso_local i32 @bdw_get_pipemisc_bpp(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.intel_crtc, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @to_i915(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @PIPEMISC(i32 noundef %4)\n%6 = tail call i32 @I915_READ(i32 noundef %5)\n%7 = load i32, ptr @PIPEMISC_DITHER_BPC_MASK, align 4\n%8 = and i32 %7, %6\n%9 = add i32 %8, -128\n%10 = icmp ult i32 %9, 4\nbr i1 %10, label %B2, label %B1\n\nB1:\n%11 = tail call i32 @MISSING_CASE(i32 noundef %6)\nbr label %B3\n\nB2:\n%12 = sext i32 %9 to i64\n%13 = getelementptr inbounds [4 x i32], ptr @switch.table.bdw_get_pipemisc_bpp, i64 0, i64 %12\n%14 = load i32, ptr %13, align 4\nbr label %B3\n\nB3:\n%15 = phi i32 [ 0, %B1 ], [ %14, %B2 ]\nret i32 %15\n}", "codegemma": "define dso_local i32 @bdw_get_pipemisc_bpp(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.intel_crtc, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call ptr @to_i915(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @PIPEMISC(i32 noundef %4)\n%6 = tail call i32 @I915_READ(i32 noundef %5)\n%7 = load i32, ptr @PIPEMISC_DITHER_BPC_MASK, align 4\n%8 = and i32 %7, %6\nswitch i32 %8, label %B4 [\ni32 129, label %B5\ni32 128, label %B1\ni32 131, label %B2\ni32 130, label %B3\n]\n\nB1:\nbr label %B5\n\nB2:\nbr label %B5\n\nB3:\nbr label %B5\n\nB4:\n%9 = tail call i32 @MISSING_CASE(i32 noundef %6)\nbr label %B5\n\nB5:\n%10 = phi i32 [ 0, %B4 ], [ 36, %B3 ], [ 30, %B2 ], [ 24, %B1 ], [ 18, %B ]\nret i32 %10\n}"}, "define internal void @write_e7000(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load i32, ptr @e7000_desc, align 4\n%4 = load ptr, ptr %2, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @strlen(ptr noundef %5)\n%7 = call i32 @serial_write(i32 noundef %3, ptr noundef %4, i32 noundef %6)\nret void\n}": {"base_truth": "define internal void @write_e7000(ptr noundef %0) {\nB:\n%1 = load i32, ptr @e7000_desc, align 4\n%2 = tail call i32 @strlen(ptr noundef %0)\n%3 = tail call i32 @serial_write(i32 noundef %1, ptr noundef %0, i32 noundef %2)\nret void\n}", "codellama": "define internal void @write_e7000(ptr noundef %0) {\nB:\n%1 = load i32, ptr @e7000_desc, align 4\n%2 = tail call i32 @strlen(ptr noundef %0)\n%3 = tail call i32 @serial_write(i32 noundef %1, ptr noundef %0, i32 noundef %2)\nret void\n}", "codegemma": "define internal void @write_e7000(ptr noundef %0) {\nB:\n%1 = load i32, ptr @e7000_desc, align 4\n%2 = tail call i32 @strlen(ptr noundef %0)\n%3 = tail call i32 @serial_write(i32 noundef %1, ptr noundef %0, i32 noundef %2)\nret void\n}"}, "define dso_local void @rain_ext_int_abs(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = load i32, ptr @INT, align 4\n%7 = call i64 @BOX_ISNT(ptr noundef %5, i32 noundef %6)\n%8 = icmp ne i64 %7, 0\nbr i1 %8, label %9, label %12\n\n9:\n%10 = load i32, ptr @rain_exc_arg_mismatch, align 4\n%11 = call i32 @rain_panic(i32 noundef %10)\nbr label %12\n\n12:\n%13 = load ptr, ptr %3, align 8\n%14 = load ptr, ptr %4, align 8\n%15 = getelementptr inbounds %struct.TYPE_8__, ptr %14, i32 0, i32 0\n%16 = getelementptr inbounds %struct.TYPE_7__, ptr %15, i32 0, i32 0\n%17 = load i32, ptr %16, align 4\n%18 = call i32 @labs(i32 noundef %17)\n%19 = call i32 @rain_set_int(ptr noundef %13, i32 noundef %18)\nret void\n}": {"base_truth": "define dso_local void @rain_ext_int_abs(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @INT, align 4\n%3 = tail call i64 @BOX_ISNT(ptr noundef %1, i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @rain_exc_arg_mismatch, align 4\n%6 = tail call i32 @rain_panic(i32 noundef %5)\nbr label %B2\n\nB2:\n%7 = load i32, ptr %1, align 4\n%8 = tail call i32 @llvm.abs.i32(i32 %7, i1 true)\n%9 = tail call i32 @rain_set_int(ptr noundef %0, i32 noundef %8)\nret void\n}", "codellama": "define dso_local void @rain_ext_int_abs(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @INT, align 4\n%3 = tail call i64 @BOX_ISNT(ptr noundef %1, i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @rain_exc_arg_mismatch, align 4\n%6 = tail call i32 @rain_panic(i32 noundef %5)\nbr label %B2\n\nB2:\n%7 = load i32, ptr %1, align 4\n%8 = tail call i32 @llvm.abs.i32(i32 %7, i1 true)\n%9 = tail call i32 @rain_set_int(ptr noundef %0, i32 noundef %8)\nret void\n}", "codegemma": "define dso_local void @rain_ext_int_abs(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @INT, align 4\n%3 = tail call i64 @BOX_ISNT(ptr noundef %1, i32 noundef %2)\n%4 = icmp eq i64 %3, 0\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = load i32, ptr @rain_exc_arg_mismatch, align 4\n%6 = tail call i32 @rain_panic(i32 noundef %5)\nbr label %B2\n\nB2:\n%7 = load i32, ptr %1, align 4\n%8 = tail call i32 @labs(i32 noundef %7)\n%9 = tail call i32 @rain_set_int(ptr noundef %0, i32 noundef %8)\nret void\n}"}, "define dso_local i32 @byte_buf_append_byte_buf(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.byte_buf ptr %6, i32 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.byte_buf ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = call i32 @byte_buf_append_bytes(ptr noundef %5, i32 noundef %8, i32 noundef %11)\nret i32 %12\n}": {"base_truth": "define dso_local i32 @byte_buf_append_byte_buf(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = getelementptr inbounds %struct.byte_buf, ptr %1, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @byte_buf_append_bytes(ptr noundef %0, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}", "codellama": "define dso_local i32 @byte_buf_append_byte_buf(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = getelementptr inbounds %struct.byte_buf, ptr %1, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @byte_buf_append_bytes(ptr noundef %0, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}", "codegemma": "define dso_local i32 @byte_buf_append_byte_buf(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = getelementptr inbounds %struct.byte_buf, ptr %1, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @byte_buf_append_bytes(ptr noundef %0, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}"}, "define internal void @property_defn_free(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @ossl_property_free(i32 noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @OPENSSL_free(ptr noundef %7)\nret void\n}": {"base_truth": "define internal void @property_defn_free(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @ossl_property_free(i32 noundef %1)\n%3 = tail call i32 @OPENSSL_free(ptr noundef nonnull %0)\nret void\n}", "codellama": "define internal void @property_defn_free(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @ossl_property_free(i32 noundef %1)\n%3 = tail call i32 @OPENSSL_free(ptr noundef nonnull %0)\nret void\n}", "codegemma": "define internal void @property_defn_free(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @ossl_property_free(i32 noundef %1)\n%3 = tail call i32 @OPENSSL_free(ptr noundef nonnull %0)\nret void\n}"}, "define dso_local void @VIRTUAL_parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @parser__ReduceAction91__action(ptr noundef %5, ptr noundef %6)\nbr label %8\n\n8:\nret void\n}": {"base_truth": "define dso_local void @VIRTUAL_parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @VIRTUAL_parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @VIRTUAL_parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @parser__ReduceAction91__action(ptr noundef %0, ptr noundef %1)\nret void\n}"}, "define dso_local void @native_machine_crash_shutdown(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 (...) @local_irq_disable()\n%4 = call i32 (...) @crash_smp_send_stop()\n%5 = call i32 (...) @cpu_crash_vmclear_loaded_vmcss()\n%6 = call i32 (...) @cpu_emergency_vmxoff()\n%7 = call i32 (...) @cpu_emergency_svm_disable()\n%8 = call i32 (...) @cpu_emergency_stop_pt()\n%9 = call i32 (...) @lapic_shutdown()\n%10 = call i32 (...) @restore_boot_irq_mode()\n%11 = load ptr, ptr %2, align 8\n%12 = call i32 (...) @safe_smp_processor_id()\n%13 = call i32 @crash_save_cpu(ptr noundef %11, i32 noundef %12)\nret void\n}": {"base_truth": "define dso_local void @native_machine_crash_shutdown(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @local_irq_disable()\n%2 = tail call i32 (...) @crash_smp_send_stop()\n%3 = tail call i32 (...) @cpu_crash_vmclear_loaded_vmcss()\n%4 = tail call i32 (...) @cpu_emergency_vmxoff()\n%5 = tail call i32 (...) @cpu_emergency_svm_disable()\n%6 = tail call i32 (...) @cpu_emergency_stop_pt()\n%7 = tail call i32 (...) @lapic_shutdown()\n%8 = tail call i32 (...) @restore_boot_irq_mode()\n%9 = tail call i32 (...) @safe_smp_processor_id()\n%10 = tail call i32 @crash_save_cpu(ptr noundef %0, i32 noundef %9)\nret void\n}", "codellama": "define dso_local void @native_machine_crash_shutdown(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @local_irq_disable()\n%2 = tail call i32 (...) @crash_smp_send_stop()\n%3 = tail call i32 (...) @cpu_crash_vmclear_loaded_vmcss()\n%4 = tail call i32 (...) @cpu_emergency_vmxoff()\n%5 = tail call i32 (...) @cpu_emergency_svm_disable()\n%6 = tail call i32 (...) @cpu_emergency_stop_pt()\n%7 = tail call i32 (...) @lapic_shutdown()\n%8 = tail call i32 (...) @restore_boot_irq_mode()\n%9 = tail call i32 (...) @safe_smp_processor_id()\n%10 = tail call i32 @crash_save_cpu(ptr noundef %0, i32 noundef %9)\nret void\n}", "codegemma": "define dso_local void @native_machine_crash_shutdown(ptr noundef %0) {\nB:\n%1 = tail call i32 (...) @local_irq_disable()\n%2 = tail call i32 (...) @crash_smp_send_stop()\n%3 = tail call i32 (...) @cpu_crash_vmclear_loaded_vmcss()\n%4 = tail call i32 (...) @cpu_emergency_vmxoff()\n%5 = tail call i32 (...) @cpu_emergency_svm_disable()\n%6 = tail call i32 (...) @cpu_emergency_stop_pt()\n%7 = tail call i32 (...) @lapic_shutdown()\n%8 = tail call i32 (...) @restore_boot_irq_mode()\n%9 = tail call i32 (...) @safe_smp_processor_id()\n%10 = tail call i32 @crash_save_cpu(ptr noundef %0, i32 noundef %9)\nret void\n}"}, "define dso_local void @rds_ib_dev_put(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.rds_ib_device ptr %3, i32 0, i32 1\n%5 = call i64 @atomic_read(ptr noundef %4)\n%6 = icmp sle i64 %5, 0\n%7 = zext i1 %6 to i32\n%8 = call i32 @BUG_ON(i32 noundef %7)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.rds_ib_device ptr %9, i32 0, i32 1\n%11 = call i64 @atomic_dec_and_test(ptr noundef %10)\n%12 = icmp ne i64 %11, 0\nbr i1 %12, label %13, label %18\n\n13:\n%14 = load i32, ptr @rds_wq, align 4\n%15 = load ptr, ptr %2, align 8\n%16 = getelementptr inbounds %struct.rds_ib_device ptr %15, i32 0, i32 0\n%17 = call i32 @queue_work(i32 noundef %14, ptr noundef %16)\nbr label %18\n\n18:\nret void\n}": {"base_truth": "define dso_local void @rds_ib_dev_put(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.rds_ib_device, ptr %0, i64 0, i32 1\n%2 = tail call i64 @atomic_read(ptr noundef nonnull %1)\n%3 = icmp slt i64 %2, 1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @BUG_ON(i32 noundef %4)\n%6 = tail call i64 @atomic_dec_and_test(ptr noundef nonnull %1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @rds_wq, align 4\n%9 = tail call i32 @queue_work(i32 noundef %8, ptr noundef %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @rds_ib_dev_put(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.rds_ib_device, ptr %0, i64 0, i32 1\n%2 = tail call i64 @atomic_read(ptr noundef nonnull %1)\n%3 = icmp slt i64 %2, 1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @BUG_ON(i32 noundef %4)\n%6 = tail call i64 @atomic_dec_and_test(ptr noundef nonnull %1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @rds_wq, align 4\n%9 = tail call i32 @queue_work(i32 noundef %8, ptr noundef %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @rds_ib_dev_put(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.rds_ib_device, ptr %0, i64 0, i32 1\n%2 = tail call i64 @atomic_read(ptr noundef nonnull %1)\n%3 = icmp slt i64 %2, 1\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @BUG_ON(i32 noundef %4)\n%6 = tail call i64 @atomic_dec_and_test(ptr noundef nonnull %1)\n%7 = icmp eq i64 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @rds_wq, align 4\n%9 = tail call i32 @queue_work(i32 noundef %8, ptr noundef %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local void @printnode(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\n%12 = call i32 @printf(ptr noundef @.str, i32 noundef %5, i32 noundef %8, i32 noundef %11)\nret void\n}": {"base_truth": "define dso_local void @printnode(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %2, i32 noundef %4)\nret void\n}", "codellama": "define dso_local void @printnode(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %2, i32 noundef %4)\nret void\n}", "codegemma": "define dso_local void @printnode(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %2, i32 noundef %4)\nret void\n}"}, "define dso_local void @deinit_builtin_commands() {\n%1 = load i32, ptr @cmd_map, align 4\n%2 = call i32 @trie_free(i32 noundef %1)\nret void\n}": {"base_truth": "define dso_local void @deinit_builtin_commands() {\nB:\n%0 = load i32, ptr @cmd_map, align 4\n%1 = tail call i32 @trie_free(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @deinit_builtin_commands() {\nB:\n%0 = load i32, ptr @cmd_map, align 4\n%1 = tail call i32 @trie_free(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @deinit_builtin_commands() {\nB:\n%0 = load i32, ptr @cmd_map, align 4\n%1 = tail call i32 @trie_free(i32 noundef %0)\nret void\n}"}, "define internal i32 @compute_yday(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 2\n%5 = load i32, ptr %4, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = sub nsw i64 %8, 1\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 8\n%13 = call i32 @rtc_year_days(i32 noundef %5, i64 noundef %9, i32 noundef %12)\nret i32 %13\n}": {"base_truth": "define internal i32 @compute_yday(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%2 = load i32, ptr %1, align 8\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%4 = load i64, ptr %3, align 8\n%5 = add nsw i64 %4, -1\n%6 = load i32, ptr %0, align 8\n%7 = tail call i32 @rtc_year_days(i32 noundef %2, i64 noundef %5, i32 noundef %6)\nret i32 %7\n}", "codellama": "define internal i32 @compute_yday(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%2 = load i32, ptr %1, align 8\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%4 = load i64, ptr %3, align 8\n%5 = add nsw i64 %4, -1\n%6 = load i32, ptr %0, align 8\n%7 = tail call i32 @rtc_year_days(i32 noundef %2, i64 noundef %5, i32 noundef %6)\nret i32 %7\n}", "codegemma": "define internal i32 @compute_yday(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 2\n%2 = load i32, ptr %1, align 8\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %0, i64 0, i32 1\n%4 = load i64, ptr %3, align 8\n%5 = add nsw i64 %4, -1\n%6 = load i32, ptr %0, align 8\n%7 = tail call i32 @rtc_year_days(i32 noundef %2, i64 noundef %5, i32 noundef %6)\nret i32 %7\n}"}, "define internal void @mvneta_bm_config_clear(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%8 = call i32 @mvneta_bm_read(ptr noundef %6, i32 noundef %7)\nstore i32 %8, ptr %5, align 4\n%9 = load i32, ptr %4, align 4\n%10 = xor i32 %9, -1\n%11 = load i32, ptr %5, align 4\n%12 = and i32 %11, %10\nstore i32 %12, ptr %5, align 4\n%13 = load ptr, ptr %3, align 8\n%14 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%15 = load i32, ptr %5, align 4\n%16 = call i32 @mvneta_bm_write(ptr noundef %13, i32 noundef %14, i32 noundef %15)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define internal void @mvneta_bm_config_clear(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%3 = tail call i32 @mvneta_bm_read(ptr noundef %0, i32 noundef %2)\n%4 = xor i32 %1, -1\n%5 = and i32 %3, %4\n%6 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%7 = tail call i32 @mvneta_bm_write(ptr noundef %0, i32 noundef %6, i32 noundef %5)\nret void\n}", "codellama": "define internal void @mvneta_bm_config_clear(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%3 = tail call i32 @mvneta_bm_read(ptr noundef %0, i32 noundef %2)\n%4 = xor i32 %1, -1\n%5 = and i32 %3, %4\n%6 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%7 = tail call i32 @mvneta_bm_write(ptr noundef %0, i32 noundef %6, i32 noundef %5)\nret void\n}", "codegemma": "define internal void @mvneta_bm_config_clear(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%3 = tail call i32 @mvneta_bm_read(ptr noundef %0, i32 noundef %2)\n%4 = xor i32 %1, -1\n%5 = and i32 %3, %4\n%6 = load i32, ptr @MVNETA_BM_CONFIG_REG, align 4\n%7 = tail call i32 @mvneta_bm_write(ptr noundef %0, i32 noundef %6, i32 noundef %5)\nret void\n}"}, "define dso_local void @BitString32_destroy(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @Memory_free(i32 noundef %3)\nret void\n}": {"base_truth": "define dso_local void @BitString32_destroy(i32 noundef %0) {\nB:\n%1 = tail call i32 @Memory_free(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @BitString32_destroy(i32 noundef %0) {\nB:\n%1 = tail call i32 @Memory_free(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @BitString32_destroy(i32 noundef %0) {\nB:\n%1 = tail call i32 @Memory_free(i32 noundef %0)\nret void\n}"}, "define dso_local ptr @eap_ikev2_build_frag_ack(i32 noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%8 = load i32, ptr @EAP_VENDOR_IETF, align 4\n%9 = load i32, ptr @EAP_TYPE_IKEV2, align 4\n%10 = load i32, ptr %5, align 4\n%11 = load i32, ptr %4, align 4\n%12 = call ptr @eap_msg_alloc(i32 noundef %8, i32 noundef %9, i32 noundef 0, i32 noundef %10, i32 noundef %11)\nstore ptr %12, ptr %6, align 8\n%13 = load ptr, ptr %6, align 8\n%14 = icmp eq ptr %13, null\nbr i1 %14, label %15, label %18\n\n15:\n%16 = load i32, ptr @MSG_ERROR, align 4\n%17 = call i32 @wpa_printf(i32 noundef %16, ptr noundef @.str)\nstore ptr null, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %22\n\n18:\n%19 = load i32, ptr @MSG_DEBUG, align 4\n%20 = call i32 @wpa_printf(i32 noundef %19, ptr noundef @.str.1)\n%21 = load ptr, ptr %6, align 8\nstore ptr %21, ptr %3, align 8\nstore i32 1, ptr %7, align 4\nbr label %22\n\n22:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%23 = load ptr, ptr %3, align 8\nret ptr %23\n}": {"base_truth": "define dso_local ptr @eap_ikev2_build_frag_ack(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @EAP_VENDOR_IETF, align 4\n%3 = load i32, ptr @EAP_TYPE_IKEV2, align 4\n%4 = tail call ptr @eap_msg_alloc(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %1, i32 noundef %0)\n%5 = icmp eq ptr %4, null\n%6 = select i1 %5, ptr @.str, ptr @.str.1\n%7 = load i32, ptr @MSG_ERROR, align 4\n%8 = load i32, ptr @MSG_DEBUG, align 4\n%9 = select i1 %5, i32 %7, i32 %8\n%10 = tail call i32 @wpa_printf(i32 noundef %9, ptr noundef nonnull %6)\nret ptr %4\n}", "codellama": "define dso_local ptr @eap_ikev2_build_frag_ack(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @EAP_VENDOR_IETF, align 4\n%3 = load i32, ptr @EAP_TYPE_IKEV2, align 4\n%4 = tail call ptr @eap_msg_alloc(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %1, i32 noundef %0)\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = load i32, ptr @MSG_ERROR, align 4\n%7 = tail call i32 @wpa_printf(i32 noundef %6, ptr noundef nonnull @.str)\nbr label %B3\n\nB2:\n%8 = load i32, ptr @MSG_DEBUG, align 4\n%9 = tail call i32 @wpa_printf(i32 noundef %8, ptr noundef nonnull @.str.1)\nbr label %B3\n\nB3:\nret ptr %4\n}", "codegemma": "define dso_local ptr @eap_ikev2_build_frag_ack(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @EAP_VENDOR_IETF, align 4\n%3 = load i32, ptr @EAP_TYPE_IKEV2, align 4\n%4 = tail call ptr @eap_msg_alloc(i32 noundef %2, i32 noundef %3, i32 noundef 0, i32 noundef %1, i32 noundef %0)\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = load i32, ptr @MSG_ERROR, align 4\n%7 = tail call i32 @wpa_printf(i32 noundef %6, ptr noundef nonnull @.str)\nbr label %B3\n\nB2:\n%8 = load i32, ptr @MSG_DEBUG, align 4\n%9 = tail call i32 @wpa_printf(i32 noundef %8, ptr noundef nonnull @.str.1)\nbr label %B3\n\nB3:\nret ptr %4\n}"}, "define dso_local ptr @settings_new() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call ptr @malloc(i32 noundef 16)\nstore ptr %2, ptr %1, align 8\n%3 = load ptr, ptr %1, align 8\n%4 = getelementptr inbounds %struct.Settings ptr %3, i32 0, i32 0\nstore i32 -1, ptr %4, align 4\n%5 = load ptr, ptr %1, align 8\n%6 = getelementptr inbounds %struct.Settings ptr %5, i32 0, i32 1\nstore i32 -1, ptr %6, align 4\n%7 = load ptr, ptr %1, align 8\n%8 = getelementptr inbounds %struct.Settings ptr %7, i32 0, i32 2\nstore i32 -1, ptr %8, align 4\n%9 = load ptr, ptr %1, align 8\n%10 = getelementptr inbounds %struct.Settings ptr %9, i32 0, i32 3\nstore i32 -1, ptr %10, align 4\n%11 = load ptr, ptr %1, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %11\n}": {"base_truth": "define dso_local ptr @settings_new() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 16)\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(16) %0, i8 -1, i64 16, i1 false)\nret ptr %0\n}", "codellama": "define dso_local ptr @settings_new() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 16)\nstore <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, ptr %0, align 4\nret ptr %0\n}", "codegemma": "define dso_local ptr @settings_new() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 16)\nstore i32 -1, ptr %0, align 4\n%1 = getelementptr inbounds %struct.Settings, ptr %0, i64 0, i32 1\nstore i32 -1, ptr %1, align 4\n%2 = getelementptr inbounds %struct.Settings, ptr %0, i64 0, i32 2\nstore i32 -1, ptr %2, align 4\n%3 = getelementptr inbounds %struct.Settings, ptr %0, i64 0, i32 3\nstore i32 -1, ptr %3, align 4\nret ptr %0\n}"}, "define dso_local void @xlPutStr(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\nbr label %5\n\n5:\n%6 = load ptr, ptr %4, align 8\n%7 = load i8, ptr %6, align 1\n%8 = icmp ne i8 %7, 0\nbr i1 %8, label %9, label %16\n\n9:\n%10 = load i32, ptr %3, align 4\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds i8, ptr %11, i32 1\nstore ptr %12, ptr %4, align 8\n%13 = load i8, ptr %11, align 1\n%14 = sext i8 %13 to i32\n%15 = call i32 @xlPutC(i32 noundef %10, i32 noundef %14)\nbr label %5\n\n16:\nret void\n}": {"base_truth": "define dso_local void @xlPutStr(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i8, ptr %1, align 1\n%3 = icmp eq i8 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = phi i8 [ %9, %B1 ], [ %2, %B ]\n%5 = phi ptr [ %6, %B1 ], [ %1, %B ]\n%6 = getelementptr inbounds i8, ptr %5, i64 1\n%7 = sext i8 %4 to i32\n%8 = tail call i32 @xlPutC(i32 noundef %0, i32 noundef %7)\n%9 = load i8, ptr %6, align 1\n%10 = icmp eq i8 %9, 0\nbr i1 %10, label %B2, label %B1\n\nB2:\nret void\n}", "codellama": "define dso_local void @xlPutStr(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i8, ptr %1, align 1\n%3 = icmp eq i8 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = phi i8 [ %9, %B1 ], [ %2, %B ]\n%5 = phi ptr [ %7, %B1 ], [ %1, %B ]\n%6 = sext i8 %4 to i32\n%7 = getelementptr inbounds i8, ptr %5, i64 1\n%8 = tail call i32 @xlPutC(i32 noundef %0, i32 noundef %6)\n%9 = load i8, ptr %7, align 1\n%10 = icmp eq i8 %9, 0\nbr i1 %10, label %B2, label %B1\n\nB2:\nret void\n}", "codegemma": "define dso_local void @xlPutStr(i32 noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i8, ptr %1, align 1\n%3 = icmp eq i8 %2, 0\nbr i1 %3, label %B2, label %B1\n\nB1:\n%4 = phi i8 [ %9, %B1 ], [ %2, %B ]\n%5 = phi ptr [ %6, %B1 ], [ %1, %B ]\n%6 = getelementptr inbounds i8, ptr %5, i64 1\n%7 = sext i8 %4 to i32\n%8 = tail call i32 @xlPutC(i32 noundef %0, i32 noundef %7)\n%9 = load i8, ptr %6, align 1\n%10 = icmp eq i8 %9, 0\nbr i1 %10, label %B2, label %B1\n\nB2:\nret void\n}"}, "define dso_local void @Dequeue_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @DoublyList_init(ptr noundef %3)\nret void\n}": {"base_truth": "define dso_local void @Dequeue_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @DoublyList_init(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @Dequeue_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @DoublyList_init(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @Dequeue_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @DoublyList_init(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @GlobalsDeinit() {\n%1 = load i32, ptr @g_pool, align 4\n%2 = call i32 @free(i32 noundef %1)\n%3 = load i32, ptr @g_tuplespace, align 4\n%4 = call i32 @free(i32 noundef %3)\n%5 = call i32 (...) @closelog()\nret i32 0\n}": {"base_truth": "define dso_local i32 @GlobalsDeinit() {\nB:\n%0 = load i32, ptr @g_pool, align 4\n%1 = tail call i32 @free(i32 noundef %0)\n%2 = load i32, ptr @g_tuplespace, align 4\n%3 = tail call i32 @free(i32 noundef %2)\n%4 = tail call i32 (...) @closelog()\nret i32 0\n}", "codellama": "define dso_local i32 @GlobalsDeinit() {\nB:\n%0 = load i32, ptr @g_pool, align 4\n%1 = tail call i32 @free(i32 noundef %0)\n%2 = load i32, ptr @g_tuplespace, align 4\n%3 = tail call i32 @free(i32 noundef %2)\n%4 = tail call i32 (...) @closelog()\nret i32 0\n}", "codegemma": "define dso_local i32 @GlobalsDeinit() {\nB:\n%0 = load i32, ptr @g_pool, align 4\n%1 = tail call i32 @free(i32 noundef %0)\n%2 = load i32, ptr @g_tuplespace, align 4\n%3 = tail call i32 @free(i32 noundef %2)\n%4 = tail call i32 (...) @closelog()\nret i32 0\n}"}, "define internal i32 @prog_dmabuf_dac(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @stop_dac(ptr noundef %3)\n%5 = load ptr, ptr %2, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.au1550_state ptr %6, i32 0, i32 0\n%8 = call i32 @prog_dmabuf(ptr noundef %5, ptr noundef %7)\nret i32 %8\n}": {"base_truth": "define internal i32 @prog_dmabuf_dac(ptr noundef %0) {\nB:\n%1 = tail call i32 @stop_dac(ptr noundef %0)\n%2 = tail call i32 @prog_dmabuf(ptr noundef %0, ptr noundef %0)\nret i32 %2\n}", "codellama": "define internal i32 @prog_dmabuf_dac(ptr noundef %0) {\nB:\n%1 = tail call i32 @stop_dac(ptr noundef %0)\n%2 = tail call i32 @prog_dmabuf(ptr noundef %0, ptr noundef %0)\nret i32 %2\n}", "codegemma": "define internal i32 @prog_dmabuf_dac(ptr noundef %0) {\nB:\n%1 = tail call i32 @stop_dac(ptr noundef %0)\n%2 = tail call i32 @prog_dmabuf(ptr noundef %0, ptr noundef %0)\nret i32 %2\n}"}, "define dso_local void @fst_detach(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @fst_iface_get_group(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = load i32, ptr @MSG_DEBUG, align 4\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @fst_group_get_id(ptr noundef %8)\n%10 = call i32 @fst_printf_iface(ptr noundef %6, i32 noundef %7, ptr noundef @.str, i32 noundef %9)\n%11 = load ptr, ptr %2, align 8\n%12 = call i32 @fst_session_global_on_iface_detached(ptr noundef %11)\n%13 = load i32, ptr @on_iface_removed, align 4\n%14 = load ptr, ptr %2, align 8\n%15 = call i32 @foreach_fst_ctrl_call(i32 noundef %13, ptr noundef %14)\n%16 = load ptr, ptr %3, align 8\n%17 = load ptr, ptr %2, align 8\n%18 = call i32 @fst_group_detach_iface(ptr noundef %16, ptr noundef %17)\n%19 = load ptr, ptr %2, align 8\n%20 = call i32 @fst_iface_delete(ptr noundef %19)\n%21 = load ptr, ptr %3, align 8\n%22 = call i32 @fst_group_update_ie(ptr noundef %21)\n%23 = load ptr, ptr %3, align 8\n%24 = call i32 @fst_group_delete_if_empty(ptr noundef %23)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @fst_detach(ptr noundef %0) {\nB:\n%1 = tail call ptr @fst_iface_get_group(ptr noundef %0)\n%2 = load i32, ptr @MSG_DEBUG, align 4\n%3 = tail call i32 @fst_group_get_id(ptr noundef %1)\n%4 = tail call i32 @fst_printf_iface(ptr noundef %0, i32 noundef %2, ptr noundef nonnull @.str, i32 noundef %3)\n%5 = tail call i32 @fst_session_global_on_iface_detached(ptr noundef %0)\n%6 = load i32, ptr @on_iface_removed, align 4\n%7 = tail call i32 @foreach_fst_ctrl_call(i32 noundef %6, ptr noundef %0)\n%8 = tail call i32 @fst_group_detach_iface(ptr noundef %1, ptr noundef %0)\n%9 = tail call i32 @fst_iface_delete(ptr noundef %0)\n%10 = tail call i32 @fst_group_update_ie(ptr noundef %1)\n%11 = tail call i32 @fst_group_delete_if_empty(ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @fst_detach(ptr noundef %0) {\nB:\n%1 = tail call ptr @fst_iface_get_group(ptr noundef %0)\n%2 = load i32, ptr @MSG_DEBUG, align 4\n%3 = tail call i32 @fst_group_get_id(ptr noundef %1)\n%4 = tail call i32 @fst_printf_iface(ptr noundef %0, i32 noundef %2, ptr noundef nonnull @.str, i32 noundef %3)\n%5 = tail call i32 @fst_session_global_on_iface_detached(ptr noundef %0)\n%6 = load i32, ptr @on_iface_removed, align 4\n%7 = tail call i32 @foreach_fst_ctrl_call(i32 noundef %6, ptr noundef %0)\n%8 = tail call i32 @fst_group_detach_iface(ptr noundef %1, ptr noundef %0)\n%9 = tail call i32 @fst_iface_delete(ptr noundef %0)\n%10 = tail call i32 @fst_group_update_ie(ptr noundef %1)\n%11 = tail call i32 @fst_group_delete_if_empty(ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @fst_detach(ptr noundef %0) {\nB:\n%1 = tail call ptr @fst_iface_get_group(ptr noundef %0)\n%2 = load i32, ptr @MSG_DEBUG, align 4\n%3 = tail call i32 @fst_group_get_id(ptr noundef %1)\n%4 = tail call i32 @fst_printf_iface(ptr noundef %0, i32 noundef %2, ptr noundef nonnull @.str, i32 noundef %3)\n%5 = tail call i32 @fst_session_global_on_iface_detached(ptr noundef %0)\n%6 = load i32, ptr @on_iface_removed, align 4\n%7 = tail call i32 @foreach_fst_ctrl_call(i32 noundef %6, ptr noundef %0)\n%8 = tail call i32 @fst_group_detach_iface(ptr noundef %1, ptr noundef %0)\n%9 = tail call i32 @fst_iface_delete(ptr noundef %0)\n%10 = tail call i32 @fst_group_update_ie(ptr noundef %1)\n%11 = tail call i32 @fst_group_delete_if_empty(ptr noundef %1)\nret void\n}"}, "define dso_local nofpclass(nan inf) double @pg_erand48(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call i32 @_dorand48(ptr noundef %4)\nstore i32 %5, ptr %3, align 4\n%6 = load i32, ptr %3, align 4\n%7 = call i32 @UINT64CONST(i32 noundef -1)\n%8 = and i32 %6, %7\n%9 = sitofp i32 %8 to double\n%10 = call fast nofpclass(nan inf) double @ldexp(double noundef nofpclass(nan inf) %9, i32 noundef -48)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret double %10\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @pg_erand48(ptr noundef %0) {\nB:\n%1 = tail call i32 @_dorand48(ptr noundef %0)\n%2 = tail call i32 @UINT64CONST(i32 noundef -1)\n%3 = and i32 %2, %1\n%4 = sitofp i32 %3 to double\n%5 = tail call fast nofpclass(nan inf) double @ldexp(double noundef nofpclass(nan inf) %4, i32 noundef -48)\nret double %5\n}", "codellama": "define dso_local nofpclass(nan inf) double @pg_erand48(ptr noundef %0) {\nB:\n%1 = tail call i32 @_dorand48(ptr noundef %0)\n%2 = tail call i32 @UINT64CONST(i32 noundef -1)\n%3 = and i32 %2, %1\n%4 = sitofp i32 %3 to double\n%5 = tail call fast nofpclass(nan inf) double @ldexp(double noundef nofpclass(nan inf) %4, i32 noundef -48)\nret double %5\n}", "codegemma": "define dso_local nofpclass(nan inf) double @pg_erand48(ptr noundef %0) {\nB:\n%1 = tail call i32 @_dorand48(ptr noundef %0)\n%2 = tail call i32 @UINT64CONST(i32 noundef -1)\n%3 = and i32 %2, %1\n%4 = sitofp i32 %3 to double\n%5 = tail call fast nofpclass(nan inf) double @ldexp(double noundef nofpclass(nan inf) %4, i32 noundef -48)\nret double %5\n}"}, "define internal void @cell_iommu_setup_hardware(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i64, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore i64 %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i64, ptr %5, align 8\n%9 = load i64, ptr %6, align 8\n%10 = call i32 @cell_iommu_setup_stab(ptr noundef %7, i64 noundef %8, i64 noundef %9, i32 noundef 0, i32 noundef 0)\n%11 = load ptr, ptr %4, align 8\n%12 = load i64, ptr %5, align 8\n%13 = load i64, ptr %6, align 8\n%14 = load i32, ptr @IOMMU_PAGE_SHIFT_4K, align 4\n%15 = call i32 @cell_iommu_alloc_ptab(ptr noundef %11, i64 noundef %12, i64 noundef %13, i32 noundef 0, i32 noundef 0, i32 noundef %14)\n%16 = load ptr, ptr %4, align 8\n%17 = getelementptr inbounds %struct.cbe_iommu ptr %16, i32 0, i32 0\nstore i32 %15, ptr %17, align 4\n%18 = load ptr, ptr %4, align 8\n%19 = call i32 @cell_iommu_enable_hardware(ptr noundef %18)\nret void\n}": {"base_truth": "define internal void @cell_iommu_setup_hardware(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = tail call i32 @cell_iommu_setup_stab(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, i32 noundef 0)\n%4 = load i32, ptr @IOMMU_PAGE_SHIFT_4K, align 4\n%5 = tail call i32 @cell_iommu_alloc_ptab(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef %4)\nstore i32 %5, ptr %0, align 4\n%6 = tail call i32 @cell_iommu_enable_hardware(ptr noundef nonnull %0)\nret void\n}", "codellama": "define internal void @cell_iommu_setup_hardware(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = tail call i32 @cell_iommu_setup_stab(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, i32 noundef 0)\n%4 = load i32, ptr @IOMMU_PAGE_SHIFT_4K, align 4\n%5 = tail call i32 @cell_iommu_alloc_ptab(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef %4)\nstore i32 %5, ptr %0, align 4\n%6 = tail call i32 @cell_iommu_enable_hardware(ptr noundef nonnull %0)\nret void\n}", "codegemma": "define internal void @cell_iommu_setup_hardware(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = tail call i32 @cell_iommu_setup_stab(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, i32 noundef 0)\n%4 = load i32, ptr @IOMMU_PAGE_SHIFT_4K, align 4\n%5 = tail call i32 @cell_iommu_alloc_ptab(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef %4)\nstore i32 %5, ptr %0, align 4\n%6 = tail call i32 @cell_iommu_enable_hardware(ptr noundef nonnull %0)\nret void\n}"}, "define dso_local void @codegen_reset() {\n%1 = load i32, ptr @codeblock, align 4\n%2 = call i32 @memset(i32 noundef %1, i32 noundef 0, i32 noundef 65536)\n%3 = load i32, ptr @codeblock_hash, align 4\n%4 = call i32 @memset(i32 noundef %3, i32 noundef 0, i32 noundef 1048576)\n%5 = call i32 (...) @mem_reset_page_blocks()\nret void\n}": {"base_truth": "define dso_local void @codegen_reset() {\nB:\n%0 = load i32, ptr @codeblock, align 4\n%1 = tail call i32 @memset(i32 noundef %0, i32 noundef 0, i32 noundef 65536)\n%2 = load i32, ptr @codeblock_hash, align 4\n%3 = tail call i32 @memset(i32 noundef %2, i32 noundef 0, i32 noundef 1048576)\n%4 = tail call i32 (...) @mem_reset_page_blocks()\nret void\n}", "codellama": "define dso_local void @codegen_reset() {\nB:\n%0 = load i32, ptr @codeblock, align 4\n%1 = tail call i32 @memset(i32 noundef %0, i32 noundef 0, i32 noundef 65536)\n%2 = load i32, ptr @codeblock_hash, align 4\n%3 = tail call i32 @memset(i32 noundef %2, i32 noundef 0, i32 noundef 1048576)\n%4 = tail call i32 (...) @mem_reset_page_blocks()\nret void\n}", "codegemma": "define dso_local void @codegen_reset() {\nB:\n%0 = load i32, ptr @codeblock, align 4\n%1 = tail call i32 @memset(i32 noundef %0, i32 noundef 0, i32 noundef 65536)\n%2 = load i32, ptr @codeblock_hash, align 4\n%3 = tail call i32 @memset(i32 noundef %2, i32 noundef 0, i32 noundef 1048576)\n%4 = tail call i32 (...) @mem_reset_page_blocks()\nret void\n}"}, "define dso_local void @bigint_set_zero(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\nstore i64 0, ptr %4, align 8\nret void\n}": {"base_truth": "define dso_local void @bigint_set_zero(ptr nocapture noundef writeonly %0) {\nB:\nstore i64 0, ptr %0, align 8\nret void\n}", "codellama": "define dso_local void @bigint_set_zero(ptr nocapture noundef writeonly %0) {\nB:\nstore i64 0, ptr %0, align 8\nret void\n}", "codegemma": "define dso_local void @bigint_set_zero(ptr nocapture noundef writeonly %0) {\nB:\nstore i64 0, ptr %0, align 8\nret void\n}"}, "define internal void @vfe_send_bus_overflow_msg() {\n%1 = alloca ptr, align 8\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%3 = load i32, ptr @GFP_ATOMIC, align 4\n%4 = call ptr @kzalloc(i32 noundef 8, i32 noundef %3)\nstore ptr %4, ptr %1, align 8\n%5 = load ptr, ptr %1, align 8\n%6 = icmp ne ptr %5, null\nbr i1 %6, label %8, label %7\n\n7:\nstore i32 1, ptr %2, align 4\nbr label %15\n\n8:\n%9 = load i32, ptr @VFE_MSG_ID_BUS_OVERFLOW, align 4\n%10 = load ptr, ptr %1, align 8\n%11 = getelementptr inbounds %struct.vfe_message ptr %10, i32 0, i32 1\nstore i32 %9, ptr %11, align 4\n%12 = load i32, ptr @VFE_MSG_ID_BUS_OVERFLOW, align 4\n%13 = load ptr, ptr %1, align 8\n%14 = call i32 @vfe_proc_ops(i32 noundef %12, ptr noundef %13, i32 noundef 8)\nstore i32 0, ptr %2, align 4\nbr label %15\n\n15:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\n%16 = load i32, ptr %2, align 4\nswitch i32 %16, label %18 [\ni32 0, label %17\ni32 1, label %17\n]\n\n17:\nret void\n\n18:\nunreachable\n}": {"base_truth": "define internal void @vfe_send_bus_overflow_msg() {\nB:\n%0 = load i32, ptr @GFP_ATOMIC, align 4\n%1 = tail call ptr @kzalloc(i32 noundef 8, i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.vfe_message, ptr %1, i64 0, i32 1\n%4 = load i32, ptr @VFE_MSG_ID_BUS_OVERFLOW, align 4\nstore i32 %4, ptr %3, align 4\n%5 = tail call i32 @vfe_proc_ops(i32 noundef %4, ptr noundef nonnull %1, i32 noundef 8)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define internal void @vfe_send_bus_overflow_msg() {\nB:\n%0 = load i32, ptr @GFP_ATOMIC, align 4\n%1 = tail call ptr @kzalloc(i32 noundef 8, i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = getelementptr inbounds %struct.vfe_message, ptr %1, i64 0, i32 1\n%4 = load i32, ptr @VFE_MSG_ID_BUS_OVERFLOW, align 4\nstore i32 %4, ptr %3, align 4\n%5 = tail call i32 @vfe_proc_ops(i32 noundef %4, ptr noundef nonnull %1, i32 noundef 8)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define internal void @vfe_send_bus_overflow_msg() {\nB:\n%0 = load i32, ptr @GFP_ATOMIC, align 4\n%1 = tail call ptr @kzalloc(i32 noundef 8, i32 noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr @VFE_MSG_ID_BUS_OVERFLOW, align 4\n%4 = getelementptr inbounds %struct.vfe_message, ptr %1, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\n%5 = tail call i32 @vfe_proc_ops(i32 noundef %3, ptr noundef nonnull %1, i32 noundef 8)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i32 @ADC_TO_MV(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %4, align 4\n%7 = mul nsw i32 %5, %6\n%8 = sdiv i32 %7, 1024\nret i32 %8\n}": {"base_truth": "define internal i32 @ADC_TO_MV(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = mul nsw i32 %1, %0\n%3 = sdiv i32 %2, 1024\nret i32 %3\n}", "codellama": "define internal i32 @ADC_TO_MV(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = mul nsw i32 %1, %0\n%3 = sdiv i32 %2, 1024\nret i32 %3\n}", "codegemma": "define internal i32 @ADC_TO_MV(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = mul nsw i32 %1, %0\n%3 = sdiv i32 %2, 1024\nret i32 %3\n}"}, "define dso_local i32 @config(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 (...) @bar()\nret i32 0\n}": {"base_truth": "define dso_local i32 @config(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @bar()\nret i32 0\n}", "codellama": "define dso_local i32 @config(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @bar()\nret i32 0\n}", "codegemma": "define dso_local i32 @config(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @bar()\nret i32 0\n}"}, "define dso_local i32 @ultrasonicRead(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load i32, ptr %3, align 4\n%7 = call i32 @write_block(i32 noundef 7, i32 noundef %6, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%8 = call i32 @usleep(i32 noundef 1000)\n%9 = call i32 @read_block(i32 noundef 3)\n%10 = load ptr, ptr @r_buf, align 8\n%11 = getelementptr inbounds i32, ptr %10, i64 1\n%12 = load i32, ptr %11, align 4\n%13 = mul nsw i32 %12, 256\n%14 = load ptr, ptr @r_buf, align 8\n%15 = getelementptr inbounds i32, ptr %14, i64 2\n%16 = load i32, ptr %15, align 4\n%17 = add nsw i32 %13, %16\nstore i32 %17, ptr %4, align 4\n%18 = load i32, ptr %4, align 4\n%19 = icmp eq i32 %18, 65535\nbr i1 %19, label %20, label %21\n\n20:\nstore i32 -1, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %23\n\n21:\n%22 = load i32, ptr %4, align 4\nstore i32 %22, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %23\n\n23:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%24 = load i32, ptr %2, align 4\nret i32 %24\n}": {"base_truth": "define dso_local i32 @ultrasonicRead(i32 noundef %0) {\nB:\n%1 = tail call i32 @write_block(i32 noundef 7, i32 noundef %0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%2 = tail call i32 @usleep(i32 noundef 1000)\n%3 = tail call i32 @read_block(i32 noundef 3)\n%4 = load ptr, ptr @r_buf, align 8\n%5 = getelementptr inbounds i32, ptr %4, i64 1\n%6 = load i32, ptr %5, align 4\n%7 = shl nsw i32 %6, 8\n%8 = getelementptr inbounds i32, ptr %4, i64 2\n%9 = load i32, ptr %8, align 4\n%10 = add nsw i32 %7, %9\n%11 = icmp eq i32 %10, 65535\n%12 = select i1 %11, i32 -1, i32 %10\nret i32 %12\n}", "codellama": "define dso_local i32 @ultrasonicRead(i32 noundef %0) {\nB:\n%1 = tail call i32 @write_block(i32 noundef 7, i32 noundef %0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%2 = tail call i32 @usleep(i32 noundef 1000)\n%3 = tail call i32 @read_block(i32 noundef 3)\n%4 = load ptr, ptr @r_buf, align 8\n%5 = getelementptr inbounds i32, ptr %4, i64 1\n%6 = load i32, ptr %5, align 4\n%7 = shl nsw i32 %6, 8\n%8 = getelementptr inbounds i32, ptr %4, i64 2\n%9 = load i32, ptr %8, align 4\n%10 = add nsw i32 %7, %9\n%11 = icmp eq i32 %10, 65535\n%12 = select i1 %11, i32 -1, i32 %10\nret i32 %12\n}", "codegemma": "define dso_local i32 @ultrasonicRead(i32 noundef %0) {\nB:\n%1 = tail call i32 @write_block(i32 noundef 7, i32 noundef %0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)\n%2 = tail call i32 @usleep(i32 noundef 1000)\n%3 = tail call i32 @read_block(i32 noundef 3)\n%4 = load ptr, ptr @r_buf, align 8\n%5 = getelementptr inbounds i32, ptr %4, i64 1\n%6 = load i32, ptr %5, align 4\n%7 = mul nsw i32 %6, 256\n%8 = getelementptr inbounds i32, ptr %4, i64 2\n%9 = load i32, ptr %8, align 4\n%10 = add nsw i32 %7, %9\n%11 = icmp eq i32 %10, 65535\n%12 = select i1 %11, i32 -1, i32 %10\nret i32 %12\n}"}, "define dso_local i64 @memcons_get_size(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.memcons ptr %3, i32 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = call i64 @be32_to_cpu(i32 noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.memcons ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i64 @be32_to_cpu(i32 noundef %9)\n%11 = add nsw i64 %6, %10\nret i64 %11\n}": {"base_truth": "define dso_local i64 @memcons_get_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.memcons, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i64 @be32_to_cpu(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i64 @be32_to_cpu(i32 noundef %4)\n%6 = add nsw i64 %5, %3\nret i64 %6\n}", "codellama": "define dso_local i64 @memcons_get_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.memcons, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i64 @be32_to_cpu(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i64 @be32_to_cpu(i32 noundef %4)\n%6 = add nsw i64 %5, %3\nret i64 %6\n}", "codegemma": "define dso_local i64 @memcons_get_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.memcons, ptr %0, i64 0, i32 1\n%2 = load i32, ptr %1, align 4\n%3 = tail call i64 @be32_to_cpu(i32 noundef %2)\n%4 = load i32, ptr %0, align 4\n%5 = tail call i64 @be32_to_cpu(i32 noundef %4)\n%6 = add nsw i64 %5, %3\nret i64 %6\n}"}, "define dso_local i32 @pa_ip_acl_check() {\n%1 = alloca i32, align 4\n%2 = call i32 @printf(ptr noundef @.str)\n%3 = load i32, ptr %1, align 4\nret i32 %3\n}": {"base_truth": "define dso_local i32 @pa_ip_acl_check() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 undef\n}", "codellama": "define dso_local i32 @pa_ip_acl_check() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 undef\n}", "codegemma": "define dso_local i32 @pa_ip_acl_check() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 undef\n}"}, "define dso_local void @clean_up() {\n%1 = load i32, ptr @K, align 4\n%2 = call i32 @free(i32 noundef %1)\n%3 = load i32, ptr @E, align 4\n%4 = call i32 @free(i32 noundef %3)\nstore i32 1, ptr @Kcount, align 4\nstore i32 1, ptr @Ecount, align 4\nret void\n}": {"base_truth": "define dso_local void @clean_up() {\nB:\n%0 = load i32, ptr @K, align 4\n%1 = tail call i32 @free(i32 noundef %0)\n%2 = load i32, ptr @E, align 4\n%3 = tail call i32 @free(i32 noundef %2)\nstore i32 1, ptr @Kcount, align 4\nstore i32 1, ptr @Ecount, align 4\nret void\n}", "codellama": "define dso_local void @clean_up() {\nB:\n%0 = load i32, ptr @K, align 4\n%1 = tail call i32 @free(i32 noundef %0)\n%2 = load i32, ptr @E, align 4\n%3 = tail call i32 @free(i32 noundef %2)\nstore i32 1, ptr @Kcount, align 4\nstore i32 1, ptr @Ecount, align 4\nret void\n}", "codegemma": "define dso_local void @clean_up() {\nB:\n%0 = load i32, ptr @K, align 4\n%1 = tail call i32 @free(i32 noundef %0)\n%2 = load i32, ptr @E, align 4\n%3 = tail call i32 @free(i32 noundef %2)\nstore i32 1, ptr @Kcount, align 4\nstore i32 1, ptr @Ecount, align 4\nret void\n}"}, "define dso_local void @grabber_wake_touch(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = call i32 @grabber_wake(ptr noundef %7)\nret void\n}": {"base_truth": "define dso_local void @grabber_wake_touch(ptr noundef %0, ptr nocapture noundef readnone %1, ptr nocapture noundef readnone %2) {\nB:\n%3 = tail call i32 @grabber_wake(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @grabber_wake_touch(ptr noundef %0, ptr nocapture noundef readnone %1, ptr nocapture noundef readnone %2) {\nB:\n%3 = tail call i32 @grabber_wake(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @grabber_wake_touch(ptr noundef %0, ptr nocapture noundef readnone %1, ptr nocapture noundef readnone %2) {\nB:\n%3 = tail call i32 @grabber_wake(ptr noundef %0)\nret void\n}"}, "define internal void @snd_media_stream_delete(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define internal void @snd_media_stream_delete(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define internal void @snd_media_stream_delete(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define internal void @snd_media_stream_delete(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define dso_local i32 @getElapsedMs() {\n%1 = call i32 @postMessage(i32 noundef 0, i32 noundef 36, i32 noundef 0)\n%2 = call i32 @getMessageFrom(ptr noundef @temp_msg, i32 noundef 0, i32 noundef 36)\n%3 = load i32, ptr @temp_msg, align 4\nret i32 %3\n}": {"base_truth": "define dso_local i32 @getElapsedMs() {\nB:\n%0 = tail call i32 @postMessage(i32 noundef 0, i32 noundef 36, i32 noundef 0)\n%1 = tail call i32 @getMessageFrom(ptr noundef nonnull @temp_msg, i32 noundef 0, i32 noundef 36)\n%2 = load i32, ptr @temp_msg, align 4\nret i32 %2\n}", "codellama": "define dso_local i32 @getElapsedMs() {\nB:\n%0 = tail call i32 @postMessage(i32 noundef 0, i32 noundef 36, i32 noundef 0)\n%1 = tail call i32 @getMessageFrom(ptr noundef nonnull @temp_msg, i32 noundef 0, i32 noundef 36)\n%2 = load i32, ptr @temp_msg, align 4\nret i32 %2\n}", "codegemma": "define dso_local i32 @getElapsedMs() {\nB:\n%0 = tail call i32 @postMessage(i32 noundef 0, i32 noundef 36, i32 noundef 0)\n%1 = tail call i32 @getMessageFrom(ptr noundef nonnull @temp_msg, i32 noundef 0, i32 noundef 36)\n%2 = load i32, ptr @temp_msg, align 4\nret i32 %2\n}"}, "define dso_local void @run_waitdo_lace_tool_pipem_callback(i32 noundef %0, i32 noundef %1, ptr noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%8 = load i32, ptr %4, align 4\n%9 = load i32, ptr %5, align 4\n%10 = load ptr, ptr %6, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 1\n%12 = load i32, ptr %11, align 4\n%13 = load ptr, ptr %6, align 8\n%14 = getelementptr inbounds %struct.TYPE_3__, ptr %13, i32 0, i32 0\n%15 = load i32, ptr %14, align 4\n%16 = call i32 @lace_compat_fd_spawnlp_wait(i32 noundef %8, i32 noundef %9, i32 noundef 2, ptr noundef null, i32 noundef %12, ptr noundef @.str, i32 noundef %15, ptr noundef @.str.1, ptr noundef @.str.2, ptr noundef @.str.3, ptr noundef null)\nstore i32 %16, ptr %7, align 4\n%17 = load i32, ptr %7, align 4\n%18 = icmp eq i32 %17, 0\n%19 = zext i1 %18 to i32\n%20 = call i32 @assert(i32 noundef %19)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret void\n}": {"base_truth": "define dso_local void @run_waitdo_lace_tool_pipem_callback(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @lace_compat_fd_spawnlp_wait(i32 noundef %0, i32 noundef %1, i32 noundef 2, ptr noundef null, i32 noundef %4, ptr noundef nonnull @.str, i32 noundef %5, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.3, ptr noundef null)\n%7 = icmp eq i32 %6, 0\n%8 = zext i1 %7 to i32\n%9 = tail call i32 @assert(i32 noundef %8)\nret void\n}", "codellama": "define dso_local void @run_waitdo_lace_tool_pipem_callback(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @lace_compat_fd_spawnlp_wait(i32 noundef %0, i32 noundef %1, i32 noundef 2, ptr noundef null, i32 noundef %4, ptr noundef nonnull @.str, i32 noundef %5, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.3, ptr noundef null)\n%7 = icmp eq i32 %6, 0\n%8 = zext i1 %7 to i32\n%9 = tail call i32 @assert(i32 noundef %8)\nret void\n}", "codegemma": "define dso_local void @run_waitdo_lace_tool_pipem_callback(i32 noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @lace_compat_fd_spawnlp_wait(i32 noundef %0, i32 noundef %1, i32 noundef 2, ptr noundef null, i32 noundef %4, ptr noundef nonnull @.str, i32 noundef %5, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.3, ptr noundef null)\n%7 = icmp eq i32 %6, 0\n%8 = zext i1 %7 to i32\n%9 = tail call i32 @assert(i32 noundef %8)\nret void\n}"}, "define dso_local void @net_dead() {\n%1 = call i32 @set_heart_beat(i32 noundef 0)\n%2 = call i32 (...) @environment()\n%3 = call i32 (...) @query_name()\n%4 = sext i32 %3 to i64\n%5 = getelementptr inbounds i8, ptr @.str, i64 %4\n%6 = call i32 @tell_room(i32 noundef %2, ptr noundef %5)\nret void\n}": {"base_truth": "define dso_local void @net_dead() {\nB:\n%0 = tail call i32 @set_heart_beat(i32 noundef 0)\n%1 = tail call i32 (...) @environment()\n%2 = tail call i32 (...) @query_name()\n%3 = sext i32 %2 to i64\n%4 = getelementptr inbounds i8, ptr @.str, i64 %3\n%5 = tail call i32 @tell_room(i32 noundef %1, ptr noundef nonnull %4)\nret void\n}", "codellama": "define dso_local void @net_dead() {\nB:\n%0 = tail call i32 @set_heart_beat(i32 noundef 0)\n%1 = tail call i32 (...) @environment()\n%2 = tail call i32 (...) @query_name()\n%3 = sext i32 %2 to i64\n%4 = getelementptr inbounds i8, ptr @.str, i64 %3\n%5 = tail call i32 @tell_room(i32 noundef %1, ptr noundef %4)\nret void\n}", "codegemma": "define dso_local void @net_dead() {\nB:\n%0 = tail call i32 @set_heart_beat(i32 noundef 0)\n%1 = tail call i32 (...) @environment()\n%2 = tail call i32 (...) @query_name()\n%3 = sext i32 %2 to i64\n%4 = getelementptr inbounds i8, ptr @.str, i64 %3\n%5 = tail call i32 @tell_room(i32 noundef %1, ptr noundef %4)\nret void\n}"}, "define dso_local void @checkasm_check_llviddspenc() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = call i32 @ff_llvidencdsp_init(ptr noundef %1)\n%3 = call i32 @check_diff_bytes(ptr noundef %1)\n%4 = call i32 @report(ptr noundef @.str)\n%5 = call i32 @check_sub_left_pred(ptr noundef %1)\n%6 = call i32 @report(ptr noundef @.str.1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @checkasm_check_llviddspenc() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @ff_llvidencdsp_init(ptr noundef nonnull %0)\n%2 = call i32 @check_diff_bytes(ptr noundef nonnull %0)\n%3 = call i32 @report(ptr noundef nonnull @.str)\n%4 = call i32 @check_sub_left_pred(ptr noundef nonnull %0)\n%5 = call i32 @report(ptr noundef nonnull @.str.1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @checkasm_check_llviddspenc() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @ff_llvidencdsp_init(ptr noundef nonnull %0)\n%2 = call i32 @check_diff_bytes(ptr noundef nonnull %0)\n%3 = call i32 @report(ptr noundef nonnull @.str)\n%4 = call i32 @check_sub_left_pred(ptr noundef nonnull %0)\n%5 = call i32 @report(ptr noundef nonnull @.str.1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @checkasm_check_llviddspenc() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = call i32 @ff_llvidencdsp_init(ptr noundef nonnull %0)\n%2 = call i32 @check_diff_bytes(ptr noundef nonnull %0)\n%3 = call i32 @report(ptr noundef nonnull @.str)\n%4 = call i32 @check_sub_left_pred(ptr noundef nonnull %0)\n%5 = call i32 @report(ptr noundef nonnull @.str.1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret void\n}"}, "define dso_local ptr @prefix_undef_type(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i32 %2, ptr %7, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %8)\n%10 = load ptr, ptr %5, align 8\n%11 = load ptr, ptr %6, align 8\n%12 = load i32, ptr %7, align 4\n%13 = call ptr @prefix_find_type_binding(ptr noundef %10, ptr noundef %11, i32 noundef %12)\nstore ptr %13, ptr %8, align 8\n%14 = load ptr, ptr %8, align 8\n%15 = icmp ne ptr %14, null\nbr i1 %15, label %16, label %21\n\n16:\n%17 = load ptr, ptr %8, align 8\n%18 = call i32 @hash_map_sym_pop_value(ptr noundef %17)\n%19 = sext i32 %18 to i64\n%20 = inttoptr i64 %19 to ptr\nstore ptr %20, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %22\n\n21:\nstore ptr null, ptr %4, align 8\nstore i32 1, ptr %9, align 4\nbr label %22\n\n22:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %8)\n%23 = load ptr, ptr %4, align 8\nret ptr %23\n}": {"base_truth": "define dso_local ptr @prefix_undef_type(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call ptr @prefix_find_type_binding(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @hash_map_sym_pop_value(ptr noundef nonnull %3)\n%6 = sext i32 %5 to i64\n%7 = inttoptr i64 %6 to ptr\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ null, %B ]\nret ptr %8\n}", "codellama": "define dso_local ptr @prefix_undef_type(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call ptr @prefix_find_type_binding(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @hash_map_sym_pop_value(ptr noundef nonnull %3)\n%6 = sext i32 %5 to i64\n%7 = inttoptr i64 %6 to ptr\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ null, %B ]\nret ptr %8\n}", "codegemma": "define dso_local ptr @prefix_undef_type(ptr noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = tail call ptr @prefix_find_type_binding(ptr noundef %0, ptr noundef %1, i32 noundef %2)\n%4 = icmp eq ptr %3, null\nbr i1 %4, label %B2, label %B1\n\nB1:\n%5 = tail call i32 @hash_map_sym_pop_value(ptr noundef nonnull %3)\n%6 = sext i32 %5 to i64\n%7 = inttoptr i64 %6 to ptr\nbr label %B2\n\nB2:\n%8 = phi ptr [ %7, %B1 ], [ null, %B ]\nret ptr %8\n}"}, "define dso_local i32 @dbDelete(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.TYPE_6__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %5, align 8\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = call i64 @dictDelete(i32 noundef %8, i32 noundef %11)\n%13 = icmp eq i64 %12, 0\nbr i1 %13, label %14, label %15\n\n14:\nstore i32 1, ptr %3, align 4\nbr label %16\n\n15:\nstore i32 0, ptr %3, align 4\nbr label %16\n\n16:\n%17 = load i32, ptr %3, align 4\nret i32 %17\n}": {"base_truth": "define dso_local i32 @dbDelete(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr %1, align 4\n%4 = tail call i64 @dictDelete(i32 noundef %2, i32 noundef %3)\n%5 = icmp eq i64 %4, 0\n%6 = zext i1 %5 to i32\nret i32 %6\n}", "codellama": "define dso_local i32 @dbDelete(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr %1, align 4\n%4 = tail call i64 @dictDelete(i32 noundef %2, i32 noundef %3)\n%5 = icmp eq i64 %4, 0\n%6 = zext i1 %5 to i32\nret i32 %6\n}", "codegemma": "define dso_local i32 @dbDelete(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr %1, align 4\n%4 = tail call i64 @dictDelete(i32 noundef %2, i32 noundef %3)\n%5 = icmp eq i64 %4, 0\n%6 = zext i1 %5 to i32\nret i32 %6\n}"}, "define dso_local i32 @get_hashfunc_49(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load i32, ptr %4, align 4\n%7 = and i32 %6, -2147483648\n%8 = icmp ne i32 %7, 0\nbr i1 %8, label %9, label %17\n\n9:\n%10 = load i32, ptr %4, align 4\n%11 = and i32 %10, -2147483648\n%12 = icmp eq i32 %11, -2147483648\nbr i1 %12, label %13, label %14\n\n13:\nstore i32 33, ptr %5, align 4\nbr label %16\n\n14:\n%15 = load i32, ptr %3, align 4\nstore i32 %15, ptr %5, align 4\nbr label %16\n\n16:\nbr label %18\n\n17:\nstore i32 35, ptr %5, align 4\nbr label %18\n\n18:\n%19 = load i32, ptr %5, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret i32 %19\n}": {"base_truth": "define dso_local i32 @get_hashfunc_49(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %1, -1\n%3 = select i1 %2, i32 35, i32 33\nret i32 %3\n}", "codellama": "define dso_local i32 @get_hashfunc_49(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %1, -1\n%3 = select i1 %2, i32 35, i32 33\nret i32 %3\n}", "codegemma": "define dso_local i32 @get_hashfunc_49(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = icmp sgt i32 %1, -1\n%3 = select i1 %2, i32 35, i32 33\nret i32 %3\n}"}, "define dso_local void @t_sqrt_62() {\n%1 = call i32 @isqrt(i32 noundef 62)\n%2 = icmp eq i32 %1, 7\n%3 = zext i1 %2 to i32\n%4 = call i32 @Assert_real(i32 noundef %3, ptr noundef @.str, i32 noundef 315, ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @t_sqrt_62() {\nB:\n%0 = tail call i32 @isqrt(i32 noundef 62)\n%1 = icmp eq i32 %0, 7\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @Assert_real(i32 noundef %2, ptr noundef nonnull @.str, i32 noundef 315, ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @t_sqrt_62() {\nB:\n%0 = tail call i32 @isqrt(i32 noundef 62)\n%1 = icmp eq i32 %0, 7\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @Assert_real(i32 noundef %2, ptr noundef nonnull @.str, i32 noundef 315, ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @t_sqrt_62() {\nB:\n%0 = tail call i32 @isqrt(i32 noundef 62)\n%1 = icmp eq i32 %0, 7\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @Assert_real(i32 noundef %2, ptr noundef nonnull @.str, i32 noundef 315, ptr noundef nonnull @.str.1)\nret void\n}"}, "define dso_local void @ES_search(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load i32, ptr @ES_next_gen, align 4\n%8 = call i32 @evol_frame(ptr noundef %5, ptr noundef %6, i32 noundef %7)\nret void\n}": {"base_truth": "define dso_local void @ES_search(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @ES_next_gen, align 4\n%3 = tail call i32 @evol_frame(ptr noundef %0, ptr noundef %1, i32 noundef %2)\nret void\n}", "codellama": "define dso_local void @ES_search(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @ES_next_gen, align 4\n%3 = tail call i32 @evol_frame(ptr noundef %0, ptr noundef %1, i32 noundef %2)\nret void\n}", "codegemma": "define dso_local void @ES_search(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @ES_next_gen, align 4\n%3 = tail call i32 @evol_frame(ptr noundef %0, ptr noundef %1, i32 noundef %2)\nret void\n}"}, "define dso_local i32 @create_gdbmi_result_record() {\n%1 = call i32 @calloc(i32 noundef 1, i32 noundef 4)\nret i32 %1\n}": {"base_truth": "define dso_local i32 @create_gdbmi_result_record() {\nB:\n%0 = tail call i32 @calloc(i32 noundef 1, i32 noundef 4)\nret i32 %0\n}", "codellama": "define dso_local i32 @create_gdbmi_result_record() {\nB:\n%0 = tail call i32 @calloc(i32 noundef 1, i32 noundef 4)\nret i32 %0\n}", "codegemma": "define dso_local i32 @create_gdbmi_result_record() {\nB:\n%0 = tail call i32 @calloc(i32 noundef 1, i32 noundef 4)\nret i32 %0\n}"}, "define dso_local i32 @get_xdim(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %2, align 8\n%7 = call ptr @ostrdup(ptr noundef %6)\nstore ptr %7, ptr %4, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = call ptr @strtok(ptr noundef %8, ptr noundef @.str)\n%10 = call ptr @strtok(ptr noundef null, ptr noundef @.str)\n%11 = call ptr @strtok(ptr noundef null, ptr noundef @.str)\nstore ptr %11, ptr %5, align 8\n%12 = load ptr, ptr %5, align 8\n%13 = icmp ne ptr %12, null\nbr i1 %13, label %14, label %17\n\n14:\n%15 = load ptr, ptr %5, align 8\n%16 = call i32 @atoi(ptr noundef %15)\nstore i32 %16, ptr %3, align 4\nbr label %17\n\n17:\n%18 = load ptr, ptr %4, align 8\n%19 = call i32 @ofree(ptr noundef %18)\n%20 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %20\n}": {"base_truth": "define dso_local i32 @get_xdim(ptr noundef %0) {\nB:\n%1 = tail call ptr @ostrdup(ptr noundef %0)\n%2 = tail call ptr @strtok(ptr noundef %1, ptr noundef nonnull @.str)\n%3 = tail call ptr @strtok(ptr noundef null, ptr noundef nonnull @.str)\n%4 = tail call ptr @strtok(ptr noundef null, ptr noundef nonnull @.str)\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @atoi(ptr nocapture noundef nonnull %4)\nbr label %B2\n\nB2:\n%7 = phi i32 [ %6, %B1 ], [ 0, %B ]\n%8 = tail call i32 @ofree(ptr noundef %1)\nret i32 %7\n}", "codellama": "define dso_local i32 @get_xdim(ptr noundef %0) {\nB:\n%1 = tail call ptr @ostrdup(ptr noundef %0)\n%2 = tail call ptr @strtok(ptr noundef %1, ptr noundef nonnull @.str)\n%3 = tail call ptr @strtok(ptr noundef null, ptr noundef nonnull @.str)\n%4 = tail call ptr @strtok(ptr noundef null, ptr noundef nonnull @.str)\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @atoi(ptr nocapture noundef nonnull %4)\nbr label %B2\n\nB2:\n%7 = phi i32 [ %6, %B1 ], [ 0, %B ]\n%8 = tail call i32 @ofree(ptr noundef %1)\nret i32 %7\n}", "codegemma": "define dso_local i32 @get_xdim(ptr noundef %0) {\nB:\n%1 = tail call ptr @ostrdup(ptr noundef %0)\n%2 = tail call ptr @strtok(ptr noundef %1, ptr noundef nonnull @.str)\n%3 = tail call ptr @strtok(ptr noundef null, ptr noundef nonnull @.str)\n%4 = tail call ptr @strtok(ptr noundef null, ptr noundef nonnull @.str)\n%5 = icmp eq ptr %4, null\nbr i1 %5, label %B2, label %B1\n\nB1:\n%6 = tail call i32 @atoi(ptr nocapture noundef nonnull %4)\nbr label %B2\n\nB2:\n%7 = phi i32 [ %6, %B1 ], [ 0, %B ]\n%8 = tail call i32 @ofree(ptr noundef %1)\nret i32 %7\n}"}, "define dso_local void @foo1() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 0, ptr %1, align 4\nbr label %12\n\n2:\n%3 = load i32, ptr %1, align 4\n%4 = icmp eq i32 %3, 2\n%5 = zext i1 %4 to i32\n%6 = call i32 @assert(i32 noundef %5)\nstore i32 3, ptr %1, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n\n7:\n%8 = load i32, ptr %1, align 4\n%9 = icmp eq i32 %8, 1\n%10 = zext i1 %9 to i32\n%11 = call i32 @assert(i32 noundef %10)\nstore i32 2, ptr %1, align 4\nbr label %2\n\n12:\n%13 = load i32, ptr %1, align 4\n%14 = icmp eq i32 %13, 0\n%15 = zext i1 %14 to i32\n%16 = call i32 @assert(i32 noundef %15)\nstore i32 1, ptr %1, align 4\nbr label %7\n}": {"base_truth": "define dso_local void @foo1() {\nB:\n%0 = tail call i32 @assert(i32 noundef 1)\n%1 = tail call i32 @assert(i32 noundef 1)\n%2 = tail call i32 @assert(i32 noundef 1)\nret void\n}", "codellama": "define dso_local void @foo1() {\nB:\n%0 = tail call i32 @assert(i32 noundef 0)\n%1 = tail call i32 @assert(i32 noundef 0)\n%2 = tail call i32 @assert(i32 noundef 1)\nret void\n}", "codegemma": "define dso_local void @foo1() {\nB:\n%0 = tail call i32 @assert(i32 noundef 0)\n%1 = tail call i32 @assert(i32 noundef 1)\n%2 = tail call i32 @assert(i32 noundef 0)\n%3 = tail call i32 @assert(i32 noundef 1)\nret void\n}"}, "define dso_local void @injfile_iter_exports(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.injfile_t ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = load i32, ptr %4, align 4\n%9 = call i32 @injfile_iter_symbols(i32 noundef %7, i32 noundef %8)\nret void\n}": {"base_truth": "define dso_local void @injfile_iter_exports(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @injfile_iter_symbols(i32 noundef %2, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @injfile_iter_exports(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @injfile_iter_symbols(i32 noundef %2, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @injfile_iter_exports(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @injfile_iter_symbols(i32 noundef %2, i32 noundef %1)\nret void\n}"}, "define dso_local i64 @qm_available(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.qm_block ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.qm_block ptr %6, i32 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = sub i64 %5, %8\nret i64 %9\n}": {"base_truth": "define dso_local i64 @qm_available(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.qm_block, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = sub i64 %1, %3\nret i64 %4\n}", "codellama": "define dso_local i64 @qm_available(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.qm_block, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = sub i64 %1, %3\nret i64 %4\n}", "codegemma": "define dso_local i64 @qm_available(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = getelementptr inbounds %struct.qm_block, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = sub i64 %1, %3\nret i64 %4\n}"}, "define dso_local ptr @sws_getIdentityVec() {\n%1 = call ptr @sws_getConstVec(double noundef nofpclass(nan inf) 1.000000e+00, i32 noundef 1)\nret ptr %1\n}": {"base_truth": "define dso_local ptr @sws_getIdentityVec() {\nB:\n%0 = tail call ptr @sws_getConstVec(double noundef nofpclass(nan inf) 1.000000e+00, i32 noundef 1)\nret ptr %0\n}", "codellama": "define dso_local ptr @sws_getIdentityVec() {\nB:\n%0 = tail call ptr @sws_getConstVec(double noundef nofpclass(nan inf) 1.000000e+00, i32 noundef 1)\nret ptr %0\n}", "codegemma": "define dso_local ptr @sws_getIdentityVec() {\nB:\n%0 = tail call ptr @sws_getConstVec(double noundef nofpclass(nan inf) 1.000000e+00, i32 noundef 1)\nret ptr %0\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\n%2 = call i32 (...) @read_only()\n%3 = call i32 (...) @my_create()\n%4 = call i32 (...) @my_write()\n%5 = call i32 (...) @my_read()\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 (...) @read_only()\n%1 = tail call i32 (...) @my_create()\n%2 = tail call i32 (...) @my_write()\n%3 = tail call i32 (...) @my_read()\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 (...) @read_only()\n%1 = tail call i32 (...) @my_create()\n%2 = tail call i32 (...) @my_write()\n%3 = tail call i32 (...) @my_read()\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 (...) @read_only()\n%1 = tail call i32 (...) @my_create()\n%2 = tail call i32 (...) @my_write()\n%3 = tail call i32 (...) @my_read()\nret i32 0\n}"}, "define dso_local void @nni_sock_sys_init() {\n%1 = load i32, ptr @nni_sock, align 4\n%2 = load i32, ptr @s_node, align 4\n%3 = call i32 @offsetof(i32 noundef %1, i32 noundef %2)\n%4 = call i32 @nni_list_init_offset(ptr noundef @sock_list, i32 noundef %3)\n%5 = call i32 @nni_mtx_init(ptr noundef @sock_lk)\n%6 = call i32 @nni_id_map_init(ptr noundef @sock_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\n%7 = call i32 @nni_id_map_init(ptr noundef @ctx_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\nstore i32 1, ptr @inited, align 4\nret void\n}": {"base_truth": "define dso_local void @nni_sock_sys_init() {\nB:\n%0 = load i32, ptr @nni_sock, align 4\n%1 = load i32, ptr @s_node, align 4\n%2 = tail call i32 @offsetof(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 @nni_list_init_offset(ptr noundef nonnull @sock_list, i32 noundef %2)\n%4 = tail call i32 @nni_mtx_init(ptr noundef nonnull @sock_lk)\n%5 = tail call i32 @nni_id_map_init(ptr noundef nonnull @sock_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\n%6 = tail call i32 @nni_id_map_init(ptr noundef nonnull @ctx_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\nstore i32 1, ptr @inited, align 4\nret void\n}", "codellama": "define dso_local void @nni_sock_sys_init() {\nB:\n%0 = load i32, ptr @nni_sock, align 4\n%1 = load i32, ptr @s_node, align 4\n%2 = tail call i32 @offsetof(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 @nni_list_init_offset(ptr noundef nonnull @sock_list, i32 noundef %2)\n%4 = tail call i32 @nni_mtx_init(ptr noundef nonnull @sock_lk)\n%5 = tail call i32 @nni_id_map_init(ptr noundef nonnull @sock_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\n%6 = tail call i32 @nni_id_map_init(ptr noundef nonnull @ctx_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\nstore i32 1, ptr @inited, align 4\nret void\n}", "codegemma": "define dso_local void @nni_sock_sys_init() {\nB:\n%0 = load i32, ptr @nni_sock, align 4\n%1 = load i32, ptr @s_node, align 4\n%2 = tail call i32 @offsetof(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 @nni_list_init_offset(ptr noundef nonnull @sock_list, i32 noundef %2)\n%4 = tail call i32 @nni_mtx_init(ptr noundef nonnull @sock_lk)\n%5 = tail call i32 @nni_id_map_init(ptr noundef nonnull @sock_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\n%6 = tail call i32 @nni_id_map_init(ptr noundef nonnull @ctx_ids, i32 noundef 1, i32 noundef 2147483647, i32 noundef 0)\nstore i32 1, ptr @inited, align 4\nret void\n}"}, "define dso_local void @TimerScheduler_Init() {\n%1 = call i32 (...) @TimerList_Init()\nret void\n}": {"base_truth": "define dso_local void @TimerScheduler_Init() {\nB:\n%0 = tail call i32 (...) @TimerList_Init()\nret void\n}", "codellama": "define dso_local void @TimerScheduler_Init() {\nB:\n%0 = tail call i32 (...) @TimerList_Init()\nret void\n}", "codegemma": "define dso_local void @TimerScheduler_Init() {\nB:\n%0 = tail call i32 (...) @TimerList_Init()\nret void\n}"}, "define internal void @vpush_tokc(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca %struct.TYPE_3__, align 8\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 24, ptr %3)\ncall void @llvm.memset.p0.i64(ptr align 8 %3, i8 0, i64 24, i1 false)\n%4 = load i32, ptr %2, align 4\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\nstore i32 %4, ptr %5, align 8\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 1\nstore ptr null, ptr %6, align 8\n%7 = load i32, ptr @VT_CONST, align 4\n%8 = call i32 @vsetc(ptr noundef %3, i32 noundef %7, ptr noundef @tokc)\ncall void @llvm.lifetime.end.p0(i64 24, ptr %3)\nret void\n}": {"base_truth": "define internal void @vpush_tokc(i32 noundef %0) {\nB:\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %1)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %1, i8 0, i64 24, i1 false)\nstore i32 %0, ptr %1, align 8\n%2 = load i32, ptr @VT_CONST, align 4\n%3 = call i32 @vsetc(ptr noundef nonnull %1, i32 noundef %2, ptr noundef nonnull @tokc)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %1)\nret void\n}", "codellama": "define internal void @vpush_tokc(i32 noundef %0) {\nB:\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %1)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %1, i8 0, i64 24, i1 false)\nstore i32 %0, ptr %1, align 8\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\nstore ptr null, ptr %2, align 8\n%3 = load i32, ptr @VT_CONST, align 4\n%4 = call i32 @vsetc(ptr noundef nonnull %1, i32 noundef %3, ptr noundef nonnull @tokc)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %1)\nret void\n}", "codegemma": "define internal void @vpush_tokc(i32 noundef %0) {\nB:\n%1 = alloca %struct.TYPE_3__, align 8\ncall void @llvm.lifetime.start.p0(i64 24, ptr nonnull %1)\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %1, i8 0, i64 24, i1 false)\nstore i32 %0, ptr %1, align 8\n%2 = getelementptr inbounds %struct.TYPE_3__, ptr %1, i64 0, i32 1\nstore ptr null, ptr %2, align 8\n%3 = load i32, ptr @VT_CONST, align 4\n%4 = call i32 @vsetc(ptr noundef nonnull %1, i32 noundef %3, ptr noundef nonnull @tokc)\ncall void @llvm.lifetime.end.p0(i64 24, ptr nonnull %1)\nret void\n}"}, "define dso_local void @PushSyntax(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @PushSyntax2(i32 noundef %3, i32 noundef 0)\nret void\n}": {"base_truth": "define dso_local void @PushSyntax(i32 noundef %0) {\nB:\n%1 = tail call i32 @PushSyntax2(i32 noundef %0, i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @PushSyntax(i32 noundef %0) {\nB:\n%1 = tail call i32 @PushSyntax2(i32 noundef %0, i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @PushSyntax(i32 noundef %0) {\nB:\n%1 = tail call i32 @PushSyntax2(i32 noundef %0, i32 noundef 0)\nret void\n}"}, "define internal i32 @mlx5e_grp_2863_get_num_stats(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load i32, ptr @NUM_PPORT_2863_COUNTERS, align 4\nret i32 %3\n}": {"base_truth": "define internal i32 @mlx5e_grp_2863_get_num_stats(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @NUM_PPORT_2863_COUNTERS, align 4\nret i32 %1\n}", "codellama": "define internal i32 @mlx5e_grp_2863_get_num_stats(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @NUM_PPORT_2863_COUNTERS, align 4\nret i32 %1\n}", "codegemma": "define internal i32 @mlx5e_grp_2863_get_num_stats(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @NUM_PPORT_2863_COUNTERS, align 4\nret i32 %1\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca %struct.sigaction, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%3 = load i32, ptr @sigint_handler, align 4\n%4 = getelementptr inbounds %struct.sigaction, ptr %2, i32 0, i32 0\nstore i32 %3, ptr %4, align 4\n%5 = load i32, ptr @SIGINT, align 4\n%6 = call i32 @sigaction(i32 noundef %5, ptr noundef %2, ptr noundef null)\n%7 = call i32 (...) @shell_loop()\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = load i32, ptr @sigint_handler, align 4\nstore i32 %1, ptr %0, align 4\n%2 = load i32, ptr @SIGINT, align 4\n%3 = call i32 @sigaction(i32 noundef %2, ptr noundef nonnull %0, ptr noundef null)\n%4 = call i32 (...) @shell_loop()\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %4\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = load i32, ptr @sigint_handler, align 4\nstore i32 %1, ptr %0, align 4\n%2 = load i32, ptr @SIGINT, align 4\n%3 = call i32 @sigaction(i32 noundef %2, ptr noundef nonnull %0, ptr noundef null)\n%4 = call i32 (...) @shell_loop()\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %4\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca %struct.sigaction, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = load i32, ptr @sigint_handler, align 4\nstore i32 %1, ptr %0, align 4\n%2 = load i32, ptr @SIGINT, align 4\n%3 = call i32 @sigaction(i32 noundef %2, ptr noundef nonnull %0, ptr noundef null)\n%4 = call i32 (...) @shell_loop()\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %4\n}"}, "define internal i32 @central_print_res(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.central_devinfo ptr %3, i32 0, i32 0\n%5 = load i32, ptr @SYS_RES_MEMORY, align 4\n%6 = call i32 @resource_list_print_type(ptr noundef %4, ptr noundef @.str, i32 noundef %5, ptr noundef @.str.1)\nret i32 %6\n}": {"base_truth": "define internal i32 @central_print_res(ptr noundef %0) {\nB:\n%1 = load i32, ptr @SYS_RES_MEMORY, align 4\n%2 = tail call i32 @resource_list_print_type(ptr noundef %0, ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull @.str.1)\nret i32 %2\n}", "codellama": "define internal i32 @central_print_res(ptr noundef %0) {\nB:\n%1 = load i32, ptr @SYS_RES_MEMORY, align 4\n%2 = tail call i32 @resource_list_print_type(ptr noundef %0, ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull @.str.1)\nret i32 %2\n}", "codegemma": "define internal i32 @central_print_res(ptr noundef %0) {\nB:\n%1 = load i32, ptr @SYS_RES_MEMORY, align 4\n%2 = tail call i32 @resource_list_print_type(ptr noundef %0, ptr noundef nonnull @.str, i32 noundef %1, ptr noundef nonnull @.str.1)\nret i32 %2\n}"}, "define dso_local i32 @make_env_t_1055(i32 noundef %0) {\n%2 = alloca %struct.TYPE_3__, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i32 0, i32 0\nstore i32 %4, ptr %5, align 4\n%6 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\nret i32 %7\n}": {"base_truth": "define dso_local i32 @make_env_t_1055(i32 noundef returned %0) {\nB:\nret i32 %0\n}", "codellama": "define dso_local i32 @make_env_t_1055(i32 noundef returned %0) {\nB:\nret i32 %0\n}", "codegemma": "define dso_local i32 @make_env_t_1055(i32 noundef returned %0) {\nB:\nret i32 %0\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca ptr, align 8\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%3 = call ptr (...) @curl_easy_init()\nstore ptr %3, ptr %2, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = icmp ne ptr %4, null\nbr i1 %5, label %6, label %26\n\n6:\n%7 = load ptr, ptr %2, align 8\n%8 = load i32, ptr @CURLOPT_URL, align 4\n%9 = call i32 @curl_easy_setopt(ptr noundef %7, i32 noundef %8, ptr noundef @.str)\n%10 = load ptr, ptr %2, align 8\n%11 = load i32, ptr @CURLOPT_CONV_FROM_NETWORK_FUNCTION, align 4\n%12 = load ptr, ptr @my_conv_from_ascii_to_ebcdic, align 8\n%13 = call i32 @curl_easy_setopt(ptr noundef %10, i32 noundef %11, ptr noundef %12)\n%14 = load ptr, ptr %2, align 8\n%15 = load i32, ptr @CURLOPT_CONV_TO_NETWORK_FUNCTION, align 4\n%16 = load ptr, ptr @my_conv_from_ebcdic_to_ascii, align 8\n%17 = call i32 @curl_easy_setopt(ptr noundef %14, i32 noundef %15, ptr noundef %16)\n%18 = load ptr, ptr %2, align 8\n%19 = load i32, ptr @CURLOPT_CONV_FROM_UTF8_FUNCTION, align 4\n%20 = load ptr, ptr @my_conv_from_utf8_to_ebcdic, align 8\n%21 = call i32 @curl_easy_setopt(ptr noundef %18, i32 noundef %19, ptr noundef %20)\n%22 = load ptr, ptr %2, align 8\n%23 = call i32 @curl_easy_perform(ptr noundef %22)\n%24 = load ptr, ptr %2, align 8\n%25 = call i32 @curl_easy_cleanup(ptr noundef %24)\nbr label %26\n\n26:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr (...) @curl_easy_init()\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr @CURLOPT_URL, align 4\n%3 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %2, ptr noundef nonnull @.str)\n%4 = load i32, ptr @CURLOPT_CONV_FROM_NETWORK_FUNCTION, align 4\n%5 = load ptr, ptr @my_conv_from_ascii_to_ebcdic, align 8\n%6 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %4, ptr noundef %5)\n%7 = load i32, ptr @CURLOPT_CONV_TO_NETWORK_FUNCTION, align 4\n%8 = load ptr, ptr @my_conv_from_ebcdic_to_ascii, align 8\n%9 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %7, ptr noundef %8)\n%10 = load i32, ptr @CURLOPT_CONV_FROM_UTF8_FUNCTION, align 4\n%11 = load ptr, ptr @my_conv_from_utf8_to_ebcdic, align 8\n%12 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %10, ptr noundef %11)\n%13 = tail call i32 @curl_easy_perform(ptr noundef nonnull %0)\n%14 = tail call i32 @curl_easy_cleanup(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr (...) @curl_easy_init()\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr @CURLOPT_URL, align 4\n%3 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %2, ptr noundef nonnull @.str)\n%4 = load i32, ptr @CURLOPT_CONV_FROM_NETWORK_FUNCTION, align 4\n%5 = load ptr, ptr @my_conv_from_ascii_to_ebcdic, align 8\n%6 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %4, ptr noundef %5)\n%7 = load i32, ptr @CURLOPT_CONV_TO_NETWORK_FUNCTION, align 4\n%8 = load ptr, ptr @my_conv_from_ebcdic_to_ascii, align 8\n%9 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %7, ptr noundef %8)\n%10 = load i32, ptr @CURLOPT_CONV_FROM_UTF8_FUNCTION, align 4\n%11 = load ptr, ptr @my_conv_from_utf8_to_ebcdic, align 8\n%12 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %10, ptr noundef %11)\n%13 = tail call i32 @curl_easy_perform(ptr noundef nonnull %0)\n%14 = tail call i32 @curl_easy_cleanup(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr (...) @curl_easy_init()\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = load i32, ptr @CURLOPT_URL, align 4\n%3 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %2, ptr noundef nonnull @.str)\n%4 = load i32, ptr @CURLOPT_CONV_FROM_NETWORK_FUNCTION, align 4\n%5 = load ptr, ptr @my_conv_from_ascii_to_ebcdic, align 8\n%6 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %4, ptr noundef %5)\n%7 = load i32, ptr @CURLOPT_CONV_TO_NETWORK_FUNCTION, align 4\n%8 = load ptr, ptr @my_conv_from_ebcdic_to_ascii, align 8\n%9 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %7, ptr noundef %8)\n%10 = load i32, ptr @CURLOPT_CONV_FROM_UTF8_FUNCTION, align 4\n%11 = load ptr, ptr @my_conv_from_utf8_to_ebcdic, align 8\n%12 = tail call i32 @curl_easy_setopt(ptr noundef nonnull %0, i32 noundef %10, ptr noundef %11)\n%13 = tail call i32 @curl_easy_perform(ptr noundef nonnull %0)\n%14 = tail call i32 @curl_easy_cleanup(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret i32 0\n}"}, "define internal void @xencons_cnterm(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define internal void @xencons_cnterm(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define internal void @xencons_cnterm(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define internal void @xencons_cnterm(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define dso_local void @firstPwd() {\n%1 = alloca [1024 x i8], align 16\n%2 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 1024, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\n%3 = getelementptr inbounds [1024 x i8], ptr %1, i64 0, i64 0\n%4 = call ptr @getcwd(ptr noundef %3, i32 noundef 1024)\nstore ptr %4, ptr %2, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = icmp eq ptr null, %5\nbr i1 %6, label %7, label %10\n\n7:\n%8 = call i32 @perror(ptr noundef @.str)\n%9 = call i32 @exit(i32 noundef -1)\nunreachable\n\n10:\n%11 = load ptr, ptr %2, align 8\n%12 = call i32 @printf(ptr noundef @.str.1, ptr noundef %11)\nbr label %13\n\n13:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 1024, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @firstPwd() {\nB:\n%0 = alloca [1024 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %0)\n%1 = call ptr @getcwd(ptr noundef nonnull %0, i32 noundef 1024)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = call i32 @perror(ptr noundef nonnull @.str)\n%4 = call i32 @exit(i32 noundef -1)\nunreachable\n\nB2:\n%5 = call i32 @printf(ptr noundef nonnull @.str.1, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %0)\nret void\n}", "codellama": "define dso_local void @firstPwd() {\nB:\n%0 = alloca [1024 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %0)\n%1 = call ptr @getcwd(ptr noundef nonnull %0, i32 noundef 1024)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = call i32 @perror(ptr noundef nonnull @.str)\n%4 = call i32 @exit(i32 noundef -1)\nunreachable\n\nB2:\n%5 = call i32 @printf(ptr noundef nonnull @.str.1, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %0)\nret void\n}", "codegemma": "define dso_local void @firstPwd() {\nB:\n%0 = alloca [1024 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %0)\n%1 = call ptr @getcwd(ptr noundef nonnull %0, i32 noundef 1024)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = call i32 @perror(ptr noundef nonnull @.str)\n%4 = call i32 @exit(i32 noundef -1)\nunreachable\n\nB2:\n%5 = call i32 @printf(ptr noundef nonnull @.str.1, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %0)\nret void\n}"}, "define dso_local i32 @libfoo2_LTX_hello() {\n%1 = call i32 @printf(ptr noundef @.str)\nret i32 57616\n}": {"base_truth": "define dso_local i32 @libfoo2_LTX_hello() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 57616\n}", "codellama": "define dso_local i32 @libfoo2_LTX_hello() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 57616\n}", "codegemma": "define dso_local i32 @libfoo2_LTX_hello() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 57616\n}"}, "define dso_local void @wStackPush(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @wMemTest(ptr noundef %5, ptr noundef @.str)\n%7 = call ptr (...) @wStackPushNothing()\nstore ptr %7, ptr %4, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = call i32 @wMemTest(ptr noundef %8, ptr noundef @.str.1)\n%10 = load ptr, ptr %4, align 8\n%11 = load ptr, ptr %2, align 8\n%12 = call i32 @wVariantCopy(ptr noundef %10, ptr noundef %11)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @wStackPush(ptr noundef %0) {\nB:\n%1 = tail call i32 @wMemTest(ptr noundef %0, ptr noundef nonnull @.str)\n%2 = tail call ptr (...) @wStackPushNothing()\n%3 = tail call i32 @wMemTest(ptr noundef %2, ptr noundef nonnull @.str.1)\n%4 = tail call i32 @wVariantCopy(ptr noundef %2, ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @wStackPush(ptr noundef %0) {\nB:\n%1 = tail call i32 @wMemTest(ptr noundef %0, ptr noundef nonnull @.str)\n%2 = tail call ptr (...) @wStackPushNothing()\n%3 = tail call i32 @wMemTest(ptr noundef %2, ptr noundef nonnull @.str.1)\n%4 = tail call i32 @wVariantCopy(ptr noundef %2, ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @wStackPush(ptr noundef %0) {\nB:\n%1 = tail call i32 @wMemTest(ptr noundef %0, ptr noundef nonnull @.str)\n%2 = tail call ptr (...) @wStackPushNothing()\n%3 = tail call i32 @wMemTest(ptr noundef %2, ptr noundef nonnull @.str.1)\n%4 = tail call i32 @wVariantCopy(ptr noundef %2, ptr noundef %0)\nret void\n}"}, "define dso_local void @ecore_ppfid_wr(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\n%11 = alloca i32, align 4\nstore ptr %0, ptr %6, align 8\nstore ptr %1, ptr %7, align 8\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\nstore i32 %4, ptr %10, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %11)\n%12 = load ptr, ptr %6, align 8\n%13 = load i32, ptr %8, align 4\n%14 = call i32 @ECORE_PFID_BY_PPFID(ptr noundef %12, i32 noundef %13)\nstore i32 %14, ptr %11, align 4\n%15 = load ptr, ptr %6, align 8\n%16 = load ptr, ptr %7, align 8\n%17 = load i32, ptr %11, align 4\n%18 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%19 = shl i32 %17, %18\n%20 = call i32 @ecore_fid_pretend(ptr noundef %15, ptr noundef %16, i32 noundef %19)\n%21 = load ptr, ptr %6, align 8\n%22 = load ptr, ptr %7, align 8\n%23 = load i32, ptr %9, align 4\n%24 = load i32, ptr %10, align 4\n%25 = call i32 @ecore_wr(ptr noundef %21, ptr noundef %22, i32 noundef %23, i32 noundef %24)\n%26 = load ptr, ptr %6, align 8\n%27 = load ptr, ptr %7, align 8\n%28 = load ptr, ptr %6, align 8\n%29 = getelementptr inbounds %struct.ecore_hwfn ptr %28, i32 0, i32 0\n%30 = load i32, ptr %29, align 4\n%31 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%32 = shl i32 %30, %31\n%33 = call i32 @ecore_fid_pretend(ptr noundef %26, ptr noundef %27, i32 noundef %32)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %11)\nret void\n}": {"base_truth": "define dso_local void @ecore_ppfid_wr(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = tail call i32 @ECORE_PFID_BY_PPFID(ptr noundef %0, i32 noundef %2)\n%6 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%7 = shl i32 %5, %6\n%8 = tail call i32 @ecore_fid_pretend(ptr noundef %0, ptr noundef %1, i32 noundef %7)\n%9 = tail call i32 @ecore_wr(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4)\n%10 = load i32, ptr %0, align 4\n%11 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%12 = shl i32 %10, %11\n%13 = tail call i32 @ecore_fid_pretend(ptr noundef nonnull %0, ptr noundef %1, i32 noundef %12)\nret void\n}", "codellama": "define dso_local void @ecore_ppfid_wr(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = tail call i32 @ECORE_PFID_BY_PPFID(ptr noundef %0, i32 noundef %2)\n%6 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%7 = shl i32 %5, %6\n%8 = tail call i32 @ecore_fid_pretend(ptr noundef %0, ptr noundef %1, i32 noundef %7)\n%9 = tail call i32 @ecore_wr(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4)\n%10 = load i32, ptr %0, align 4\n%11 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%12 = shl i32 %10, %11\n%13 = tail call i32 @ecore_fid_pretend(ptr noundef nonnull %0, ptr noundef %1, i32 noundef %12)\nret void\n}", "codegemma": "define dso_local void @ecore_ppfid_wr(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = tail call i32 @ECORE_PFID_BY_PPFID(ptr noundef %0, i32 noundef %2)\n%6 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%7 = shl i32 %5, %6\n%8 = tail call i32 @ecore_fid_pretend(ptr noundef %0, ptr noundef %1, i32 noundef %7)\n%9 = tail call i32 @ecore_wr(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4)\n%10 = load i32, ptr %0, align 4\n%11 = load i32, ptr @PXP_PRETEND_CONCRETE_FID_PFID_SHIFT, align 4\n%12 = shl i32 %10, %11\n%13 = tail call i32 @ecore_fid_pretend(ptr noundef nonnull %0, ptr noundef %1, i32 noundef %12)\nret void\n}"}, "define dso_local ptr @kr_client_info_table(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr %4, align 4\n%7 = call ptr @kr_client_apply(ptr noundef %5, i32 noundef 32, i32 noundef %6, i32 noundef 0, ptr noundef null)\nret ptr %7\n}": {"base_truth": "define dso_local ptr @kr_client_info_table(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @kr_client_apply(ptr noundef %0, i32 noundef 32, i32 noundef %1, i32 noundef 0, ptr noundef null)\nret ptr %2\n}", "codellama": "define dso_local ptr @kr_client_info_table(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @kr_client_apply(ptr noundef %0, i32 noundef 32, i32 noundef %1, i32 noundef 0, ptr noundef null)\nret ptr %2\n}", "codegemma": "define dso_local ptr @kr_client_info_table(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @kr_client_apply(ptr noundef %0, i32 noundef 32, i32 noundef %1, i32 noundef 0, ptr noundef null)\nret ptr %2\n}"}, "define dso_local void @printer_print_temperature() {\n%1 = call i64 @heater_get_temperature(ptr noundef @nozzle)\n%2 = trunc i64 %1 to i32\n%3 = call i64 @heater_get_temperature(ptr noundef @bed)\n%4 = trunc i64 %3 to i32\n%5 = call i32 @uart_printf(ptr noundef @.str, i32 noundef %2, i32 noundef %4)\nret void\n}": {"base_truth": "define dso_local void @printer_print_temperature() {\nB:\n%0 = tail call i64 @heater_get_temperature(ptr noundef nonnull @nozzle)\n%1 = trunc i64 %0 to i32\n%2 = tail call i64 @heater_get_temperature(ptr noundef nonnull @bed)\n%3 = trunc i64 %2 to i32\n%4 = tail call i32 @uart_printf(ptr noundef nonnull @.str, i32 noundef %1, i32 noundef %3)\nret void\n}", "codellama": "define dso_local void @printer_print_temperature() {\nB:\n%0 = tail call i64 @heater_get_temperature(ptr noundef nonnull @nozzle)\n%1 = tail call i64 @heater_get_temperature(ptr noundef nonnull @bed)\n%2 = tail call i32 @uart_printf(ptr noundef nonnull @.str, i32 noundef trunc i64 %0 to i32, i32 noundef trunc i64 %1 to i32)\nret void\n}", "codegemma": "define dso_local void @printer_print_temperature() {\nB:\n%0 = tail call i64 @heater_get_temperature(ptr noundef nonnull @nozzle)\n%1 = trunc i64 %0 to i32\n%2 = tail call i64 @heater_get_temperature(ptr noundef nonnull @bed)\n%3 = trunc i64 %2 to i32\n%4 = tail call i32 @uart_printf(ptr noundef nonnull @.str, i32 noundef %1, i32 noundef %3)\nret void\n}"}, "define dso_local i32 @rs600_get_vblank_counter(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %5, align 4\n%7 = icmp eq i32 %6, 0\nbr i1 %7, label %8, label %11\n\n8:\n%9 = load i32, ptr @R_0060A4_D1CRTC_STATUS_FRAME_COUNT, align 4\n%10 = call i32 @RREG32(i32 noundef %9)\nstore i32 %10, ptr %3, align 4\nbr label %14\n\n11:\n%12 = load i32, ptr @R_0068A4_D2CRTC_STATUS_FRAME_COUNT, align 4\n%13 = call i32 @RREG32(i32 noundef %12)\nstore i32 %13, ptr %3, align 4\nbr label %14\n\n14:\n%15 = load i32, ptr %3, align 4\nret i32 %15\n}": {"base_truth": "define dso_local i32 @rs600_get_vblank_counter(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\n%3 = load i32, ptr @R_0060A4_D1CRTC_STATUS_FRAME_COUNT, align 4\n%4 = load i32, ptr @R_0068A4_D2CRTC_STATUS_FRAME_COUNT, align 4\n%5 = select i1 %2, i32 %3, i32 %4\n%6 = tail call i32 @RREG32(i32 noundef %5)\nret i32 %6\n}", "codellama": "define dso_local i32 @rs600_get_vblank_counter(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\n%3 = load i32, ptr @R_0060A4_D1CRTC_STATUS_FRAME_COUNT, align 4\n%4 = load i32, ptr @R_0068A4_D2CRTC_STATUS_FRAME_COUNT, align 4\n%5 = select i1 %2, i32 %3, i32 %4\n%6 = tail call i32 @RREG32(i32 noundef %5)\nret i32 %6\n}", "codegemma": "define dso_local i32 @rs600_get_vblank_counter(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\n%3 = load i32, ptr @R_0060A4_D1CRTC_STATUS_FRAME_COUNT, align 4\n%4 = load i32, ptr @R_0068A4_D2CRTC_STATUS_FRAME_COUNT, align 4\n%5 = select i1 %2, i32 %3, i32 %4\n%6 = tail call i32 @RREG32(i32 noundef %5)\nret i32 %6\n}"}, "define internal void @Temp2CHAD(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore ptr %1, ptr %5, align 8\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %8)\n%9 = load i32, ptr %4, align 4\n%10 = load i32, ptr %6, align 4\n%11 = call i32 @cmsWhitePointFromTemp(i32 noundef %9, ptr noundef %8, i32 noundef %10)\n%12 = load i32, ptr %4, align 4\n%13 = call i32 @cmsxyY2XYZ(i32 noundef %12, ptr noundef %7, ptr noundef %8)\n%14 = load i32, ptr %4, align 4\n%15 = load ptr, ptr %5, align 8\n%16 = load i32, ptr %4, align 4\n%17 = call i32 @cmsD50_XYZ(i32 noundef %16)\n%18 = call i32 @_cmsAdaptationMatrix(i32 noundef %14, ptr noundef %15, ptr noundef null, ptr noundef %7, i32 noundef %17)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %8)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret void\n}": {"base_truth": "define internal void @Temp2CHAD(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\n%5 = call i32 @cmsWhitePointFromTemp(i32 noundef %0, ptr noundef nonnull %4, i32 noundef %2)\n%6 = call i32 @cmsxyY2XYZ(i32 noundef %0, ptr noundef nonnull %3, ptr noundef nonnull %4)\n%7 = call i32 @cmsD50_XYZ(i32 noundef %0)\n%8 = call i32 @_cmsAdaptationMatrix(i32 noundef %0, ptr noundef %1, ptr noundef null, ptr noundef nonnull %3, i32 noundef %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret void\n}", "codellama": "define internal void @Temp2CHAD(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\n%5 = call i32 @cmsWhitePointFromTemp(i32 noundef %0, ptr noundef nonnull %4, i32 noundef %2)\n%6 = call i32 @cmsxyY2XYZ(i32 noundef %0, ptr noundef nonnull %3, ptr noundef nonnull %4)\n%7 = call i32 @cmsD50_XYZ(i32 noundef %0)\n%8 = call i32 @_cmsAdaptationMatrix(i32 noundef %0, ptr noundef %1, ptr noundef null, ptr noundef nonnull %3, i32 noundef %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret void\n}", "codegemma": "define internal void @Temp2CHAD(i32 noundef %0, ptr noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)\n%5 = call i32 @cmsWhitePointFromTemp(i32 noundef %0, ptr noundef nonnull %4, i32 noundef %2)\n%6 = call i32 @cmsxyY2XYZ(i32 noundef %0, ptr noundef nonnull %3, ptr noundef nonnull %4)\n%7 = call i32 @cmsD50_XYZ(i32 noundef %0)\n%8 = call i32 @_cmsAdaptationMatrix(i32 noundef %0, ptr noundef %1, ptr noundef null, ptr noundef nonnull %3, i32 noundef %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)\nret void\n}"}, "define dso_local i32 @globus_list_empty(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp eq ptr %3, null\n%5 = zext i1 %4 to i32\nret i32 %5\n}": {"base_truth": "define dso_local i32 @globus_list_empty(ptr noundef readnone %0) {\nB:\n%1 = icmp eq ptr %0, null\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codellama": "define dso_local i32 @globus_list_empty(ptr noundef readnone %0) {\nB:\n%1 = icmp eq ptr %0, null\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codegemma": "define dso_local i32 @globus_list_empty(ptr noundef readnone %0) {\nB:\n%1 = icmp eq ptr %0, null\n%2 = zext i1 %1 to i32\nret i32 %2\n}"}, "define dso_local i32 @nd6_prefix_onlink(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @IFSCOPE_NONE, align 4\n%6 = call i32 @nd6_prefix_onlink_common(ptr noundef %3, i32 noundef %4, i32 noundef %5)\nret i32 %6\n}": {"base_truth": "define dso_local i32 @nd6_prefix_onlink(ptr noundef %0) {\nB:\n%1 = load i32, ptr @FALSE, align 4\n%2 = load i32, ptr @IFSCOPE_NONE, align 4\n%3 = tail call i32 @nd6_prefix_onlink_common(ptr noundef %0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @nd6_prefix_onlink(ptr noundef %0) {\nB:\n%1 = load i32, ptr @FALSE, align 4\n%2 = load i32, ptr @IFSCOPE_NONE, align 4\n%3 = tail call i32 @nd6_prefix_onlink_common(ptr noundef %0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @nd6_prefix_onlink(ptr noundef %0) {\nB:\n%1 = load i32, ptr @FALSE, align 4\n%2 = load i32, ptr @IFSCOPE_NONE, align 4\n%3 = tail call i32 @nd6_prefix_onlink_common(ptr noundef %0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}"}, "define dso_local i32 @get_CA6() {\n%1 = load i32, ptr @extern_CA6, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @get_CA6() {\nB:\n%0 = load i32, ptr @extern_CA6, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @get_CA6() {\nB:\n%0 = load i32, ptr @extern_CA6, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @get_CA6() {\nB:\n%0 = load i32, ptr @extern_CA6, align 4\nret i32 %0\n}"}, "define dso_local void @ConsoleResetAnsiSequence() {\nstore ptr @.str, ptr @ansi_standout, align 8\nstore ptr @.str, ptr @ansi_reverse, align 8\nstore ptr @.str.1, ptr @ansi_blink, align 8\nstore ptr @.str.2, ptr @ansi_underline, align 8\nstore ptr @.str.3, ptr @ansi_hilight, align 8\nret void\n}": {"base_truth": "define dso_local void @ConsoleResetAnsiSequence() {\nB:\nstore ptr @.str, ptr @ansi_standout, align 8\nstore ptr @.str, ptr @ansi_reverse, align 8\nstore ptr @.str.1, ptr @ansi_blink, align 8\nstore ptr @.str.2, ptr @ansi_underline, align 8\nstore ptr @.str.3, ptr @ansi_hilight, align 8\nret void\n}", "codellama": "define dso_local void @ConsoleResetAnsiSequence() {\nB:\nstore ptr @.str, ptr @ansi_standout, align 8\nstore ptr @.str, ptr @ansi_reverse, align 8\nstore ptr @.str.1, ptr @ansi_blink, align 8\nstore ptr @.str.2, ptr @ansi_underline, align 8\nstore ptr @.str.3, ptr @ansi_hilight, align 8\nret void\n}", "codegemma": "define dso_local void @ConsoleResetAnsiSequence() {\nB:\nstore ptr @.str, ptr @ansi_standout, align 8\nstore ptr @.str, ptr @ansi_reverse, align 8\nstore ptr @.str.1, ptr @ansi_blink, align 8\nstore ptr @.str.2, ptr @ansi_underline, align 8\nstore ptr @.str.3, ptr @ansi_hilight, align 8\nret void\n}"}, "define dso_local void @d_move(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = call i32 @spin_lock(ptr noundef @dcache_lock)\n%6 = load ptr, ptr %3, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = call i32 @d_move_locked(ptr noundef %6, ptr noundef %7)\n%9 = call i32 @spin_unlock(ptr noundef @dcache_lock)\nret void\n}": {"base_truth": "define dso_local void @d_move(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @spin_lock(ptr noundef nonnull @dcache_lock)\n%3 = tail call i32 @d_move_locked(ptr noundef %0, ptr noundef %1)\n%4 = tail call i32 @spin_unlock(ptr noundef nonnull @dcache_lock)\nret void\n}", "codellama": "define dso_local void @d_move(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @spin_lock(ptr noundef nonnull @dcache_lock)\n%3 = tail call i32 @d_move_locked(ptr noundef %0, ptr noundef %1)\n%4 = tail call i32 @spin_unlock(ptr noundef nonnull @dcache_lock)\nret void\n}", "codegemma": "define dso_local void @d_move(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @spin_lock(ptr noundef nonnull @dcache_lock)\n%3 = tail call i32 @d_move_locked(ptr noundef %0, ptr noundef %1)\n%4 = tail call i32 @spin_unlock(ptr noundef nonnull @dcache_lock)\nret void\n}"}, "define dso_local i32 @dlg_last_getc() {\n%1 = load i32, ptr @last_getc, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @dlg_last_getc() {\nB:\n%0 = load i32, ptr @last_getc, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @dlg_last_getc() {\nB:\n%0 = load i32, ptr @last_getc, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @dlg_last_getc() {\nB:\n%0 = load i32, ptr @last_getc, align 4\nret i32 %0\n}"}, "define dso_local void @ccu_gate_helper_disable(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i64, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%8 = load i32, ptr %4, align 4\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %11, label %10\n\n10:\nstore i32 1, ptr %7, align 4\nbr label %42\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.ccu_common ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 8\n%15 = load i64, ptr %5, align 8\n%16 = call i32 @spin_lock_irqsave(i32 noundef %14, i64 noundef %15)\n%17 = load ptr, ptr %3, align 8\n%18 = getelementptr inbounds %struct.ccu_common ptr %17, i32 0, i32 2\n%19 = load i64, ptr %18, align 8\n%20 = load ptr, ptr %3, align 8\n%21 = getelementptr inbounds %struct.ccu_common ptr %20, i32 0, i32 1\n%22 = load i64, ptr %21, align 8\n%23 = add nsw i64 %19, %22\n%24 = call i32 @readl(i64 noundef %23)\nstore i32 %24, ptr %6, align 4\n%25 = load i32, ptr %6, align 4\n%26 = load i32, ptr %4, align 4\n%27 = xor i32 %26, -1\n%28 = and i32 %25, %27\n%29 = load ptr, ptr %3, align 8\n%30 = getelementptr inbounds %struct.ccu_common ptr %29, i32 0, i32 2\n%31 = load i64, ptr %30, align 8\n%32 = load ptr, ptr %3, align 8\n%33 = getelementptr inbounds %struct.ccu_common ptr %32, i32 0, i32 1\n%34 = load i64, ptr %33, align 8\n%35 = add nsw i64 %31, %34\n%36 = call i32 @writel(i32 noundef %28, i64 noundef %35)\n%37 = load ptr, ptr %3, align 8\n%38 = getelementptr inbounds %struct.ccu_common ptr %37, i32 0, i32 0\n%39 = load i32, ptr %38, align 8\n%40 = load i64, ptr %5, align 8\n%41 = call i32 @spin_unlock_irqrestore(i32 noundef %39, i64 noundef %40)\nstore i32 0, ptr %7, align 4\nbr label %42\n\n42:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\n%43 = load i32, ptr %7, align 4\nswitch i32 %43, label %45 [\ni32 0, label %44\ni32 1, label %44\n]\n\n44:\nret void\n\n45:\nunreachable\n}": {"base_truth": "define dso_local void @ccu_gate_helper_disable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 8\n%4 = tail call i32 @spin_lock_irqsave(i32 noundef %3, i64 noundef undef)\n%5 = getelementptr inbounds %struct.ccu_common, ptr %0, i64 0, i32 2\n%6 = load i64, ptr %5, align 8\n%7 = getelementptr inbounds %struct.ccu_common, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = add nsw i64 %8, %6\n%10 = tail call i32 @readl(i64 noundef %9)\n%11 = xor i32 %1, -1\n%12 = and i32 %10, %11\n%13 = load i64, ptr %5, align 8\n%14 = load i64, ptr %7, align 8\n%15 = add nsw i64 %14, %13\n%16 = tail call i32 @writel(i32 noundef %12, i64 noundef %15)\n%17 = load i32, ptr %0, align 8\n%18 = tail call i32 @spin_unlock_irqrestore(i32 noundef %17, i64 noundef undef)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @ccu_gate_helper_disable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 8\n%4 = tail call i32 @spin_lock_irqsave(i32 noundef %3, i64 noundef undef)\n%5 = getelementptr inbounds %struct.ccu_common, ptr %0, i64 0, i32 2\n%6 = load i64, ptr %5, align 8\n%7 = getelementptr inbounds %struct.ccu_common, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = add nsw i64 %8, %6\n%10 = tail call i32 @readl(i64 noundef %9)\n%11 = xor i32 %1, -1\n%12 = and i32 %10, %11\n%13 = load i64, ptr %5, align 8\n%14 = load i64, ptr %7, align 8\n%15 = add nsw i64 %14, %13\n%16 = tail call i32 @writel(i32 noundef %12, i64 noundef %15)\n%17 = load i32, ptr %0, align 8\n%18 = tail call i32 @spin_unlock_irqrestore(i32 noundef %17, i64 noundef undef)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @ccu_gate_helper_disable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = icmp eq i32 %1, 0\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = load i32, ptr %0, align 8\n%4 = tail call i32 @spin_lock_irqsave(i32 noundef %3, i64 noundef undef)\n%5 = getelementptr inbounds %struct.ccu_common, ptr %0, i64 0, i32 2\n%6 = load i64, ptr %5, align 8\n%7 = getelementptr inbounds %struct.ccu_common, ptr %0, i64 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = add nsw i64 %8, %6\n%10 = tail call i32 @readl(i64 noundef %9)\n%11 = xor i32 %1, -1\n%12 = and i32 %10, %11\n%13 = load i64, ptr %5, align 8\n%14 = load i64, ptr %7, align 8\n%15 = add nsw i64 %14, %13\n%16 = tail call i32 @writel(i32 noundef %12, i64 noundef %15)\n%17 = load i32, ptr %0, align 8\n%18 = tail call i32 @spin_unlock_irqrestore(i32 noundef %17, i64 noundef undef)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @hasIntAndFloat(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = sext i32 %3 to i64\n%5 = urem i64 %4, 4\n%6 = icmp eq i64 %5, 0\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define dso_local i32 @hasIntAndFloat(i32 noundef %0) {\nB:\n%1 = and i32 %0, 3\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define dso_local i32 @hasIntAndFloat(i32 noundef %0) {\nB:\n%1 = and i32 %0, 3\n%2 = icmp eq i32 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define dso_local i32 @hasIntAndFloat(i32 noundef %0) {\nB:\n%1 = sext i32 %0 to i64\n%2 = and i64 %1, 3\n%3 = icmp eq i64 %2, 0\n%4 = zext i1 %3 to i32\nret i32 %4\n}"}, "define internal void @da8xx_cfgchip_gate_clk_disable(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @to_da8xx_cfgchip_gate_clk(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk ptr %6, i32 0, i32 2\n%8 = load i32, ptr %7, align 4\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 4\n%15 = call i32 @regmap_write_bits(i32 noundef %8, i32 noundef %11, i32 noundef %14, i32 noundef 0)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @da8xx_cfgchip_gate_clk_disable(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_da8xx_cfgchip_gate_clk(ptr noundef %0)\n%2 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk, ptr %1, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk, ptr %1, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr %1, align 4\n%7 = tail call i32 @regmap_write_bits(i32 noundef %3, i32 noundef %5, i32 noundef %6, i32 noundef 0)\nret void\n}", "codellama": "define internal void @da8xx_cfgchip_gate_clk_disable(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_da8xx_cfgchip_gate_clk(ptr noundef %0)\n%2 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk, ptr %1, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk, ptr %1, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr %1, align 4\n%7 = tail call i32 @regmap_write_bits(i32 noundef %3, i32 noundef %5, i32 noundef %6, i32 noundef 0)\nret void\n}", "codegemma": "define internal void @da8xx_cfgchip_gate_clk_disable(ptr noundef %0) {\nB:\n%1 = tail call ptr @to_da8xx_cfgchip_gate_clk(ptr noundef %0)\n%2 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk, ptr %1, i64 0, i32 2\n%3 = load i32, ptr %2, align 4\n%4 = getelementptr inbounds %struct.da8xx_cfgchip_gate_clk, ptr %1, i64 0, i32 1\n%5 = load i32, ptr %4, align 4\n%6 = load i32, ptr %1, align 4\n%7 = tail call i32 @regmap_write_bits(i32 noundef %3, i32 noundef %5, i32 noundef %6, i32 noundef 0)\nret void\n}"}, "define dso_local i64 @r682side_effect_free(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i64, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\nstore i64 0, ptr %3, align 8\nstore i64 1, ptr %3, align 8\n%4 = load i64, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i64 %4\n}": {"base_truth": "define dso_local i64 @r682side_effect_free(ptr nocapture noundef readnone %0) {\nB:\nret i64 1\n}", "codellama": "define dso_local i64 @r682side_effect_free(ptr nocapture noundef readnone %0) {\nB:\nret i64 1\n}", "codegemma": "define dso_local i64 @r682side_effect_free(ptr nocapture noundef readnone %0) {\nB:\nret i64 1\n}"}, "define dso_local void @moveBackServos(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = icmp eq i32 %3, 1\nbr i1 %4, label %5, label %13\n\n5:\n%6 = load ptr, ptr @servo, align 8\n%7 = load i64, ptr @BRServo, align 8\n%8 = getelementptr inbounds i32, ptr %6, i64 %7\nstore i32 80, ptr %8, align 4\n%9 = load ptr, ptr @servo, align 8\n%10 = load i64, ptr @BLServo, align 8\n%11 = getelementptr inbounds i32, ptr %9, i64 %10\nstore i32 175, ptr %11, align 4\n%12 = call i32 @wait1Msec(i32 noundef 500)\nbr label %21\n\n13:\n%14 = load ptr, ptr @servo, align 8\n%15 = load i64, ptr @BRServo, align 8\n%16 = getelementptr inbounds i32, ptr %14, i64 %15\nstore i32 178, ptr %16, align 4\n%17 = load ptr, ptr @servo, align 8\n%18 = load i64, ptr @BLServo, align 8\n%19 = getelementptr inbounds i32, ptr %17, i64 %18\nstore i32 75, ptr %19, align 4\n%20 = call i32 @wait1Msec(i32 noundef 500)\nbr label %21\n\n21:\nret void\n}": {"base_truth": "define dso_local void @moveBackServos(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 1\n%2 = load ptr, ptr @servo, align 8\n%3 = load i64, ptr @BRServo, align 8\n%4 = getelementptr inbounds i32, ptr %2, i64 %3\n%5 = select i1 %1, i32 80, i32 178\n%6 = select i1 %1, i32 175, i32 75\nstore i32 %5, ptr %4, align 4\n%7 = load i64, ptr @BLServo, align 8\n%8 = getelementptr inbounds i32, ptr %2, i64 %7\nstore i32 %6, ptr %8, align 4\n%9 = tail call i32 @wait1Msec(i32 noundef 500)\nret void\n}", "codellama": "define dso_local void @moveBackServos(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 1\n%2 = load ptr, ptr @servo, align 8\n%3 = load i64, ptr @BRServo, align 8\n%4 = getelementptr inbounds i32, ptr %2, i64 %3\n%5 = load i64, ptr @BLServo, align 8\n%6 = getelementptr inbounds i32, ptr %2, i64 %5\n%7 = select i1 %1, i32 80, i32 178\n%8 = select i1 %1, i32 175, i32 75\nstore i32 %7, ptr %4, align 4\nstore i32 %8, ptr %6, align 4\n%9 = tail call i32 @wait1Msec(i32 noundef 500)\nret void\n}", "codegemma": "define dso_local void @moveBackServos(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 1\n%2 = load ptr, ptr @servo, align 8\n%3 = load i64, ptr @BRServo, align 8\n%4 = getelementptr inbounds i32, ptr %2, i64 %3\n%5 = load i64, ptr @BLServo, align 8\n%6 = getelementptr inbounds i32, ptr %2, i64 %5\nbr i1 %1, label %B1, label %B2\n\nB1:\nstore i32 80, ptr %4, align 4\nstore i32 175, ptr %6, align 4\nbr label %B3\n\nB2:\nstore i32 178, ptr %4, align 4\nstore i32 75, ptr %6, align 4\nbr label %B3\n\nB3:\n%7 = tail call i32 @wait1Msec(i32 noundef 500)\nret void\n}"}, "define dso_local i32 @kmain() {\n%1 = alloca i32, align 4\n%2 = call i32 (...) @kinit()\n%3 = call i32 @kexit(i32 noundef 0)\n%4 = load i32, ptr %1, align 4\nret i32 %4\n}": {"base_truth": "define dso_local i32 @kmain() {\nB:\n%0 = tail call i32 (...) @kinit()\n%1 = tail call i32 @kexit(i32 noundef 0)\nret i32 undef\n}", "codellama": "define dso_local i32 @kmain() {\nB:\n%0 = tail call i32 (...) @kinit()\n%1 = tail call i32 @kexit(i32 noundef 0)\nret i32 undef\n}", "codegemma": "define dso_local i32 @kmain() {\nB:\n%0 = tail call i32 (...) @kinit()\n%1 = tail call i32 @kexit(i32 noundef 0)\nret i32 undef\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca %struct.TYPE_4__, align 8\n%4 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 32, ptr %3)\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 3\nstore ptr null, ptr %5, align 8\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 2\nstore i64 0, ptr %6, align 8\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 1\nstore ptr %2, ptr %7, align 8\n%8 = call i32 @rdt_interface_init(ptr noundef %3)\n%9 = call i32 @rdt_interface_runprog(ptr noundef %3, ptr noundef @.str)\n%10 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 0\n%11 = load i64, ptr %10, align 8\n%12 = icmp ne i64 %11, 0\nbr i1 %12, label %13, label %14\n\n13:\nstore i32 1, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %15\n\n14:\nstore i32 0, ptr %1, align 4\nstore i32 1, ptr %4, align 4\nbr label %15\n\n15:\ncall void @llvm.lifetime.end.p0(i64 32, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%16 = load i32, ptr %1, align 4\nret i32 %16\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca %struct.TYPE_4__, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 32, ptr nonnull %1)\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 2\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 1\ncall void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %2, i8 0, i64 16, i1 false)\nstore ptr %0, ptr %3, align 8\n%4 = call i32 @rdt_interface_init(ptr noundef nonnull %1)\n%5 = call i32 @rdt_interface_runprog(ptr noundef nonnull %1, ptr noundef nonnull @.str)\n%6 = load i64, ptr %1, align 8\n%7 = icmp ne i64 %6, 0\n%8 = zext i1 %7 to i32\ncall void @llvm.lifetime.end.p0(i64 32, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %8\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\n%1 = alloca %struct.TYPE_4__, align 8\ncall void @llvm.lifetime.start.p0(i64 32, ptr nonnull %1)\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 3\nstore ptr null, ptr %2, align 8\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 2\nstore i64 0, ptr %3, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 1\nstore ptr %0, ptr %4, align 8\n%5 = call i32 @rdt_interface_init(ptr noundef nonnull %1)\n%6 = call i32 @rdt_interface_runprog(ptr noundef nonnull %1, ptr noundef nonnull @.str)\n%7 = load i64, ptr %1, align 8\n%8 = icmp ne i64 %7, 0\n%9 = zext i1 %8 to i32\ncall void @llvm.lifetime.end.p0(i64 32, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %9\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca i32, align 4\n%1 = alloca %struct.TYPE_4__, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)\ncall void @llvm.lifetime.start.p0(i64 32, ptr nonnull %1)\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 3\nstore ptr null, ptr %2, align 8\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 2\nstore i64 0, ptr %3, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i64 0, i32 1\nstore ptr %0, ptr %4, align 8\n%5 = call i32 @rdt_interface_init(ptr noundef nonnull %1)\n%6 = call i32 @rdt_interface_runprog(ptr noundef nonnull %1, ptr noundef nonnull @.str)\n%7 = load i64, ptr %1, align 8\n%8 = icmp ne i64 %7, 0\n%9 = zext i1 %8 to i32\ncall void @llvm.lifetime.end.p0(i64 32, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)\nret i32 %9\n}"}, "define dso_local void @test_avl_locate_gt_double(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca double, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore double %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load double, ptr %6, align 8\n%9 = call i64 @avl_locate_gt_double(ptr noundef %7, double noundef nofpclass(nan inf) %8)\n%10 = load ptr, ptr %5, align 8\n%11 = load double, ptr %6, align 8\n%12 = call i64 @avm_locate_gt_double(ptr noundef %10, double noundef nofpclass(nan inf) %11)\n%13 = icmp eq i64 %9, %12\n%14 = zext i1 %13 to i32\n%15 = call i32 @assert(i32 noundef %14)\nret void\n}": {"base_truth": "define dso_local void @test_avl_locate_gt_double(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = tail call i64 @avl_locate_gt_double(ptr noundef %0, double noundef nofpclass(nan inf) %2)\n%4 = tail call i64 @avm_locate_gt_double(ptr noundef %1, double noundef nofpclass(nan inf) %2)\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @assert(i32 noundef %6)\nret void\n}", "codellama": "define dso_local void @test_avl_locate_gt_double(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = tail call i64 @avl_locate_gt_double(ptr noundef %0, double noundef nofpclass(nan inf) %2)\n%4 = tail call i64 @avm_locate_gt_double(ptr noundef %1, double noundef nofpclass(nan inf) %2)\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @assert(i32 noundef %6)\nret void\n}", "codegemma": "define dso_local void @test_avl_locate_gt_double(ptr noundef %0, ptr noundef %1, double noundef nofpclass(nan inf) %2) {\nB:\n%3 = tail call i64 @avl_locate_gt_double(ptr noundef %0, double noundef nofpclass(nan inf) %2)\n%4 = tail call i64 @avm_locate_gt_double(ptr noundef %1, double noundef nofpclass(nan inf) %2)\n%5 = icmp eq i64 %3, %4\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @assert(i32 noundef %6)\nret void\n}"}, "define dso_local i32 @G_Normal(i32 %0) {\n%2 = alloca %struct.TYPE_3__, align 4\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i32 0, i32 0\nstore i32 %0, ptr %3, align 4\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @G_Perpendicular(i32 noundef %5)\n%7 = call i32 @G_Normalize(i32 noundef %6)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @G_Normal(i32 %0) {\nB:\n%1 = tail call i32 @G_Perpendicular(i32 noundef %0)\n%2 = tail call i32 @G_Normalize(i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @G_Normal(i32 %0) {\nB:\n%1 = tail call i32 @G_Perpendicular(i32 noundef %0)\n%2 = tail call i32 @G_Normalize(i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @G_Normal(i32 %0) {\nB:\n%1 = tail call i32 @G_Perpendicular(i32 noundef %0)\n%2 = tail call i32 @G_Normalize(i32 noundef %1)\nret i32 %2\n}"}, "define dso_local void @rtllib_softmac_start_protocol(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.rtllib_device ptr %5, i32 0, i32 0\n%7 = call i32 @mutex_lock(ptr noundef %6)\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @rtllib_start_protocol(ptr noundef %8)\n%10 = load ptr, ptr %3, align 8\n%11 = getelementptr inbounds %struct.rtllib_device ptr %10, i32 0, i32 0\n%12 = call i32 @mutex_unlock(ptr noundef %11)\nret void\n}": {"base_truth": "define dso_local void @rtllib_softmac_start_protocol(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @mutex_lock(ptr noundef %0)\n%3 = tail call i32 @rtllib_start_protocol(ptr noundef %0)\n%4 = tail call i32 @mutex_unlock(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @rtllib_softmac_start_protocol(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @mutex_lock(ptr noundef %0)\n%3 = tail call i32 @rtllib_start_protocol(ptr noundef %0)\n%4 = tail call i32 @mutex_unlock(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @rtllib_softmac_start_protocol(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @mutex_lock(ptr noundef %0)\n%3 = tail call i32 @rtllib_start_protocol(ptr noundef %0)\n%4 = tail call i32 @mutex_unlock(ptr noundef %0)\nret void\n}"}, "define dso_local void @softTimerCallback() {\n%1 = load i32, ptr @_LED2, align 4\n%2 = call i32 @LED_Toggle(i32 noundef %1)\n%3 = call i32 @printf(ptr noundef @.str, ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @softTimerCallback() {\nB:\n%0 = load i32, ptr @_LED2, align 4\n%1 = tail call i32 @LED_Toggle(i32 noundef %0)\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @softTimerCallback() {\nB:\n%0 = load i32, ptr @_LED2, align 4\n%1 = tail call i32 @LED_Toggle(i32 noundef %0)\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @softTimerCallback() {\nB:\n%0 = load i32, ptr @_LED2, align 4\n%1 = tail call i32 @LED_Toggle(i32 noundef %0)\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\nret void\n}"}, "define dso_local void @print_mac(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds i64, ptr %3, i64 0\n%5 = load i64, ptr %4, align 8\n%6 = trunc i64 %5 to i32\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds i64, ptr %7, i64 1\n%9 = load i64, ptr %8, align 8\n%10 = trunc i64 %9 to i32\n%11 = load ptr, ptr %2, align 8\n%12 = getelementptr inbounds i64, ptr %11, i64 2\n%13 = load i64, ptr %12, align 8\n%14 = trunc i64 %13 to i32\n%15 = load ptr, ptr %2, align 8\n%16 = getelementptr inbounds i64, ptr %15, i64 3\n%17 = load i64, ptr %16, align 8\n%18 = trunc i64 %17 to i32\n%19 = load ptr, ptr %2, align 8\n%20 = getelementptr inbounds i64, ptr %19, i64 4\n%21 = load i64, ptr %20, align 8\n%22 = trunc i64 %21 to i32\n%23 = load ptr, ptr %2, align 8\n%24 = getelementptr inbounds i64, ptr %23, i64 5\n%25 = load i64, ptr %24, align 8\n%26 = trunc i64 %25 to i32\n%27 = call i32 @printf(ptr noundef @.str, i32 noundef %6, i32 noundef %10, i32 noundef %14, i32 noundef %18, i32 noundef %22, i32 noundef %26)\nret void\n}": {"base_truth": "define dso_local void @print_mac(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = trunc i64 %1 to i32\n%3 = getelementptr inbounds i64, ptr %0, i64 1\n%4 = load i64, ptr %3, align 8\n%5 = trunc i64 %4 to i32\n%6 = getelementptr inbounds i64, ptr %0, i64 2\n%7 = load i64, ptr %6, align 8\n%8 = trunc i64 %7 to i32\n%9 = getelementptr inbounds i64, ptr %0, i64 3\n%10 = load i64, ptr %9, align 8\n%11 = trunc i64 %10 to i32\n%12 = getelementptr inbounds i64, ptr %0, i64 4\n%13 = load i64, ptr %12, align 8\n%14 = trunc i64 %13 to i32\n%15 = getelementptr inbounds i64, ptr %0, i64 5\n%16 = load i64, ptr %15, align 8\n%17 = trunc i64 %16 to i32\n%18 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %2, i32 noundef %5, i32 noundef %8, i32 noundef %11, i32 noundef %14, i32 noundef %17)\nret void\n}", "codellama": "define dso_local void @print_mac(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = trunc i64 %1 to i32\n%3 = getelementptr inbounds i64, ptr %0, i64 1\n%4 = load i64, ptr %3, align 8\n%5 = trunc i64 %4 to i32\n%6 = getelementptr inbounds i64, ptr %0, i64 2\n%7 = load i64, ptr %6, align 8\n%8 = trunc i64 %7 to i32\n%9 = getelementptr inbounds i64, ptr %0, i64 3\n%10 = load i64, ptr %9, align 8\n%11 = trunc i64 %10 to i32\n%12 = getelementptr inbounds i64, ptr %0, i64 4\n%13 = load i64, ptr %12, align 8\n%14 = trunc i64 %13 to i32\n%15 = getelementptr inbounds i64, ptr %0, i64 5\n%16 = load i64, ptr %15, align 8\n%17 = trunc i64 %16 to i32\n%18 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %2, i32 noundef %5, i32 noundef %8, i32 noundef %11, i32 noundef %14, i32 noundef %17)\nret void\n}", "codegemma": "define dso_local void @print_mac(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = trunc i64 %1 to i32\n%3 = getelementptr inbounds i64, ptr %0, i64 1\n%4 = load i64, ptr %3, align 8\n%5 = trunc i64 %4 to i32\n%6 = getelementptr inbounds i64, ptr %0, i64 2\n%7 = load i64, ptr %6, align 8\n%8 = trunc i64 %7 to i32\n%9 = getelementptr inbounds i64, ptr %0, i64 3\n%10 = load i64, ptr %9, align 8\n%11 = trunc i64 %10 to i32\n%12 = getelementptr inbounds i64, ptr %0, i64 4\n%13 = load i64, ptr %12, align 8\n%14 = trunc i64 %13 to i32\n%15 = getelementptr inbounds i64, ptr %0, i64 5\n%16 = load i64, ptr %15, align 8\n%17 = trunc i64 %16 to i32\n%18 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %2, i32 noundef %5, i32 noundef %8, i32 noundef %11, i32 noundef %14, i32 noundef %17)\nret void\n}"}, "define internal void @tasks_lock_enter(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = call i32 @tasks_lock_block_signals(ptr noundef %5)\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i32 @r_th_lock_enter(i32 noundef %9)\nret void\n}": {"base_truth": "define internal void @tasks_lock_enter(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @tasks_lock_block_signals(ptr noundef %1)\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @r_th_lock_enter(i32 noundef %3)\nret void\n}", "codellama": "define internal void @tasks_lock_enter(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @tasks_lock_block_signals(ptr noundef %1)\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @r_th_lock_enter(i32 noundef %3)\nret void\n}", "codegemma": "define internal void @tasks_lock_enter(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @tasks_lock_block_signals(ptr noundef %1)\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @r_th_lock_enter(i32 noundef %3)\nret void\n}"}, "define dso_local void @Act_Abort() {\n%1 = call i32 @exit(i32 noundef 0)\nunreachable\n}": {"base_truth": "define dso_local void @Act_Abort() {\nB:\n%0 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codellama": "define dso_local void @Act_Abort() {\nB:\n%0 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codegemma": "define dso_local void @Act_Abort() {\nB:\n%0 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}"}, "define dso_local i32 @os_perf_uncore_started(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = getelementptr inbounds %struct.TYPE_3__, ptr %4, i32 0, i32 0\n%6 = load i64, ptr %5, align 8\n%7 = load i64, ptr @PERF_STATUS_UNCORE_STARTED, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %9, label %11\n\n9:\n%10 = load i32, ptr @B_TRUE, align 4\nstore i32 %10, ptr %2, align 4\nbr label %13\n\n11:\n%12 = load i32, ptr @B_FALSE, align 4\nstore i32 %12, ptr %2, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %2, align 4\nret i32 %14\n}": {"base_truth": "define dso_local i32 @os_perf_uncore_started(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @PERF_STATUS_UNCORE_STARTED, align 8\n%3 = icmp eq i64 %1, %2\n%4 = load i32, ptr @B_TRUE, align 4\n%5 = load i32, ptr @B_FALSE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}", "codellama": "define dso_local i32 @os_perf_uncore_started(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @PERF_STATUS_UNCORE_STARTED, align 8\n%3 = icmp eq i64 %1, %2\n%4 = load i32, ptr @B_TRUE, align 4\n%5 = load i32, ptr @B_FALSE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}", "codegemma": "define dso_local i32 @os_perf_uncore_started(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @PERF_STATUS_UNCORE_STARTED, align 8\n%3 = icmp eq i64 %1, %2\n%4 = load i32, ptr @B_TRUE, align 4\n%5 = load i32, ptr @B_FALSE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}"}, "define dso_local void @r653visit_like_feature_type_mark(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = call i32 @r653crash(ptr noundef %5)\nret void\n}": {"base_truth": "define dso_local void @r653visit_like_feature_type_mark(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 @r653crash(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @r653visit_like_feature_type_mark(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 @r653crash(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @r653visit_like_feature_type_mark(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 @r653crash(ptr noundef %0)\nret void\n}"}, "define internal void @_rtl88ee_phy_set_rf_sleep(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @rtl_priv(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = load i32, ptr @REG_TXPAUSE, align 4\n%8 = call i32 @rtl_write_byte(ptr noundef %6, i32 noundef %7, i32 noundef 255)\n%9 = load ptr, ptr %2, align 8\n%10 = load i32, ptr @RF90_PATH_A, align 4\n%11 = load i32, ptr @RFREG_OFFSET_MASK, align 4\n%12 = call i32 @rtl_set_rfreg(ptr noundef %9, i32 noundef %10, i32 noundef 0, i32 noundef %11, i32 noundef 0)\n%13 = load ptr, ptr %3, align 8\n%14 = load i32, ptr @REG_SYS_FUNC_EN, align 4\n%15 = call i32 @rtl_write_byte(ptr noundef %13, i32 noundef %14, i32 noundef 226)\n%16 = load ptr, ptr %3, align 8\n%17 = load i32, ptr @REG_SPS0_CTRL, align 4\n%18 = call i32 @rtl_write_byte(ptr noundef %16, i32 noundef %17, i32 noundef 34)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @_rtl88ee_phy_set_rf_sleep(ptr noundef %0) {\nB:\n%1 = tail call ptr @rtl_priv(ptr noundef %0)\n%2 = load i32, ptr @REG_TXPAUSE, align 4\n%3 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %2, i32 noundef 255)\n%4 = load i32, ptr @RF90_PATH_A, align 4\n%5 = load i32, ptr @RFREG_OFFSET_MASK, align 4\n%6 = tail call i32 @rtl_set_rfreg(ptr noundef %0, i32 noundef %4, i32 noundef 0, i32 noundef %5, i32 noundef 0)\n%7 = load i32, ptr @REG_SYS_FUNC_EN, align 4\n%8 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %7, i32 noundef 226)\n%9 = load i32, ptr @REG_SPS0_CTRL, align 4\n%10 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %9, i32 noundef 34)\nret void\n}", "codellama": "define internal void @_rtl88ee_phy_set_rf_sleep(ptr noundef %0) {\nB:\n%1 = tail call ptr @rtl_priv(ptr noundef %0)\n%2 = load i32, ptr @REG_TXPAUSE, align 4\n%3 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %2, i32 noundef 255)\n%4 = load i32, ptr @RF90_PATH_A, align 4\n%5 = load i32, ptr @RFREG_OFFSET_MASK, align 4\n%6 = tail call i32 @rtl_set_rfreg(ptr noundef %0, i32 noundef %4, i32 noundef 0, i32 noundef %5, i32 noundef 0)\n%7 = load i32, ptr @REG_SYS_FUNC_EN, align 4\n%8 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %7, i32 noundef 226)\n%9 = load i32, ptr @REG_SPS0_CTRL, align 4\n%10 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %9, i32 noundef 34)\nret void\n}", "codegemma": "define internal void @_rtl88ee_phy_set_rf_sleep(ptr noundef %0) {\nB:\n%1 = tail call ptr @rtl_priv(ptr noundef %0)\n%2 = load i32, ptr @REG_TXPAUSE, align 4\n%3 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %2, i32 noundef 255)\n%4 = load i32, ptr @RF90_PATH_A, align 4\n%5 = load i32, ptr @RFREG_OFFSET_MASK, align 4\n%6 = tail call i32 @rtl_set_rfreg(ptr noundef %0, i32 noundef %4, i32 noundef 0, i32 noundef %5, i32 noundef 0)\n%7 = load i32, ptr @REG_SYS_FUNC_EN, align 4\n%8 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %7, i32 noundef 226)\n%9 = load i32, ptr @REG_SPS0_CTRL, align 4\n%10 = tail call i32 @rtl_write_byte(ptr noundef %1, i32 noundef %9, i32 noundef 34)\nret void\n}"}, "define dso_local void @confctl_set_semicolon(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.confctl ptr %6, i32 0, i32 0\nstore i32 %5, ptr %7, align 4\nret void\n}": {"base_truth": "define dso_local void @confctl_set_semicolon(ptr nocapture noundef writeonly %0, i32 noundef %1) {\nB:\nstore i32 %1, ptr %0, align 4\nret void\n}", "codellama": "define dso_local void @confctl_set_semicolon(ptr nocapture noundef writeonly %0, i32 noundef %1) {\nB:\nstore i32 %1, ptr %0, align 4\nret void\n}", "codegemma": "define dso_local void @confctl_set_semicolon(ptr nocapture noundef writeonly %0, i32 noundef %1) {\nB:\nstore i32 %1, ptr %0, align 4\nret void\n}"}, "define dso_local zeroext i8 @paddle_1_read() {\n%1 = call zeroext i8 @paddle_read(i32 noundef 0)\nret i8 %1\n}": {"base_truth": "define dso_local zeroext i8 @paddle_1_read() {\nB:\n%0 = tail call zeroext i8 @paddle_read(i32 noundef 0)\nret i8 %0\n}", "codellama": "define dso_local zeroext i8 @paddle_1_read() {\nB:\n%0 = tail call zeroext i8 @paddle_read(i32 noundef 0)\nret i8 %0\n}", "codegemma": "define dso_local zeroext i8 @paddle_1_read() {\nB:\n%0 = tail call zeroext i8 @paddle_read(i32 noundef 0)\nret i8 %0\n}"}, "define dso_local i32 @G_IsSinglePlayerGame() {\n%1 = alloca i32, align 4\n%2 = load i64, ptr @g_gametype, align 8\n%3 = load i64, ptr @GT_SINGLE_PLAYER, align 8\n%4 = icmp eq i64 %2, %3\nbr i1 %4, label %9, label %5\n\n5:\n%6 = load i64, ptr @g_gametype, align 8\n%7 = load i64, ptr @GT_COOP, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %9, label %11\n\n9:\n%10 = load i32, ptr @qtrue, align 4\nstore i32 %10, ptr %1, align 4\nbr label %13\n\n11:\n%12 = load i32, ptr @qfalse, align 4\nstore i32 %12, ptr %1, align 4\nbr label %13\n\n13:\n%14 = load i32, ptr %1, align 4\nret i32 %14\n}": {"base_truth": "define dso_local i32 @G_IsSinglePlayerGame() {\nB:\n%0 = load i64, ptr @g_gametype, align 8\n%1 = load i64, ptr @GT_SINGLE_PLAYER, align 8\n%2 = icmp eq i64 %0, %1\n%3 = load i64, ptr @GT_COOP, align 8\n%4 = icmp eq i64 %0, %3\n%5 = select i1 %2, i1 true, i1 %4\n%6 = load i32, ptr @qtrue, align 4\n%7 = load i32, ptr @qfalse, align 4\n%8 = select i1 %5, i32 %6, i32 %7\nret i32 %8\n}", "codellama": "define dso_local i32 @G_IsSinglePlayerGame() {\nB:\n%0 = load i64, ptr @g_gametype, align 8\n%1 = load i64, ptr @GT_SINGLE_PLAYER, align 8\n%2 = icmp eq i64 %0, %1\n%3 = load i64, ptr @GT_COOP, align 8\n%4 = icmp eq i64 %0, %3\n%5 = load i32, ptr @qtrue, align 4\n%6 = load i32, ptr @qfalse, align 4\n%7 = select i1 %4, i32 %5, i32 %6\n%8 = select i1 %2, i32 %5, i32 %7\nret i32 %8\n}", "codegemma": "define dso_local i32 @G_IsSinglePlayerGame() {\nB:\n%0 = load i64, ptr @g_gametype, align 8\n%1 = load i64, ptr @GT_SINGLE_PLAYER, align 8\n%2 = icmp eq i64 %0, %1\n%3 = load i64, ptr @GT_COOP, align 8\n%4 = icmp eq i64 %0, %3\n%5 = select i1 %2, i1 true, i1 %4\n%6 = load i32, ptr @qtrue, align 4\n%7 = load i32, ptr @qfalse, align 4\n%8 = select i1 %5, i32 %6, i32 %7\nret i32 %8\n}"}, "define internal i32 @bwi_rxeof64(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret i32 0\n}": {"base_truth": "define internal i32 @bwi_rxeof64(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}", "codellama": "define internal i32 @bwi_rxeof64(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}", "codegemma": "define internal i32 @bwi_rxeof64(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}"}, "define dso_local ptr @capsule_init(float noundef nofpclass(nan inf) %0, float noundef nofpclass(nan inf) %1, ptr noundef %2) {\n%4 = alloca float, align 4\n%5 = alloca float, align 4\n%6 = alloca ptr, align 8\n%7 = alloca ptr, align 8\nstore float %0, ptr %4, align 4\nstore float %1, ptr %5, align 4\nstore ptr %2, ptr %6, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%8 = call ptr @malloc(i32 noundef 8)\nstore ptr %8, ptr %7, align 8\n%9 = load float, ptr %4, align 4\n%10 = load ptr, ptr %7, align 8\n%11 = getelementptr inbounds %struct.TYPE_7__, ptr %10, i32 0, i32 0\nstore float %9, ptr %11, align 4\n%12 = load float, ptr %5, align 4\n%13 = load ptr, ptr %7, align 8\n%14 = getelementptr inbounds %struct.TYPE_7__, ptr %13, i32 0, i32 1\nstore float %12, ptr %14, align 4\n%15 = load ptr, ptr %6, align 8\n%16 = getelementptr inbounds %struct.TYPE_6__, ptr %15, i32 0, i32 0\n%17 = load i32, ptr %16, align 4\n%18 = load ptr, ptr %7, align 8\n%19 = getelementptr inbounds %struct.TYPE_7__, ptr %18, i32 0, i32 2\nstore i32 %17, ptr %19, align 4\n%20 = load ptr, ptr %7, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret ptr %20\n}": {"base_truth": "define dso_local ptr @capsule_init(float noundef nofpclass(nan inf) %0, float noundef nofpclass(nan inf) %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = tail call ptr @malloc(i32 noundef 8)\nstore float %0, ptr %3, align 4\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i64 0, i32 1\nstore float %1, ptr %4, align 4\n%5 = load i32, ptr %2, align 4\n%6 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i64 0, i32 2\nstore i32 %5, ptr %6, align 4\nret ptr %3\n}", "codellama": "define dso_local ptr @capsule_init(float noundef nofpclass(nan inf) %0, float noundef nofpclass(nan inf) %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = tail call ptr @malloc(i32 noundef 8)\nstore float %0, ptr %3, align 4\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i64 0, i32 1\nstore float %1, ptr %4, align 4\n%5 = load i32, ptr %2, align 4\n%6 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i64 0, i32 2\nstore i32 %5, ptr %6, align 4\nret ptr %3\n}", "codegemma": "define dso_local ptr @capsule_init(float noundef nofpclass(nan inf) %0, float noundef nofpclass(nan inf) %1, ptr nocapture noundef readonly %2) {\nB:\n%3 = tail call ptr @malloc(i32 noundef 8)\nstore float %0, ptr %3, align 4\n%4 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i64 0, i32 1\nstore float %1, ptr %4, align 4\n%5 = load i32, ptr %2, align 4\n%6 = getelementptr inbounds %struct.TYPE_7__, ptr %3, i64 0, i32 2\nstore i32 %5, ptr %6, align 4\nret ptr %3\n}"}, "define dso_local i32 @Tile_GetPosX(i32 %0) {\n%2 = alloca %struct.TYPE_5__, align 4\n%3 = getelementptr inbounds %struct.TYPE_5__, ptr %2, i32 0, i32 0\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 0\nstore i32 %0, ptr %4, align 4\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %2, i32 0, i32 0\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\nret i32 %7\n}": {"base_truth": "define dso_local i32 @Tile_GetPosX(i32 returned %0) {\nB:\nret i32 %0\n}", "codellama": "define dso_local i32 @Tile_GetPosX(i32 returned %0) {\nB:\nret i32 %0\n}", "codegemma": "define dso_local i32 @Tile_GetPosX(i32 returned %0) {\nB:\nret i32 %0\n}"}, "define dso_local void @backlight_set_suspend_state(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\nstore i32 %3, ptr @g_suspend_state, align 4\nret void\n}": {"base_truth": "define dso_local void @backlight_set_suspend_state(i32 noundef %0) {\nB:\nstore i32 %0, ptr @g_suspend_state, align 4\nret void\n}", "codellama": "define dso_local void @backlight_set_suspend_state(i32 noundef %0) {\nB:\nstore i32 %0, ptr @g_suspend_state, align 4\nret void\n}", "codegemma": "define dso_local void @backlight_set_suspend_state(i32 noundef %0) {\nB:\nstore i32 %0, ptr @g_suspend_state, align 4\nret void\n}"}, "define dso_local ptr @get_staff_material_tab() {\n%1 = load ptr, ptr @staff_material_tab, align 8\nret ptr %1\n}": {"base_truth": "define dso_local ptr @get_staff_material_tab() {\nB:\n%0 = load ptr, ptr @staff_material_tab, align 8\nret ptr %0\n}", "codellama": "define dso_local ptr @get_staff_material_tab() {\nB:\n%0 = load ptr, ptr @staff_material_tab, align 8\nret ptr %0\n}", "codegemma": "define dso_local ptr @get_staff_material_tab() {\nB:\n%0 = load ptr, ptr @staff_material_tab, align 8\nret ptr %0\n}"}, "define internal void @xgbe_an_clear_interrupts_all(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @xgbe_an73_clear_interrupts(ptr noundef %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @xgbe_an37_clear_interrupts(ptr noundef %5)\nret void\n}": {"base_truth": "define internal void @xgbe_an_clear_interrupts_all(ptr noundef %0) {\nB:\n%1 = tail call i32 @xgbe_an73_clear_interrupts(ptr noundef %0)\n%2 = tail call i32 @xgbe_an37_clear_interrupts(ptr noundef %0)\nret void\n}", "codellama": "define internal void @xgbe_an_clear_interrupts_all(ptr noundef %0) {\nB:\n%1 = tail call i32 @xgbe_an73_clear_interrupts(ptr noundef %0)\n%2 = tail call i32 @xgbe_an37_clear_interrupts(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @xgbe_an_clear_interrupts_all(ptr noundef %0) {\nB:\n%1 = tail call i32 @xgbe_an73_clear_interrupts(ptr noundef %0)\n%2 = tail call i32 @xgbe_an37_clear_interrupts(ptr noundef %0)\nret void\n}"}, "define internal void @pch_udc_ep_bit_set(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i64, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore i64 %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = load i64, ptr %5, align 8\n%10 = call i64 @pch_udc_ep_readl(ptr noundef %8, i64 noundef %9)\n%11 = load i64, ptr %6, align 8\n%12 = or i64 %10, %11\n%13 = load i64, ptr %5, align 8\n%14 = call i32 @pch_udc_ep_writel(ptr noundef %7, i64 noundef %12, i64 noundef %13)\nret void\n}": {"base_truth": "define internal void @pch_udc_ep_bit_set(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = tail call i64 @pch_udc_ep_readl(ptr noundef %0, i64 noundef %1)\n%4 = or i64 %3, %2\n%5 = tail call i32 @pch_udc_ep_writel(ptr noundef %0, i64 noundef %4, i64 noundef %1)\nret void\n}", "codellama": "define internal void @pch_udc_ep_bit_set(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = tail call i64 @pch_udc_ep_readl(ptr noundef %0, i64 noundef %1)\n%4 = or i64 %3, %2\n%5 = tail call i32 @pch_udc_ep_writel(ptr noundef %0, i64 noundef %4, i64 noundef %1)\nret void\n}", "codegemma": "define internal void @pch_udc_ep_bit_set(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = tail call i64 @pch_udc_ep_readl(ptr noundef %0, i64 noundef %1)\n%4 = or i64 %3, %2\n%5 = tail call i32 @pch_udc_ep_writel(ptr noundef %0, i64 noundef %4, i64 noundef %1)\nret void\n}"}, "define internal i32 @hmc5843_i2c_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.i2c_client, ptr %3, i32 0, i32 0\n%5 = call i32 @hmc5843_common_remove(ptr noundef %4)\nret i32 %5\n}": {"base_truth": "define internal i32 @hmc5843_i2c_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @hmc5843_common_remove(ptr noundef %0)\nret i32 %1\n}", "codellama": "define internal i32 @hmc5843_i2c_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @hmc5843_common_remove(ptr noundef %0)\nret i32 %1\n}", "codegemma": "define internal i32 @hmc5843_i2c_remove(ptr noundef %0) {\nB:\n%1 = tail call i32 @hmc5843_common_remove(ptr noundef %0)\nret i32 %1\n}"}, "define dso_local ptr @rpi_firmware_get(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = call ptr @of_find_device_by_node(ptr noundef %6)\nstore ptr %7, ptr %4, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = icmp ne ptr %8, null\nbr i1 %9, label %11, label %10\n\n10:\nstore ptr null, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %14\n\n11:\n%12 = load ptr, ptr %4, align 8\n%13 = call ptr @platform_get_drvdata(ptr noundef %12)\nstore ptr %13, ptr %2, align 8\nstore i32 1, ptr %5, align 4\nbr label %14\n\n14:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%15 = load ptr, ptr %2, align 8\nret ptr %15\n}": {"base_truth": "define dso_local ptr @rpi_firmware_get(ptr noundef %0) {\nB:\n%1 = tail call ptr @of_find_device_by_node(ptr noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call ptr @platform_get_drvdata(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %3, %B1 ], [ null, %B ]\nret ptr %4\n}", "codellama": "define dso_local ptr @rpi_firmware_get(ptr noundef %0) {\nB:\n%1 = tail call ptr @of_find_device_by_node(ptr noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call ptr @platform_get_drvdata(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %3, %B1 ], [ null, %B ]\nret ptr %4\n}", "codegemma": "define dso_local ptr @rpi_firmware_get(ptr noundef %0) {\nB:\n%1 = tail call ptr @of_find_device_by_node(ptr noundef %0)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B2, label %B1\n\nB1:\n%3 = tail call ptr @platform_get_drvdata(ptr noundef nonnull %1)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %3, %B1 ], [ null, %B ]\nret ptr %4\n}"}, "define internal i32 @alg_accept(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore ptr %1, ptr %6, align 8\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\n%9 = load ptr, ptr %5, align 8\n%10 = getelementptr inbounds %struct.socket ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = load ptr, ptr %6, align 8\n%13 = load i32, ptr %8, align 4\n%14 = call i32 @af_alg_accept(i32 noundef %11, ptr noundef %12, i32 noundef %13)\nret i32 %14\n}": {"base_truth": "define internal i32 @alg_accept(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @af_alg_accept(i32 noundef %4, ptr noundef %1, i32 noundef %3)\nret i32 %5\n}", "codellama": "define internal i32 @alg_accept(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @af_alg_accept(i32 noundef %4, ptr noundef %1, i32 noundef %3)\nret i32 %5\n}", "codegemma": "define internal i32 @alg_accept(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %0, align 4\n%5 = tail call i32 @af_alg_accept(i32 noundef %4, ptr noundef %1, i32 noundef %3)\nret i32 %5\n}"}, "define dso_local void @mirrorCollisionHandler() {\n%1 = load i64, ptr @ballYPosition, align 8\n%2 = load i64, ptr @mirrorLocation, align 8\n%3 = icmp eq i64 %1, %2\nbr i1 %3, label %4, label %7\n\n4:\n%5 = load i32, ptr @currXTrajectory, align 4\n%6 = call i32 @reverseXTrajectory(i32 noundef %5)\nbr label %7\n\n7:\nret void\n}": {"base_truth": "define dso_local void @mirrorCollisionHandler() {\nB:\n%0 = load i64, ptr @ballYPosition, align 8\n%1 = load i64, ptr @mirrorLocation, align 8\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @currXTrajectory, align 4\n%4 = tail call i32 @reverseXTrajectory(i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @mirrorCollisionHandler() {\nB:\n%0 = load i64, ptr @ballYPosition, align 8\n%1 = load i64, ptr @mirrorLocation, align 8\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @currXTrajectory, align 4\n%4 = tail call i32 @reverseXTrajectory(i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @mirrorCollisionHandler() {\nB:\n%0 = load i64, ptr @ballYPosition, align 8\n%1 = load i64, ptr @mirrorLocation, align 8\n%2 = icmp eq i64 %0, %1\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = load i32, ptr @currXTrajectory, align 4\n%4 = tail call i32 @reverseXTrajectory(i32 noundef %3)\nbr label %B2\n\nB2:\nret void\n}"}, "define internal i64 @skl_clk_round_rate(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load i64, ptr %5, align 8\nret i64 %7\n}": {"base_truth": "define internal i64 @skl_clk_round_rate(ptr nocapture noundef readnone %0, i64 noundef returned %1, ptr nocapture noundef readnone %2) {\nB:\nret i64 %1\n}", "codellama": "define internal i64 @skl_clk_round_rate(ptr nocapture noundef readnone %0, i64 noundef returned %1, ptr nocapture noundef readnone %2) {\nB:\nret i64 %1\n}", "codegemma": "define internal i64 @skl_clk_round_rate(ptr nocapture noundef readnone %0, i64 noundef returned %1, ptr nocapture noundef readnone %2) {\nB:\nret i64 %1\n}"}, "define dso_local void @_conn_plain_fini() {\nret void\n}": {"base_truth": "define dso_local void @_conn_plain_fini() {\nB:\nret void\n}", "codellama": "define dso_local void @_conn_plain_fini() {\nB:\nret void\n}", "codegemma": "define dso_local void @_conn_plain_fini() {\nB:\nret void\n}"}, "define dso_local i32 @main() {\n%1 = call i32 @f(i32 noundef 6)\n%2 = call i32 @printf(ptr noundef @.str, i32 noundef %1)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @f(i32 noundef 6)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @f(i32 noundef 6)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @f(i32 noundef 6)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nret i32 0\n}"}, "define internal i32 @smu10_apply_state_adjust_rules(ptr noundef %0, ptr noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\nret i32 0\n}": {"base_truth": "define internal i32 @smu10_apply_state_adjust_rules(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1, ptr nocapture noundef readnone %2) {\nB:\nret i32 0\n}", "codellama": "define internal i32 @smu10_apply_state_adjust_rules(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1, ptr nocapture noundef readnone %2) {\nB:\nret i32 0\n}", "codegemma": "define internal i32 @smu10_apply_state_adjust_rules(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1, ptr nocapture noundef readnone %2) {\nB:\nret i32 0\n}"}, "define dso_local i32 @output(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca double, align 8\nstore i32 %0, ptr %4, align 4\nstore double %1, ptr %5, align 8\n%6 = load i32, ptr %4, align 4\n%7 = load double, ptr %5, align 8\n%8 = call i32 @printf(ptr noundef @.str, i32 noundef %6, double noundef nofpclass(nan inf) %7)\n%9 = load i32, ptr %3, align 4\nret i32 %9\n}": {"base_truth": "define dso_local i32 @output(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, double noundef nofpclass(nan inf) %1)\nret i32 undef\n}", "codellama": "define dso_local i32 @output(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, double noundef nofpclass(nan inf) %1)\nret i32 undef\n}", "codegemma": "define dso_local i32 @output(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, double noundef nofpclass(nan inf) %1)\nret i32 undef\n}"}, "define internal i32 @tps80031_vbus_enable(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%8 = load ptr, ptr %3, align 8\n%9 = call ptr @rdev_get_drvdata(ptr noundef %8)\nstore ptr %9, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%10 = load ptr, ptr %3, align 8\n%11 = call ptr @to_tps80031_dev(ptr noundef %10)\nstore ptr %11, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%12 = load ptr, ptr %5, align 8\n%13 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%14 = load i32, ptr @TPS80031_CHARGERUSB_CTRL1, align 4\n%15 = load i32, ptr @OPA_MODE_EN, align 4\n%16 = call i32 @tps80031_set_bits(ptr noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15)\nstore i32 %16, ptr %6, align 4\n%17 = load i32, ptr %6, align 4\n%18 = icmp slt i32 %17, 0\nbr i1 %18, label %19, label %27\n\n19:\n%20 = load ptr, ptr %4, align 8\n%21 = getelementptr inbounds %struct.tps80031_regulator ptr %20, i32 0, i32 0\n%22 = load i32, ptr %21, align 4\n%23 = load i32, ptr @TPS80031_CHARGERUSB_CTRL1, align 4\n%24 = load i32, ptr %6, align 4\n%25 = call i32 @dev_err(i32 noundef %22, ptr noundef @.str, i32 noundef %23, i32 noundef %24)\n%26 = load i32, ptr %6, align 4\nstore i32 %26, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %45\n\n27:\n%28 = load ptr, ptr %5, align 8\n%29 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%30 = load i32, ptr @TPS80031_CHARGERUSB_CTRL3, align 4\n%31 = load i32, ptr @BOOST_HW_PWR_EN, align 4\n%32 = call i32 @tps80031_set_bits(ptr noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %31)\nstore i32 %32, ptr %6, align 4\n%33 = load i32, ptr %6, align 4\n%34 = icmp slt i32 %33, 0\nbr i1 %34, label %35, label %43\n\n35:\n%36 = load ptr, ptr %4, align 8\n%37 = getelementptr inbounds %struct.tps80031_regulator ptr %36, i32 0, i32 0\n%38 = load i32, ptr %37, align 4\n%39 = load i32, ptr @TPS80031_CHARGERUSB_CTRL3, align 4\n%40 = load i32, ptr %6, align 4\n%41 = call i32 @dev_err(i32 noundef %38, ptr noundef @.str, i32 noundef %39, i32 noundef %40)\n%42 = load i32, ptr %6, align 4\nstore i32 %42, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %45\n\n43:\n%44 = load i32, ptr %6, align 4\nstore i32 %44, ptr %2, align 4\nstore i32 1, ptr %7, align 4\nbr label %45\n\n45:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%46 = load i32, ptr %2, align 4\nret i32 %46\n}": {"base_truth": "define internal i32 @tps80031_vbus_enable(ptr noundef %0) {\nB:\n%1 = tail call ptr @rdev_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @to_tps80031_dev(ptr noundef %0)\n%3 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%4 = load i32, ptr @TPS80031_CHARGERUSB_CTRL1, align 4\n%5 = load i32, ptr @OPA_MODE_EN, align 4\n%6 = tail call i32 @tps80031_set_bits(ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%9 = load i32, ptr @TPS80031_CHARGERUSB_CTRL3, align 4\n%10 = load i32, ptr @BOOST_HW_PWR_EN, align 4\n%11 = tail call i32 @tps80031_set_bits(ptr noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef %10)\n%12 = icmp slt i32 %11, 0\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = phi ptr [ @TPS80031_CHARGERUSB_CTRL1, %B ], [ @TPS80031_CHARGERUSB_CTRL3, %B1 ]\n%14 = phi i32 [ %6, %B ], [ %11, %B1 ]\n%15 = load i32, ptr %1, align 4\n%16 = load i32, ptr %13, align 4\n%17 = tail call i32 @dev_err(i32 noundef %15, ptr noundef nonnull @.str, i32 noundef %16, i32 noundef %14)\nbr label %B3\n\nB3:\n%18 = phi i32 [ %11, %B1 ], [ %14, %B2 ]\nret i32 %18\n}", "codellama": "define internal i32 @tps80031_vbus_enable(ptr noundef %0) {\nB:\n%1 = tail call ptr @rdev_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @to_tps80031_dev(ptr noundef %0)\n%3 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%4 = load i32, ptr @TPS80031_CHARGERUSB_CTRL1, align 4\n%5 = load i32, ptr @OPA_MODE_EN, align 4\n%6 = tail call i32 @tps80031_set_bits(ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B1, label %B2\n\nB1:\n%8 = load i32, ptr %1, align 4\n%9 = load i32, ptr @TPS80031_CHARGERUSB_CTRL1, align 4\n%10 = tail call i32 @dev_err(i32 noundef %8, ptr noundef nonnull @.str, i32 noundef %9, i32 noundef %6)\nbr label %B4\n\nB2:\n%11 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%12 = load i32, ptr @TPS80031_CHARGERUSB_CTRL3, align 4\n%13 = load i32, ptr @BOOST_HW_PWR_EN, align 4\n%14 = tail call i32 @tps80031_set_bits(ptr noundef %2, i32 noundef %11, i32 noundef %12, i32 noundef %13)\n%15 = icmp slt i32 %14, 0\nbr i1 %15, label %B3, label %B4\n\nB3:\n%16 = load i32, ptr %1, align 4\n%17 = load i32, ptr @TPS80031_CHARGERUSB_CTRL3, align 4\n%18 = tail call i32 @dev_err(i32 noundef %16, ptr noundef nonnull @.str, i32 noundef %17, i32 noundef %14)\nbr label %B4\n\nB4:\n%19 = phi i32 [ %6, %B1 ], [ %14, %B3 ], [ %14, %B2 ]\nret i32 %19\n}", "codegemma": "define internal i32 @tps80031_vbus_enable(ptr noundef %0) {\nB:\n%1 = tail call ptr @rdev_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @to_tps80031_dev(ptr noundef %0)\n%3 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%4 = load i32, ptr @TPS80031_CHARGERUSB_CTRL1, align 4\n%5 = load i32, ptr @OPA_MODE_EN, align 4\n%6 = tail call i32 @tps80031_set_bits(ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)\n%7 = icmp slt i32 %6, 0\nbr i1 %7, label %B2, label %B1\n\nB1:\n%8 = load i32, ptr @TPS80031_SLAVE_ID2, align 4\n%9 = load i32, ptr @TPS80031_CHARGERUSB_CTRL3, align 4\n%10 = load i32, ptr @BOOST_HW_PWR_EN, align 4\n%11 = tail call i32 @tps80031_set_bits(ptr noundef %2, i32 noundef %8, i32 noundef %9, i32 noundef %10)\n%12 = icmp slt i32 %11, 0\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = phi ptr [ @TPS80031_CHARGERUSB_CTRL1, %B ], [ @TPS80031_CHARGERUSB_CTRL3, %B1 ]\n%14 = load i32, ptr %1, align 4\n%15 = load i32, ptr %13, align 4\n%16 = tail call i32 @dev_err(i32 noundef %14, ptr noundef nonnull @.str, i32 noundef %15, i32 noundef %6)\nbr label %B3\n\nB3:\n%17 = phi i32 [ %6, %B1 ], [ %11, %B2 ]\nret i32 %17\n}"}, "define dso_local i32 @reb_tools_orbit2d_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6) {\n%8 = alloca %struct.reb_particle align 4\n%9 = alloca %struct.reb_particle align 4\n%10 = alloca double, align 8\n%11 = alloca double, align 8\n%12 = alloca double, align 8\n%13 = alloca double, align 8\n%14 = alloca double, align 8\n%15 = alloca double, align 8\n%16 = alloca double, align 8\n%17 = alloca double, align 8\n%18 = getelementptr inbounds %struct.reb_particle ptr %9, i32 0, i32 0\nstore i32 %1, ptr %18, align 4\nstore double %0, ptr %10, align 8\nstore double %2, ptr %11, align 8\nstore double %3, ptr %12, align 8\nstore double %4, ptr %13, align 8\nstore double %5, ptr %14, align 8\nstore double %6, ptr %15, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %16)\nstore double 0.000000e+00, ptr %16, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %17)\nstore double 0.000000e+00, ptr %17, align 8\n%19 = load double, ptr %10, align 8\n%20 = load double, ptr %11, align 8\n%21 = load double, ptr %12, align 8\n%22 = load double, ptr %13, align 8\n%23 = load double, ptr %17, align 8\n%24 = load double, ptr %16, align 8\n%25 = load double, ptr %14, align 8\n%26 = load double, ptr %15, align 8\n%27 = getelementptr inbounds %struct.reb_particle ptr %9, i32 0, i32 0\n%28 = load i32, ptr %27, align 4\n%29 = call i32 @reb_tools_orbit_to_particle(double noundef nofpclass(nan inf) %19, i32 %28, double noundef nofpclass(nan inf) %20, double noundef nofpclass(nan inf) %21, double noundef nofpclass(nan inf) %22, double noundef nofpclass(nan inf) %23, double noundef nofpclass(nan inf) %24, double noundef nofpclass(nan inf) %25, double noundef nofpclass(nan inf) %26)\n%30 = getelementptr inbounds %struct.reb_particle ptr %8, i32 0, i32 0\nstore i32 %29, ptr %30, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %17)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %16)\n%31 = getelementptr inbounds %struct.reb_particle ptr %8, i32 0, i32 0\n%32 = load i32, ptr %31, align 4\nret i32 %32\n}": {"base_truth": "define dso_local i32 @reb_tools_orbit2d_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6) {\nB:\n%7 = tail call i32 @reb_tools_orbit_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6)\nret i32 %7\n}", "codellama": "define dso_local i32 @reb_tools_orbit2d_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6) {\nB:\n%7 = tail call i32 @reb_tools_orbit_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) 0.000000e+00, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6)\nret i32 %7\n}", "codegemma": "define dso_local i32 @reb_tools_orbit2d_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6) {\nB:\n%7 = tail call i32 @reb_tools_orbit_to_particle(double noundef nofpclass(nan inf) %0, i32 %1, double noundef nofpclass(nan inf) %2, double noundef nofpclass(nan inf) %3, double noundef nofpclass(nan inf) %4, double noundef nofpclass(nan inf) %5, double noundef nofpclass(nan inf) %6)\nret i32 %7\n}"}, "define dso_local void @release_segments(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @release_segments(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @release_segments(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @release_segments(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define dso_local i32 @unknown_handler(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = call i32 @printf(ptr noundef @.str, ptr noundef %5)\nret i32 0\n}": {"base_truth": "define dso_local i32 @unknown_handler(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret i32 0\n}", "codellama": "define dso_local i32 @unknown_handler(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @unknown_handler(ptr noundef %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret i32 0\n}"}, "define dso_local i32 @d_ne_mm3(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load double, ptr %5, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load double, ptr %7, align 8\n%9 = fcmp fast une double %6, %8\nbr i1 %9, label %10, label %12\n\n10:\n%11 = load i32, ptr @x, align 4\nbr label %14\n\n12:\n%13 = load i32, ptr @y, align 4\nbr label %14\n\n14:\n%15 = phi i32 [ %11, %10 ], [ %13, %12 ]\nret i32 %15\n}": {"base_truth": "define dso_local i32 @d_ne_mm3(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load double, ptr %0, align 8\n%3 = load double, ptr %1, align 8\n%4 = fcmp fast une double %2, %3\n%5 = load i32, ptr @x, align 4\n%6 = load i32, ptr @y, align 4\n%7 = select i1 %4, i32 %5, i32 %6\nret i32 %7\n}", "codellama": "define dso_local i32 @d_ne_mm3(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load double, ptr %0, align 8\n%3 = load double, ptr %1, align 8\n%4 = fcmp fast une double %2, %3\n%5 = load i32, ptr @x, align 4\n%6 = load i32, ptr @y, align 4\n%7 = select i1 %4, i32 %5, i32 %6\nret i32 %7\n}", "codegemma": "define dso_local i32 @d_ne_mm3(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load double, ptr %0, align 8\n%3 = load double, ptr %1, align 8\n%4 = fcmp fast une double %2, %3\n%5 = load i32, ptr @x, align 4\n%6 = load i32, ptr @y, align 4\n%7 = select i1 %4, i32 %5, i32 %6\nret i32 %7\n}"}, "define dso_local i32 @listSizetrans_fun_typeuint(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @listSizetrans_fun_typeuint(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @listSizetrans_fun_typeuint(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @listSizetrans_fun_typeuint(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local void @instance_created(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @printf(ptr noundef @.str, i32 noundef %3)\nret void\n}": {"base_truth": "define dso_local void @instance_created(i32 noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @instance_created(i32 noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @instance_created(i32 noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0)\nret void\n}"}, "define dso_local void @setup_os_exceptions() {\n%1 = call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 2, ptr noundef @dsi_exception_cb)\n%2 = call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 3, ptr noundef @isi_exception_cb)\n%3 = call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 6, ptr noundef @program_exception_cb)\nret void\n}": {"base_truth": "define dso_local void @setup_os_exceptions() {\nB:\n%0 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 2, ptr noundef nonnull @dsi_exception_cb)\n%1 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 3, ptr noundef nonnull @isi_exception_cb)\n%2 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 6, ptr noundef nonnull @program_exception_cb)\nret void\n}", "codellama": "define dso_local void @setup_os_exceptions() {\nB:\n%0 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 2, ptr noundef nonnull @dsi_exception_cb)\n%1 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 3, ptr noundef nonnull @isi_exception_cb)\n%2 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 6, ptr noundef nonnull @program_exception_cb)\nret void\n}", "codegemma": "define dso_local void @setup_os_exceptions() {\nB:\n%0 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 2, ptr noundef nonnull @dsi_exception_cb)\n%1 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 3, ptr noundef nonnull @isi_exception_cb)\n%2 = tail call i32 @OSSetExceptionCallbackEx(i32 noundef 4, i32 noundef 6, ptr noundef nonnull @program_exception_cb)\nret void\n}"}, "define internal ptr @mpcf_input_str_ast(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %4, align 8\n%7 = call ptr @mpc_ast_new(ptr noundef @.str, ptr noundef %6)\nstore ptr %7, ptr %5, align 8\n%8 = load ptr, ptr %3, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = call i32 @mpc_free(ptr noundef %8, ptr noundef %9)\n%11 = load ptr, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret ptr %11\n}": {"base_truth": "define internal ptr @mpcf_input_str_ast(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @mpc_ast_new(ptr noundef nonnull @.str, ptr noundef %1)\n%3 = tail call i32 @mpc_free(ptr noundef %0, ptr noundef %1)\nret ptr %2\n}", "codellama": "define internal ptr @mpcf_input_str_ast(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @mpc_ast_new(ptr noundef nonnull @.str, ptr noundef %1)\n%3 = tail call i32 @mpc_free(ptr noundef %0, ptr noundef %1)\nret ptr %2\n}", "codegemma": "define internal ptr @mpcf_input_str_ast(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call ptr @mpc_ast_new(ptr noundef nonnull @.str, ptr noundef %1)\n%3 = tail call i32 @mpc_free(ptr noundef %0, ptr noundef %1)\nret ptr %2\n}"}, "define dso_local void @rrpge_m_acc_init() {\n%1 = call i32 @rrpge_m_stat_add_rw_handler(ptr noundef @rrpge_m_acc_stat_regs_read, ptr noundef @rrpge_m_acc_stat_regs_write, i32 noundef 160, i32 noundef 32)\n%2 = call i32 @rrpge_m_stat_add_rw_handler(ptr noundef @rrpge_m_acc_stat_rtab_read, ptr noundef @rrpge_m_acc_stat_rtab_write, i32 noundef 768, i32 noundef 256)\nret void\n}": {"base_truth": "define dso_local void @rrpge_m_acc_init() {\nB:\n%0 = tail call i32 @rrpge_m_stat_add_rw_handler(ptr noundef nonnull @rrpge_m_acc_stat_regs_read, ptr noundef nonnull @rrpge_m_acc_stat_regs_write, i32 noundef 160, i32 noundef 32)\n%1 = tail call i32 @rrpge_m_stat_add_rw_handler(ptr noundef nonnull @rrpge_m_acc_stat_rtab_read, ptr noundef nonnull @rrpge_m_acc_stat_rtab_write, i32 noundef 768, i32 noundef 256)\nret void\n}", "codellama": "define dso_local void @rrpge_m_acc_init() {\nB:\n%0 = tail call i32 @rrpge_m_stat_add_rw_handler(ptr noundef nonnull @rrpge_m_acc_stat_regs_read, ptr noundef nonnull @rrpge_m_acc_stat_regs_write, i32 noundef 160, i32 noundef 32)\n%1 = tail call i32 @rrpge_m_stat_add_rw_handler(ptr noundef nonnull @rrpge_m_acc_stat_rtab_read, ptr noundef nonnull @rrpge_m_acc_stat_rtab_write, i32 noundef 768, i32 noundef 256)\nret void\n}", "codegemma": "define dso_local void @rrpge_m_acc_init() {\nB:\n%0 = tail call i32 @rrpge_m_stat_add_rw_handler(ptr noundef nonnull @rrpge_m_acc_stat_regs_read, ptr noundef nonnull @rrpge_m_acc_stat_regs_write, i32 noundef 160, i32 noundef 32)\n%1 = tail call i32 @rrpge_m_stat_add_rw_handler(ptr noundef nonnull @rrpge_m_acc_stat_rtab_read, ptr noundef nonnull @rrpge_m_acc_stat_rtab_write, i32 noundef 768, i32 noundef 256)\nret void\n}"}, "define dso_local void @nrf_802154_auto_pending_bit_set(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @nrf_802154_ack_pending_bit_set(i32 noundef %3)\nret void\n}": {"base_truth": "define dso_local void @nrf_802154_auto_pending_bit_set(i32 noundef %0) {\nB:\n%1 = tail call i32 @nrf_802154_ack_pending_bit_set(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @nrf_802154_auto_pending_bit_set(i32 noundef %0) {\nB:\n%1 = tail call i32 @nrf_802154_ack_pending_bit_set(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @nrf_802154_auto_pending_bit_set(i32 noundef %0) {\nB:\n%1 = tail call i32 @nrf_802154_ack_pending_bit_set(i32 noundef %0)\nret void\n}"}, "define internal i32 @synth_full() {\n%1 = load i64, ptr @synth_port, align 8\n%2 = load i64, ptr @UART_RX, align 8\n%3 = add nsw i64 %1, %2\n%4 = call i32 @inb_p(i64 noundef %3)\n%5 = and i32 %4, 128\n%6 = icmp eq i32 %5, 0\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define internal i32 @synth_full() {\nB:\n%0 = load i64, ptr @synth_port, align 8\n%1 = load i64, ptr @UART_RX, align 8\n%2 = add nsw i64 %1, %0\n%3 = tail call i32 @inb_p(i64 noundef %2)\n%4 = lshr i32 %3, 7\n%5 = and i32 %4, 1\n%6 = xor i32 %5, 1\nret i32 %6\n}", "codellama": "define internal i32 @synth_full() {\nB:\n%0 = load i64, ptr @synth_port, align 8\n%1 = load i64, ptr @UART_RX, align 8\n%2 = add nsw i64 %1, %0\n%3 = tail call i32 @inb_p(i64 noundef %2)\n%4 = lshr i32 %3, 7\n%5 = and i32 %4, 1\n%6 = xor i32 %5, 1\nret i32 %6\n}", "codegemma": "define internal i32 @synth_full() {\nB:\n%0 = load i64, ptr @synth_port, align 8\n%1 = load i64, ptr @UART_RX, align 8\n%2 = add nsw i64 %1, %0\n%3 = tail call i32 @inb_p(i64 noundef %2)\n%4 = and i32 %3, 128\n%5 = icmp eq i32 %4, 0\n%6 = zext i1 %5 to i32\nret i32 %6\n}"}, "define dso_local void @mqtt_message_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @memset(ptr noundef %3, i32 noundef 0, i32 noundef 4)\nret void\n}": {"base_truth": "define dso_local void @mqtt_message_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret void\n}", "codellama": "define dso_local void @mqtt_message_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret void\n}", "codegemma": "define dso_local void @mqtt_message_init(ptr noundef %0) {\nB:\n%1 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 4)\nret void\n}"}, "define dso_local void @buf_deinit(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.buf ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @free(i32 noundef %5)\nret void\n}": {"base_truth": "define dso_local void @buf_deinit(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @free(i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @buf_deinit(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @free(i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @buf_deinit(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @free(i32 noundef %1)\nret void\n}"}, "define dso_local i32 @copy_multprec_target_solutions_to_container() {\n%1 = alloca ptr, align 8\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr %1, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = call i32 @_ada_use_c2phc(i32 noundef 285, ptr noundef %5, ptr noundef %6, ptr noundef %7)\nstore i32 %8, ptr %3, align 4\n%9 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 %9\n}": {"base_truth": "define dso_local i32 @copy_multprec_target_solutions_to_container() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 285, ptr noundef undef, ptr noundef undef, ptr noundef undef)\nret i32 %0\n}", "codellama": "define dso_local i32 @copy_multprec_target_solutions_to_container() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 285, ptr noundef undef, ptr noundef undef, ptr noundef undef)\nret i32 %0\n}", "codegemma": "define dso_local i32 @copy_multprec_target_solutions_to_container() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 285, ptr noundef undef, ptr noundef undef, ptr noundef undef)\nret i32 %0\n}"}, "define internal void @test_VarUI2ChangeTypeEx() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\nstore i32 1, ptr %2, align 4\n%5 = load i32, ptr @VT_UI2, align 4\n%6 = load i32, ptr @V_UI2, align 4\n%7 = call i32 @INITIAL_TYPETEST(i32 noundef %5, i32 noundef %6, ptr noundef @.str)\n%8 = load i32, ptr @COMMON_TYPETEST, align 4\n%9 = load i32, ptr @VT_UI2, align 4\n%10 = load i32, ptr @V_UI2, align 4\n%11 = load i32, ptr @VT_I2, align 4\n%12 = load i32, ptr @V_I2, align 4\n%13 = call i32 @NEGATIVE_TYPETEST(i32 noundef %9, i32 noundef %10, ptr noundef @.str, i32 noundef %11, i32 noundef %12)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define internal void @test_VarUI2ChangeTypeEx() {\nB:\n%0 = load i32, ptr @VT_UI2, align 4\n%1 = load i32, ptr @V_UI2, align 4\n%2 = tail call i32 @INITIAL_TYPETEST(i32 noundef %0, i32 noundef %1, ptr noundef nonnull @.str)\n%3 = load i32, ptr @VT_UI2, align 4\n%4 = load i32, ptr @V_UI2, align 4\n%5 = load i32, ptr @VT_I2, align 4\n%6 = load i32, ptr @V_I2, align 4\n%7 = tail call i32 @NEGATIVE_TYPETEST(i32 noundef %3, i32 noundef %4, ptr noundef nonnull @.str, i32 noundef %5, i32 noundef %6)\nret void\n}", "codellama": "define internal void @test_VarUI2ChangeTypeEx() {\nB:\n%0 = load i32, ptr @VT_UI2, align 4\n%1 = load i32, ptr @V_UI2, align 4\n%2 = tail call i32 @INITIAL_TYPETEST(i32 noundef %0, i32 noundef %1, ptr noundef nonnull @.str)\n%3 = load i32, ptr @VT_UI2, align 4\n%4 = load i32, ptr @V_UI2, align 4\n%5 = load i32, ptr @VT_I2, align 4\n%6 = load i32, ptr @V_I2, align 4\n%7 = tail call i32 @NEGATIVE_TYPETEST(i32 noundef %3, i32 noundef %4, ptr noundef nonnull @.str, i32 noundef %5, i32 noundef %6)\nret void\n}", "codegemma": "define internal void @test_VarUI2ChangeTypeEx() {\nB:\n%0 = load i32, ptr @VT_UI2, align 4\n%1 = load i32, ptr @V_UI2, align 4\n%2 = tail call i32 @INITIAL_TYPETEST(i32 noundef %0, i32 noundef %1, ptr noundef nonnull @.str)\n%3 = load i32, ptr @COMMON_TYPETEST, align 4\n%4 = load i32, ptr @VT_UI2, align 4\n%5 = load i32, ptr @V_UI2, align 4\n%6 = load i32, ptr @VT_I2, align 4\n%7 = load i32, ptr @V_I2, align 4\n%8 = tail call i32 @NEGATIVE_TYPETEST(i32 noundef %4, i32 noundef %5, ptr noundef nonnull @.str, i32 noundef %6, i32 noundef %7)\nret void\n}"}, "define dso_local i32 @f33(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @f32(i32 noundef %3)\n%5 = call i32 @f32(i32 noundef %4)\nret i32 %5\n}": {"base_truth": "define dso_local i32 @f33(i32 noundef %0) {\nB:\n%1 = tail call i32 @f32(i32 noundef %0)\n%2 = tail call i32 @f32(i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @f33(i32 noundef %0) {\nB:\n%1 = tail call i32 @f32(i32 noundef %0)\n%2 = tail call i32 @f32(i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @f33(i32 noundef %0) {\nB:\n%1 = tail call i32 @f32(i32 noundef %0)\n%2 = tail call i32 @f32(i32 noundef %1)\nret i32 %2\n}"}, "define dso_local void @opcb_43() {\n%1 = load i32, ptr @E, align 4\n%2 = call i32 @bit_reg8(i32 noundef 0, i32 noundef %1)\nret void\n}": {"base_truth": "define dso_local void @opcb_43() {\nB:\n%0 = load i32, ptr @E, align 4\n%1 = tail call i32 @bit_reg8(i32 noundef 0, i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @opcb_43() {\nB:\n%0 = load i32, ptr @E, align 4\n%1 = tail call i32 @bit_reg8(i32 noundef 0, i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @opcb_43() {\nB:\n%0 = load i32, ptr @E, align 4\n%1 = tail call i32 @bit_reg8(i32 noundef 0, i32 noundef %0)\nret void\n}"}, "define dso_local void @ftk_params_destroy(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %5, label %17\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @ftk_pairs_destroy(i32 noundef %8)\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds %struct.TYPE_4__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = call i32 @ftk_pairs_destroy(i32 noundef %12)\n%14 = call i32 (...) @ftk_default_allocator()\n%15 = load ptr, ptr %2, align 8\n%16 = call i32 @ftk_allocator_free(i32 noundef %14, ptr noundef %15)\nstore ptr null, ptr %2, align 8\nbr label %17\n\n17:\nret void\n}": {"base_truth": "define dso_local void @ftk_params_destroy(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @ftk_pairs_destroy(i32 noundef %3)\n%5 = load i32, ptr %0, align 4\n%6 = tail call i32 @ftk_pairs_destroy(i32 noundef %5)\n%7 = tail call i32 (...) @ftk_default_allocator()\n%8 = tail call i32 @ftk_allocator_free(i32 noundef %7, ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @ftk_params_destroy(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @ftk_pairs_destroy(i32 noundef %3)\n%5 = load i32, ptr %0, align 4\n%6 = tail call i32 @ftk_pairs_destroy(i32 noundef %5)\n%7 = tail call i32 (...) @ftk_default_allocator()\n%8 = tail call i32 @ftk_allocator_free(i32 noundef %7, ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @ftk_params_destroy(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @ftk_pairs_destroy(i32 noundef %3)\n%5 = load i32, ptr %0, align 4\n%6 = tail call i32 @ftk_pairs_destroy(i32 noundef %5)\n%7 = tail call i32 (...) @ftk_default_allocator()\n%8 = tail call i32 @ftk_allocator_free(i32 noundef %7, ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @notify_signal(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.notify ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @eventfd_write(i32 noundef %5, i32 noundef 1)\nret i32 %6\n}": {"base_truth": "define dso_local i32 @notify_signal(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @eventfd_write(i32 noundef %1, i32 noundef 1)\nret i32 %2\n}", "codellama": "define dso_local i32 @notify_signal(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @eventfd_write(i32 noundef %1, i32 noundef 1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @notify_signal(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @eventfd_write(i32 noundef %1, i32 noundef 1)\nret i32 %2\n}"}, "define internal i32 @OnAction_p2p(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr @_SUCCESS, align 4\nret i32 %5\n}": {"base_truth": "define internal i32 @OnAction_p2p(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @_SUCCESS, align 4\nret i32 %2\n}", "codellama": "define internal i32 @OnAction_p2p(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @_SUCCESS, align 4\nret i32 %2\n}", "codegemma": "define internal i32 @OnAction_p2p(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\n%2 = load i32, ptr @_SUCCESS, align 4\nret i32 %2\n}"}, "define dso_local i32 @tga_is_pixel_intersection() {\n%1 = load i32, ptr @tga_pixel_intersection, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @tga_is_pixel_intersection() {\nB:\n%0 = load i32, ptr @tga_pixel_intersection, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @tga_is_pixel_intersection() {\nB:\n%0 = load i32, ptr @tga_pixel_intersection, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @tga_is_pixel_intersection() {\nB:\n%0 = load i32, ptr @tga_pixel_intersection, align 4\nret i32 %0\n}"}, "define dso_local void @sigintHandler(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\nstore i64 0, ptr @running, align 8\nret void\n}": {"base_truth": "define dso_local void @sigintHandler(i32 noundef %0) {\nB:\nstore i64 0, ptr @running, align 8\nret void\n}", "codellama": "define dso_local void @sigintHandler(i32 noundef %0) {\nB:\nstore i64 0, ptr @running, align 8\nret void\n}", "codegemma": "define dso_local void @sigintHandler(i32 noundef %0) {\nB:\nstore i64 0, ptr @running, align 8\nret void\n}"}, "define dso_local ptr @AMD64RMI_Imm(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = call ptr @LibVEX_Alloc_inline(i32 noundef 8)\nstore ptr %4, ptr %3, align 8\n%5 = load i32, ptr @Armi_Imm, align 4\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.TYPE_8__, ptr %6, i32 0, i32 1\nstore i32 %5, ptr %7, align 4\n%8 = load i32, ptr %2, align 4\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.TYPE_8__, ptr %9, i32 0, i32 0\n%11 = getelementptr inbounds %struct.TYPE_7__, ptr %10, i32 0, i32 0\n%12 = getelementptr inbounds %struct.TYPE_6__, ptr %11, i32 0, i32 0\nstore i32 %8, ptr %12, align 4\n%13 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @AMD64RMI_Imm(i32 noundef %0) {\nB:\n%1 = tail call ptr @LibVEX_Alloc_inline(i32 noundef 8)\n%2 = load i32, ptr @Armi_Imm, align 4\n%3 = getelementptr inbounds %struct.TYPE_8__, ptr %1, i64 0, i32 1\nstore i32 %2, ptr %3, align 4\nstore i32 %0, ptr %1, align 4\nret ptr %1\n}", "codellama": "define dso_local ptr @AMD64RMI_Imm(i32 noundef %0) {\nB:\n%1 = tail call ptr @LibVEX_Alloc_inline(i32 noundef 8)\n%2 = load i32, ptr @Armi_Imm, align 4\n%3 = getelementptr inbounds %struct.TYPE_8__, ptr %1, i64 0, i32 1\nstore i32 %2, ptr %3, align 4\nstore i32 %0, ptr %1, align 4\nret ptr %1\n}", "codegemma": "define dso_local ptr @AMD64RMI_Imm(i32 noundef %0) {\nB:\n%1 = tail call ptr @LibVEX_Alloc_inline(i32 noundef 8)\n%2 = load i32, ptr @Armi_Imm, align 4\n%3 = getelementptr inbounds %struct.TYPE_8__, ptr %1, i64 0, i32 1\nstore i32 %2, ptr %3, align 4\nstore i32 %0, ptr %1, align 4\nret ptr %1\n}"}, "define internal i32 @unparse_GetVisibility(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%8 = load ptr, ptr %5, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.TYPE_3__, ptr %9, i32 0, i32 0\n%11 = load i64, ptr %10, align 8\n%12 = icmp ne i64 %11, 0\n%13 = zext i1 %12 to i64\n%14 = select i1 %12, i32 1, i32 0\n%15 = call i32 @BufferPrintf(ptr noundef %8, ptr noundef @.str, i32 noundef %14)\nstore i32 %15, ptr %6, align 4\n%16 = load i32, ptr %6, align 4\n%17 = load i32, ptr @VLC_SUCCESS, align 4\n%18 = icmp ne i32 %16, %17\nbr i1 %18, label %19, label %21\n\n19:\n%20 = load i32, ptr %6, align 4\nstore i32 %20, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %23\n\n21:\n%22 = load i32, ptr @VLC_SUCCESS, align 4\nstore i32 %22, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %23\n\n23:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%24 = load i32, ptr %3, align 4\nret i32 %24\n}": {"base_truth": "define internal i32 @unparse_GetVisibility(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = icmp ne i64 %2, 0\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @BufferPrintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %4)\nret i32 %5\n}", "codellama": "define internal i32 @unparse_GetVisibility(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = icmp ne i64 %2, 0\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @BufferPrintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %4)\n%6 = load i32, ptr @VLC_SUCCESS, align 4\n%7 = icmp eq i32 %5, %6\n%8 = select i1 %7, i32 %6, i32 %5\nret i32 %8\n}", "codegemma": "define internal i32 @unparse_GetVisibility(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = icmp ne i64 %2, 0\n%4 = zext i1 %3 to i32\n%5 = tail call i32 @BufferPrintf(ptr noundef %1, ptr noundef nonnull @.str, i32 noundef %4)\n%6 = load i32, ptr @VLC_SUCCESS, align 4\n%7 = icmp eq i32 %5, %6\n%8 = select i1 %7, i32 %6, i32 %5\nret i32 %8\n}"}, "define dso_local void @qla4_82xx_idc_unlock(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @PCIE_SEM5_UNLOCK, align 4\n%5 = call i32 @QLA82XX_PCIE_REG(i32 noundef %4)\n%6 = call i32 @qla4_82xx_rd_32(ptr noundef %3, i32 noundef %5)\nret void\n}": {"base_truth": "define dso_local void @qla4_82xx_idc_unlock(ptr noundef %0) {\nB:\n%1 = load i32, ptr @PCIE_SEM5_UNLOCK, align 4\n%2 = tail call i32 @QLA82XX_PCIE_REG(i32 noundef %1)\n%3 = tail call i32 @qla4_82xx_rd_32(ptr noundef %0, i32 noundef %2)\nret void\n}", "codellama": "define dso_local void @qla4_82xx_idc_unlock(ptr noundef %0) {\nB:\n%1 = load i32, ptr @PCIE_SEM5_UNLOCK, align 4\n%2 = tail call i32 @QLA82XX_PCIE_REG(i32 noundef %1)\n%3 = tail call i32 @qla4_82xx_rd_32(ptr noundef %0, i32 noundef %2)\nret void\n}", "codegemma": "define dso_local void @qla4_82xx_idc_unlock(ptr noundef %0) {\nB:\n%1 = load i32, ptr @PCIE_SEM5_UNLOCK, align 4\n%2 = tail call i32 @QLA82XX_PCIE_REG(i32 noundef %1)\n%3 = tail call i32 @qla4_82xx_rd_32(ptr noundef %0, i32 noundef %2)\nret void\n}"}, "define dso_local i32 @anetUnixNonBlockConnect(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load i32, ptr @ANET_CONNECT_NONBLOCK, align 4\n%8 = call i32 @anetUnixGenericConnect(ptr noundef %5, ptr noundef %6, i32 noundef %7)\nret i32 %8\n}": {"base_truth": "define dso_local i32 @anetUnixNonBlockConnect(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @ANET_CONNECT_NONBLOCK, align 4\n%3 = tail call i32 @anetUnixGenericConnect(ptr noundef %0, ptr noundef %1, i32 noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @anetUnixNonBlockConnect(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @ANET_CONNECT_NONBLOCK, align 4\n%3 = tail call i32 @anetUnixGenericConnect(ptr noundef %0, ptr noundef %1, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @anetUnixNonBlockConnect(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr @ANET_CONNECT_NONBLOCK, align 4\n%3 = tail call i32 @anetUnixGenericConnect(ptr noundef %0, ptr noundef %1, i32 noundef %2)\nret i32 %3\n}"}, "define dso_local void @openop_init(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = call i32 @assert(ptr noundef %5)\n%7 = load i32, ptr %4, align 4\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.openop ptr %8, i32 0, i32 0\nstore i32 %7, ptr %9, align 4\nret void\n}": {"base_truth": "define dso_local void @openop_init(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @assert(ptr noundef %0)\nstore i32 %1, ptr %0, align 4\nret void\n}", "codellama": "define dso_local void @openop_init(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @assert(ptr noundef %0)\nstore i32 %1, ptr %0, align 4\nret void\n}", "codegemma": "define dso_local void @openop_init(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @assert(ptr noundef %0)\nstore i32 %1, ptr %0, align 4\nret void\n}"}, "define dso_local i32 @odb_add_node(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = load i32, ptr %5, align 4\n%11 = load i32, ptr %6, align 4\n%12 = call i32 @add_node(i32 noundef %9, i32 noundef %10, i32 noundef %11)\nret i32 %12\n}": {"base_truth": "define dso_local i32 @odb_add_node(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @add_node(i32 noundef %3, i32 noundef %1, i32 noundef %2)\nret i32 %4\n}", "codellama": "define dso_local i32 @odb_add_node(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @add_node(i32 noundef %3, i32 noundef %1, i32 noundef %2)\nret i32 %4\n}", "codegemma": "define dso_local i32 @odb_add_node(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr %0, align 4\n%4 = tail call i32 @add_node(i32 noundef %3, i32 noundef %1, i32 noundef %2)\nret i32 %4\n}"}, "define dso_local i32 @System7Up() {\n%1 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i32, ptr @gestaltSystemVersion, align 4\n%3 = call i32 @Gestalt(i32 noundef %2, ptr noundef %1)\n%4 = load i64, ptr %1, align 8\n%5 = icmp sge i64 %4, 1792\n%6 = zext i1 %5 to i32\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 %6\n}": {"base_truth": "define dso_local i32 @System7Up() {\nB:\n%0 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %0)\n%1 = load i32, ptr @gestaltSystemVersion, align 4\n%2 = call i32 @Gestalt(i32 noundef %1, ptr noundef nonnull %0)\n%3 = load i64, ptr %0, align 8\n%4 = icmp sgt i64 %3, 1791\n%5 = zext i1 %4 to i32\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %0)\nret i32 %5\n}", "codellama": "define dso_local i32 @System7Up() {\nB:\n%0 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %0)\n%1 = load i32, ptr @gestaltSystemVersion, align 4\n%2 = call i32 @Gestalt(i32 noundef %1, ptr noundef nonnull %0)\n%3 = load i64, ptr %0, align 8\n%4 = icmp sgt i64 %3, 1791\n%5 = zext i1 %4 to i32\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %0)\nret i32 %5\n}", "codegemma": "define dso_local i32 @System7Up() {\nB:\n%0 = alloca i64, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %0)\n%1 = load i32, ptr @gestaltSystemVersion, align 4\n%2 = call i32 @Gestalt(i32 noundef %1, ptr noundef nonnull %0)\n%3 = load i64, ptr %0, align 8\n%4 = icmp sgt i64 %3, 1791\n%5 = zext i1 %4 to i32\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %0)\nret i32 %5\n}"}, "define dso_local void @blk_clear_pm_only(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.request_queue, ptr %4, i32 0, i32 1\n%6 = call i32 @atomic_dec_return(ptr noundef %5)\nstore i32 %6, ptr %3, align 4\n%7 = load i32, ptr %3, align 4\n%8 = icmp slt i32 %7, 0\n%9 = zext i1 %8 to i32\n%10 = call i32 @WARN_ON_ONCE(i32 noundef %9)\n%11 = load i32, ptr %3, align 4\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %13, label %17\n\n13:\n%14 = load ptr, ptr %2, align 8\n%15 = getelementptr inbounds %struct.request_queue, ptr %14, i32 0, i32 0\n%16 = call i32 @wake_up_all(ptr noundef %15)\nbr label %17\n\n17:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define dso_local void @blk_clear_pm_only(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.request_queue, ptr %0, i64 0, i32 1\n%2 = tail call i32 @atomic_dec_return(ptr noundef nonnull %1)\n%3 = lshr i32 %2, 31\n%4 = tail call i32 @WARN_ON_ONCE(i32 noundef %3)\n%5 = icmp eq i32 %2, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @wake_up_all(ptr noundef %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @blk_clear_pm_only(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.request_queue, ptr %0, i64 0, i32 1\n%2 = tail call i32 @atomic_dec_return(ptr noundef nonnull %1)\n%3 = lshr i32 %2, 31\n%4 = tail call i32 @WARN_ON_ONCE(i32 noundef %3)\n%5 = icmp eq i32 %2, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @wake_up_all(ptr noundef %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @blk_clear_pm_only(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.request_queue, ptr %0, i64 0, i32 1\n%2 = tail call i32 @atomic_dec_return(ptr noundef nonnull %1)\n%3 = lshr i32 %2, 31\n%4 = tail call i32 @WARN_ON_ONCE(i32 noundef %3)\n%5 = icmp eq i32 %2, 0\nbr i1 %5, label %B1, label %B2\n\nB1:\n%6 = tail call i32 @wake_up_all(ptr noundef %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\n%2 = call i32 @contNum(i32 noundef 762021192, i32 noundef 2, i32 noundef 0)\n%3 = call i32 @printf(ptr noundef @.str, i32 noundef %2, i32 noundef 762021192)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @contNum(i32 noundef 762021192, i32 noundef 2, i32 noundef 0)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef 762021192)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @contNum(i32 noundef 762021192, i32 noundef 2, i32 noundef 0)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef 762021192)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @contNum(i32 noundef 762021192, i32 noundef 2, i32 noundef 0)\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef 762021192)\nret i32 0\n}"}, "define dso_local signext i8 @lettre_de_piece(i32 noundef %0) {\n%2 = alloca i8, align 1\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\nswitch i32 %4, label %12 [\ni32 131, label %5\ni32 128, label %6\ni32 134, label %7\ni32 132, label %8\ni32 133, label %9\ni32 129, label %10\ni32 130, label %11\n]\n\n5:\nstore i8 112, ptr %2, align 1\nbr label %13\n\n6:\nstore i8 82, ptr %2, align 1\nbr label %13\n\n7:\nstore i8 78, ptr %2, align 1\nbr label %13\n\n8:\nstore i8 70, ptr %2, align 1\nbr label %13\n\n9:\nstore i8 81, ptr %2, align 1\nbr label %13\n\n10:\nstore i8 75, ptr %2, align 1\nbr label %13\n\n11:\nstore i8 32, ptr %2, align 1\nbr label %13\n\n12:\nstore i8 42, ptr %2, align 1\nbr label %13\n\n13:\n%14 = load i8, ptr %2, align 1\nret i8 %14\n}": {"base_truth": "define dso_local signext i8 @lettre_de_piece(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 7\n%3 = zext i32 %1 to i56\n%4 = shl nuw nsw i56 %3, 3\n%5 = lshr i56 22044411154156370, %4\n%6 = trunc i56 %5 to i8\n%7 = select i1 %2, i8 %6, i8 42\nret i8 %7\n}", "codellama": "define dso_local signext i8 @lettre_de_piece(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 7\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [7 x i8], ptr @switch.table.lettre_de_piece, i64 0, i64 %3\n%5 = load i8, ptr %4, align 1\nbr label %B2\n\nB2:\n%6 = phi i8 [ %5, %B1 ], [ 42, %B ]\nret i8 %6\n}", "codegemma": "define dso_local signext i8 @lettre_de_piece(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 7\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [7 x i8], ptr @switch.table.lettre_de_piece, i64 0, i64 %3\n%5 = load i8, ptr %4, align 1\nbr label %B2\n\nB2:\n%6 = phi i8 [ %5, %B1 ], [ 42, %B ]\nret i8 %6\n}"}, "define internal i32 @u132_periodic_reinit(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.u132 ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = and i32 %11, 16383\nstore i32 %12, ptr %5, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%13 = load ptr, ptr %3, align 8\n%14 = load i32, ptr %7, align 4\n%15 = call i32 @u132_read_pcimem(ptr noundef %13, i32 noundef %14, ptr noundef %7)\nstore i32 %15, ptr %4, align 4\n%16 = load i32, ptr %4, align 4\n%17 = icmp ne i32 %16, 0\nbr i1 %17, label %18, label %20\n\n18:\n%19 = load i32, ptr %4, align 4\nstore i32 %19, ptr %2, align 4\nstore i32 1, ptr %8, align 4\nbr label %46\n\n20:\n%21 = load i32, ptr %7, align 4\n%22 = load i32, ptr @FIT, align 4\n%23 = and i32 %21, %22\nstore i32 %23, ptr %6, align 4\n%24 = load ptr, ptr %3, align 8\n%25 = load i32, ptr %7, align 4\n%26 = load i32, ptr %6, align 4\n%27 = load i32, ptr @FIT, align 4\n%28 = xor i32 %26, %27\n%29 = load ptr, ptr %3, align 8\n%30 = getelementptr inbounds %struct.u132 ptr %29, i32 0, i32 0\n%31 = load i32, ptr %30, align 4\n%32 = or i32 %28, %31\n%33 = call i32 @u132_write_pcimem(ptr noundef %24, i32 noundef %25, i32 noundef %32)\nstore i32 %33, ptr %4, align 4\n%34 = load i32, ptr %4, align 4\n%35 = icmp ne i32 %34, 0\nbr i1 %35, label %36, label %38\n\n36:\n%37 = load i32, ptr %4, align 4\nstore i32 %37, ptr %2, align 4\nstore i32 1, ptr %8, align 4\nbr label %46\n\n38:\n%39 = load ptr, ptr %3, align 8\n%40 = load i32, ptr @periodicstart, align 4\n%41 = load i32, ptr %5, align 4\n%42 = mul nsw i32 9, %41\n%43 = sdiv i32 %42, 10\n%44 = and i32 %43, 16383\n%45 = call i32 @u132_write_pcimem(ptr noundef %39, i32 noundef %40, i32 noundef %44)\nstore i32 %45, ptr %2, align 4\nstore i32 1, ptr %8, align 4\nbr label %46\n\n46:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%47 = load i32, ptr %2, align 4\nret i32 %47\n}": {"base_truth": "define internal i32 @u132_periodic_reinit(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = load i32, ptr %0, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%3 = call i32 @u132_read_pcimem(ptr noundef nonnull %0, i32 noundef undef, ptr noundef nonnull %1)\n%4 = icmp eq i32 %3, 0\nbr i1 %4, label %B1, label %B3\n\nB1:\n%5 = load i32, ptr %1, align 4\n%6 = load i32, ptr @FIT, align 4\n%7 = xor i32 %5, -1\n%8 = and i32 %6, %7\n%9 = load i32, ptr %0, align 4\n%10 = or i32 %8, %9\n%11 = call i32 @u132_write_pcimem(ptr noundef nonnull %0, i32 noundef %5, i32 noundef %10)\n%12 = icmp eq i32 %11, 0\nbr i1 %12, label %B2, label %B3\n\nB2:\n%13 = and i32 %2, 16383\n%14 = mul nuw nsw i32 %13, 9\n%15 = load i32, ptr @periodicstart, align 4\n%16 = udiv i32 %14, 10\n%17 = call i32 @u132_write_pcimem(ptr noundef nonnull %0, i32 noundef %15, i32 noundef %16)\nbr label %B3\n\nB3:\n%18 = phi i32 [ %17, %B2 ], [ %3, %B ], [ %11, %B1 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %18\n}", "codellama": "define internal i32 @u132_periodic_reinit(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\n%2 = load i32, ptr %0, align 4\n%3 = and i32 %2, 16383\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%4 = call i32 @u132_read_pcimem(ptr noundef nonnull %0, i32 noundef undef, ptr noundef nonnull %1)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr @FIT, align 4\n%8 = and i32 %7, %6\n%9 = xor i32 %8, %7\n%10 = load i32, ptr %0, align 4\n%11 = or i32 %10, %9\n%12 = call i32 @u132_write_pcimem(ptr noundef nonnull %0, i32 noundef %6, i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B2, label %B3\n\nB2:\n%14 = load i32, ptr @periodicstart, align 4\n%15 = mul nuw nsw i32 %3, 9\n%16 = udiv i32 %15, 10\n%17 = and i32 %16, 16383\n%18 = call i32 @u132_write_pcimem(ptr noundef nonnull %0, i32 noundef %14, i32 noundef %17)\nbr label %B3\n\nB3:\n%19 = phi i32 [ %18, %B2 ], [ %4, %B ], [ %12, %B1 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %19\n}", "codegemma": "define internal i32 @u132_periodic_reinit(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr %0, align 4\n%3 = and i32 %2, 16383\n%4 = call i32 @u132_read_pcimem(ptr noundef nonnull %0, i32 noundef undef, ptr noundef nonnull %1)\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %B1, label %B3\n\nB1:\n%6 = load i32, ptr %1, align 4\n%7 = load i32, ptr @FIT, align 4\n%8 = and i32 %7, %6\n%9 = load i32, ptr %0, align 4\n%10 = xor i32 %8, %9\n%11 = or i32 %10, %3\n%12 = call i32 @u132_write_pcimem(ptr noundef nonnull %0, i32 noundef %6, i32 noundef %11)\n%13 = icmp eq i32 %12, 0\nbr i1 %13, label %B2, label %B3\n\nB2:\n%14 = load i32, ptr @periodicstart, align 4\n%15 = mul nsw i32 %3, 9\n%16 = sdiv i32 %15, 10\n%17 = and i32 %16, 16383\n%18 = call i32 @u132_write_pcimem(ptr noundef nonnull %0, i32 noundef %14, i32 noundef %17)\nbr label %B3\n\nB3:\n%19 = phi i32 [ %18, %B2 ], [ %4, %B ], [ %12, %B1 ]\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %19\n}"}, "define dso_local void @xmalloc_state_lock_on() {\nstore i32 1, ptr @xmalloc_state_lock, align 4\nret void\n}": {"base_truth": "define dso_local void @xmalloc_state_lock_on() {\nB:\nstore i32 1, ptr @xmalloc_state_lock, align 4\nret void\n}", "codellama": "define dso_local void @xmalloc_state_lock_on() {\nB:\nstore i32 1, ptr @xmalloc_state_lock, align 4\nret void\n}", "codegemma": "define dso_local void @xmalloc_state_lock_on() {\nB:\nstore i32 1, ptr @xmalloc_state_lock, align 4\nret void\n}"}, "define dso_local void @eps_heap_usage_start() {\nstore i64 0, ptr @maxusage, align 8\nstore i64 0, ptr @curusage, align 8\nret void\n}": {"base_truth": "define dso_local void @eps_heap_usage_start() {\nB:\nstore i64 0, ptr @maxusage, align 8\nstore i64 0, ptr @curusage, align 8\nret void\n}", "codellama": "define dso_local void @eps_heap_usage_start() {\nB:\nstore i64 0, ptr @maxusage, align 8\nstore i64 0, ptr @curusage, align 8\nret void\n}", "codegemma": "define dso_local void @eps_heap_usage_start() {\nB:\nstore i64 0, ptr @maxusage, align 8\nstore i64 0, ptr @curusage, align 8\nret void\n}"}, "define dso_local ptr @get_file_name(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @strrchr(ptr noundef %4, i8 noundef signext 47)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %11, label %8\n\n8:\n%9 = load ptr, ptr %2, align 8\n%10 = call ptr @strrchr(ptr noundef %9, i8 noundef signext 92)\nstore ptr %10, ptr %3, align 8\nbr label %11\n\n11:\n%12 = load ptr, ptr %3, align 8\n%13 = icmp ne ptr %12, null\nbr i1 %13, label %14, label %17\n\n14:\n%15 = load ptr, ptr %3, align 8\n%16 = getelementptr inbounds i8, ptr %15, i32 1\nstore ptr %16, ptr %3, align 8\nbr label %19\n\n17:\n%18 = load ptr, ptr %2, align 8\nstore ptr %18, ptr %3, align 8\nbr label %19\n\n19:\n%20 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %20\n}": {"base_truth": "define dso_local ptr @get_file_name(ptr noundef %0) {\nB:\n%1 = tail call ptr @strrchr(ptr noundef %0, i8 noundef signext 47)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call ptr @strrchr(ptr noundef %0, i8 noundef signext 92)\nbr label %B2\n\nB2:\n%4 = phi ptr [ %1, %B ], [ %3, %B1 ]\n%5 = icmp eq ptr %4, null\n%6 = getelementptr inbounds i8, ptr %4, i64 1\n%7 = select i1 %5, ptr %0, ptr %6\nret ptr %7\n}", "codellama": "define dso_local ptr @get_file_name(ptr noundef %0) {\nB:\n%1 = tail call ptr @strrchr(ptr noundef %0, i8 noundef signext 47)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call ptr @strrchr(ptr noundef %0, i8 noundef signext 92)\n%4 = icmp eq ptr %3, null\n%5 = getelementptr inbounds i8, ptr %3, i64 1\n%6 = select i1 %4, ptr %0, ptr %5\nbr label %B2\n\nB2:\n%7 = phi ptr [ %1, %B ], [ %6, %B1 ]\nret ptr %7\n}", "codegemma": "define dso_local ptr @get_file_name(ptr noundef %0) {\nB:\n%1 = tail call ptr @strrchr(ptr noundef %0, i8 noundef signext 47)\n%2 = icmp eq ptr %1, null\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = tail call ptr @strrchr(ptr noundef %0, i8 noundef signext 92)\n%4 = icmp eq ptr %3, null\n%5 = getelementptr inbounds i8, ptr %3, i64 1\n%6 = select i1 %4, ptr %0, ptr %5\nbr label %B2\n\nB2:\n%7 = phi ptr [ %1, %B ], [ %6, %B1 ]\nret ptr %7\n}"}, "define internal i32 @ni_660x_pci_probe(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = getelementptr inbounds %struct.pci_device_id, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @comedi_pci_auto_config(ptr noundef %5, ptr noundef @ni_660x_driver, i32 noundef %8)\nret i32 %9\n}": {"base_truth": "define internal i32 @ni_660x_pci_probe(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @comedi_pci_auto_config(ptr noundef %0, ptr noundef nonnull @ni_660x_driver, i32 noundef %2)\nret i32 %3\n}", "codellama": "define internal i32 @ni_660x_pci_probe(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @comedi_pci_auto_config(ptr noundef %0, ptr noundef nonnull @ni_660x_driver, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define internal i32 @ni_660x_pci_probe(ptr noundef %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i32, ptr %1, align 4\n%3 = tail call i32 @comedi_pci_auto_config(ptr noundef %0, ptr noundef nonnull @ni_660x_driver, i32 noundef %2)\nret i32 %3\n}"}, "define dso_local void @ooaofooa_ACT_IOP_R657_Unlink(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %4, align 8\n%6 = getelementptr inbounds %struct.TYPE_6__, ptr %5, i32 0, i32 1\nstore i64 0, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %7, i32 0, i32 0\nstore i64 0, ptr %8, align 8\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %9, i32 0, i32 0\n%11 = load ptr, ptr %4, align 8\n%12 = call i32 @Escher_SetRemoveElement(ptr noundef %10, ptr noundef %11)\nret void\n}": {"base_truth": "define dso_local void @ooaofooa_ACT_IOP_R657_Unlink(ptr noundef %0, ptr noundef %1) {\nB:\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\n%2 = tail call i32 @Escher_SetRemoveElement(ptr noundef %0, ptr noundef nonnull %1)\nret void\n}", "codellama": "define dso_local void @ooaofooa_ACT_IOP_R657_Unlink(ptr noundef %0, ptr noundef %1) {\nB:\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\n%2 = tail call i32 @Escher_SetRemoveElement(ptr noundef %0, ptr noundef nonnull %1)\nret void\n}", "codegemma": "define dso_local void @ooaofooa_ACT_IOP_R657_Unlink(ptr noundef %0, ptr noundef %1) {\nB:\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\n%2 = tail call i32 @Escher_SetRemoveElement(ptr noundef %0, ptr noundef nonnull %1)\nret void\n}"}, "define dso_local i32 @BN_priv_rand_ex(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4) {\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca ptr, align 8\nstore ptr %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\nstore ptr %4, ptr %10, align 8\n%11 = load i32, ptr @PRIVATE, align 4\n%12 = load ptr, ptr %6, align 8\n%13 = load i32, ptr %7, align 4\n%14 = load i32, ptr %8, align 4\n%15 = load i32, ptr %9, align 4\n%16 = load ptr, ptr %10, align 8\n%17 = call i32 @bnrand(i32 noundef %11, ptr noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15, ptr noundef %16)\nret i32 %17\n}": {"base_truth": "define dso_local i32 @BN_priv_rand_ex(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4) {\nB:\n%5 = load i32, ptr @PRIVATE, align 4\n%6 = tail call i32 @bnrand(i32 noundef %5, ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4)\nret i32 %6\n}", "codellama": "define dso_local i32 @BN_priv_rand_ex(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4) {\nB:\n%5 = load i32, ptr @PRIVATE, align 4\n%6 = tail call i32 @bnrand(i32 noundef %5, ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4)\nret i32 %6\n}", "codegemma": "define dso_local i32 @BN_priv_rand_ex(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4) {\nB:\n%5 = load i32, ptr @PRIVATE, align 4\n%6 = tail call i32 @bnrand(i32 noundef %5, ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4)\nret i32 %6\n}"}, "define dso_local void @writeBookshelf(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 @writeBookshelfNodes(ptr noundef @.str)\n%4 = call i32 @writeBookshelfPl(ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @writeBookshelf(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 @writeBookshelfNodes(ptr noundef nonnull @.str)\n%2 = tail call i32 @writeBookshelfPl(ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @writeBookshelf(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 @writeBookshelfNodes(ptr noundef nonnull @.str)\n%2 = tail call i32 @writeBookshelfPl(ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @writeBookshelf(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 @writeBookshelfNodes(ptr noundef nonnull @.str)\n%2 = tail call i32 @writeBookshelfPl(ptr noundef nonnull @.str.1)\nret void\n}"}, "define dso_local void @dns_worker() {\n%1 = load ptr, ptr @config, align 8\n%2 = call i32 @printf(ptr noundef @.str, ptr noundef %1)\nret void\n}": {"base_truth": "define dso_local void @dns_worker() {\nB:\n%0 = load ptr, ptr @config, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @dns_worker() {\nB:\n%0 = load ptr, ptr @config, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @dns_worker() {\nB:\n%0 = load ptr, ptr @config, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret void\n}"}, "define internal void @xfrm4_net_sysctl_exit(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define internal void @xfrm4_net_sysctl_exit(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define internal void @xfrm4_net_sysctl_exit(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define internal void @xfrm4_net_sysctl_exit(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define dso_local ptr @jsonDbGetBegin(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load ptr, ptr @jsonMessage, align 8\n%4 = getelementptr inbounds i8, ptr %3, i64 0\nstore i8 0, ptr %4, align 1\n%5 = call i32 @catName(ptr noundef @.str)\n%6 = call i32 @catString(ptr noundef @.str.1)\n%7 = load i32, ptr %2, align 4\n%8 = call i32 @catNameValueInt(ptr noundef @.str.2, i32 noundef %7)\n%9 = call i32 @catString(ptr noundef @.str.3)\n%10 = load ptr, ptr @jsonMessage, align 8\nret ptr %10\n}": {"base_truth": "define dso_local ptr @jsonDbGetBegin(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @jsonMessage, align 8\nstore i8 0, ptr %1, align 1\n%2 = tail call i32 @catName(ptr noundef nonnull @.str)\n%3 = tail call i32 @catString(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @catNameValueInt(ptr noundef nonnull @.str.2, i32 noundef %0)\n%5 = tail call i32 @catString(ptr noundef nonnull @.str.3)\n%6 = load ptr, ptr @jsonMessage, align 8\nret ptr %6\n}", "codellama": "define dso_local ptr @jsonDbGetBegin(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @jsonMessage, align 8\nstore i8 0, ptr %1, align 1\n%2 = tail call i32 @catName(ptr noundef nonnull @.str)\n%3 = tail call i32 @catString(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @catNameValueInt(ptr noundef nonnull @.str.2, i32 noundef %0)\n%5 = tail call i32 @catString(ptr noundef nonnull @.str.3)\n%6 = load ptr, ptr @jsonMessage, align 8\nret ptr %6\n}", "codegemma": "define dso_local ptr @jsonDbGetBegin(i32 noundef %0) {\nB:\n%1 = load ptr, ptr @jsonMessage, align 8\nstore i8 0, ptr %1, align 1\n%2 = tail call i32 @catName(ptr noundef nonnull @.str)\n%3 = tail call i32 @catString(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @catNameValueInt(ptr noundef nonnull @.str.2, i32 noundef %0)\n%5 = tail call i32 @catString(ptr noundef nonnull @.str.3)\n%6 = load ptr, ptr @jsonMessage, align 8\nret ptr %6\n}"}, "define dso_local void @xo_set_style(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = call ptr @xo_default(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\n%7 = load i32, ptr %4, align 4\n%8 = load ptr, ptr %3, align 8\n%9 = getelementptr inbounds %struct.TYPE_5__, ptr %8, i32 0, i32 0\nstore i32 %7, ptr %9, align 4\nret void\n}": {"base_truth": "define dso_local void @xo_set_style(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @xo_default(ptr noundef %0)\nstore i32 %1, ptr %2, align 4\nret void\n}", "codellama": "define dso_local void @xo_set_style(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @xo_default(ptr noundef %0)\nstore i32 %1, ptr %2, align 4\nret void\n}", "codegemma": "define dso_local void @xo_set_style(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @xo_default(ptr noundef %0)\nstore i32 %1, ptr %2, align 4\nret void\n}"}, "define dso_local i64 @ajReadbinInt8(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %4, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.TYPE_3__, ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call i64 @fread(ptr noundef %6, i32 noundef 8, i32 noundef 1, i32 noundef %9)\nstore i64 %10, ptr %5, align 8\n%11 = load i64, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i64 %11\n}": {"base_truth": "define dso_local i64 @ajReadbinInt8(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @fread(ptr noundef %1, i32 noundef 8, i32 noundef 1, i32 noundef %2)\nret i64 %3\n}", "codellama": "define dso_local i64 @ajReadbinInt8(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @fread(ptr noundef %1, i32 noundef 8, i32 noundef 1, i32 noundef %2)\nret i64 %3\n}", "codegemma": "define dso_local i64 @ajReadbinInt8(ptr nocapture noundef readonly %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i64 @fread(ptr noundef %1, i32 noundef 8, i32 noundef 1, i32 noundef %2)\nret i64 %3\n}"}, "define dso_local nofpclass(nan inf) double @asec(double noundef nofpclass(nan inf) %0) {\n%2 = alloca double, align 8\nstore double %0, ptr %2, align 8\n%3 = load double, ptr %2, align 8\n%4 = fdiv fast double 1.000000e+00, %3\n%5 = call fast nofpclass(nan inf) double @acos(double noundef nofpclass(nan inf) %4)\nret double %5\n}": {"base_truth": "define dso_local nofpclass(nan inf) double @asec(double noundef nofpclass(nan inf) %0) {\nB:\n%1 = fdiv fast double 1.000000e+00, %0\n%2 = tail call fast nofpclass(nan inf) double @acos(double noundef nofpclass(nan inf) %1)\nret double %2\n}", "codellama": "define dso_local nofpclass(nan inf) double @asec(double noundef nofpclass(nan inf) %0) {\nB:\n%1 = fdiv fast double 1.000000e+00, %0\n%2 = tail call fast nofpclass(nan inf) double @acos(double noundef nofpclass(nan inf) %1)\nret double %2\n}", "codegemma": "define dso_local nofpclass(nan inf) double @asec(double noundef nofpclass(nan inf) %0) {\nB:\n%1 = fdiv fast double 1.000000e+00, %0\n%2 = tail call fast nofpclass(nan inf) double @acos(double noundef nofpclass(nan inf) %1)\nret double %2\n}"}, "define internal i64 @stm32_hash_read(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.stm32_hash_dev ptr %5, i32 0, i32 0\n%7 = load i64, ptr %6, align 8\n%8 = load i64, ptr %4, align 8\n%9 = add nsw i64 %7, %8\n%10 = call i64 @readl_relaxed(i64 noundef %9)\nret i64 %10\n}": {"base_truth": "define internal i64 @stm32_hash_read(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = add nsw i64 %2, %1\n%4 = tail call i64 @readl_relaxed(i64 noundef %3)\nret i64 %4\n}", "codellama": "define internal i64 @stm32_hash_read(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = add nsw i64 %2, %1\n%4 = tail call i64 @readl_relaxed(i64 noundef %3)\nret i64 %4\n}", "codegemma": "define internal i64 @stm32_hash_read(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = add nsw i64 %2, %1\n%4 = tail call i64 @readl_relaxed(i64 noundef %3)\nret i64 %4\n}"}, "define dso_local void @_Locale_messages_destroy(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @_Locale_messages_destroy(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @_Locale_messages_destroy(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @_Locale_messages_destroy(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define internal ptr @alloc_commit_graph() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call ptr @xcalloc(i32 noundef 1, i32 noundef 4)\nstore ptr %2, ptr %1, align 8\n%3 = load ptr, ptr %1, align 8\n%4 = getelementptr inbounds %struct.commit_graph ptr %3, i32 0, i32 0\nstore i32 -1, ptr %4, align 4\n%5 = load ptr, ptr %1, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret ptr %5\n}": {"base_truth": "define internal ptr @alloc_commit_graph() {\nB:\n%0 = tail call ptr @xcalloc(i32 noundef 1, i32 noundef 4)\nstore i32 -1, ptr %0, align 4\nret ptr %0\n}", "codellama": "define internal ptr @alloc_commit_graph() {\nB:\n%0 = tail call ptr @xcalloc(i32 noundef 1, i32 noundef 4)\nstore i32 -1, ptr %0, align 4\nret ptr %0\n}", "codegemma": "define internal ptr @alloc_commit_graph() {\nB:\n%0 = tail call ptr @xcalloc(i32 noundef 1, i32 noundef 4)\nstore i32 -1, ptr %0, align 4\nret ptr %0\n}"}, "define internal i32 @InvalidCall(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @DPRINT1(ptr noundef @.str, i32 noundef %5)\n%7 = call i32 (...) @UNLOCK_D3DDEVICE9()\n%8 = load i32, ptr @D3DERR_INVALIDCALL, align 4\nret i32 %8\n}": {"base_truth": "define internal i32 @InvalidCall(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @DPRINT1(ptr noundef nonnull @.str, i32 noundef %1)\n%3 = tail call i32 (...) @UNLOCK_D3DDEVICE9()\n%4 = load i32, ptr @D3DERR_INVALIDCALL, align 4\nret i32 %4\n}", "codellama": "define internal i32 @InvalidCall(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @DPRINT1(ptr noundef nonnull @.str, i32 noundef %1)\n%3 = tail call i32 (...) @UNLOCK_D3DDEVICE9()\n%4 = load i32, ptr @D3DERR_INVALIDCALL, align 4\nret i32 %4\n}", "codegemma": "define internal i32 @InvalidCall(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @DPRINT1(ptr noundef nonnull @.str, i32 noundef %1)\n%3 = tail call i32 (...) @UNLOCK_D3DDEVICE9()\n%4 = load i32, ptr @D3DERR_INVALIDCALL, align 4\nret i32 %4\n}"}, "define dso_local i32 @benchmark() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = load i32, ptr @a, align 4\n%3 = call i32 @fib(i32 noundef %2)\nstore i32 %3, ptr %1, align 4\n%4 = load i32, ptr %1, align 4\n%5 = call i32 @verify_benchmark(i32 noundef %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret i32 %5\n}": {"base_truth": "define dso_local i32 @benchmark() {\nB:\n%0 = load i32, ptr @a, align 4\n%1 = tail call i32 @fib(i32 noundef %0)\n%2 = tail call i32 @verify_benchmark(i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @benchmark() {\nB:\n%0 = load i32, ptr @a, align 4\n%1 = tail call i32 @fib(i32 noundef %0)\n%2 = tail call i32 @verify_benchmark(i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @benchmark() {\nB:\n%0 = load i32, ptr @a, align 4\n%1 = tail call i32 @fib(i32 noundef %0)\n%2 = tail call i32 @verify_benchmark(i32 noundef %1)\nret i32 %2\n}"}, "define dso_local i32 @AXICAT_AL_OW_Xfr_Cancel(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr %3, align 8\n%6 = ptrtoint ptr %5 to i64\n%7 = sub i64 %6, 0\n%8 = sdiv exact i64 %7, 4\n%9 = inttoptr i64 %8 to ptr\nstore ptr %9, ptr %4, align 8\n%10 = load ptr, ptr %4, align 8\n%11 = call i32 @OW_Xfr_Cancel(ptr noundef %10)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\n%12 = load i32, ptr %2, align 4\nret i32 %12\n}": {"base_truth": "define dso_local i32 @AXICAT_AL_OW_Xfr_Cancel(ptr noundef %0) {\nB:\n%1 = ptrtoint ptr %0 to i64\n%2 = ashr exact i64 %1, 2\n%3 = inttoptr i64 %2 to ptr\n%4 = tail call i32 @OW_Xfr_Cancel(ptr noundef %3)\nret i32 undef\n}", "codellama": "define dso_local i32 @AXICAT_AL_OW_Xfr_Cancel(ptr noundef %0) {\nB:\n%1 = ptrtoint ptr %0 to i64\n%2 = ashr exact i64 %1, 2\n%3 = inttoptr i64 %2 to ptr\n%4 = tail call i32 @OW_Xfr_Cancel(ptr noundef %3)\nret i32 undef\n}", "codegemma": "define dso_local i32 @AXICAT_AL_OW_Xfr_Cancel(ptr noundef %0) {\nB:\n%1 = ptrtoint ptr %0 to i64\n%2 = add i64 %1, 0\n%3 = sdiv exact i64 %2, 4\n%4 = inttoptr i64 %3 to ptr\n%5 = tail call i32 @OW_Xfr_Cancel(ptr noundef %4)\nret i32 undef\n}"}, "define dso_local ptr @mpg123_new(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call ptr @mpg123_parnew(ptr noundef null, ptr noundef %3)\nret ptr %4\n}": {"base_truth": "define dso_local ptr @mpg123_new(ptr noundef %0) {\nB:\n%1 = tail call ptr @mpg123_parnew(ptr noundef null, ptr noundef %0)\nret ptr %1\n}", "codellama": "define dso_local ptr @mpg123_new(ptr noundef %0) {\nB:\n%1 = tail call ptr @mpg123_parnew(ptr noundef null, ptr noundef %0)\nret ptr %1\n}", "codegemma": "define dso_local ptr @mpg123_new(ptr noundef %0) {\nB:\n%1 = tail call ptr @mpg123_parnew(ptr noundef null, ptr noundef %0)\nret ptr %1\n}"}, "define internal void @inc_ap_pending(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.drbd_device ptr %3, i32 0, i32 0\n%5 = call i32 @atomic_inc(ptr noundef %4)\nret void\n}": {"base_truth": "define internal void @inc_ap_pending(ptr noundef %0) {\nB:\n%1 = tail call i32 @atomic_inc(ptr noundef %0)\nret void\n}", "codellama": "define internal void @inc_ap_pending(ptr noundef %0) {\nB:\n%1 = tail call i32 @atomic_inc(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @inc_ap_pending(ptr noundef %0) {\nB:\n%1 = tail call i32 @atomic_inc(ptr noundef %0)\nret void\n}"}, "define dso_local void @caml_gr_fill_poly() {\n%1 = call i32 @exit(i32 noundef 1)\nunreachable\n}": {"base_truth": "define dso_local void @caml_gr_fill_poly() {\nB:\n%0 = tail call i32 @exit(i32 noundef 1)\nunreachable\n}", "codellama": "define dso_local void @caml_gr_fill_poly() {\nB:\n%0 = tail call i32 @exit(i32 noundef 1)\nunreachable\n}", "codegemma": "define dso_local void @caml_gr_fill_poly() {\nB:\n%0 = tail call i32 @exit(i32 noundef 1)\nunreachable\n}"}, "define dso_local void @glProgramUniform1i(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore i32 %0, ptr %4, align 4\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load i32, ptr @NFOSMESA_GLPROGRAMUNIFORM1I, align 4\n%8 = load i32, ptr @cur_context, align 4\n%9 = call i32 @HostCall_p(i32 noundef %7, i32 noundef %8, ptr noundef %4)\nret void\n}": {"base_truth": "define dso_local void @glProgramUniform1i(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr @NFOSMESA_GLPROGRAMUNIFORM1I, align 4\n%5 = load i32, ptr @cur_context, align 4\n%6 = call i32 @HostCall_p(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %3)\nret void\n}", "codellama": "define dso_local void @glProgramUniform1i(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr @NFOSMESA_GLPROGRAMUNIFORM1I, align 4\n%5 = load i32, ptr @cur_context, align 4\n%6 = call i32 @HostCall_p(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %3)\nret void\n}", "codegemma": "define dso_local void @glProgramUniform1i(i32 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr @NFOSMESA_GLPROGRAMUNIFORM1I, align 4\n%5 = load i32, ptr @cur_context, align 4\n%6 = call i32 @HostCall_p(i32 noundef %4, i32 noundef %5, ptr noundef nonnull %3)\nret void\n}"}, "define dso_local void @and_eax_imm32(i64 noundef %0) {\n%2 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\n%3 = call i32 @put8(i32 noundef 37)\n%4 = load i64, ptr %2, align 8\n%5 = call i32 @put32(i64 noundef %4)\nret void\n}": {"base_truth": "define dso_local void @and_eax_imm32(i64 noundef %0) {\nB:\n%1 = tail call i32 @put8(i32 noundef 37)\n%2 = tail call i32 @put32(i64 noundef %0)\nret void\n}", "codellama": "define dso_local void @and_eax_imm32(i64 noundef %0) {\nB:\n%1 = tail call i32 @put8(i32 noundef 37)\n%2 = tail call i32 @put32(i64 noundef %0)\nret void\n}", "codegemma": "define dso_local void @and_eax_imm32(i64 noundef %0) {\nB:\n%1 = tail call i32 @put8(i32 noundef 37)\n%2 = tail call i32 @put32(i64 noundef %0)\nret void\n}"}, "define dso_local ptr @message_get_body(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load ptr, ptr %4, align 8\nret ptr %5\n}": {"base_truth": "define dso_local ptr @message_get_body(ptr nocapture noundef readonly %0) {\nB:\n%1 = load ptr, ptr %0, align 8\nret ptr %1\n}", "codellama": "define dso_local ptr @message_get_body(ptr nocapture noundef readonly %0) {\nB:\n%1 = load ptr, ptr %0, align 8\nret ptr %1\n}", "codegemma": "define dso_local ptr @message_get_body(ptr nocapture noundef readonly %0) {\nB:\n%1 = load ptr, ptr %0, align 8\nret ptr %1\n}"}, "define dso_local i32 @gseq_to_gse(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca double, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore double %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load double, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr %6, align 4\n%10 = load i32, ptr @BACK, align 4\n%11 = call i32 @gse_twixt_gseq(double noundef nofpclass(nan inf) %7, i32 noundef %8, i32 noundef %9, i32 noundef %10)\nret i32 %11\n}": {"base_truth": "define dso_local i32 @gseq_to_gse(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @BACK, align 4\n%4 = tail call i32 @gse_twixt_gseq(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2, i32 noundef %3)\nret i32 %4\n}", "codellama": "define dso_local i32 @gseq_to_gse(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @BACK, align 4\n%4 = tail call i32 @gse_twixt_gseq(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2, i32 noundef %3)\nret i32 %4\n}", "codegemma": "define dso_local i32 @gseq_to_gse(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @BACK, align 4\n%4 = tail call i32 @gse_twixt_gseq(double noundef nofpclass(nan inf) %0, i32 noundef %1, i32 noundef %2, i32 noundef %3)\nret i32 %4\n}"}, "define dso_local i32 @NoUiDrawStatusText(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = call i32 @printf(ptr noundef @.str, ptr noundef %4)\n%6 = load i32, ptr %2, align 4\nret i32 %6\n}": {"base_truth": "define dso_local i32 @NoUiDrawStatusText(ptr noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret i32 undef\n}", "codellama": "define dso_local i32 @NoUiDrawStatusText(ptr noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret i32 undef\n}", "codegemma": "define dso_local i32 @NoUiDrawStatusText(ptr noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\nret i32 undef\n}"}, "define internal i32 @exp_proc_init(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret i32 0\n}": {"base_truth": "define internal i32 @exp_proc_init(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}", "codellama": "define internal i32 @exp_proc_init(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}", "codegemma": "define internal i32 @exp_proc_init(ptr nocapture noundef readnone %0) {\nB:\nret i32 0\n}"}, "define dso_local i32 @frag_now_fix() {\n%1 = call i32 (...) @frag_now_fix_octets()\n%2 = load i32, ptr @OCTETS_PER_BYTE, align 4\n%3 = sdiv i32 %1, %2\nret i32 %3\n}": {"base_truth": "define dso_local i32 @frag_now_fix() {\nB:\n%0 = tail call i32 (...) @frag_now_fix_octets()\n%1 = load i32, ptr @OCTETS_PER_BYTE, align 4\n%2 = sdiv i32 %0, %1\nret i32 %2\n}", "codellama": "define dso_local i32 @frag_now_fix() {\nB:\n%0 = tail call i32 (...) @frag_now_fix_octets()\n%1 = load i32, ptr @OCTETS_PER_BYTE, align 4\n%2 = sdiv i32 %0, %1\nret i32 %2\n}", "codegemma": "define dso_local i32 @frag_now_fix() {\nB:\n%0 = tail call i32 (...) @frag_now_fix_octets()\n%1 = load i32, ptr @OCTETS_PER_BYTE, align 4\n%2 = sdiv i32 %0, %1\nret i32 %2\n}"}, "define dso_local i32 @dup2(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @syscall_dup2(i32 noundef %5, i32 noundef %6)\nret i32 %7\n}": {"base_truth": "define dso_local i32 @dup2(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @syscall_dup2(i32 noundef %0, i32 noundef %1)\nret i32 %2\n}", "codellama": "define dso_local i32 @dup2(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @syscall_dup2(i32 noundef %0, i32 noundef %1)\nret i32 %2\n}", "codegemma": "define dso_local i32 @dup2(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @syscall_dup2(i32 noundef %0, i32 noundef %1)\nret i32 %2\n}"}, "define dso_local void @rgb_matrix_decrease_val() {\n%1 = load i32, ptr @rgb_matrix_config, align 4\n%2 = load i32, ptr @RGB_MATRIX_VAL_STEP, align 4\n%3 = call i32 @qsub8(i32 noundef %1, i32 noundef %2)\nstore i32 %3, ptr @rgb_matrix_config, align 4\n%4 = call i32 (...) @eeconfig_update_rgb_matrix()\nret void\n}": {"base_truth": "define dso_local void @rgb_matrix_decrease_val() {\nB:\n%0 = load i32, ptr @rgb_matrix_config, align 4\n%1 = load i32, ptr @RGB_MATRIX_VAL_STEP, align 4\n%2 = tail call i32 @qsub8(i32 noundef %0, i32 noundef %1)\nstore i32 %2, ptr @rgb_matrix_config, align 4\n%3 = tail call i32 (...) @eeconfig_update_rgb_matrix()\nret void\n}", "codellama": "define dso_local void @rgb_matrix_decrease_val() {\nB:\n%0 = load i32, ptr @rgb_matrix_config, align 4\n%1 = load i32, ptr @RGB_MATRIX_VAL_STEP, align 4\n%2 = tail call i32 @qsub8(i32 noundef %0, i32 noundef %1)\nstore i32 %2, ptr @rgb_matrix_config, align 4\n%3 = tail call i32 (...) @eeconfig_update_rgb_matrix()\nret void\n}", "codegemma": "define dso_local void @rgb_matrix_decrease_val() {\nB:\n%0 = load i32, ptr @rgb_matrix_config, align 4\n%1 = load i32, ptr @RGB_MATRIX_VAL_STEP, align 4\n%2 = tail call i32 @qsub8(i32 noundef %0, i32 noundef %1)\nstore i32 %2, ptr @rgb_matrix_config, align 4\n%3 = tail call i32 (...) @eeconfig_update_rgb_matrix()\nret void\n}"}, "define dso_local i32 @util_privilege_ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca i64, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\nstore i64 %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%8 = load i32, ptr @runner_uid, align 4\n%9 = load i32, ptr @owner_uid, align 4\n%10 = call i32 @setreuid(i32 noundef %8, i32 noundef %9)\n%11 = load i64, ptr %4, align 8\n%12 = load i32, ptr %5, align 4\n%13 = load i32, ptr %6, align 4\n%14 = call i32 @ioperm(i64 noundef %11, i32 noundef %12, i32 noundef %13)\nstore i32 %14, ptr %7, align 4\n%15 = load i32, ptr @owner_uid, align 4\n%16 = load i32, ptr @runner_uid, align 4\n%17 = call i32 @setreuid(i32 noundef %15, i32 noundef %16)\n%18 = load i32, ptr %7, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\nret i32 %18\n}": {"base_truth": "define dso_local i32 @util_privilege_ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @runner_uid, align 4\n%4 = load i32, ptr @owner_uid, align 4\n%5 = tail call i32 @setreuid(i32 noundef %3, i32 noundef %4)\n%6 = tail call i32 @ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2)\n%7 = load i32, ptr @owner_uid, align 4\n%8 = load i32, ptr @runner_uid, align 4\n%9 = tail call i32 @setreuid(i32 noundef %7, i32 noundef %8)\nret i32 %6\n}", "codellama": "define dso_local i32 @util_privilege_ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @runner_uid, align 4\n%4 = load i32, ptr @owner_uid, align 4\n%5 = tail call i32 @setreuid(i32 noundef %3, i32 noundef %4)\n%6 = tail call i32 @ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2)\n%7 = load i32, ptr @owner_uid, align 4\n%8 = load i32, ptr @runner_uid, align 4\n%9 = tail call i32 @setreuid(i32 noundef %7, i32 noundef %8)\nret i32 %6\n}", "codegemma": "define dso_local i32 @util_privilege_ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = load i32, ptr @runner_uid, align 4\n%4 = load i32, ptr @owner_uid, align 4\n%5 = tail call i32 @setreuid(i32 noundef %3, i32 noundef %4)\n%6 = tail call i32 @ioperm(i64 noundef %0, i32 noundef %1, i32 noundef %2)\n%7 = load i32, ptr @owner_uid, align 4\n%8 = load i32, ptr @runner_uid, align 4\n%9 = tail call i32 @setreuid(i32 noundef %7, i32 noundef %8)\nret i32 %6\n}"}, "define dso_local i32 @Script_Team_GetMembers(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load ptr, ptr @g_scriptCurrentTeam, align 8\n%5 = getelementptr inbounds %struct.TYPE_2__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\nret i32 %6\n}": {"base_truth": "define dso_local i32 @Script_Team_GetMembers(ptr nocapture noundef readnone %0) {\nB:\n%1 = load ptr, ptr @g_scriptCurrentTeam, align 8\n%2 = load i32, ptr %1, align 4\nret i32 %2\n}", "codellama": "define dso_local i32 @Script_Team_GetMembers(ptr nocapture noundef readnone %0) {\nB:\n%1 = load ptr, ptr @g_scriptCurrentTeam, align 8\n%2 = load i32, ptr %1, align 4\nret i32 %2\n}", "codegemma": "define dso_local i32 @Script_Team_GetMembers(ptr nocapture noundef readnone %0) {\nB:\n%1 = load ptr, ptr @g_scriptCurrentTeam, align 8\n%2 = load i32, ptr %1, align 4\nret i32 %2\n}"}, "define dso_local ptr @findref2(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @findref(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = icmp ne ptr %6, null\nbr i1 %7, label %8, label %10\n\n8:\n%9 = load ptr, ptr %3, align 8\nbr label %12\n\n10:\n%11 = load ptr, ptr %2, align 8\nbr label %12\n\n12:\n%13 = phi ptr [ %9, %8 ], [ %11, %10 ]\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %13\n}": {"base_truth": "define dso_local ptr @findref2(ptr noundef %0) {\nB:\n%1 = tail call ptr @findref(ptr noundef %0)\n%2 = icmp eq ptr %1, null\n%3 = select i1 %2, ptr %0, ptr %1\nret ptr %3\n}", "codellama": "define dso_local ptr @findref2(ptr noundef %0) {\nB:\n%1 = tail call ptr @findref(ptr noundef %0)\n%2 = icmp eq ptr %1, null\n%3 = select i1 %2, ptr %0, ptr %1\nret ptr %3\n}", "codegemma": "define dso_local ptr @findref2(ptr noundef %0) {\nB:\n%1 = tail call ptr @findref(ptr noundef %0)\n%2 = icmp eq ptr %1, null\n%3 = select i1 %2, ptr %0, ptr %1\nret ptr %3\n}"}, "define dso_local i32 @main() {\n%1 = alloca [40 x i8], align 16\n%2 = alloca [8 x i8], align 1\n%3 = alloca [38 x i8], align 16\n%4 = alloca [2 x i8], align 1\ncall void @llvm.lifetime.start.p0(i64 40, ptr %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 16 %1, ptr align 16 @__const.main.str1, i64 40, i1 false)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 1 @__const.main.str2, i64 8, i1 false)\n%5 = getelementptr inbounds [40 x i8], ptr %1, i64 0, i64 0\n%6 = getelementptr inbounds [8 x i8], ptr %2, i64 0, i64 0\n%7 = call i32 @strsearch(ptr noundef %5, ptr noundef %6)\ncall void @llvm.lifetime.start.p0(i64 38, ptr %3)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 16 %3, ptr align 16 @__const.main.str3, i64 38, i1 false)\ncall void @llvm.lifetime.start.p0(i64 2, ptr %4)\ncall void @llvm.memcpy.p0.p0.i64(ptr align 1 %4, ptr align 1 @__const.main.str4, i64 2, i1 false)\n%8 = getelementptr inbounds [38 x i8], ptr %3, i64 0, i64 0\n%9 = getelementptr inbounds [2 x i8], ptr %4, i64 0, i64 0\n%10 = call i32 @strsearch(ptr noundef %8, ptr noundef %9)\ncall void @llvm.lifetime.end.p0(i64 2, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 38, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 40, ptr %1)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = alloca [40 x i8], align 16\n%1 = alloca [8 x i8], align 8\n%2 = alloca [38 x i8], align 16\n%3 = alloca [2 x i8], align 2\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(40) %0, ptr noundef nonnull align 16 dereferenceable(40) @__const.main.str1, i64 40, i1 false)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %1)\nstore i64 27412342654460513, ptr %1, align 8\n%4 = call i32 @strsearch(ptr noundef nonnull %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 38, ptr nonnull %2)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(38) %2, ptr noundef nonnull align 16 dereferenceable(38) @__const.main.str3, i64 38, i1 false)\ncall void @llvm.lifetime.start.p0(i64 2, ptr nonnull %3)\nstore i16 44, ptr %3, align 2\n%5 = call i32 @strsearch(ptr noundef nonnull %2, ptr noundef nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 2, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 38, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = alloca [40 x i8], align 16\n%1 = alloca [8 x i8], align 8\n%2 = alloca [38 x i8], align 16\n%3 = alloca [2 x i8], align 2\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(40) %0, ptr noundef nonnull align 16 dereferenceable(40) @__const.main.str1, i64 40, i1 false)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %1)\nstore i64 12884901890, ptr %1, align 8\n%4 = call i32 @strsearch(ptr noundef nonnull %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 38, ptr nonnull %2)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(38) %2, ptr noundef nonnull align 16 dereferenceable(38) @__const.main.str3, i64 38, i1 false)\ncall void @llvm.lifetime.start.p0(i64 2, ptr nonnull %3)\nstore i16 104, ptr %3, align 2\n%5 = call i32 @strsearch(ptr noundef nonnull %2, ptr noundef nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 2, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 38, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = alloca [40 x i8], align 16\n%1 = alloca [8 x i8], align 8\n%2 = alloca [38 x i8], align 16\n%3 = alloca [2 x i8], align 2\ncall void @llvm.lifetime.start.p0(i64 40, ptr nonnull %0)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(40) %0, ptr noundef nonnull align 16 dereferenceable(40) @__const.main.str1, i64 40, i1 false)\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %1)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(8) %1, ptr noundef nonnull align 8 dereferenceable(8) @__const.main.str2, i64 8, i1 false)\n%4 = call i32 @strsearch(ptr noundef nonnull %0, ptr noundef nonnull %1)\ncall void @llvm.lifetime.start.p0(i64 38, ptr nonnull %2)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(38) %2, ptr noundef nonnull align 16 dereferenceable(38) @__const.main.str3, i64 38, i1 false)\ncall void @llvm.lifetime.start.p0(i64 2, ptr nonnull %3)\ncall void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 2 dereferenceable(2) %3, ptr noundef nonnull align 2 dereferenceable(2) @__const.main.str4, i64 2, i1 false)\n%5 = call i32 @strsearch(ptr noundef nonnull %2, ptr noundef nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 2, ptr nonnull %3)\ncall void @llvm.lifetime.end.p0(i64 38, ptr nonnull %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 40, ptr nonnull %0)\nret i32 0\n}"}, "define internal ptr @nbdcmd_to_ascii(i32 noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\nswitch i32 %4, label %10 [\ni32 130, label %5\ni32 128, label %6\ni32 132, label %7\ni32 131, label %8\ni32 129, label %9\n]\n\n5:\nstore ptr @.str, ptr %2, align 8\nbr label %11\n\n6:\nstore ptr @.str.1, ptr %2, align 8\nbr label %11\n\n7:\nstore ptr @.str.2, ptr %2, align 8\nbr label %11\n\n8:\nstore ptr @.str.3, ptr %2, align 8\nbr label %11\n\n9:\nstore ptr @.str.4, ptr %2, align 8\nbr label %11\n\n10:\nstore ptr @.str.5, ptr %2, align 8\nbr label %11\n\n11:\n%12 = load ptr, ptr %2, align 8\nret ptr %12\n}": {"base_truth": "define internal nonnull ptr @nbdcmd_to_ascii(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 5\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [5 x ptr], ptr @switch.table.nbdcmd_to_ascii, i64 0, i64 %3\n%5 = load ptr, ptr %4, align 8\nbr label %B2\n\nB2:\n%6 = phi ptr [ %5, %B1 ], [ @.str.5, %B ]\nret ptr %6\n}", "codellama": "define internal nonnull ptr @nbdcmd_to_ascii(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 5\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [5 x ptr], ptr @switch.table.nbdcmd_to_ascii, i64 0, i64 %3\n%5 = load ptr, ptr %4, align 8\nbr label %B2\n\nB2:\n%6 = phi ptr [ %5, %B1 ], [ @.str.5, %B ]\nret ptr %6\n}", "codegemma": "define internal nonnull ptr @nbdcmd_to_ascii(i32 noundef %0) {\nB:\n%1 = add i32 %0, -128\n%2 = icmp ult i32 %1, 5\nbr i1 %2, label %B1, label %B2\n\nB1:\n%3 = sext i32 %1 to i64\n%4 = getelementptr inbounds [5 x ptr], ptr @switch.table.nbdcmd_to_ascii, i64 0, i64 %3\n%5 = load ptr, ptr %4, align 8\nbr label %B2\n\nB2:\n%6 = phi ptr [ %5, %B1 ], [ @.str.5, %B ]\nret ptr %6\n}"}, "define internal i32 @da9052_ts_input_open(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @input_get_drvdata(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.da9052_tsi ptr %6, i32 0, i32 0\nstore i32 0, ptr %7, align 4\n%8 = call i32 (...) @mb()\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.da9052_tsi ptr %9, i32 0, i32 1\n%11 = load i32, ptr %10, align 4\n%12 = load i32, ptr @DA9052_IRQ_PENDOWN, align 4\n%13 = call i32 @da9052_enable_irq(i32 noundef %11, i32 noundef %12)\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.da9052_tsi ptr %14, i32 0, i32 1\n%16 = load i32, ptr %15, align 4\n%17 = load i32, ptr @DA9052_TSI_CONT_A_REG, align 4\n%18 = call i32 @da9052_reg_update(i32 noundef %16, i32 noundef %17, i32 noundef 2, i32 noundef 2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %18\n}": {"base_truth": "define internal i32 @da9052_ts_input_open(ptr noundef %0) {\nB:\n%1 = tail call ptr @input_get_drvdata(ptr noundef %0)\nstore i32 0, ptr %1, align 4\n%2 = tail call i32 (...) @mb()\n%3 = getelementptr inbounds %struct.da9052_tsi, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @DA9052_IRQ_PENDOWN, align 4\n%6 = tail call i32 @da9052_enable_irq(i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @DA9052_TSI_CONT_A_REG, align 4\n%9 = tail call i32 @da9052_reg_update(i32 noundef %7, i32 noundef %8, i32 noundef 2, i32 noundef 2)\nret i32 %9\n}", "codellama": "define internal i32 @da9052_ts_input_open(ptr noundef %0) {\nB:\n%1 = tail call ptr @input_get_drvdata(ptr noundef %0)\nstore i32 0, ptr %1, align 4\n%2 = tail call i32 (...) @mb()\n%3 = getelementptr inbounds %struct.da9052_tsi, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @DA9052_IRQ_PENDOWN, align 4\n%6 = tail call i32 @da9052_enable_irq(i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @DA9052_TSI_CONT_A_REG, align 4\n%9 = tail call i32 @da9052_reg_update(i32 noundef %7, i32 noundef %8, i32 noundef 2, i32 noundef 2)\nret i32 %9\n}", "codegemma": "define internal i32 @da9052_ts_input_open(ptr noundef %0) {\nB:\n%1 = tail call ptr @input_get_drvdata(ptr noundef %0)\nstore i32 0, ptr %1, align 4\n%2 = tail call i32 (...) @mb()\n%3 = getelementptr inbounds %struct.da9052_tsi, ptr %1, i64 0, i32 1\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @DA9052_IRQ_PENDOWN, align 4\n%6 = tail call i32 @da9052_enable_irq(i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @DA9052_TSI_CONT_A_REG, align 4\n%9 = tail call i32 @da9052_reg_update(i32 noundef %7, i32 noundef %8, i32 noundef 2, i32 noundef 2)\nret i32 %9\n}"}, "define dso_local i32 @dump() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\nstore ptr @__start_my_section, ptr %1, align 8\n%2 = load ptr, ptr %1, align 8\n%3 = getelementptr inbounds i32, ptr %2, i64 0\n%4 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 %4\n}": {"base_truth": "define dso_local i32 @dump() {\nB:\n%0 = load i32, ptr @__start_my_section, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @dump() {\nB:\n%0 = load i32, ptr @__start_my_section, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @dump() {\nB:\n%0 = load i32, ptr @__start_my_section, align 4\nret i32 %0\n}"}, "define dso_local void @bcma_driver_unregister(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.bcma_driver ptr %3, i32 0, i32 0\n%5 = call i32 @driver_unregister(ptr noundef %4)\nret void\n}": {"base_truth": "define dso_local void @bcma_driver_unregister(ptr noundef %0) {\nB:\n%1 = tail call i32 @driver_unregister(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @bcma_driver_unregister(ptr noundef %0) {\nB:\n%1 = tail call i32 @driver_unregister(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @bcma_driver_unregister(ptr noundef %0) {\nB:\n%1 = tail call i32 @driver_unregister(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @main() {\n%1 = call i32 @f(i64 noundef 3)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @f(i64 noundef 3)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @f(i64 noundef 3)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @f(i64 noundef 3)\nret i32 0\n}"}, "define dso_local void @dw_hdmi_phy_gen2_pddq(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr %4, align 4\n%7 = load i32, ptr @HDMI_PHY_CONF0, align 4\n%8 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET, align 4\n%9 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_MASK, align 4\n%10 = call i32 @hdmi_mask_writeb(ptr noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)\nret void\n}": {"base_truth": "define dso_local void @dw_hdmi_phy_gen2_pddq(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @HDMI_PHY_CONF0, align 4\n%3 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET, align 4\n%4 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_MASK, align 4\n%5 = tail call i32 @hdmi_mask_writeb(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4)\nret void\n}", "codellama": "define dso_local void @dw_hdmi_phy_gen2_pddq(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @HDMI_PHY_CONF0, align 4\n%3 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET, align 4\n%4 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_MASK, align 4\n%5 = tail call i32 @hdmi_mask_writeb(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4)\nret void\n}", "codegemma": "define dso_local void @dw_hdmi_phy_gen2_pddq(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @HDMI_PHY_CONF0, align 4\n%3 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET, align 4\n%4 = load i32, ptr @HDMI_PHY_CONF0_GEN2_PDDQ_MASK, align 4\n%5 = tail call i32 @hdmi_mask_writeb(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4)\nret void\n}"}, "define dso_local ptr @dsl_deadlist_last(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i32 0, i32 0\n%6 = call i32 @mutex_enter(ptr noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @dsl_deadlist_load_tree(ptr noundef %7)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.TYPE_4__, ptr %9, i32 0, i32 1\n%11 = call ptr @avl_last(ptr noundef %10)\nstore ptr %11, ptr %3, align 8\n%12 = load ptr, ptr %2, align 8\n%13 = getelementptr inbounds %struct.TYPE_4__, ptr %12, i32 0, i32 0\n%14 = call i32 @mutex_exit(ptr noundef %13)\n%15 = load ptr, ptr %3, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret ptr %15\n}": {"base_truth": "define dso_local ptr @dsl_deadlist_last(ptr noundef %0) {\nB:\n%1 = tail call i32 @mutex_enter(ptr noundef %0)\n%2 = tail call i32 @dsl_deadlist_load_tree(ptr noundef %0)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%4 = tail call ptr @avl_last(ptr noundef nonnull %3)\n%5 = tail call i32 @mutex_exit(ptr noundef %0)\nret ptr %4\n}", "codellama": "define dso_local ptr @dsl_deadlist_last(ptr noundef %0) {\nB:\n%1 = tail call i32 @mutex_enter(ptr noundef %0)\n%2 = tail call i32 @dsl_deadlist_load_tree(ptr noundef %0)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%4 = tail call ptr @avl_last(ptr noundef nonnull %3)\n%5 = tail call i32 @mutex_exit(ptr noundef %0)\nret ptr %4\n}", "codegemma": "define dso_local ptr @dsl_deadlist_last(ptr noundef %0) {\nB:\n%1 = tail call i32 @mutex_enter(ptr noundef %0)\n%2 = tail call i32 @dsl_deadlist_load_tree(ptr noundef %0)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%4 = tail call ptr @avl_last(ptr noundef nonnull %3)\n%5 = tail call i32 @mutex_exit(ptr noundef %0)\nret ptr %4\n}"}, "define dso_local i32 @copy_start_solutions_to_container() {\n%1 = alloca ptr, align 8\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%5 = load ptr, ptr %1, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = call i32 @_ada_use_c2phc(i32 noundef 7, ptr noundef %5, ptr noundef %6, ptr noundef %7, i32 noundef 0)\nstore i32 %8, ptr %3, align 4\n%9 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 %9\n}": {"base_truth": "define dso_local i32 @copy_start_solutions_to_container() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 7, ptr noundef undef, ptr noundef undef, ptr noundef undef, i32 noundef 0)\nret i32 %0\n}", "codellama": "define dso_local i32 @copy_start_solutions_to_container() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 7, ptr noundef undef, ptr noundef undef, ptr noundef undef, i32 noundef 0)\nret i32 %0\n}", "codegemma": "define dso_local i32 @copy_start_solutions_to_container() {\nB:\n%0 = tail call i32 @_ada_use_c2phc(i32 noundef 7, ptr noundef undef, ptr noundef undef, ptr noundef undef, i32 noundef 0)\nret i32 %0\n}"}, "define dso_local i32 @mySHA512_Size() {\nret i32 4\n}": {"base_truth": "define dso_local i32 @mySHA512_Size() {\nB:\nret i32 4\n}", "codellama": "define dso_local i32 @mySHA512_Size() {\nB:\nret i32 4\n}", "codegemma": "define dso_local i32 @mySHA512_Size() {\nB:\nret i32 4\n}"}, "define internal void @enet_dma_writel(ptr noundef %0, i64 noundef %1, i64 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca i64, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore i64 %2, ptr %6, align 8\n%7 = load i64, ptr %5, align 8\n%8 = load ptr, ptr @bcm_enet_shared_base, align 8\n%9 = getelementptr inbounds i64, ptr %8, i64 0\n%10 = load i64, ptr %9, align 8\n%11 = load i64, ptr %6, align 8\n%12 = add nsw i64 %10, %11\n%13 = call i32 @bcm_writel(i64 noundef %7, i64 noundef %12)\nret void\n}": {"base_truth": "define internal void @enet_dma_writel(ptr nocapture noundef readnone %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = load ptr, ptr @bcm_enet_shared_base, align 8\n%4 = load i64, ptr %3, align 8\n%5 = add nsw i64 %4, %2\n%6 = tail call i32 @bcm_writel(i64 noundef %1, i64 noundef %5)\nret void\n}", "codellama": "define internal void @enet_dma_writel(ptr nocapture noundef readnone %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = load ptr, ptr @bcm_enet_shared_base, align 8\n%4 = load i64, ptr %3, align 8\n%5 = add nsw i64 %4, %2\n%6 = tail call i32 @bcm_writel(i64 noundef %1, i64 noundef %5)\nret void\n}", "codegemma": "define internal void @enet_dma_writel(ptr nocapture noundef readnone %0, i64 noundef %1, i64 noundef %2) {\nB:\n%3 = load ptr, ptr @bcm_enet_shared_base, align 8\n%4 = load i64, ptr %3, align 8\n%5 = add nsw i64 %4, %2\n%6 = tail call i32 @bcm_writel(i64 noundef %1, i64 noundef %5)\nret void\n}"}, "define dso_local signext i16 @VIRTUAL_hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\n%5 = alloca i16, align 2\n%6 = alloca i16, align 2\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 2, ptr %5)\ncall void @llvm.lifetime.start.p0(i64 2, ptr %6)\n%7 = load ptr, ptr %3, align 8\n%8 = load ptr, ptr %4, align 8\n%9 = call signext i16 @hash_collection__HashSet__has(ptr noundef %7, ptr noundef %8)\nstore i16 %9, ptr %6, align 2\n%10 = load i16, ptr %6, align 2\nstore i16 %10, ptr %5, align 2\nbr label %11\n\n11:\n%12 = load i16, ptr %5, align 2\ncall void @llvm.lifetime.end.p0(i64 2, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 2, ptr %5)\nret i16 %12\n}": {"base_truth": "define dso_local signext i16 @VIRTUAL_hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call signext i16 @hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1)\nret i16 %2\n}", "codellama": "define dso_local signext i16 @VIRTUAL_hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call signext i16 @hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1)\nret i16 %2\n}", "codegemma": "define dso_local signext i16 @VIRTUAL_hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call signext i16 @hash_collection__HashSet__has(ptr noundef %0, ptr noundef %1)\nret i16 %2\n}"}, "define dso_local void @main() {\n%1 = call i32 @preload_seq(i32 noundef 175)\n%2 = call i32 @sp_brain(ptr noundef @current_sprite, i32 noundef 0)\n%3 = call i32 @sp_hitpoints(ptr noundef @current_sprite, i32 noundef 0)\nret void\n}": {"base_truth": "define dso_local void @main() {\nB:\n%0 = tail call i32 @preload_seq(i32 noundef 175)\n%1 = tail call i32 @sp_brain(ptr noundef nonnull @current_sprite, i32 noundef 0)\n%2 = tail call i32 @sp_hitpoints(ptr noundef nonnull @current_sprite, i32 noundef 0)\nret void\n}", "codellama": "define dso_local void @main() {\nB:\n%0 = tail call i32 @preload_seq(i32 noundef 175)\n%1 = tail call i32 @sp_brain(ptr noundef nonnull @current_sprite, i32 noundef 0)\n%2 = tail call i32 @sp_hitpoints(ptr noundef nonnull @current_sprite, i32 noundef 0)\nret void\n}", "codegemma": "define dso_local void @main() {\nB:\n%0 = tail call i32 @preload_seq(i32 noundef 175)\n%1 = tail call i32 @sp_brain(ptr noundef nonnull @current_sprite, i32 noundef 0)\n%2 = tail call i32 @sp_hitpoints(ptr noundef nonnull @current_sprite, i32 noundef 0)\nret void\n}"}, "define internal i64 @xsdfec_regread(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\n%5 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.xsdfec_dev ptr %6, i32 0, i32 1\n%8 = load i64, ptr %7, align 8\n%9 = load i64, ptr %4, align 8\n%10 = add nsw i64 %8, %9\n%11 = call i64 @ioread32(i64 noundef %10)\nstore i64 %11, ptr %5, align 8\n%12 = load ptr, ptr %3, align 8\n%13 = getelementptr inbounds %struct.xsdfec_dev ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 8\n%15 = load i64, ptr %5, align 8\n%16 = load i64, ptr %4, align 8\n%17 = call i32 @dev_dbg(i32 noundef %14, ptr noundef @.str, i64 noundef %15, i64 noundef %16)\n%18 = load i64, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i64 %18\n}": {"base_truth": "define internal i64 @xsdfec_regread(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.xsdfec_dev, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = add nsw i64 %3, %1\n%5 = tail call i64 @ioread32(i64 noundef %4)\n%6 = load i32, ptr %0, align 8\n%7 = tail call i32 @dev_dbg(i32 noundef %6, ptr noundef nonnull @.str, i64 noundef %5, i64 noundef %1)\nret i64 %5\n}", "codellama": "define internal i64 @xsdfec_regread(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.xsdfec_dev, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = add nsw i64 %3, %1\n%5 = tail call i64 @ioread32(i64 noundef %4)\n%6 = load i32, ptr %0, align 8\n%7 = tail call i32 @dev_dbg(i32 noundef %6, ptr noundef nonnull @.str, i64 noundef %5, i64 noundef %1)\nret i64 %5\n}", "codegemma": "define internal i64 @xsdfec_regread(ptr nocapture noundef readonly %0, i64 noundef %1) {\nB:\n%2 = getelementptr inbounds %struct.xsdfec_dev, ptr %0, i64 0, i32 1\n%3 = load i64, ptr %2, align 8\n%4 = add nsw i64 %3, %1\n%5 = tail call i64 @ioread32(i64 noundef %4)\n%6 = load i32, ptr %0, align 8\n%7 = tail call i32 @dev_dbg(i32 noundef %6, ptr noundef nonnull @.str, i64 noundef %5, i64 noundef %1)\nret i64 %5\n}"}, "define dso_local void @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\nstore i32 3, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 5, ptr %2, align 4\n%3 = load i32, ptr %1, align 4\n%4 = load i32, ptr %2, align 4\n%5 = load i32, ptr %1, align 4\n%6 = mul nsw i32 %4, %5\n%7 = add nsw i32 %3, %6\n%8 = load i32, ptr %2, align 4\n%9 = add nsw i32 %7, %8\n%10 = call i32 @printf(ptr noundef @.str, i32 noundef %9)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 23)\nret void\n}", "codellama": "define dso_local void @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 21)\nret void\n}", "codegemma": "define dso_local void @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 30)\nret void\n}"}, "define dso_local i32 @sqlite3_changes(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @sqlite3_changes(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @sqlite3_changes(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @sqlite3_changes(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define internal void @b43legacy_debugfs_exit() {\nret void\n}": {"base_truth": "define internal void @b43legacy_debugfs_exit() {\nB:\nret void\n}", "codellama": "define internal void @b43legacy_debugfs_exit() {\nB:\nret void\n}", "codegemma": "define internal void @b43legacy_debugfs_exit() {\nB:\nret void\n}"}, "define internal i32 @mlx4_parse_lazy_cqe(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.mlx4_cq ptr %7, i32 0, i32 0\n%9 = call i32 @mlx4_parse_cqe(ptr noundef %5, ptr noundef %6, ptr noundef %8, ptr noundef null, i32 noundef 1)\nret i32 %9\n}": {"base_truth": "define internal i32 @mlx4_parse_lazy_cqe(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @mlx4_parse_cqe(ptr noundef %0, ptr noundef %1, ptr noundef %0, ptr noundef null, i32 noundef 1)\nret i32 %2\n}", "codellama": "define internal i32 @mlx4_parse_lazy_cqe(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @mlx4_parse_cqe(ptr noundef %0, ptr noundef %1, ptr noundef %0, ptr noundef null, i32 noundef 1)\nret i32 %2\n}", "codegemma": "define internal i32 @mlx4_parse_lazy_cqe(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @mlx4_parse_cqe(ptr noundef %0, ptr noundef %1, ptr noundef %0, ptr noundef null, i32 noundef 1)\nret i32 %2\n}"}, "define internal void @bluetooth_exit() {\n%1 = load ptr, ptr @tpacpi_pdev, align 8\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %1, i32 0, i32 0\n%3 = getelementptr inbounds %struct.TYPE_3__, ptr %2, i32 0, i32 0\n%4 = call i32 @sysfs_remove_group(ptr noundef %3, ptr noundef @bluetooth_attr_group)\n%5 = load i32, ptr @TPACPI_RFK_BLUETOOTH_SW_ID, align 4\n%6 = call i32 @tpacpi_destroy_rfkill(i32 noundef %5)\n%7 = call i32 (...) @bluetooth_shutdown()\nret void\n}": {"base_truth": "define internal void @bluetooth_exit() {\nB:\n%0 = load ptr, ptr @tpacpi_pdev, align 8\n%1 = tail call i32 @sysfs_remove_group(ptr noundef %0, ptr noundef nonnull @bluetooth_attr_group)\n%2 = load i32, ptr @TPACPI_RFK_BLUETOOTH_SW_ID, align 4\n%3 = tail call i32 @tpacpi_destroy_rfkill(i32 noundef %2)\n%4 = tail call i32 (...) @bluetooth_shutdown()\nret void\n}", "codellama": "define internal void @bluetooth_exit() {\nB:\n%0 = load ptr, ptr @tpacpi_pdev, align 8\n%1 = tail call i32 @sysfs_remove_group(ptr noundef %0, ptr noundef nonnull @bluetooth_attr_group)\n%2 = load i32, ptr @TPACPI_RFK_BLUETOOTH_SW_ID, align 4\n%3 = tail call i32 @tpacpi_destroy_rfkill(i32 noundef %2)\n%4 = tail call i32 (...) @bluetooth_shutdown()\nret void\n}", "codegemma": "define internal void @bluetooth_exit() {\nB:\n%0 = load ptr, ptr @tpacpi_pdev, align 8\n%1 = tail call i32 @sysfs_remove_group(ptr noundef %0, ptr noundef nonnull @bluetooth_attr_group)\n%2 = load i32, ptr @TPACPI_RFK_BLUETOOTH_SW_ID, align 4\n%3 = tail call i32 @tpacpi_destroy_rfkill(i32 noundef %2)\n%4 = tail call i32 (...) @bluetooth_shutdown()\nret void\n}"}, "define internal i32 @ui_write(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\nret i32 1\n}": {"base_truth": "define internal i32 @ui_write(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\nret i32 1\n}", "codellama": "define internal i32 @ui_write(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\nret i32 1\n}", "codegemma": "define internal i32 @ui_write(ptr nocapture noundef readnone %0, ptr nocapture noundef readnone %1) {\nB:\nret i32 1\n}"}, "define dso_local void @mu_lock_mutex(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = call i32 (...) @abort()\nunreachable\n}": {"base_truth": "define dso_local void @mu_lock_mutex(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @abort()\nunreachable\n}", "codellama": "define dso_local void @mu_lock_mutex(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @abort()\nunreachable\n}", "codegemma": "define dso_local void @mu_lock_mutex(ptr nocapture noundef readnone %0) {\nB:\n%1 = tail call i32 (...) @abort()\nunreachable\n}"}, "define dso_local i32 @X509_LOOKUP_meth_get_ctrl(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @X509_LOOKUP_meth_get_ctrl(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @X509_LOOKUP_meth_get_ctrl(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @X509_LOOKUP_meth_get_ctrl(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local ptr @str_from_i(i64 noundef %0) {\n%2 = alloca i64, align 8\n%3 = alloca [30 x i8], align 16\nstore i64 %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 30, ptr %3)\n%4 = getelementptr inbounds [30 x i8], ptr %3, i64 0, i64 0\n%5 = load i64, ptr %2, align 8\n%6 = call i32 @sprintf(ptr noundef %4, ptr noundef @.str, i64 noundef %5)\n%7 = getelementptr inbounds [30 x i8], ptr %3, i64 0, i64 0\n%8 = call ptr @str_new(ptr noundef %7)\ncall void @llvm.lifetime.end.p0(i64 30, ptr %3)\nret ptr %8\n}": {"base_truth": "define dso_local ptr @str_from_i(i64 noundef %0) {\nB:\n%1 = alloca [30 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 30, ptr nonnull %1)\n%2 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i64 noundef %0)\n%3 = call ptr @str_new(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 30, ptr nonnull %1)\nret ptr %3\n}", "codellama": "define dso_local ptr @str_from_i(i64 noundef %0) {\nB:\n%1 = alloca [30 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 30, ptr nonnull %1)\n%2 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i64 noundef %0)\n%3 = call ptr @str_new(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 30, ptr nonnull %1)\nret ptr %3\n}", "codegemma": "define dso_local ptr @str_from_i(i64 noundef %0) {\nB:\n%1 = alloca [30 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 30, ptr nonnull %1)\n%2 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i64 noundef %0)\n%3 = call ptr @str_new(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 30, ptr nonnull %1)\nret ptr %3\n}"}, "define dso_local void @io_reset(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 1\nstore i64 0, ptr %4, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = getelementptr inbounds %struct.TYPE_4__, ptr %5, i32 0, i32 2\nstore i64 0, ptr %6, align 8\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @io_get_sys_size(ptr noundef %7)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.TYPE_4__, ptr %9, i32 0, i32 0\nstore i32 %8, ptr %10, align 8\nret void\n}": {"base_truth": "define dso_local void @io_reset(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\n%2 = tail call i32 @io_get_sys_size(ptr noundef %0)\nstore i32 %2, ptr %0, align 8\nret void\n}", "codellama": "define dso_local void @io_reset(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\n%2 = tail call i32 @io_get_sys_size(ptr noundef %0)\nstore i32 %2, ptr %0, align 8\nret void\n}", "codegemma": "define dso_local void @io_reset(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\ntail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)\n%2 = tail call i32 @io_get_sys_size(ptr noundef %0)\nstore i32 %2, ptr %0, align 8\nret void\n}"}, "define dso_local void @slave_power_on() {\nret void\n}": {"base_truth": "define dso_local void @slave_power_on() {\nB:\nret void\n}", "codellama": "define dso_local void @slave_power_on() {\nB:\nret void\n}", "codegemma": "define dso_local void @slave_power_on() {\nB:\nret void\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\nstore i32 10, ptr %2, align 4\nstore i32 20, ptr %3, align 4\n%6 = call ptr @malloc(i32 noundef 4)\nstore ptr %6, ptr %4, align 8\n%7 = call ptr @malloc(i32 noundef 4)\nstore ptr %7, ptr %5, align 8\n%8 = load ptr, ptr %4, align 8\nstore i32 30, ptr %8, align 4\n%9 = load ptr, ptr %5, align 8\nstore ptr %9, ptr %4, align 8\n%10 = load ptr, ptr %5, align 8\nstore i32 40, ptr %10, align 4\n%11 = load i32, ptr %2, align 4\n%12 = load i32, ptr %3, align 4\n%13 = load ptr, ptr %4, align 8\n%14 = load i32, ptr %13, align 4\n%15 = load ptr, ptr %5, align 8\n%16 = load i32, ptr %15, align 4\n%17 = call i32 @printf(ptr noundef @.str, i32 noundef %11, i32 noundef %12, i32 noundef %14, i32 noundef %16)\n%18 = load ptr, ptr %4, align 8\n%19 = call i32 @free(ptr noundef %18)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 4)\n%1 = tail call ptr @malloc(i32 noundef 4)\nstore i32 30, ptr %0, align 4\nstore i32 40, ptr %1, align 4\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 10, i32 noundef 20, i32 noundef 40, i32 noundef 40)\n%3 = tail call i32 @free(ptr noundef nonnull %1)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 4)\n%1 = tail call ptr @malloc(i32 noundef 4)\nstore i32 30, ptr %0, align 4\nstore ptr %1, ptr %0, align 8\nstore i32 40, ptr %1, align 4\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 10, i32 noundef 20, i32 noundef 30, i32 noundef 40)\n%3 = tail call i32 @free(ptr noundef nonnull %1)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\n%0 = tail call ptr @malloc(i32 noundef 4)\n%1 = tail call ptr @malloc(i32 noundef 4)\nstore i32 30, ptr %0, align 4\nstore i32 40, ptr %1, align 4\n%2 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 10, i32 noundef 20, i32 noundef 30, i32 noundef 40)\n%3 = tail call i32 @free(ptr noundef nonnull %0)\nret i32 0\n}"}, "define dso_local void @setup_eth_ipv4_sctp_mock_header1(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = call i32 @setup_common_eth_header(i32 noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = call i32 @setup_ipv4_header(i32 noundef %5)\n%7 = load i32, ptr %2, align 4\n%8 = call i32 @setup_sctp_common_header(i32 noundef %7)\n%9 = load i32, ptr %2, align 4\n%10 = call i32 @setup_sctp_data_chunk(i32 noundef %9)\nret void\n}": {"base_truth": "define dso_local void @setup_eth_ipv4_sctp_mock_header1(i32 noundef %0) {\nB:\n%1 = tail call i32 @setup_common_eth_header(i32 noundef %0)\n%2 = tail call i32 @setup_ipv4_header(i32 noundef %0)\n%3 = tail call i32 @setup_sctp_common_header(i32 noundef %0)\n%4 = tail call i32 @setup_sctp_data_chunk(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @setup_eth_ipv4_sctp_mock_header1(i32 noundef %0) {\nB:\n%1 = tail call i32 @setup_common_eth_header(i32 noundef %0)\n%2 = tail call i32 @setup_ipv4_header(i32 noundef %0)\n%3 = tail call i32 @setup_sctp_common_header(i32 noundef %0)\n%4 = tail call i32 @setup_sctp_data_chunk(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @setup_eth_ipv4_sctp_mock_header1(i32 noundef %0) {\nB:\n%1 = tail call i32 @setup_common_eth_header(i32 noundef %0)\n%2 = tail call i32 @setup_ipv4_header(i32 noundef %0)\n%3 = tail call i32 @setup_sctp_common_header(i32 noundef %0)\n%4 = tail call i32 @setup_sctp_data_chunk(i32 noundef %0)\nret void\n}"}, "define dso_local void @test2() {\n%1 = call fast nofpclass(nan inf) double @calculate_tax(i32 noundef 2700)\n%2 = fcmp fast oeq double 7.000000e+01, %1\n%3 = zext i1 %2 to i32\n%4 = call i32 @assert(i32 noundef %3)\nret void\n}": {"base_truth": "define dso_local void @test2() {\nB:\n%0 = tail call fast nofpclass(nan inf) double @calculate_tax(i32 noundef 2700)\n%1 = fcmp fast oeq double %0, 7.000000e+01\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @assert(i32 noundef %2)\nret void\n}", "codellama": "define dso_local void @test2() {\nB:\n%0 = tail call fast nofpclass(nan inf) double @calculate_tax(i32 noundef 2700)\n%1 = fcmp fast oeq double %0, 7.000000e+01\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @assert(i32 noundef %2)\nret void\n}", "codegemma": "define dso_local void @test2() {\nB:\n%0 = tail call fast nofpclass(nan inf) double @calculate_tax(i32 noundef 2700)\n%1 = fcmp fast oeq double %0, 7.000000e+01\n%2 = zext i1 %1 to i32\n%3 = tail call i32 @assert(i32 noundef %2)\nret void\n}"}, "define dso_local ptr @tmp_mem_dup(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load i32, ptr %4, align 4\n%7 = call ptr @tmp_mem_alloc(i32 noundef %6)\nstore ptr %7, ptr %5, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = load ptr, ptr %3, align 8\n%10 = load i32, ptr %4, align 4\n%11 = call i32 @memcpy(ptr noundef %8, ptr noundef %9, i32 noundef %10)\n%12 = load ptr, ptr %5, align 8\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret ptr %12\n}": {"base_truth": "define dso_local ptr @tmp_mem_dup(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @tmp_mem_alloc(i32 noundef %1)\n%3 = tail call i32 @memcpy(ptr noundef %2, ptr noundef %0, i32 noundef %1)\nret ptr %2\n}", "codellama": "define dso_local ptr @tmp_mem_dup(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @tmp_mem_alloc(i32 noundef %1)\n%3 = tail call i32 @memcpy(ptr noundef %2, ptr noundef %0, i32 noundef %1)\nret ptr %2\n}", "codegemma": "define dso_local ptr @tmp_mem_dup(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @tmp_mem_alloc(i32 noundef %1)\n%3 = tail call i32 @memcpy(ptr noundef %2, ptr noundef %0, i32 noundef %1)\nret ptr %2\n}"}, "define dso_local void @Divide() {\n%1 = call i32 @Match(i8 noundef signext 47)\n%2 = call i32 (...) @Factor()\n%3 = call i32 @EmitLn(ptr noundef @.str)\n%4 = call i32 @EmitLn(ptr noundef @.str.1)\n%5 = call i32 @EmitLn(ptr noundef @.str.2)\n%6 = call i32 @EmitLn(ptr noundef @.str.3)\n%7 = call i32 @EmitLn(ptr noundef @.str.4)\n%8 = call i32 @EmitLn(ptr noundef @.str.5)\n%9 = call i32 @EmitLn(ptr noundef @.str.1)\nret void\n}": {"base_truth": "define dso_local void @Divide() {\nB:\n%0 = tail call i32 @Match(i8 noundef signext 47)\n%1 = tail call i32 (...) @Factor()\n%2 = tail call i32 @EmitLn(ptr noundef nonnull @.str)\n%3 = tail call i32 @EmitLn(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @EmitLn(ptr noundef nonnull @.str.2)\n%5 = tail call i32 @EmitLn(ptr noundef nonnull @.str.3)\n%6 = tail call i32 @EmitLn(ptr noundef nonnull @.str.4)\n%7 = tail call i32 @EmitLn(ptr noundef nonnull @.str.5)\n%8 = tail call i32 @EmitLn(ptr noundef nonnull @.str.1)\nret void\n}", "codellama": "define dso_local void @Divide() {\nB:\n%0 = tail call i32 @Match(i8 noundef signext 47)\n%1 = tail call i32 (...) @Factor()\n%2 = tail call i32 @EmitLn(ptr noundef nonnull @.str)\n%3 = tail call i32 @EmitLn(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @EmitLn(ptr noundef nonnull @.str.2)\n%5 = tail call i32 @EmitLn(ptr noundef nonnull @.str.3)\n%6 = tail call i32 @EmitLn(ptr noundef nonnull @.str.4)\n%7 = tail call i32 @EmitLn(ptr noundef nonnull @.str.5)\n%8 = tail call i32 @EmitLn(ptr noundef nonnull @.str.1)\nret void\n}", "codegemma": "define dso_local void @Divide() {\nB:\n%0 = tail call i32 @Match(i8 noundef signext 47)\n%1 = tail call i32 (...) @Factor()\n%2 = tail call i32 @EmitLn(ptr noundef nonnull @.str)\n%3 = tail call i32 @EmitLn(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @EmitLn(ptr noundef nonnull @.str.2)\n%5 = tail call i32 @EmitLn(ptr noundef nonnull @.str.3)\n%6 = tail call i32 @EmitLn(ptr noundef nonnull @.str.4)\n%7 = tail call i32 @EmitLn(ptr noundef nonnull @.str.5)\n%8 = tail call i32 @EmitLn(ptr noundef nonnull @.str.1)\nret void\n}"}, "define internal void @cvm_oct_mdio_dummy_write(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %5, align 8\nstore i32 %1, ptr %6, align 4\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\nret void\n}": {"base_truth": "define internal void @cvm_oct_mdio_dummy_write(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\nret void\n}", "codellama": "define internal void @cvm_oct_mdio_dummy_write(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\nret void\n}", "codegemma": "define internal void @cvm_oct_mdio_dummy_write(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) {\nB:\nret void\n}"}, "define dso_local signext i16 @c_tools__ExternFile__add_to_jar(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i16, align 2\n%4 = alloca i16, align 2\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 2, ptr %3)\ncall void @llvm.lifetime.start.p0(i64 2, ptr %4)\nstore i16 0, ptr %4, align 2\n%5 = load i16, ptr %4, align 2\nstore i16 %5, ptr %3, align 2\nbr label %6\n\n6:\n%7 = load i16, ptr %3, align 2\ncall void @llvm.lifetime.end.p0(i64 2, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 2, ptr %3)\nret i16 %7\n}": {"base_truth": "define dso_local signext i16 @c_tools__ExternFile__add_to_jar(ptr nocapture noundef readnone %0) {\nB:\nret i16 0\n}", "codellama": "define dso_local signext i16 @c_tools__ExternFile__add_to_jar(ptr nocapture noundef readnone %0) {\nB:\nret i16 0\n}", "codegemma": "define dso_local signext i16 @c_tools__ExternFile__add_to_jar(ptr nocapture noundef readnone %0) {\nB:\nret i16 0\n}"}, "define dso_local i32 @TIFFSetField_TIFFTAG_SUBFILETYPE(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr @TIFFTAG_SUBFILETYPE, align 4\n%7 = load i32, ptr %4, align 4\n%8 = call i32 @TIFFSetField(ptr noundef %5, i32 noundef %6, i32 noundef %7)\nret i32 %8\n}": {"base_truth": "define dso_local i32 @TIFFSetField_TIFFTAG_SUBFILETYPE(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @TIFFTAG_SUBFILETYPE, align 4\n%3 = tail call i32 @TIFFSetField(ptr noundef %0, i32 noundef %2, i32 noundef %1)\nret i32 %3\n}", "codellama": "define dso_local i32 @TIFFSetField_TIFFTAG_SUBFILETYPE(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @TIFFTAG_SUBFILETYPE, align 4\n%3 = tail call i32 @TIFFSetField(ptr noundef %0, i32 noundef %2, i32 noundef %1)\nret i32 %3\n}", "codegemma": "define dso_local i32 @TIFFSetField_TIFFTAG_SUBFILETYPE(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @TIFFTAG_SUBFILETYPE, align 4\n%3 = tail call i32 @TIFFSetField(ptr noundef %0, i32 noundef %2, i32 noundef %1)\nret i32 %3\n}"}, "define dso_local void @res_S() {\n%1 = call i32 @message(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @res_S() {\nB:\n%0 = tail call i32 @message(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @res_S() {\nB:\n%0 = tail call i32 @message(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @res_S() {\nB:\n%0 = tail call i32 @message(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local void @amiheader_destroy(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = icmp ne ptr %3, null\nbr i1 %4, label %5, label %16\n\n5:\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 1\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @str_destroy(i32 noundef %8)\n%10 = load ptr, ptr %2, align 8\n%11 = getelementptr inbounds %struct.TYPE_4__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = call i32 @str_destroy(i32 noundef %12)\n%14 = load ptr, ptr %2, align 8\n%15 = call i32 @free(ptr noundef %14)\nbr label %16\n\n16:\nstore ptr null, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @amiheader_destroy(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @str_destroy(i32 noundef %3)\n%5 = load i32, ptr %0, align 4\n%6 = tail call i32 @str_destroy(i32 noundef %5)\n%7 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codellama": "define dso_local void @amiheader_destroy(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @str_destroy(i32 noundef %3)\n%5 = load i32, ptr %0, align 4\n%6 = tail call i32 @str_destroy(i32 noundef %5)\n%7 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}", "codegemma": "define dso_local void @amiheader_destroy(ptr noundef %0) {\nB:\n%1 = icmp eq ptr %0, null\nbr i1 %1, label %B2, label %B1\n\nB1:\n%2 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @str_destroy(i32 noundef %3)\n%5 = load i32, ptr %0, align 4\n%6 = tail call i32 @str_destroy(i32 noundef %5)\n%7 = tail call i32 @free(ptr noundef nonnull %0)\nbr label %B2\n\nB2:\nret void\n}"}, "define dso_local ptr @get_cvs_context(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @cvs_probe, align 4\n%5 = load i32, ptr @cvs_get_info, align 4\n%6 = call ptr @init_context(ptr noundef @.str, ptr noundef %3, i32 noundef %4, i32 noundef %5)\nret ptr %6\n}": {"base_truth": "define dso_local ptr @get_cvs_context(ptr noundef %0) {\nB:\n%1 = load i32, ptr @cvs_probe, align 4\n%2 = load i32, ptr @cvs_get_info, align 4\n%3 = tail call ptr @init_context(ptr noundef nonnull @.str, ptr noundef %0, i32 noundef %1, i32 noundef %2)\nret ptr %3\n}", "codellama": "define dso_local ptr @get_cvs_context(ptr noundef %0) {\nB:\n%1 = load i32, ptr @cvs_probe, align 4\n%2 = load i32, ptr @cvs_get_info, align 4\n%3 = tail call ptr @init_context(ptr noundef nonnull @.str, ptr noundef %0, i32 noundef %1, i32 noundef %2)\nret ptr %3\n}", "codegemma": "define dso_local ptr @get_cvs_context(ptr noundef %0) {\nB:\n%1 = load i32, ptr @cvs_probe, align 4\n%2 = load i32, ptr @cvs_get_info, align 4\n%3 = tail call ptr @init_context(ptr noundef nonnull @.str, ptr noundef %0, i32 noundef %1, i32 noundef %2)\nret ptr %3\n}"}, "define dso_local void @manager(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = load i32, ptr @SIGUSR1, align 4\n%5 = icmp eq i32 %3, %4\nbr i1 %5, label %6, label %7\n\n6:\nbr label %7\n\n7:\nret void\n}": {"base_truth": "define dso_local void @manager(i32 noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @manager(i32 noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @manager(i32 noundef %0) {\nB:\nret void\n}"}, "define dso_local i32 @Shelp() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\nstore ptr @.str, ptr %1, align 8\n%2 = load ptr, ptr %1, align 8\n%3 = call i32 @PrintOutPut(ptr noundef %2)\n%4 = load i32, ptr @noError, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret i32 %4\n}": {"base_truth": "define dso_local i32 @Shelp() {\nB:\n%0 = tail call i32 @PrintOutPut(ptr noundef nonnull @.str)\n%1 = load i32, ptr @noError, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @Shelp() {\nB:\n%0 = tail call i32 @PrintOutPut(ptr noundef nonnull @.str)\n%1 = load i32, ptr @noError, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @Shelp() {\nB:\n%0 = tail call i32 @PrintOutPut(ptr noundef nonnull @.str)\n%1 = load i32, ptr @noError, align 4\nret i32 %1\n}"}, "define dso_local i32 @Random() {\n%1 = call i32 (...) @rand()\n%2 = sub nsw i32 %1, 1\nret i32 %2\n}": {"base_truth": "define dso_local i32 @Random() {\nB:\n%0 = tail call i32 (...) @rand()\n%1 = add nsw i32 %0, -1\nret i32 %1\n}", "codellama": "define dso_local i32 @Random() {\nB:\n%0 = tail call i32 (...) @rand()\n%1 = add nsw i32 %0, -1\nret i32 %1\n}", "codegemma": "define dso_local i32 @Random() {\nB:\n%0 = tail call i32 (...) @rand()\n%1 = add nsw i32 %0, -1\nret i32 %1\n}"}, "define dso_local i32 @main() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 0, ptr %1, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\nstore i32 65, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\nstore i32 0, ptr %3, align 4\nbr label %4\n\n4:\n%5 = load i32, ptr %2, align 4\n%6 = icmp sgt i32 %5, 0\nbr i1 %6, label %7, label %14\n\n7:\n%8 = load i32, ptr %2, align 4\n%9 = load i32, ptr %2, align 4\n%10 = sub nsw i32 %9, 1\n%11 = and i32 %8, %10\nstore i32 %11, ptr %2, align 4\n%12 = load i32, ptr %3, align 4\n%13 = add nsw i32 %12, 1\nstore i32 %13, ptr %3, align 4\nbr label %4\n\n14:\n%15 = load i32, ptr %3, align 4\n%16 = call i32 @printf(ptr noundef @.str, i32 noundef %15)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\nret i32 0\n}": {"base_truth": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 2)\nret i32 0\n}", "codellama": "define dso_local i32 @main() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef 1)\nret i32 0\n}", "codegemma": "define dso_local i32 @main() {\nB:\nbr label %B1\n\nB1:\n%0 = phi i32 [ 65, %B ], [ %1, %B1 ]\n%1 = phi i32 [ 0, %B ], [ %2, %B1 ]\n%2 = add nsw i32 %0, -1\n%3 = and i32 %2, %0\n%4 = icmp sgt i32 %3, 0\nbr i1 %4, label %B1, label %B2\n\nB2:\n%5 = tail call i32 @printf(ptr noundef nonnull @.str, i32 noundef %1)\nret i32 0\n}"}, "define dso_local void @greater() {\n%1 = call i32 @match(i8 noundef signext 62)\n%2 = call i32 (...) @expression()\n%3 = call i32 @emitln(ptr noundef @.str)\n%4 = call i32 @emitln(ptr noundef @.str.1)\n%5 = call i32 @emitln(ptr noundef @.str.2)\n%6 = call i32 @emitln(ptr noundef @.str.3)\nret void\n}": {"base_truth": "define dso_local void @greater() {\nB:\n%0 = tail call i32 @match(i8 noundef signext 62)\n%1 = tail call i32 (...) @expression()\n%2 = tail call i32 @emitln(ptr noundef nonnull @.str)\n%3 = tail call i32 @emitln(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @emitln(ptr noundef nonnull @.str.2)\n%5 = tail call i32 @emitln(ptr noundef nonnull @.str.3)\nret void\n}", "codellama": "define dso_local void @greater() {\nB:\n%0 = tail call i32 @match(i8 noundef signext 62)\n%1 = tail call i32 (...) @expression()\n%2 = tail call i32 @emitln(ptr noundef nonnull @.str)\n%3 = tail call i32 @emitln(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @emitln(ptr noundef nonnull @.str.2)\n%5 = tail call i32 @emitln(ptr noundef nonnull @.str.3)\nret void\n}", "codegemma": "define dso_local void @greater() {\nB:\n%0 = tail call i32 @match(i8 noundef signext 62)\n%1 = tail call i32 (...) @expression()\n%2 = tail call i32 @emitln(ptr noundef nonnull @.str)\n%3 = tail call i32 @emitln(ptr noundef nonnull @.str.1)\n%4 = tail call i32 @emitln(ptr noundef nonnull @.str.2)\n%5 = tail call i32 @emitln(ptr noundef nonnull @.str.3)\nret void\n}"}, "define dso_local i32 @KSI_Utf8StringList_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i64, align 8\n%6 = alloca ptr, align 8\nstore ptr %0, ptr %4, align 8\nstore i64 %1, ptr %5, align 8\nstore ptr %2, ptr %6, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i64, ptr %5, align 8\n%9 = load ptr, ptr %6, align 8\n%10 = call i32 @KSI_List_insertAt(ptr noundef %7, i64 noundef %8, ptr noundef %9)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @KSI_Utf8StringList_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @KSI_List_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @KSI_Utf8StringList_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @KSI_List_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @KSI_Utf8StringList_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2) {\nB:\n%3 = tail call i32 @KSI_List_insertAt(ptr noundef %0, i64 noundef %1, ptr noundef %2)\nret i32 %3\n}"}, "define dso_local void @VIRTUAL_template__Template__force_render(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @template__Template__force_render(ptr noundef %3)\nbr label %5\n\n5:\nret void\n}": {"base_truth": "define dso_local void @VIRTUAL_template__Template__force_render(ptr noundef %0) {\nB:\n%1 = tail call i32 @template__Template__force_render(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @VIRTUAL_template__Template__force_render(ptr noundef %0) {\nB:\n%1 = tail call i32 @template__Template__force_render(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @VIRTUAL_template__Template__force_render(ptr noundef %0) {\nB:\n%1 = tail call i32 @template__Template__force_render(ptr noundef %0)\nret void\n}"}, "define dso_local void @cli() {\n%1 = call i32 @printf(ptr noundef @.str, ptr noundef @.str.1, i32 noundef 7)\nret void\n}": {"base_truth": "define dso_local void @cli() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, i32 noundef 7)\nret void\n}", "codellama": "define dso_local void @cli() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, i32 noundef 7)\nret void\n}", "codegemma": "define dso_local void @cli() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, i32 noundef 7)\nret void\n}"}, "define internal i32 @rtl8211b_config_intr(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.phy_device, ptr %4, i32 0, i32 0\n%6 = load i64, ptr %5, align 8\n%7 = load i64, ptr @PHY_INTERRUPT_ENABLED, align 8\n%8 = icmp eq i64 %6, %7\nbr i1 %8, label %9, label %14\n\n9:\n%10 = load ptr, ptr %2, align 8\n%11 = load i32, ptr @RTL821x_INER, align 4\n%12 = load i32, ptr @RTL8211B_INER_INIT, align 4\n%13 = call i32 @phy_write(ptr noundef %10, i32 noundef %11, i32 noundef %12)\nstore i32 %13, ptr %3, align 4\nbr label %18\n\n14:\n%15 = load ptr, ptr %2, align 8\n%16 = load i32, ptr @RTL821x_INER, align 4\n%17 = call i32 @phy_write(ptr noundef %15, i32 noundef %16, i32 noundef 0)\nstore i32 %17, ptr %3, align 4\nbr label %18\n\n18:\n%19 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %19\n}": {"base_truth": "define internal i32 @rtl8211b_config_intr(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @PHY_INTERRUPT_ENABLED, align 8\n%3 = icmp eq i64 %1, %2\n%4 = load i32, ptr @RTL821x_INER, align 4\n%5 = load i32, ptr @RTL8211B_INER_INIT, align 4\n%6 = select i1 %3, i32 %5, i32 0\n%7 = tail call i32 @phy_write(ptr noundef nonnull %0, i32 noundef %4, i32 noundef %6)\nret i32 %7\n}", "codellama": "define internal i32 @rtl8211b_config_intr(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @PHY_INTERRUPT_ENABLED, align 8\n%3 = icmp eq i64 %1, %2\n%4 = load i32, ptr @RTL821x_INER, align 4\n%5 = load i32, ptr @RTL8211B_INER_INIT, align 4\n%6 = select i1 %3, i32 %5, i32 0\n%7 = tail call i32 @phy_write(ptr noundef nonnull %0, i32 noundef %4, i32 noundef %6)\nret i32 %7\n}", "codegemma": "define internal i32 @rtl8211b_config_intr(ptr noundef %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = load i64, ptr @PHY_INTERRUPT_ENABLED, align 8\n%3 = icmp eq i64 %1, %2\n%4 = load i32, ptr @RTL821x_INER, align 4\n%5 = load i32, ptr @RTL8211B_INER_INIT, align 4\n%6 = select i1 %3, i32 %5, i32 0\n%7 = tail call i32 @phy_write(ptr noundef nonnull %0, i32 noundef %4, i32 noundef %6)\nret i32 %7\n}"}, "define dso_local i32 @tnet_is_BE() {\n%1 = load i32, ptr @tnet_isBigEndian, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @tnet_is_BE() {\nB:\n%0 = load i32, ptr @tnet_isBigEndian, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @tnet_is_BE() {\nB:\n%0 = load i32, ptr @tnet_isBigEndian, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @tnet_is_BE() {\nB:\n%0 = load i32, ptr @tnet_isBigEndian, align 4\nret i32 %0\n}"}, "define dso_local void @Z80_ADDAH(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %4, i32 0, i32 0\n%6 = load i32, ptr %5, align 4\n%7 = call i32 @Z80_AddHelp(ptr noundef %3, i32 noundef %6)\nret void\n}": {"base_truth": "define dso_local void @Z80_ADDAH(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_AddHelp(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @Z80_ADDAH(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_AddHelp(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @Z80_ADDAH(ptr noundef %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @Z80_AddHelp(ptr noundef nonnull %0, i32 noundef %1)\nret void\n}"}, "define dso_local void @makebook_reset() {\n%1 = call i32 @setup_board(ptr noundef @board)\nstore i64 0, ptr @moves_done, align 8\nret void\n}": {"base_truth": "define dso_local void @makebook_reset() {\nB:\n%0 = tail call i32 @setup_board(ptr noundef nonnull @board)\nstore i64 0, ptr @moves_done, align 8\nret void\n}", "codellama": "define dso_local void @makebook_reset() {\nB:\n%0 = tail call i32 @setup_board(ptr noundef nonnull @board)\nstore i64 0, ptr @moves_done, align 8\nret void\n}", "codegemma": "define dso_local void @makebook_reset() {\nB:\n%0 = tail call i32 @setup_board(ptr noundef nonnull @board)\nstore i64 0, ptr @moves_done, align 8\nret void\n}"}, "define dso_local i32 @gss_sign(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\n%10 = alloca i32, align 4\nstore ptr %0, ptr %6, align 8\nstore i32 %1, ptr %7, align 4\nstore i32 %2, ptr %8, align 4\nstore i32 %3, ptr %9, align 4\nstore i32 %4, ptr %10, align 4\n%11 = load ptr, ptr %6, align 8\n%12 = load i32, ptr %7, align 4\n%13 = load i32, ptr %8, align 4\n%14 = load i32, ptr %9, align 4\n%15 = load i32, ptr %10, align 4\n%16 = call i32 @gss_get_mic(ptr noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15)\nret i32 %16\n}": {"base_truth": "define dso_local i32 @gss_sign(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = tail call i32 @gss_get_mic(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}", "codellama": "define dso_local i32 @gss_sign(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = tail call i32 @gss_get_mic(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}", "codegemma": "define dso_local i32 @gss_sign(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) {\nB:\n%5 = tail call i32 @gss_get_mic(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4)\nret i32 %5\n}"}, "define dso_local i32 @func() {\n%1 = call i32 (...) @duplicate_func()\nret i32 %1\n}": {"base_truth": "define dso_local i32 @func() {\nB:\n%0 = tail call i32 (...) @duplicate_func()\nret i32 %0\n}", "codellama": "define dso_local i32 @func() {\nB:\n%0 = tail call i32 (...) @duplicate_func()\nret i32 %0\n}", "codegemma": "define dso_local i32 @func() {\nB:\n%0 = tail call i32 (...) @duplicate_func()\nret i32 %0\n}"}, "define dso_local i32 @is_valid_shlc2(i8 noundef signext %0) {\n%2 = alloca i8, align 1\nstore i8 %0, ptr %2, align 1\n%3 = load i8, ptr %2, align 1\n%4 = sext i8 %3 to i32\n%5 = icmp ne i32 %4, 0\n%6 = zext i1 %5 to i32\nret i32 %6\n}": {"base_truth": "define dso_local i32 @is_valid_shlc2(i8 noundef signext %0) {\nB:\n%1 = icmp ne i8 %0, 0\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codellama": "define dso_local i32 @is_valid_shlc2(i8 noundef signext %0) {\nB:\n%1 = icmp ne i8 %0, 0\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codegemma": "define dso_local i32 @is_valid_shlc2(i8 noundef signext %0) {\nB:\n%1 = icmp ne i8 %0, 0\n%2 = zext i1 %1 to i32\nret i32 %2\n}"}, "define internal i32 @wm8985_writeable(ptr noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\n%6 = load i32, ptr %5, align 4\nswitch i32 %6, label %8 [\ni32 128, label %7\ni32 138, label %7\ni32 137, label %7\ni32 136, label %7\ni32 176, label %7\ni32 172, label %7\ni32 173, label %7\ni32 180, label %7\ni32 163, label %7\ni32 161, label %7\ni32 171, label %7\ni32 157, label %7\ni32 133, label %7\ni32 160, label %7\ni32 181, label %7\ni32 158, label %7\ni32 134, label %7\ni32 168, label %7\ni32 167, label %7\ni32 166, label %7\ni32 165, label %7\ni32 164, label %7\ni32 170, label %7\ni32 169, label %7\ni32 151, label %7\ni32 150, label %7\ni32 149, label %7\ni32 148, label %7\ni32 179, label %7\ni32 178, label %7\ni32 177, label %7\ni32 152, label %7\ni32 139, label %7\ni32 142, label %7\ni32 141, label %7\ni32 140, label %7\ni32 182, label %7\ni32 145, label %7\ni32 175, label %7\ni32 162, label %7\ni32 156, label %7\ni32 132, label %7\ni32 159, label %7\ni32 135, label %7\ni32 144, label %7\ni32 155, label %7\ni32 131, label %7\ni32 154, label %7\ni32 130, label %7\ni32 153, label %7\ni32 129, label %7\ni32 147, label %7\ni32 146, label %7\ni32 143, label %7\ni32 174, label %7\n]\n\n7:\nstore i32 1, ptr %3, align 4\nbr label %9\n\n8:\nstore i32 0, ptr %3, align 4\nbr label %9\n\n9:\n%10 = load i32, ptr %3, align 4\nret i32 %10\n}": {"base_truth": "define internal i32 @wm8985_writeable(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = add i32 %1, -128\n%3 = icmp ult i32 %2, 55\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codellama": "define internal i32 @wm8985_writeable(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = add i32 %1, -128\n%3 = icmp ult i32 %2, 49\n%4 = zext i1 %3 to i32\nret i32 %4\n}", "codegemma": "define internal i32 @wm8985_writeable(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = add i32 %1, -128\n%3 = icmp ult i32 %2, 55\n%4 = zext i1 %3 to i32\nret i32 %4\n}"}, "define dso_local void @printLastError() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = load i32, ptr @max_buf, align 4\n%3 = call i64 @malloc(i32 noundef %2)\n%4 = inttoptr i64 %3 to ptr\nstore ptr %4, ptr %1, align 8\n%5 = call i32 (...) @ERR_load_crypto_strings()\n%6 = call i32 (...) @ERR_get_error()\n%7 = load ptr, ptr %1, align 8\n%8 = call i32 @ERR_error_string(i32 noundef %6, ptr noundef %7)\n%9 = load ptr, ptr %1, align 8\n%10 = call i32 @printf(ptr noundef @.str, ptr noundef %9)\n%11 = load ptr, ptr %1, align 8\n%12 = call i32 @free(ptr noundef %11)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @printLastError() {\nB:\n%0 = load i32, ptr @max_buf, align 4\n%1 = tail call i64 @malloc(i32 noundef %0)\n%2 = inttoptr i64 %1 to ptr\n%3 = tail call i32 (...) @ERR_load_crypto_strings()\n%4 = tail call i32 (...) @ERR_get_error()\n%5 = tail call i32 @ERR_error_string(i32 noundef %4, ptr noundef %2)\n%6 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %2)\n%7 = tail call i32 @free(ptr noundef %2)\nret void\n}", "codellama": "define dso_local void @printLastError() {\nB:\n%0 = load i32, ptr @max_buf, align 4\n%1 = tail call i64 @malloc(i32 noundef %0)\n%2 = inttoptr i64 %1 to ptr\n%3 = tail call i32 (...) @ERR_load_crypto_strings()\n%4 = tail call i32 (...) @ERR_get_error()\n%5 = tail call i32 @ERR_error_string(i32 noundef %4, ptr noundef %2)\n%6 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %2)\n%7 = tail call i32 @free(ptr noundef %2)\nret void\n}", "codegemma": "define dso_local void @printLastError() {\nB:\n%0 = load i32, ptr @max_buf, align 4\n%1 = tail call i64 @malloc(i32 noundef %0)\n%2 = inttoptr i64 %1 to ptr\n%3 = tail call i32 (...) @ERR_load_crypto_strings()\n%4 = tail call i32 (...) @ERR_get_error()\n%5 = tail call i32 @ERR_error_string(i32 noundef %4, ptr noundef %2)\n%6 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %2)\n%7 = tail call i32 @free(ptr noundef %2)\nret void\n}"}, "define dso_local void @HMAC_CTX_cleanup(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_4__, ptr %3, i32 0, i32 2\n%5 = call i32 @EVP_MD_CTX_cleanup(ptr noundef %4)\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 1\n%8 = call i32 @EVP_MD_CTX_cleanup(ptr noundef %7)\n%9 = load ptr, ptr %2, align 8\n%10 = getelementptr inbounds %struct.TYPE_4__, ptr %9, i32 0, i32 0\n%11 = call i32 @EVP_MD_CTX_cleanup(ptr noundef %10)\n%12 = load ptr, ptr %2, align 8\n%13 = call i32 @memset(ptr noundef %12, i32 noundef 0, i32 noundef 12)\nret void\n}": {"base_truth": "define dso_local void @HMAC_CTX_cleanup(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 2\n%2 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef nonnull %1)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%4 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef nonnull %3)\n%5 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef %0)\n%6 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 12)\nret void\n}", "codellama": "define dso_local void @HMAC_CTX_cleanup(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 2\n%2 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef nonnull %1)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%4 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef nonnull %3)\n%5 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef %0)\n%6 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 12)\nret void\n}", "codegemma": "define dso_local void @HMAC_CTX_cleanup(ptr noundef %0) {\nB:\n%1 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 2\n%2 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef nonnull %1)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%4 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef nonnull %3)\n%5 = tail call i32 @EVP_MD_CTX_cleanup(ptr noundef %0)\n%6 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 12)\nret void\n}"}, "define dso_local i32 @kmem_debugging() {\nret i32 0\n}": {"base_truth": "define dso_local i32 @kmem_debugging() {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @kmem_debugging() {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @kmem_debugging() {\nB:\nret i32 0\n}"}, "define dso_local void @release_lock(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @memory_order_release, align 4\n%5 = call i32 @atomic_store_explicit(ptr noundef %3, i32 noundef 0, i32 noundef %4)\nret void\n}": {"base_truth": "define dso_local void @release_lock(ptr noundef %0) {\nB:\n%1 = load i32, ptr @memory_order_release, align 4\n%2 = tail call i32 @atomic_store_explicit(ptr noundef %0, i32 noundef 0, i32 noundef %1)\nret void\n}", "codellama": "define dso_local void @release_lock(ptr noundef %0) {\nB:\n%1 = load i32, ptr @memory_order_release, align 4\n%2 = tail call i32 @atomic_store_explicit(ptr noundef %0, i32 noundef 0, i32 noundef %1)\nret void\n}", "codegemma": "define dso_local void @release_lock(ptr noundef %0) {\nB:\n%1 = load i32, ptr @memory_order_release, align 4\n%2 = tail call i32 @atomic_store_explicit(ptr noundef %0, i32 noundef 0, i32 noundef %1)\nret void\n}"}, "define dso_local void @print_bss_start_usage() {\n%1 = call i32 @printf(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @print_bss_start_usage() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @print_bss_start_usage() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @print_bss_start_usage() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret void\n}"}, "define internal i32 @snd_bt87x_hw_free(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @snd_pcm_substream_chip(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @snd_bt87x_free_risc(ptr noundef %6)\n%8 = load ptr, ptr %2, align 8\n%9 = call i32 @snd_pcm_lib_free_pages(ptr noundef %8)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @snd_bt87x_hw_free(ptr noundef %0) {\nB:\n%1 = tail call ptr @snd_pcm_substream_chip(ptr noundef %0)\n%2 = tail call i32 @snd_bt87x_free_risc(ptr noundef %1)\n%3 = tail call i32 @snd_pcm_lib_free_pages(ptr noundef %0)\nret i32 0\n}", "codellama": "define internal i32 @snd_bt87x_hw_free(ptr noundef %0) {\nB:\n%1 = tail call ptr @snd_pcm_substream_chip(ptr noundef %0)\n%2 = tail call i32 @snd_bt87x_free_risc(ptr noundef %1)\n%3 = tail call i32 @snd_pcm_lib_free_pages(ptr noundef %0)\nret i32 0\n}", "codegemma": "define internal i32 @snd_bt87x_hw_free(ptr noundef %0) {\nB:\n%1 = tail call ptr @snd_pcm_substream_chip(ptr noundef %0)\n%2 = tail call i32 @snd_bt87x_free_risc(ptr noundef %1)\n%3 = tail call i32 @snd_pcm_lib_free_pages(ptr noundef %0)\nret i32 0\n}"}, "define dso_local void @del_tmpfile() {\n%1 = call i32 @unlink(ptr noundef @.str)\nret void\n}": {"base_truth": "define dso_local void @del_tmpfile() {\nB:\n%0 = tail call i32 @unlink(ptr noundef nonnull @.str)\nret void\n}", "codellama": "define dso_local void @del_tmpfile() {\nB:\n%0 = tail call i32 @unlink(ptr noundef nonnull @.str)\nret void\n}", "codegemma": "define dso_local void @del_tmpfile() {\nB:\n%0 = tail call i32 @unlink(ptr noundef nonnull @.str)\nret void\n}"}, "define dso_local i32 @gml_none_create(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @gml_atom_create(ptr noundef %3, ptr noundef @.str)\nret i32 %4\n}": {"base_truth": "define dso_local i32 @gml_none_create(ptr noundef %0) {\nB:\n%1 = tail call i32 @gml_atom_create(ptr noundef %0, ptr noundef nonnull @.str)\nret i32 %1\n}", "codellama": "define dso_local i32 @gml_none_create(ptr noundef %0) {\nB:\n%1 = tail call i32 @gml_atom_create(ptr noundef %0, ptr noundef nonnull @.str)\nret i32 %1\n}", "codegemma": "define dso_local i32 @gml_none_create(ptr noundef %0) {\nB:\n%1 = tail call i32 @gml_atom_create(ptr noundef %0, ptr noundef nonnull @.str)\nret i32 %1\n}"}, "define dso_local i32 @bar() {\n%1 = call ptr (...) @foo()\n%2 = icmp eq ptr %1, null\n%3 = zext i1 %2 to i32\nret i32 %3\n}": {"base_truth": "define dso_local i32 @bar() {\nB:\n%0 = tail call ptr (...) @foo()\n%1 = icmp eq ptr %0, null\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codellama": "define dso_local i32 @bar() {\nB:\n%0 = tail call ptr (...) @foo()\n%1 = icmp eq ptr %0, null\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codegemma": "define dso_local i32 @bar() {\nB:\n%0 = tail call ptr (...) @foo()\n%1 = icmp eq ptr %0, null\n%2 = zext i1 %1 to i32\nret i32 %2\n}"}, "define dso_local i32 @stackIsEmpty(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = icmp eq i32 %5, -1\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define dso_local i32 @stackIsEmpty(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, -1\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define dso_local i32 @stackIsEmpty(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, -1\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define dso_local i32 @stackIsEmpty(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = icmp eq i32 %1, -1\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define dso_local void @seekdir(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\nret void\n}": {"base_truth": "define dso_local void @seekdir(ptr nocapture noundef %0, i64 noundef %1) {\nB:\nret void\n}", "codellama": "define dso_local void @seekdir(ptr nocapture noundef %0, i64 noundef %1) {\nB:\nret void\n}", "codegemma": "define dso_local void @seekdir(ptr nocapture noundef %0, i64 noundef %1) {\nB:\nret void\n}"}, "define internal void @frag_set_pending_idx(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load ptr, ptr %3, align 8\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @skb_frag_off_set(ptr noundef %5, i32 noundef %6)\nret void\n}": {"base_truth": "define internal void @frag_set_pending_idx(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @skb_frag_off_set(ptr noundef %0, i32 noundef %1)\nret void\n}", "codellama": "define internal void @frag_set_pending_idx(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @skb_frag_off_set(ptr noundef %0, i32 noundef %1)\nret void\n}", "codegemma": "define internal void @frag_set_pending_idx(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @skb_frag_off_set(ptr noundef %0, i32 noundef %1)\nret void\n}"}, "define dso_local void @_jit_reti_d(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr @reti_d, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @jit_inc_synth_d(i32 noundef %5, i32 noundef %6)\n%8 = load i32, ptr @JIT_FRET, align 4\n%9 = load i32, ptr %4, align 4\n%10 = call i32 @jit_movi_d(i32 noundef %8, i32 noundef %9)\n%11 = call i32 (...) @jit_ret()\n%12 = call i32 (...) @jit_dec_synth()\nret void\n}": {"base_truth": "define dso_local void @_jit_reti_d(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @reti_d, align 4\n%3 = tail call i32 @jit_inc_synth_d(i32 noundef %2, i32 noundef %1)\n%4 = load i32, ptr @JIT_FRET, align 4\n%5 = tail call i32 @jit_movi_d(i32 noundef %4, i32 noundef %1)\n%6 = tail call i32 (...) @jit_ret()\n%7 = tail call i32 (...) @jit_dec_synth()\nret void\n}", "codellama": "define dso_local void @_jit_reti_d(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @reti_d, align 4\n%3 = tail call i32 @jit_inc_synth_d(i32 noundef %2, i32 noundef %1)\n%4 = load i32, ptr @JIT_FRET, align 4\n%5 = tail call i32 @jit_movi_d(i32 noundef %4, i32 noundef %1)\n%6 = tail call i32 (...) @jit_ret()\n%7 = tail call i32 (...) @jit_dec_synth()\nret void\n}", "codegemma": "define dso_local void @_jit_reti_d(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr @reti_d, align 4\n%3 = tail call i32 @jit_inc_synth_d(i32 noundef %2, i32 noundef %1)\n%4 = load i32, ptr @JIT_FRET, align 4\n%5 = tail call i32 @jit_movi_d(i32 noundef %4, i32 noundef %1)\n%6 = tail call i32 (...) @jit_ret()\n%7 = tail call i32 (...) @jit_dec_synth()\nret void\n}"}, "define dso_local void @uninitvar_feraiseexcept() {\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %1)\n%2 = load i32, ptr %1, align 4\n%3 = call i32 @feraiseexcept(i32 noundef %2)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @uninitvar_feraiseexcept() {\nB:\n%0 = tail call i32 @feraiseexcept(i32 noundef undef)\nret void\n}", "codellama": "define dso_local void @uninitvar_feraiseexcept() {\nB:\n%0 = tail call i32 @feraiseexcept(i32 noundef undef)\nret void\n}", "codegemma": "define dso_local void @uninitvar_feraiseexcept() {\nB:\n%0 = tail call i32 @feraiseexcept(i32 noundef undef)\nret void\n}"}, "define dso_local void @print_beq_after() {\n%1 = load i64, ptr @pc, align 8\n%2 = inttoptr i64 %1 to ptr\n%3 = call i32 @printf1(ptr noundef @.str, ptr noundef %2)\nret void\n}": {"base_truth": "define dso_local void @print_beq_after() {\nB:\n%0 = load i64, ptr @pc, align 8\n%1 = inttoptr i64 %0 to ptr\n%2 = tail call i32 @printf1(ptr noundef nonnull @.str, ptr noundef %1)\nret void\n}", "codellama": "define dso_local void @print_beq_after() {\nB:\n%0 = load i64, ptr @pc, align 8\n%1 = inttoptr i64 %0 to ptr\n%2 = tail call i32 @printf1(ptr noundef nonnull @.str, ptr noundef %1)\nret void\n}", "codegemma": "define dso_local void @print_beq_after() {\nB:\n%0 = load i64, ptr @pc, align 8\n%1 = inttoptr i64 %0 to ptr\n%2 = tail call i32 @printf1(ptr noundef nonnull @.str, ptr noundef %1)\nret void\n}"}, "define dso_local i32 @FreeFIB(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\n%4 = load i32, ptr %3, align 4\n%5 = load i32, ptr @FIB_TAG, align 4\n%6 = call i32 @ExFreePoolWithTag(i32 noundef %4, i32 noundef %5)\n%7 = load i32, ptr %2, align 4\nret i32 %7\n}": {"base_truth": "define dso_local i32 @FreeFIB(i32 noundef %0) {\nB:\n%1 = load i32, ptr @FIB_TAG, align 4\n%2 = tail call i32 @ExFreePoolWithTag(i32 noundef %0, i32 noundef %1)\nret i32 undef\n}", "codellama": "define dso_local i32 @FreeFIB(i32 noundef %0) {\nB:\n%1 = load i32, ptr @FIB_TAG, align 4\n%2 = tail call i32 @ExFreePoolWithTag(i32 noundef %0, i32 noundef %1)\nret i32 undef\n}", "codegemma": "define dso_local i32 @FreeFIB(i32 noundef %0) {\nB:\n%1 = load i32, ptr @FIB_TAG, align 4\n%2 = tail call i32 @ExFreePoolWithTag(i32 noundef %0, i32 noundef %1)\nret i32 undef\n}"}, "define dso_local void @ftp_html(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load ptr, ptr %2, align 8\n%5 = call i32 @printf(ptr noundef @.str, ptr noundef %3, ptr noundef %4)\nret void\n}": {"base_truth": "define dso_local void @ftp_html(ptr noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0, ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @ftp_html(ptr noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0, ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @ftp_html(ptr noundef %0) {\nB:\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0, ptr noundef %0)\nret void\n}"}, "define dso_local void @test_ignore_path__negative_prefix_rule() {\n%1 = call i32 @cl_git_rewritefile(ptr noundef @.str, ptr noundef @.str.1)\n%2 = call i32 @assert_is_ignored(i32 noundef 1, ptr noundef @.str.2)\n%3 = call i32 @assert_is_ignored(i32 noundef 1, ptr noundef @.str.3)\n%4 = call i32 @assert_is_ignored(i32 noundef 0, ptr noundef @.str.4)\nret void\n}": {"base_truth": "define dso_local void @test_ignore_path__negative_prefix_rule() {\nB:\n%0 = tail call i32 @cl_git_rewritefile(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\n%1 = tail call i32 @assert_is_ignored(i32 noundef 1, ptr noundef nonnull @.str.2)\n%2 = tail call i32 @assert_is_ignored(i32 noundef 1, ptr noundef nonnull @.str.3)\n%3 = tail call i32 @assert_is_ignored(i32 noundef 0, ptr noundef nonnull @.str.4)\nret void\n}", "codellama": "define dso_local void @test_ignore_path__negative_prefix_rule() {\nB:\n%0 = tail call i32 @cl_git_rewritefile(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\n%1 = tail call i32 @assert_is_ignored(i32 noundef 1, ptr noundef nonnull @.str.2)\n%2 = tail call i32 @assert_is_ignored(i32 noundef 1, ptr noundef nonnull @.str.3)\n%3 = tail call i32 @assert_is_ignored(i32 noundef 0, ptr noundef nonnull @.str.4)\nret void\n}", "codegemma": "define dso_local void @test_ignore_path__negative_prefix_rule() {\nB:\n%0 = tail call i32 @cl_git_rewritefile(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1)\n%1 = tail call i32 @assert_is_ignored(i32 noundef 1, ptr noundef nonnull @.str.2)\n%2 = tail call i32 @assert_is_ignored(i32 noundef 1, ptr noundef nonnull @.str.3)\n%3 = tail call i32 @assert_is_ignored(i32 noundef 0, ptr noundef nonnull @.str.4)\nret void\n}"}, "define dso_local i32 @getDamage(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\n%9 = call i32 (...) @rand()\nstore i32 %9, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %7)\n%10 = load i32, ptr %6, align 4\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.TYPE_6__, ptr %11, i32 0, i32 0\n%13 = getelementptr inbounds %struct.TYPE_5__, ptr %12, i32 0, i32 0\n%14 = load i32, ptr %13, align 4\n%15 = srem i32 %10, %14\n%16 = load ptr, ptr %5, align 8\n%17 = getelementptr inbounds %struct.TYPE_6__, ptr %16, i32 0, i32 0\n%18 = getelementptr inbounds %struct.TYPE_5__, ptr %17, i32 0, i32 1\n%19 = load i32, ptr %18, align 4\n%20 = sub nsw i32 %15, %19\n%21 = add nsw i32 %20, 1\nstore i32 %21, ptr %7, align 4\n%22 = load i32, ptr %7, align 4\n%23 = icmp sle i32 %22, 0\nbr i1 %23, label %24, label %25\n\n24:\nstore i32 0, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %27\n\n25:\n%26 = load i32, ptr %7, align 4\nstore i32 %26, ptr %3, align 4\nstore i32 1, ptr %8, align 4\nbr label %27\n\n27:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %7)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\n%28 = load i32, ptr %3, align 4\nret i32 %28\n}": {"base_truth": "define dso_local i32 @getDamage(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = tail call i32 (...) @rand()\n%3 = load i32, ptr %0, align 4\n%4 = srem i32 %2, %3\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = sub nsw i32 %4, %6\n%8 = icmp slt i32 %7, 0\n%9 = add nsw i32 %7, 1\n%10 = select i1 %8, i32 0, i32 %9\nret i32 %10\n}", "codellama": "define dso_local i32 @getDamage(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = tail call i32 (...) @rand()\n%3 = load i32, ptr %0, align 4\n%4 = srem i32 %2, %3\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = add i32 %4, 1\n%8 = sub i32 %7, %6\n%9 = tail call i32 @llvm.smax.i32(i32 %8, i32 0)\nret i32 %9\n}", "codegemma": "define dso_local i32 @getDamage(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = tail call i32 (...) @rand()\n%3 = load i32, ptr %0, align 4\n%4 = srem i32 %2, %3\n%5 = getelementptr inbounds %struct.TYPE_5__, ptr %1, i64 0, i32 1\n%6 = load i32, ptr %5, align 4\n%7 = add i32 %4, 1\n%8 = sub i32 %7, %6\n%9 = tail call i32 @llvm.smax.i32(i32 %8, i32 1)\nret i32 %9\n}"}, "define dso_local i32 @getPROCID() {\n%1 = alloca i32, align 4\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %2)\n%4 = call i32 (...) @getCPUID()\nstore i32 %4, ptr %2, align 4\n%5 = load i32, ptr %2, align 4\n%6 = lshr i32 %5, 4\n%7 = lshr i32 %6, 12\n%8 = and i32 %7, 15\n%9 = icmp eq i32 %8, 5\nbr i1 %9, label %10, label %13\n\n10:\n%11 = load i32, ptr %2, align 4\n%12 = and i32 %11, 63\nstore i32 %12, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %15\n\n13:\n%14 = load i32, ptr %2, align 4\nstore i32 %14, ptr %1, align 4\nstore i32 1, ptr %3, align 4\nbr label %15\n\n15:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %2)\n%16 = load i32, ptr %1, align 4\nret i32 %16\n}": {"base_truth": "define dso_local i32 @getPROCID() {\nB:\n%0 = tail call i32 (...) @getCPUID()\n%1 = and i32 %0, 983040\n%2 = icmp eq i32 %1, 327680\n%3 = and i32 %0, 63\n%4 = select i1 %2, i32 %3, i32 %0\nret i32 %4\n}", "codellama": "define dso_local i32 @getPROCID() {\nB:\n%0 = tail call i32 (...) @getCPUID()\n%1 = lshr i32 %0, 12\n%2 = and i32 %1, 15\n%3 = icmp eq i32 %2, 5\n%4 = and i32 %0, 63\n%5 = select i1 %3, i32 %4, i32 %0\nret i32 %5\n}", "codegemma": "define dso_local i32 @getPROCID() {\nB:\n%0 = tail call i32 (...) @getCPUID()\n%1 = lshr i32 %0, 4\n%2 = lshr i32 %1, 12\n%3 = and i32 %2, 15\n%4 = icmp eq i32 %3, 5\n%5 = and i32 %0, 63\n%6 = select i1 %4, i32 %5, i32 %0\nret i32 %6\n}"}, "define internal i32 @npcm_pspi_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @platform_get_drvdata(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @spi_master_get_devdata(ptr noundef %7)\nstore ptr %8, ptr %4, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = call i32 @npcm_pspi_reset_hw(ptr noundef %9)\n%11 = load ptr, ptr %4, align 8\n%12 = getelementptr inbounds %struct.npcm_pspi ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\n%14 = call i32 @clk_disable_unprepare(i32 noundef %13)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @npcm_pspi_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @spi_master_get_devdata(ptr noundef %1)\n%3 = tail call i32 @npcm_pspi_reset_hw(ptr noundef %2)\n%4 = load i32, ptr %2, align 4\n%5 = tail call i32 @clk_disable_unprepare(i32 noundef %4)\nret i32 0\n}", "codellama": "define internal i32 @npcm_pspi_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @spi_master_get_devdata(ptr noundef %1)\n%3 = tail call i32 @npcm_pspi_reset_hw(ptr noundef %2)\n%4 = load i32, ptr %2, align 4\n%5 = tail call i32 @clk_disable_unprepare(i32 noundef %4)\nret i32 0\n}", "codegemma": "define internal i32 @npcm_pspi_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @spi_master_get_devdata(ptr noundef %1)\n%3 = tail call i32 @npcm_pspi_reset_hw(ptr noundef %2)\n%4 = load i32, ptr %2, align 4\n%5 = tail call i32 @clk_disable_unprepare(i32 noundef %4)\nret i32 0\n}"}, "define dso_local ptr @expr_mul(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.TYPE_8__, ptr %5, i32 0, i32 0\n%7 = load i32, ptr %6, align 4\n%8 = load ptr, ptr %3, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = load i32, ptr @op_mul, align 4\n%11 = call ptr @expr_binary(i32 noundef %7, ptr noundef %8, ptr noundef %9, i32 noundef %10)\nret ptr %11\n}": {"base_truth": "define dso_local ptr @expr_mul(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr @op_mul, align 4\n%4 = tail call ptr @expr_binary(i32 noundef %2, ptr noundef nonnull %0, ptr noundef %1, i32 noundef %3)\nret ptr %4\n}", "codellama": "define dso_local ptr @expr_mul(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr @op_mul, align 4\n%4 = tail call ptr @expr_binary(i32 noundef %2, ptr noundef nonnull %0, ptr noundef %1, i32 noundef %3)\nret ptr %4\n}", "codegemma": "define dso_local ptr @expr_mul(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = load i32, ptr @op_mul, align 4\n%4 = tail call ptr @expr_binary(i32 noundef %2, ptr noundef nonnull %0, ptr noundef %1, i32 noundef %3)\nret ptr %4\n}"}, "define internal void @rza1_pin_set(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca i64, align 8\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %7)\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.rza1_port ptr %8, i32 0, i32 0\n%10 = load i64, ptr %7, align 8\n%11 = call i32 @spin_lock_irqsave(ptr noundef %9, i64 noundef %10)\n%12 = load ptr, ptr %4, align 8\n%13 = load i32, ptr @RZA1_P_REG, align 4\n%14 = load i32, ptr %5, align 4\n%15 = load i32, ptr %6, align 4\n%16 = icmp ne i32 %15, 0\n%17 = xor i1 %16, true\n%18 = xor i1 %17, true\n%19 = zext i1 %18 to i32\n%20 = call i32 @rza1_set_bit(ptr noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %19)\n%21 = load ptr, ptr %4, align 8\n%22 = getelementptr inbounds %struct.rza1_port ptr %21, i32 0, i32 0\n%23 = load i64, ptr %7, align 8\n%24 = call i32 @spin_unlock_irqrestore(ptr noundef %22, i64 noundef %23)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %7)\nret void\n}": {"base_truth": "define internal void @rza1_pin_set(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @spin_lock_irqsave(ptr noundef %0, i64 noundef undef)\n%4 = load i32, ptr @RZA1_P_REG, align 4\n%5 = icmp ne i32 %2, 0\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @rza1_set_bit(ptr noundef %0, i32 noundef %4, i32 noundef %1, i32 noundef %6)\n%8 = tail call i32 @spin_unlock_irqrestore(ptr noundef %0, i64 noundef undef)\nret void\n}", "codellama": "define internal void @rza1_pin_set(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @spin_lock_irqsave(ptr noundef %0, i64 noundef undef)\n%4 = load i32, ptr @RZA1_P_REG, align 4\n%5 = icmp ne i32 %2, 0\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @rza1_set_bit(ptr noundef %0, i32 noundef %4, i32 noundef %1, i32 noundef %6)\n%8 = tail call i32 @spin_unlock_irqrestore(ptr noundef %0, i64 noundef undef)\nret void\n}", "codegemma": "define internal void @rza1_pin_set(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @spin_lock_irqsave(ptr noundef %0, i64 noundef undef)\n%4 = load i32, ptr @RZA1_P_REG, align 4\n%5 = icmp ne i32 %2, 0\n%6 = zext i1 %5 to i32\n%7 = tail call i32 @rza1_set_bit(ptr noundef %0, i32 noundef %4, i32 noundef %1, i32 noundef %6)\n%8 = tail call i32 @spin_unlock_irqrestore(ptr noundef %0, i64 noundef undef)\nret void\n}"}, "define weak dso_local void @UART_Handler() {\n%1 = call i32 (...) @default_isr()\nret void\n}": {"base_truth": "define weak dso_local void @UART_Handler() {\nB:\n%0 = tail call i32 (...) @default_isr()\nret void\n}", "codellama": "define weak dso_local void @UART_Handler() {\nB:\n%0 = tail call i32 (...) @default_isr()\nret void\n}", "codegemma": "define weak dso_local void @UART_Handler() {\nB:\n%0 = tail call i32 (...) @default_isr()\nret void\n}"}, "define dso_local void @CRC_Init() {\n%1 = call i32 (...) @CRC_CalculateCRC8Table()\n%2 = call i32 (...) @CRC_CalculateCRC16Table()\n%3 = call i32 (...) @CRC_CalculateCRC32Table()\nret void\n}": {"base_truth": "define dso_local void @CRC_Init() {\nB:\n%0 = tail call i32 (...) @CRC_CalculateCRC8Table()\n%1 = tail call i32 (...) @CRC_CalculateCRC16Table()\n%2 = tail call i32 (...) @CRC_CalculateCRC32Table()\nret void\n}", "codellama": "define dso_local void @CRC_Init() {\nB:\n%0 = tail call i32 (...) @CRC_CalculateCRC8Table()\n%1 = tail call i32 (...) @CRC_CalculateCRC16Table()\n%2 = tail call i32 (...) @CRC_CalculateCRC32Table()\nret void\n}", "codegemma": "define dso_local void @CRC_Init() {\nB:\n%0 = tail call i32 (...) @CRC_CalculateCRC8Table()\n%1 = tail call i32 (...) @CRC_CalculateCRC16Table()\n%2 = tail call i32 (...) @CRC_CalculateCRC32Table()\nret void\n}"}, "define dso_local void @spfd5408_DisplayOff() {\n%1 = call i32 @spfd5408_WriteReg(i32 noundef 23, i32 noundef 0)\n%2 = call i32 @spfd5408_WriteReg(i32 noundef 24, i32 noundef 0)\n%3 = call i32 @spfd5408_WriteReg(i32 noundef 25, i32 noundef 0)\n%4 = call i32 @spfd5408_WriteReg(i32 noundef 28, i32 noundef 0)\n%5 = call i32 @spfd5408_WriteReg(i32 noundef 31, i32 noundef 0)\n%6 = call i32 @spfd5408_WriteReg(i32 noundef 54, i32 noundef 0)\n%7 = call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 56)\n%8 = call i32 @LCD_Delay(i32 noundef 60)\n%9 = call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 4)\nret void\n}": {"base_truth": "define dso_local void @spfd5408_DisplayOff() {\nB:\n%0 = tail call i32 @spfd5408_WriteReg(i32 noundef 23, i32 noundef 0)\n%1 = tail call i32 @spfd5408_WriteReg(i32 noundef 24, i32 noundef 0)\n%2 = tail call i32 @spfd5408_WriteReg(i32 noundef 25, i32 noundef 0)\n%3 = tail call i32 @spfd5408_WriteReg(i32 noundef 28, i32 noundef 0)\n%4 = tail call i32 @spfd5408_WriteReg(i32 noundef 31, i32 noundef 0)\n%5 = tail call i32 @spfd5408_WriteReg(i32 noundef 54, i32 noundef 0)\n%6 = tail call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 56)\n%7 = tail call i32 @LCD_Delay(i32 noundef 60)\n%8 = tail call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 4)\nret void\n}", "codellama": "define dso_local void @spfd5408_DisplayOff() {\nB:\n%0 = tail call i32 @spfd5408_WriteReg(i32 noundef 23, i32 noundef 0)\n%1 = tail call i32 @spfd5408_WriteReg(i32 noundef 24, i32 noundef 0)\n%2 = tail call i32 @spfd5408_WriteReg(i32 noundef 25, i32 noundef 0)\n%3 = tail call i32 @spfd5408_WriteReg(i32 noundef 28, i32 noundef 0)\n%4 = tail call i32 @spfd5408_WriteReg(i32 noundef 31, i32 noundef 0)\n%5 = tail call i32 @spfd5408_WriteReg(i32 noundef 54, i32 noundef 0)\n%6 = tail call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 56)\n%7 = tail call i32 @LCD_Delay(i32 noundef 60)\n%8 = tail call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 4)\nret void\n}", "codegemma": "define dso_local void @spfd5408_DisplayOff() {\nB:\n%0 = tail call i32 @spfd5408_WriteReg(i32 noundef 23, i32 noundef 0)\n%1 = tail call i32 @spfd5408_WriteReg(i32 noundef 24, i32 noundef 0)\n%2 = tail call i32 @spfd5408_WriteReg(i32 noundef 25, i32 noundef 0)\n%3 = tail call i32 @spfd5408_WriteReg(i32 noundef 28, i32 noundef 0)\n%4 = tail call i32 @spfd5408_WriteReg(i32 noundef 31, i32 noundef 0)\n%5 = tail call i32 @spfd5408_WriteReg(i32 noundef 54, i32 noundef 0)\n%6 = tail call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 56)\n%7 = tail call i32 @LCD_Delay(i32 noundef 60)\n%8 = tail call i32 @spfd5408_WriteReg(i32 noundef 40, i32 noundef 4)\nret void\n}"}, "define dso_local void @main() {\n%1 = call i32 (...) @test_random()\n%2 = call i32 (...) @test_once()\nret void\n}": {"base_truth": "define dso_local void @main() {\nB:\n%0 = tail call i32 (...) @test_random()\n%1 = tail call i32 (...) @test_once()\nret void\n}", "codellama": "define dso_local void @main() {\nB:\n%0 = tail call i32 (...) @test_random()\n%1 = tail call i32 (...) @test_once()\nret void\n}", "codegemma": "define dso_local void @main() {\nB:\n%0 = tail call i32 (...) @test_random()\n%1 = tail call i32 (...) @test_once()\nret void\n}"}, "define dso_local void @gadgetclose() {\n%1 = load i32, ptr @fd, align 4\n%2 = call i32 @close(i32 noundef %1)\nret void\n}": {"base_truth": "define dso_local void @gadgetclose() {\nB:\n%0 = load i32, ptr @fd, align 4\n%1 = tail call i32 @close(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @gadgetclose() {\nB:\n%0 = load i32, ptr @fd, align 4\n%1 = tail call i32 @close(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @gadgetclose() {\nB:\n%0 = load i32, ptr @fd, align 4\n%1 = tail call i32 @close(i32 noundef %0)\nret void\n}"}, "define internal void @spu_PrerenderEnqueue(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = getelementptr inbounds %struct.TYPE_5__, ptr %5, i32 0, i32 0\n%7 = getelementptr inbounds %struct.TYPE_4__, ptr %6, i32 0, i32 0\n%8 = call i32 @vlc_mutex_lock(ptr noundef %7)\n%9 = load ptr, ptr %3, align 8\n%10 = getelementptr inbounds %struct.TYPE_5__, ptr %9, i32 0, i32 0\n%11 = getelementptr inbounds %struct.TYPE_4__, ptr %10, i32 0, i32 2\n%12 = load ptr, ptr %4, align 8\n%13 = call i32 @vlc_vector_push(ptr noundef %11, ptr noundef %12)\n%14 = load ptr, ptr %3, align 8\n%15 = getelementptr inbounds %struct.TYPE_5__, ptr %14, i32 0, i32 0\n%16 = getelementptr inbounds %struct.TYPE_4__, ptr %15, i32 0, i32 1\n%17 = call i32 @vlc_cond_signal(ptr noundef %16)\n%18 = load ptr, ptr %3, align 8\n%19 = getelementptr inbounds %struct.TYPE_5__, ptr %18, i32 0, i32 0\n%20 = getelementptr inbounds %struct.TYPE_4__, ptr %19, i32 0, i32 0\n%21 = call i32 @vlc_mutex_unlock(ptr noundef %20)\nret void\n}": {"base_truth": "define internal void @spu_PrerenderEnqueue(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @vlc_mutex_lock(ptr noundef %0)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 2\n%4 = tail call i32 @vlc_vector_push(ptr noundef nonnull %3, ptr noundef %1)\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%6 = tail call i32 @vlc_cond_signal(ptr noundef nonnull %5)\n%7 = tail call i32 @vlc_mutex_unlock(ptr noundef %0)\nret void\n}", "codellama": "define internal void @spu_PrerenderEnqueue(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @vlc_mutex_lock(ptr noundef %0)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 2\n%4 = tail call i32 @vlc_vector_push(ptr noundef nonnull %3, ptr noundef %1)\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%6 = tail call i32 @vlc_cond_signal(ptr noundef nonnull %5)\n%7 = tail call i32 @vlc_mutex_unlock(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @spu_PrerenderEnqueue(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @vlc_mutex_lock(ptr noundef %0)\n%3 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 2\n%4 = tail call i32 @vlc_vector_push(ptr noundef nonnull %3, ptr noundef %1)\n%5 = getelementptr inbounds %struct.TYPE_4__, ptr %0, i64 0, i32 1\n%6 = tail call i32 @vlc_cond_signal(ptr noundef nonnull %5)\n%7 = tail call i32 @vlc_mutex_unlock(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @ajouter_ensemble(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5) {\n%7 = alloca i32, align 4\n%8 = alloca ptr, align 8\n%9 = alloca ptr, align 8\n%10 = alloca ptr, align 8\n%11 = alloca ptr, align 8\n%12 = alloca ptr, align 8\n%13 = alloca i32, align 4\n%14 = alloca i32, align 4\n%15 = alloca i32, align 4\nstore ptr %0, ptr %8, align 8\nstore ptr %1, ptr %9, align 8\nstore ptr %2, ptr %10, align 8\nstore ptr %3, ptr %11, align 8\nstore ptr %4, ptr %12, align 8\nstore i32 %5, ptr %13, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %14)\n%16 = load ptr, ptr %9, align 8\n%17 = load ptr, ptr %8, align 8\n%18 = ptrtoint ptr %17 to i64\n%19 = call i32 @trouver_table(ptr noundef %16, i64 noundef %18)\nstore i32 %19, ptr %14, align 4\n%20 = load i32, ptr %14, align 4\n%21 = call i64 @iterateur_est_vide(i32 noundef %20)\n%22 = icmp ne i64 %21, 0\nbr i1 %22, label %23, label %45\n\n23:\n%24 = load ptr, ptr %9, align 8\n%25 = load ptr, ptr %8, align 8\n%26 = ptrtoint ptr %25 to i64\n%27 = trunc i64 %26 to i32\n%28 = load i32, ptr %13, align 4\n%29 = sext i32 %28 to i64\n%30 = call i32 @add_table(ptr noundef %24, i32 noundef %27, i64 noundef %29)\n%31 = load ptr, ptr %10, align 8\n%32 = load i32, ptr %13, align 4\n%33 = load ptr, ptr %8, align 8\n%34 = ptrtoint ptr %33 to i64\n%35 = call i32 @add_table(ptr noundef %31, i32 noundef %32, i64 noundef %34)\n%36 = load ptr, ptr %11, align 8\n%37 = load ptr, ptr %8, align 8\n%38 = ptrtoint ptr %37 to i64\n%39 = call i32 @ajouter_fifo(ptr noundef %36, i64 noundef %38)\n%40 = load ptr, ptr %12, align 8\n%41 = load i32, ptr %13, align 4\n%42 = call i32 @ajouter_etat(ptr noundef %40, i32 noundef %41)\n%43 = load i32, ptr %13, align 4\n%44 = add nsw i32 %43, 1\nstore i32 %44, ptr %7, align 4\nstore i32 1, ptr %15, align 4\nbr label %47\n\n45:\n%46 = load i32, ptr %13, align 4\nstore i32 %46, ptr %7, align 4\nstore i32 1, ptr %15, align 4\nbr label %47\n\n47:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %14)\n%48 = load i32, ptr %7, align 4\nret i32 %48\n}": {"base_truth": "define dso_local i32 @ajouter_ensemble(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5) {\nB:\n%6 = ptrtoint ptr %0 to i64\n%7 = tail call i32 @trouver_table(ptr noundef %1, i64 noundef %6)\n%8 = tail call i64 @iterateur_est_vide(i32 noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = add nsw i32 %5, 1\n%11 = sext i32 %5 to i64\n%12 = trunc i64 %6 to i32\n%13 = tail call i32 @add_table(ptr noundef %1, i32 noundef %12, i64 noundef %11)\n%14 = tail call i32 @add_table(ptr noundef %2, i32 noundef %5, i64 noundef %6)\n%15 = tail call i32 @ajouter_fifo(ptr noundef %3, i64 noundef %6)\n%16 = tail call i32 @ajouter_etat(ptr noundef %4, i32 noundef %5)\nbr label %B2\n\nB2:\n%17 = phi i32 [ %10, %B1 ], [ %5, %B ]\nret i32 %17\n}", "codellama": "define dso_local i32 @ajouter_ensemble(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5) {\nB:\n%6 = ptrtoint ptr %0 to i64\n%7 = tail call i32 @trouver_table(ptr noundef %1, i64 noundef %6)\n%8 = tail call i64 @iterateur_est_vide(i32 noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = trunc i64 %6 to i32\n%11 = sext i32 %5 to i64\n%12 = tail call i32 @add_table(ptr noundef %1, i32 noundef %10, i64 noundef %11)\n%13 = tail call i32 @add_table(ptr noundef %2, i32 noundef %5, i64 noundef %6)\n%14 = tail call i32 @ajouter_fifo(ptr noundef %3, i64 noundef %6)\n%15 = tail call i32 @ajouter_etat(ptr noundef %4, i32 noundef %5)\n%16 = add nsw i32 %5, 1\nbr label %B2\n\nB2:\n%17 = phi i32 [ %16, %B1 ], [ %5, %B ]\nret i32 %17\n}", "codegemma": "define dso_local i32 @ajouter_ensemble(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5) {\nB:\n%6 = ptrtoint ptr %0 to i64\n%7 = tail call i32 @trouver_table(ptr noundef %1, i64 noundef %6)\n%8 = tail call i64 @iterateur_est_vide(i32 noundef %7)\n%9 = icmp eq i64 %8, 0\nbr i1 %9, label %B2, label %B1\n\nB1:\n%10 = trunc i64 %6 to i32\n%11 = sext i32 %5 to i64\n%12 = tail call i32 @add_table(ptr noundef %1, i32 noundef %10, i64 noundef %11)\n%13 = tail call i32 @add_table(ptr noundef %2, i32 noundef %5, i64 noundef %6)\n%14 = tail call i32 @ajouter_fifo(ptr noundef %3, i64 noundef %6)\n%15 = tail call i32 @ajouter_etat(ptr noundef %4, i32 noundef %5)\n%16 = add nsw i32 %5, 1\nbr label %B2\n\nB2:\n%17 = phi i32 [ %16, %B1 ], [ %5, %B ]\nret i32 %17\n}"}, "define internal void @m68k_op_sf_8_pi() {\n%1 = call i32 (...) @EA_AY_PI_8()\n%2 = call i32 @m68ki_write_8(i32 noundef %1, i32 noundef 0)\nret void\n}": {"base_truth": "define internal void @m68k_op_sf_8_pi() {\nB:\n%0 = tail call i32 (...) @EA_AY_PI_8()\n%1 = tail call i32 @m68ki_write_8(i32 noundef %0, i32 noundef 0)\nret void\n}", "codellama": "define internal void @m68k_op_sf_8_pi() {\nB:\n%0 = tail call i32 (...) @EA_AY_PI_8()\n%1 = tail call i32 @m68ki_write_8(i32 noundef %0, i32 noundef 0)\nret void\n}", "codegemma": "define internal void @m68k_op_sf_8_pi() {\nB:\n%0 = tail call i32 (...) @EA_AY_PI_8()\n%1 = tail call i32 @m68ki_write_8(i32 noundef %0, i32 noundef 0)\nret void\n}"}, "define internal void @ip32_irq5() {\n%1 = load i64, ptr @MIPS_CPU_IRQ_BASE, align 8\n%2 = add nsw i64 %1, 7\n%3 = call i32 @do_IRQ(i64 noundef %2)\nret void\n}": {"base_truth": "define internal void @ip32_irq5() {\nB:\n%0 = load i64, ptr @MIPS_CPU_IRQ_BASE, align 8\n%1 = add nsw i64 %0, 7\n%2 = tail call i32 @do_IRQ(i64 noundef %1)\nret void\n}", "codellama": "define internal void @ip32_irq5() {\nB:\n%0 = load i64, ptr @MIPS_CPU_IRQ_BASE, align 8\n%1 = add nsw i64 %0, 7\n%2 = tail call i32 @do_IRQ(i64 noundef %1)\nret void\n}", "codegemma": "define internal void @ip32_irq5() {\nB:\n%0 = load i64, ptr @MIPS_CPU_IRQ_BASE, align 8\n%1 = add nsw i64 %0, 7\n%2 = tail call i32 @do_IRQ(i64 noundef %1)\nret void\n}"}, "define dso_local void @opcode_e2() {\n%1 = call i32 (...) @ld_c_relative_a()\nret void\n}": {"base_truth": "define dso_local void @opcode_e2() {\nB:\n%0 = tail call i32 (...) @ld_c_relative_a()\nret void\n}", "codellama": "define dso_local void @opcode_e2() {\nB:\n%0 = tail call i32 (...) @ld_c_relative_a()\nret void\n}", "codegemma": "define dso_local void @opcode_e2() {\nB:\n%0 = tail call i32 (...) @ld_c_relative_a()\nret void\n}"}, "define dso_local void @BackFill(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %5)\n%6 = load i32, ptr %3, align 4\n%7 = and i32 %6, 63\nstore i32 %7, ptr %5, align 4\n%8 = load i32, ptr %4, align 4\n%9 = shl i32 %8, 6\n%10 = load i32, ptr %5, align 4\n%11 = or i32 %10, %9\nstore i32 %11, ptr %5, align 4\n%12 = load i32, ptr %5, align 4\n%13 = shl i32 %12, 8\n%14 = load i32, ptr %5, align 4\n%15 = or i32 %14, %13\nstore i32 %15, ptr %5, align 4\n%16 = load i32, ptr %5, align 4\n%17 = shl i32 %16, 16\n%18 = load i32, ptr %5, align 4\n%19 = or i32 %18, %17\nstore i32 %19, ptr %5, align 4\n%20 = load i64, ptr @HighCol, align 8\n%21 = add nsw i64 %20, 8\n%22 = inttoptr i64 %21 to ptr\n%23 = load i32, ptr %5, align 4\n%24 = call i32 @memset32(ptr noundef %22, i32 noundef %23, i32 noundef 80)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %5)\nret void\n}": {"base_truth": "define dso_local void @BackFill(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = and i32 %0, 63\n%3 = shl i32 %1, 6\n%4 = or i32 %3, %2\n%5 = shl i32 %4, 8\n%6 = or i32 %5, %4\n%7 = shl i32 %6, 16\n%8 = or i32 %7, %6\n%9 = load i64, ptr @HighCol, align 8\n%10 = add nsw i64 %9, 8\n%11 = inttoptr i64 %10 to ptr\n%12 = tail call i32 @memset32(ptr noundef %11, i32 noundef %8, i32 noundef 80)\nret void\n}", "codellama": "define dso_local void @BackFill(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = and i32 %0, 63\n%3 = shl i32 %1, 6\n%4 = or i32 %3, %2\n%5 = shl i32 %4, 8\n%6 = shl i32 %4, 16\n%7 = or i32 %6, %5\n%8 = load i64, ptr @HighCol, align 8\n%9 = add nsw i64 %8, 8\n%10 = inttoptr i64 %9 to ptr\n%11 = tail call i32 @memset32(ptr noundef %10, i32 noundef %7, i32 noundef 80)\nret void\n}", "codegemma": "define dso_local void @BackFill(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = and i32 %0, 63\n%3 = shl i32 %1, 6\n%4 = or i32 %3, %2\n%5 = shl i32 %4, 8\n%6 = or i32 %5, %4\n%7 = shl i32 %6, 16\n%8 = or i32 %7, %6\n%9 = load i64, ptr @HighCol, align 8\n%10 = add nsw i64 %9, 8\n%11 = inttoptr i64 %10 to ptr\n%12 = tail call i32 @memset32(ptr noundef %11, i32 noundef %8, i32 noundef 80)\nret void\n}"}, "define dso_local void @shine_close(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @shine_bitstream_close(ptr noundef %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @shine_formatbits_close(ptr noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.TYPE_6__, ptr %7, i32 0, i32 0\n%9 = call i32 @shine_close_bit_stream(ptr noundef %8)\n%10 = load ptr, ptr %2, align 8\n%11 = call i32 @free(ptr noundef %10)\nret void\n}": {"base_truth": "define dso_local void @shine_close(ptr noundef %0) {\nB:\n%1 = tail call i32 @shine_bitstream_close(ptr noundef %0)\n%2 = tail call i32 @shine_formatbits_close(ptr noundef %0)\n%3 = tail call i32 @shine_close_bit_stream(ptr noundef %0)\n%4 = tail call i32 @free(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @shine_close(ptr noundef %0) {\nB:\n%1 = tail call i32 @shine_bitstream_close(ptr noundef %0)\n%2 = tail call i32 @shine_formatbits_close(ptr noundef %0)\n%3 = tail call i32 @shine_close_bit_stream(ptr noundef %0)\n%4 = tail call i32 @free(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @shine_close(ptr noundef %0) {\nB:\n%1 = tail call i32 @shine_bitstream_close(ptr noundef %0)\n%2 = tail call i32 @shine_formatbits_close(ptr noundef %0)\n%3 = tail call i32 @shine_close_bit_stream(ptr noundef %0)\n%4 = tail call i32 @free(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @Gawsetmode(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\nret i32 0\n}": {"base_truth": "define dso_local i32 @Gawsetmode(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @Gawsetmode(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @Gawsetmode(ptr nocapture noundef readnone %0, i32 noundef %1) {\nB:\nret i32 0\n}"}, "define dso_local i32 @MPEG2_reset(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\n%4 = load ptr, ptr %3, align 8\n%5 = icmp ne ptr %4, null\nbr i1 %5, label %7, label %6\n\n6:\nstore i32 -3, ptr %2, align 4\nbr label %8\n\n7:\nstore i32 0, ptr %2, align 4\nbr label %8\n\n8:\n%9 = load i32, ptr %2, align 4\nret i32 %9\n}": {"base_truth": "define dso_local i32 @MPEG2_reset(ptr noundef readnone %0) {\nB:\n%1 = icmp eq ptr %0, null\n%2 = select i1 %1, i32 -3, i32 0\nret i32 %2\n}", "codellama": "define dso_local i32 @MPEG2_reset(ptr noundef readnone %0) {\nB:\n%1 = icmp eq ptr %0, null\n%2 = select i1 %1, i32 -3, i32 0\nret i32 %2\n}", "codegemma": "define dso_local i32 @MPEG2_reset(ptr noundef readnone %0) {\nB:\n%1 = icmp eq ptr %0, null\n%2 = sext i1 %1 to i32\nret i32 %2\n}"}, "define dso_local i32 @s_is_playing(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\nret i32 0\n}": {"base_truth": "define dso_local i32 @s_is_playing(i32 noundef %0) {\nB:\nret i32 0\n}", "codellama": "define dso_local i32 @s_is_playing(i32 noundef %0) {\nB:\nret i32 0\n}", "codegemma": "define dso_local i32 @s_is_playing(i32 noundef %0) {\nB:\nret i32 0\n}"}, "define dso_local void @Use_Reflective_Boundary() {\nstore i32 1, ptr @Boundary_Case_8qm5, align 4\nret void\n}": {"base_truth": "define dso_local void @Use_Reflective_Boundary() {\nB:\nstore i32 1, ptr @Boundary_Case_8qm5, align 4\nret void\n}", "codellama": "define dso_local void @Use_Reflective_Boundary() {\nB:\nstore i32 1, ptr @Boundary_Case_8qm5, align 4\nret void\n}", "codegemma": "define dso_local void @Use_Reflective_Boundary() {\nB:\nstore i32 1, ptr @Boundary_Case_8qm5, align 4\nret void\n}"}, "define internal void @tv_disconnect(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @usb_get_intfdata(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %2, align 8\n%7 = getelementptr inbounds %struct.usb_interface ptr %6, i32 0, i32 0\n%8 = call i32 @device_remove_file(ptr noundef %7, ptr noundef @dev_attr_speed)\n%9 = load ptr, ptr %2, align 8\n%10 = call i32 @usb_set_intfdata(ptr noundef %9, ptr noundef null)\n%11 = load ptr, ptr %3, align 8\n%12 = getelementptr inbounds %struct.trancevibrator ptr %11, i32 0, i32 0\n%13 = load i32, ptr %12, align 4\n%14 = call i32 @usb_put_dev(i32 noundef %13)\n%15 = load ptr, ptr %3, align 8\n%16 = call i32 @kfree(ptr noundef %15)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @tv_disconnect(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @device_remove_file(ptr noundef %0, ptr noundef nonnull @dev_attr_speed)\n%3 = tail call i32 @usb_set_intfdata(ptr noundef %0, ptr noundef null)\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @usb_put_dev(i32 noundef %4)\n%6 = tail call i32 @kfree(ptr noundef nonnull %1)\nret void\n}", "codellama": "define internal void @tv_disconnect(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @device_remove_file(ptr noundef %0, ptr noundef nonnull @dev_attr_speed)\n%3 = tail call i32 @usb_set_intfdata(ptr noundef %0, ptr noundef null)\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @usb_put_dev(i32 noundef %4)\n%6 = tail call i32 @kfree(ptr noundef nonnull %1)\nret void\n}", "codegemma": "define internal void @tv_disconnect(ptr noundef %0) {\nB:\n%1 = tail call ptr @usb_get_intfdata(ptr noundef %0)\n%2 = tail call i32 @device_remove_file(ptr noundef %0, ptr noundef nonnull @dev_attr_speed)\n%3 = tail call i32 @usb_set_intfdata(ptr noundef %0, ptr noundef null)\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @usb_put_dev(i32 noundef %4)\n%6 = tail call i32 @kfree(ptr noundef nonnull %1)\nret void\n}"}, "define dso_local void @display_help() {\n%1 = load ptr, ptr @exe_name, align 8\n%2 = call i32 @printf(ptr noundef @.str, ptr noundef %1)\n%3 = call i32 @exit(i32 noundef 0)\nunreachable\n}": {"base_truth": "define dso_local void @display_help() {\nB:\n%0 = load ptr, ptr @exe_name, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\n%2 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codellama": "define dso_local void @display_help() {\nB:\n%0 = load ptr, ptr @exe_name, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\n%2 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}", "codegemma": "define dso_local void @display_help() {\nB:\n%0 = load ptr, ptr @exe_name, align 8\n%1 = tail call i32 @printf(ptr noundef nonnull @.str, ptr noundef %0)\n%2 = tail call i32 @exit(i32 noundef 0)\nunreachable\n}"}, "define dso_local void @glBlendEquationi(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %3, align 4\n%6 = load i32, ptr %4, align 4\n%7 = call i32 @next_glBlendEquationi(i32 noundef %5, i32 noundef %6)\n%8 = call i32 (...) @printGLError()\n%9 = load i32, ptr %3, align 4\n%10 = load i32, ptr %4, align 4\n%11 = call i32 @getEnumString(i32 noundef %10)\n%12 = call i32 @debugPrint(ptr noundef @.str, i32 noundef %9, i32 noundef %11)\nret void\n}": {"base_truth": "define dso_local void @glBlendEquationi(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @next_glBlendEquationi(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @printGLError()\n%4 = tail call i32 @getEnumString(i32 noundef %1)\n%5 = tail call i32 @debugPrint(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %4)\nret void\n}", "codellama": "define dso_local void @glBlendEquationi(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @next_glBlendEquationi(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @printGLError()\n%4 = tail call i32 @getEnumString(i32 noundef %1)\n%5 = tail call i32 @debugPrint(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %4)\nret void\n}", "codegemma": "define dso_local void @glBlendEquationi(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call i32 @next_glBlendEquationi(i32 noundef %0, i32 noundef %1)\n%3 = tail call i32 (...) @printGLError()\n%4 = tail call i32 @getEnumString(i32 noundef %1)\n%5 = tail call i32 @debugPrint(ptr noundef nonnull @.str, i32 noundef %0, i32 noundef %4)\nret void\n}"}, "define dso_local i32 @lcd_width() {\n%1 = load i32, ptr @lcd, align 4\nret i32 %1\n}": {"base_truth": "define dso_local i32 @lcd_width() {\nB:\n%0 = load i32, ptr @lcd, align 4\nret i32 %0\n}", "codellama": "define dso_local i32 @lcd_width() {\nB:\n%0 = load i32, ptr @lcd, align 4\nret i32 %0\n}", "codegemma": "define dso_local i32 @lcd_width() {\nB:\n%0 = load i32, ptr @lcd, align 4\nret i32 %0\n}"}, "define internal i32 @is_color_size(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = icmp eq i32 %3, 4\n%5 = zext i1 %4 to i32\nret i32 %5\n}": {"base_truth": "define internal i32 @is_color_size(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 4\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codellama": "define internal i32 @is_color_size(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 4\n%2 = zext i1 %1 to i32\nret i32 %2\n}", "codegemma": "define internal i32 @is_color_size(i32 noundef %0) {\nB:\n%1 = icmp eq i32 %0, 4\n%2 = zext i1 %1 to i32\nret i32 %2\n}"}, "define internal void @rt2880_pci_reg_write(i64 noundef %0, i64 noundef %1) {\n%3 = alloca i64, align 8\n%4 = alloca i64, align 8\nstore i64 %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %3, align 8\n%6 = load i64, ptr @rt2880_pci_base, align 8\n%7 = load i64, ptr %4, align 8\n%8 = add nsw i64 %6, %7\n%9 = call i32 @writel(i64 noundef %5, i64 noundef %8)\nret void\n}": {"base_truth": "define internal void @rt2880_pci_reg_write(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr @rt2880_pci_base, align 8\n%3 = add nsw i64 %2, %1\n%4 = tail call i32 @writel(i64 noundef %0, i64 noundef %3)\nret void\n}", "codellama": "define internal void @rt2880_pci_reg_write(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr @rt2880_pci_base, align 8\n%3 = add nsw i64 %2, %1\n%4 = tail call i32 @writel(i64 noundef %0, i64 noundef %3)\nret void\n}", "codegemma": "define internal void @rt2880_pci_reg_write(i64 noundef %0, i64 noundef %1) {\nB:\n%2 = load i64, ptr @rt2880_pci_base, align 8\n%3 = add nsw i64 %2, %1\n%4 = tail call i32 @writel(i64 noundef %0, i64 noundef %3)\nret void\n}"}, "define dso_local i32 @BBM_DATA(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\n%7 = alloca ptr, align 8\n%8 = alloca i32, align 4\n%9 = alloca i32, align 4\nstore i32 %0, ptr %5, align 4\nstore i32 %1, ptr %6, align 4\nstore ptr %2, ptr %7, align 8\nstore i32 %3, ptr %8, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %9)\n%10 = load i32, ptr %5, align 4\n%11 = load i32, ptr %6, align 4\n%12 = load ptr, ptr %7, align 8\n%13 = load i32, ptr %8, align 4\n%14 = call i32 @bbm_data(i32 noundef %10, i32 noundef %11, ptr noundef %12, i32 noundef %13)\nstore i32 %14, ptr %9, align 4\n%15 = load i32, ptr %9, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %9)\nret i32 %15\n}": {"base_truth": "define dso_local i32 @BBM_DATA(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i32 @bbm_data(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3)\nret i32 %4\n}", "codellama": "define dso_local i32 @BBM_DATA(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i32 @bbm_data(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3)\nret i32 %4\n}", "codegemma": "define dso_local i32 @BBM_DATA(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) {\nB:\n%4 = tail call i32 @bbm_data(i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3)\nret i32 %4\n}"}, "define dso_local i32 @STORE_method_get_unlock_store_function(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @STORE_method_get_unlock_store_function(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @STORE_method_get_unlock_store_function(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @STORE_method_get_unlock_store_function(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local i64 @crypto_box_noncebytes() {\n%1 = load i64, ptr @crypto_box_NONCEBYTES, align 8\nret i64 %1\n}": {"base_truth": "define dso_local i64 @crypto_box_noncebytes() {\nB:\n%0 = load i64, ptr @crypto_box_NONCEBYTES, align 8\nret i64 %0\n}", "codellama": "define dso_local i64 @crypto_box_noncebytes() {\nB:\n%0 = load i64, ptr @crypto_box_NONCEBYTES, align 8\nret i64 %0\n}", "codegemma": "define dso_local i64 @crypto_box_noncebytes() {\nB:\n%0 = load i64, ptr @crypto_box_NONCEBYTES, align 8\nret i64 %0\n}"}, "define dso_local i32 @do_epoll_wait(i32 noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) {\n%5 = alloca i32, align 4\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\n%8 = alloca i32, align 4\nstore i32 %0, ptr %5, align 4\nstore ptr %1, ptr %6, align 8\nstore i32 %2, ptr %7, align 4\nstore i32 %3, ptr %8, align 4\n%9 = load i32, ptr %5, align 4\n%10 = load ptr, ptr %6, align 8\n%11 = getelementptr inbounds %struct.TYPE_3__, ptr %10, i32 0, i32 0\n%12 = load i32, ptr %11, align 4\n%13 = load i32, ptr %7, align 4\n%14 = load i32, ptr %8, align 4\n%15 = call i32 @epoll_wait(i32 noundef %9, i32 noundef %12, i32 noundef %13, i32 noundef %14)\nret i32 %15\n}": {"base_truth": "define dso_local i32 @do_epoll_wait(i32 noundef %0, ptr nocapture noundef readonly %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @epoll_wait(i32 noundef %0, i32 noundef %4, i32 noundef %2, i32 noundef %3)\nret i32 %5\n}", "codellama": "define dso_local i32 @do_epoll_wait(i32 noundef %0, ptr nocapture noundef readonly %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @epoll_wait(i32 noundef %0, i32 noundef %4, i32 noundef %2, i32 noundef %3)\nret i32 %5\n}", "codegemma": "define dso_local i32 @do_epoll_wait(i32 noundef %0, ptr nocapture noundef readonly %1, i32 noundef %2, i32 noundef %3) {\nB:\n%4 = load i32, ptr %1, align 4\n%5 = tail call i32 @epoll_wait(i32 noundef %0, i32 noundef %4, i32 noundef %2, i32 noundef %3)\nret i32 %5\n}"}, "define internal void @apply_handle_type(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load i32, ptr %2, align 4\n%5 = call i32 @logicalrep_read_typ(i32 noundef %4, ptr noundef %3)\n%6 = call i32 @logicalrep_typmap_update(ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret void\n}": {"base_truth": "define internal void @apply_handle_type(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @logicalrep_read_typ(i32 noundef %0, ptr noundef nonnull %1)\n%3 = call i32 @logicalrep_typmap_update(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codellama": "define internal void @apply_handle_type(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @logicalrep_read_typ(i32 noundef %0, ptr noundef nonnull %1)\n%3 = call i32 @logicalrep_typmap_update(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}", "codegemma": "define internal void @apply_handle_type(i32 noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = call i32 @logicalrep_read_typ(i32 noundef %0, ptr noundef nonnull %1)\n%3 = call i32 @logicalrep_typmap_update(ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret void\n}"}, "define dso_local i32 @bta_sys_is_register(i64 noundef %0) {\n%2 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\n%3 = load ptr, ptr @bta_sys_cb, align 8\n%4 = load i64, ptr %2, align 8\n%5 = getelementptr inbounds i32, ptr %3, i64 %4\n%6 = load i32, ptr %5, align 4\nret i32 %6\n}": {"base_truth": "define dso_local i32 @bta_sys_is_register(i64 noundef %0) {\nB:\n%1 = load ptr, ptr @bta_sys_cb, align 8\n%2 = getelementptr inbounds i32, ptr %1, i64 %0\n%3 = load i32, ptr %2, align 4\nret i32 %3\n}", "codellama": "define dso_local i32 @bta_sys_is_register(i64 noundef %0) {\nB:\n%1 = load ptr, ptr @bta_sys_cb, align 8\n%2 = getelementptr inbounds i32, ptr %1, i64 %0\n%3 = load i32, ptr %2, align 4\nret i32 %3\n}", "codegemma": "define dso_local i32 @bta_sys_is_register(i64 noundef %0) {\nB:\n%1 = load ptr, ptr @bta_sys_cb, align 8\n%2 = getelementptr inbounds i32, ptr %1, i64 %0\n%3 = load i32, ptr %2, align 4\nret i32 %3\n}"}, "define internal void @bfa_iocpf_sm_fail_entry(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.bfa_iocpf_s ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\n%6 = call i32 @bfa_trc(i32 noundef %5, i32 noundef 0)\nret void\n}": {"base_truth": "define internal void @bfa_iocpf_sm_fail_entry(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @bfa_trc(i32 noundef %1, i32 noundef 0)\nret void\n}", "codellama": "define internal void @bfa_iocpf_sm_fail_entry(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @bfa_trc(i32 noundef %1, i32 noundef 0)\nret void\n}", "codegemma": "define internal void @bfa_iocpf_sm_fail_entry(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\n%2 = tail call i32 @bfa_trc(i32 noundef %1, i32 noundef 0)\nret void\n}"}, "define internal i32 @mtk_pcie_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%5 = load ptr, ptr %2, align 8\n%6 = call ptr @platform_get_drvdata(ptr noundef %5)\nstore ptr %6, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %4)\n%7 = load ptr, ptr %3, align 8\n%8 = call ptr @pci_host_bridge_from_priv(ptr noundef %7)\nstore ptr %8, ptr %4, align 8\n%9 = load ptr, ptr %4, align 8\n%10 = getelementptr inbounds %struct.pci_host_bridge ptr %9, i32 0, i32 0\n%11 = load i32, ptr %10, align 4\n%12 = call i32 @pci_stop_root_bus(i32 noundef %11)\n%13 = load ptr, ptr %4, align 8\n%14 = getelementptr inbounds %struct.pci_host_bridge ptr %13, i32 0, i32 0\n%15 = load i32, ptr %14, align 4\n%16 = call i32 @pci_remove_root_bus(i32 noundef %15)\n%17 = load ptr, ptr %3, align 8\n%18 = call i32 @mtk_pcie_free_resources(ptr noundef %17)\n%19 = load ptr, ptr %3, align 8\n%20 = call i32 @mtk_pcie_irq_teardown(ptr noundef %19)\n%21 = load ptr, ptr %3, align 8\n%22 = call i32 @mtk_pcie_put_resources(ptr noundef %21)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %4)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 0\n}": {"base_truth": "define internal i32 @mtk_pcie_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @pci_host_bridge_from_priv(ptr noundef %1)\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @pci_stop_root_bus(i32 noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @pci_remove_root_bus(i32 noundef %5)\n%7 = tail call i32 @mtk_pcie_free_resources(ptr noundef %1)\n%8 = tail call i32 @mtk_pcie_irq_teardown(ptr noundef %1)\n%9 = tail call i32 @mtk_pcie_put_resources(ptr noundef %1)\nret i32 0\n}", "codellama": "define internal i32 @mtk_pcie_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @pci_host_bridge_from_priv(ptr noundef %1)\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @pci_stop_root_bus(i32 noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @pci_remove_root_bus(i32 noundef %5)\n%7 = tail call i32 @mtk_pcie_free_resources(ptr noundef %1)\n%8 = tail call i32 @mtk_pcie_irq_teardown(ptr noundef %1)\n%9 = tail call i32 @mtk_pcie_put_resources(ptr noundef %1)\nret i32 0\n}", "codegemma": "define internal i32 @mtk_pcie_remove(ptr noundef %0) {\nB:\n%1 = tail call ptr @platform_get_drvdata(ptr noundef %0)\n%2 = tail call ptr @pci_host_bridge_from_priv(ptr noundef %1)\n%3 = load i32, ptr %2, align 4\n%4 = tail call i32 @pci_stop_root_bus(i32 noundef %3)\n%5 = load i32, ptr %2, align 4\n%6 = tail call i32 @pci_remove_root_bus(i32 noundef %5)\n%7 = tail call i32 @mtk_pcie_free_resources(ptr noundef %1)\n%8 = tail call i32 @mtk_pcie_irq_teardown(ptr noundef %1)\n%9 = tail call i32 @mtk_pcie_put_resources(ptr noundef %1)\nret i32 0\n}"}, "define internal i64 @get_rxpacket_shiftbytes_819xusb(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.ieee80211_rx_stats ptr %3, i32 0, i32 1\n%5 = load i64, ptr %4, align 8\n%6 = add i64 4, %5\n%7 = load ptr, ptr %2, align 8\n%8 = getelementptr inbounds %struct.ieee80211_rx_stats ptr %7, i32 0, i32 0\n%9 = load i64, ptr %8, align 8\n%10 = add i64 %6, %9\nret i64 %10\n}": {"base_truth": "define internal i64 @get_rxpacket_shiftbytes_819xusb(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.ieee80211_rx_stats, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = add i64 %2, 4\n%4 = load i64, ptr %0, align 8\n%5 = add i64 %3, %4\nret i64 %5\n}", "codellama": "define internal i64 @get_rxpacket_shiftbytes_819xusb(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.ieee80211_rx_stats, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = add i64 %2, 4\n%4 = load i64, ptr %0, align 8\n%5 = add i64 %3, %4\nret i64 %5\n}", "codegemma": "define internal i64 @get_rxpacket_shiftbytes_819xusb(ptr nocapture noundef readonly %0) {\nB:\n%1 = getelementptr inbounds %struct.ieee80211_rx_stats, ptr %0, i64 0, i32 1\n%2 = load i64, ptr %1, align 8\n%3 = add i64 %2, 4\n%4 = load i64, ptr %0, align 8\n%5 = add i64 %3, %4\nret i64 %5\n}"}, "define dso_local void @opcode_82() {\n%1 = load i32, ptr @D, align 4\n%2 = call i32 @add_a_reg8(i32 noundef %1)\nret void\n}": {"base_truth": "define dso_local void @opcode_82() {\nB:\n%0 = load i32, ptr @D, align 4\n%1 = tail call i32 @add_a_reg8(i32 noundef %0)\nret void\n}", "codellama": "define dso_local void @opcode_82() {\nB:\n%0 = load i32, ptr @D, align 4\n%1 = tail call i32 @add_a_reg8(i32 noundef %0)\nret void\n}", "codegemma": "define dso_local void @opcode_82() {\nB:\n%0 = load i32, ptr @D, align 4\n%1 = tail call i32 @add_a_reg8(i32 noundef %0)\nret void\n}"}, "define internal i32 @is_indirect_le_key(i32 noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore ptr %1, ptr %4, align 8\n%5 = load i32, ptr %3, align 4\n%6 = load ptr, ptr %4, align 8\n%7 = call i64 @le_key_k_type(i32 noundef %5, ptr noundef %6)\n%8 = load i64, ptr @TYPE_INDIRECT, align 8\n%9 = icmp eq i64 %7, %8\n%10 = zext i1 %9 to i32\nret i32 %10\n}": {"base_truth": "define internal i32 @is_indirect_le_key(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i64 @le_key_k_type(i32 noundef %0, ptr noundef %1)\n%3 = load i64, ptr @TYPE_INDIRECT, align 8\n%4 = icmp eq i64 %2, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define internal i32 @is_indirect_le_key(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i64 @le_key_k_type(i32 noundef %0, ptr noundef %1)\n%3 = load i64, ptr @TYPE_INDIRECT, align 8\n%4 = icmp eq i64 %2, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codegemma": "define internal i32 @is_indirect_le_key(i32 noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i64 @le_key_k_type(i32 noundef %0, ptr noundef %1)\n%3 = load i64, ptr @TYPE_INDIRECT, align 8\n%4 = icmp eq i64 %2, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}"}, "define dso_local void @show_regs(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define dso_local void @show_regs(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define dso_local void @show_regs(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define dso_local void @show_regs(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define internal void @Tree_Del(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\nstore ptr %4, ptr %3, align 8\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @Tree_Clear(ptr noundef %5)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret void\n}": {"base_truth": "define internal void @Tree_Del(ptr noundef %0) {\nB:\n%1 = tail call i32 @Tree_Clear(ptr noundef %0)\nret void\n}", "codellama": "define internal void @Tree_Del(ptr noundef %0) {\nB:\n%1 = tail call i32 @Tree_Clear(ptr noundef %0)\nret void\n}", "codegemma": "define internal void @Tree_Del(ptr noundef %0) {\nB:\n%1 = tail call i32 @Tree_Clear(ptr noundef %0)\nret void\n}"}, "define dso_local i32 @tb_port_alloc_out_hopid(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr %6, align 4\n%10 = call i32 @tb_port_alloc_hopid(ptr noundef %7, i32 noundef 0, i32 noundef %8, i32 noundef %9)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @tb_port_alloc_out_hopid(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @tb_port_alloc_hopid(ptr noundef %0, i32 noundef 0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @tb_port_alloc_out_hopid(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @tb_port_alloc_hopid(ptr noundef %0, i32 noundef 0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @tb_port_alloc_out_hopid(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @tb_port_alloc_hopid(ptr noundef %0, i32 noundef 0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}"}, "define dso_local i32 @xdr_SECINFO_NO_NAME4res(ptr noundef %0, ptr noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca ptr, align 8\n%5 = alloca ptr, align 8\n%6 = alloca ptr, align 8\n%7 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore ptr %1, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %6)\n%8 = load ptr, ptr %4, align 8\n%9 = load ptr, ptr %5, align 8\n%10 = call i32 @xdr_SECINFO4res(ptr noundef %8, ptr noundef %9)\n%11 = icmp ne i32 %10, 0\nbr i1 %11, label %14, label %12\n\n12:\n%13 = load i32, ptr @FALSE, align 4\nstore i32 %13, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %16\n\n14:\n%15 = load i32, ptr @TRUE, align 4\nstore i32 %15, ptr %3, align 4\nstore i32 1, ptr %7, align 4\nbr label %16\n\n16:\ncall void @llvm.lifetime.end.p0(i64 8, ptr %6)\n%17 = load i32, ptr %3, align 4\nret i32 %17\n}": {"base_truth": "define dso_local i32 @xdr_SECINFO_NO_NAME4res(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_SECINFO4res(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @TRUE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}", "codellama": "define dso_local i32 @xdr_SECINFO_NO_NAME4res(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_SECINFO4res(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @TRUE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}", "codegemma": "define dso_local i32 @xdr_SECINFO_NO_NAME4res(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @xdr_SECINFO4res(ptr noundef %0, ptr noundef %1)\n%3 = icmp eq i32 %2, 0\n%4 = load i32, ptr @FALSE, align 4\n%5 = load i32, ptr @TRUE, align 4\n%6 = select i1 %3, i32 %4, i32 %5\nret i32 %6\n}"}, "define internal ptr @Iter_Brief() {\nret ptr @.str\n}": {"base_truth": "define internal nonnull ptr @Iter_Brief() {\nB:\nret ptr @.str\n}", "codellama": "define internal nonnull ptr @Iter_Brief() {\nB:\nret ptr @.str\n}", "codegemma": "define internal nonnull ptr @Iter_Brief() {\nB:\nret ptr @.str\n}"}, "define dso_local void @wlan_update() {\n%1 = call i32 (...) @_SlTaskEntry()\nret void\n}": {"base_truth": "define dso_local void @wlan_update() {\nB:\n%0 = tail call i32 (...) @_SlTaskEntry()\nret void\n}", "codellama": "define dso_local void @wlan_update() {\nB:\n%0 = tail call i32 (...) @_SlTaskEntry()\nret void\n}", "codegemma": "define dso_local void @wlan_update() {\nB:\n%0 = tail call i32 (...) @_SlTaskEntry()\nret void\n}"}, "define dso_local void @bad(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @memcmp(ptr noundef %5, ptr noundef %6, i32 noundef 8)\n%8 = load ptr, ptr %3, align 8\n%9 = call i32 @memset(ptr noundef %8, i32 noundef 0, i32 noundef 8)\n%10 = load ptr, ptr %3, align 8\n%11 = load ptr, ptr %4, align 8\n%12 = call i32 @memcpy(ptr noundef %10, ptr noundef %11, i32 noundef 8)\n%13 = load ptr, ptr %3, align 8\n%14 = load ptr, ptr %4, align 8\n%15 = call i32 @memmove(ptr noundef %13, ptr noundef %14, i32 noundef 8)\nret void\n}": {"base_truth": "define dso_local void @bad(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @memcmp(ptr noundef %0, ptr noundef %1, i32 noundef 8)\n%3 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 8)\n%4 = tail call i32 @memcpy(ptr noundef %0, ptr noundef %1, i32 noundef 8)\n%5 = tail call i32 @memmove(ptr noundef %0, ptr noundef %1, i32 noundef 8)\nret void\n}", "codellama": "define dso_local void @bad(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @memcmp(ptr noundef %0, ptr noundef %1, i32 noundef 8)\n%3 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 8)\n%4 = tail call i32 @memcpy(ptr noundef %0, ptr noundef %1, i32 noundef 8)\n%5 = tail call i32 @memmove(ptr noundef %0, ptr noundef %1, i32 noundef 8)\nret void\n}", "codegemma": "define dso_local void @bad(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @memcmp(ptr noundef %0, ptr noundef %1, i32 noundef 8)\n%3 = tail call i32 @memset(ptr noundef %0, i32 noundef 0, i32 noundef 8)\n%4 = tail call i32 @memcpy(ptr noundef %0, ptr noundef %1, i32 noundef 8)\n%5 = tail call i32 @memmove(ptr noundef %0, ptr noundef %1, i32 noundef 8)\nret void\n}"}, "define dso_local void @cx231xx_enable_OSC(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = load i32, ptr @CX23417_OSC_EN, align 4\n%5 = call i32 @cx231xx_set_gpio_value(ptr noundef %3, i32 noundef %4, i32 noundef 1)\nret void\n}": {"base_truth": "define dso_local void @cx231xx_enable_OSC(ptr noundef %0) {\nB:\n%1 = load i32, ptr @CX23417_OSC_EN, align 4\n%2 = tail call i32 @cx231xx_set_gpio_value(ptr noundef %0, i32 noundef %1, i32 noundef 1)\nret void\n}", "codellama": "define dso_local void @cx231xx_enable_OSC(ptr noundef %0) {\nB:\n%1 = load i32, ptr @CX23417_OSC_EN, align 4\n%2 = tail call i32 @cx231xx_set_gpio_value(ptr noundef %0, i32 noundef %1, i32 noundef 1)\nret void\n}", "codegemma": "define dso_local void @cx231xx_enable_OSC(ptr noundef %0) {\nB:\n%1 = load i32, ptr @CX23417_OSC_EN, align 4\n%2 = tail call i32 @cx231xx_set_gpio_value(ptr noundef %0, i32 noundef %1, i32 noundef 1)\nret void\n}"}, "define dso_local void @ccpon_pack_string_finish(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @ccpcp_pack_copy_byte(ptr noundef %3, i8 noundef signext 34)\nret void\n}": {"base_truth": "define dso_local void @ccpon_pack_string_finish(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccpcp_pack_copy_byte(ptr noundef %0, i8 noundef signext 34)\nret void\n}", "codellama": "define dso_local void @ccpon_pack_string_finish(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccpcp_pack_copy_byte(ptr noundef %0, i8 noundef signext 34)\nret void\n}", "codegemma": "define dso_local void @ccpon_pack_string_finish(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccpcp_pack_copy_byte(ptr noundef %0, i8 noundef signext 34)\nret void\n}"}, "define internal i32 @ppb_1284_reset_error(i32 noundef %0, i32 noundef %1) {\n%3 = alloca i32, align 4\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore i32 %0, ptr %3, align 4\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load i32, ptr %3, align 4\n%7 = call ptr @DEVTOSOFTC(i32 noundef %6)\nstore ptr %7, ptr %5, align 8\n%8 = load i32, ptr @PPB_NO_ERROR, align 4\n%9 = load ptr, ptr %5, align 8\n%10 = getelementptr inbounds %struct.ppb_data ptr %9, i32 0, i32 1\nstore i32 %8, ptr %10, align 4\n%11 = load i32, ptr %4, align 4\n%12 = load ptr, ptr %5, align 8\n%13 = getelementptr inbounds %struct.ppb_data ptr %12, i32 0, i32 0\nstore i32 %11, ptr %13, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 0\n}": {"base_truth": "define internal i32 @ppb_1284_reset_error(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @DEVTOSOFTC(i32 noundef %0)\n%3 = load i32, ptr @PPB_NO_ERROR, align 4\n%4 = getelementptr inbounds %struct.ppb_data, ptr %2, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\nstore i32 %1, ptr %2, align 4\nret i32 0\n}", "codellama": "define internal i32 @ppb_1284_reset_error(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @DEVTOSOFTC(i32 noundef %0)\n%3 = load i32, ptr @PPB_NO_ERROR, align 4\n%4 = getelementptr inbounds %struct.ppb_data, ptr %2, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\nstore i32 %1, ptr %2, align 4\nret i32 0\n}", "codegemma": "define internal i32 @ppb_1284_reset_error(i32 noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @DEVTOSOFTC(i32 noundef %0)\n%3 = load i32, ptr @PPB_NO_ERROR, align 4\n%4 = getelementptr inbounds %struct.ppb_data, ptr %2, i64 0, i32 1\nstore i32 %3, ptr %4, align 4\nstore i32 %1, ptr %2, align 4\nret i32 0\n}"}, "define dso_local i32 @yaffs_mount3_reldev(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\n%4 = alloca ptr, align 8\n%5 = alloca i32, align 4\n%6 = alloca i32, align 4\nstore ptr %0, ptr %4, align 8\nstore i32 %1, ptr %5, align 4\nstore i32 %2, ptr %6, align 4\n%7 = load ptr, ptr %4, align 8\n%8 = load i32, ptr %5, align 4\n%9 = load i32, ptr %6, align 4\n%10 = call i32 @yaffs_mount_common(ptr noundef %7, i32 noundef 0, i32 noundef %8, i32 noundef %9)\nret i32 %10\n}": {"base_truth": "define dso_local i32 @yaffs_mount3_reldev(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @yaffs_mount_common(ptr noundef %0, i32 noundef 0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @yaffs_mount3_reldev(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @yaffs_mount_common(ptr noundef %0, i32 noundef 0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @yaffs_mount3_reldev(ptr noundef %0, i32 noundef %1, i32 noundef %2) {\nB:\n%3 = tail call i32 @yaffs_mount_common(ptr noundef %0, i32 noundef 0, i32 noundef %1, i32 noundef %2)\nret i32 %3\n}"}, "define dso_local i32 @RectangleC_GetLeft(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @RectangleC_GetLeft(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @RectangleC_GetLeft(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @RectangleC_GetLeft(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define internal zeroext i8 @get_index(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load i32, ptr @last_index, align 4\nstore i32 %4, ptr %3, align 4\nstore i32 0, ptr @last_index, align 4\n%5 = load i32, ptr %3, align 4\n%6 = trunc i32 %5 to i8\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i8 %6\n}": {"base_truth": "define internal zeroext i8 @get_index(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @last_index, align 4\nstore i32 0, ptr @last_index, align 4\n%2 = trunc i32 %1 to i8\nret i8 %2\n}", "codellama": "define internal zeroext i8 @get_index(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @last_index, align 4\n%2 = trunc i32 %1 to i8\nstore i32 0, ptr @last_index, align 4\nret i8 %2\n}", "codegemma": "define internal zeroext i8 @get_index(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @last_index, align 4\nstore i32 0, ptr @last_index, align 4\n%2 = trunc i32 %1 to i8\nret i8 %2\n}"}, "define dso_local i32 @uv_thread_equal(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load i64, ptr %5, align 8\n%7 = load ptr, ptr %4, align 8\n%8 = load i64, ptr %7, align 8\n%9 = icmp eq i64 %6, %8\n%10 = zext i1 %9 to i32\nret i32 %10\n}": {"base_truth": "define dso_local i32 @uv_thread_equal(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr %1, align 8\n%4 = icmp eq i64 %2, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codellama": "define dso_local i32 @uv_thread_equal(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr %1, align 8\n%4 = icmp eq i64 %2, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}", "codegemma": "define dso_local i32 @uv_thread_equal(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) {\nB:\n%2 = load i64, ptr %0, align 8\n%3 = load i64, ptr %1, align 8\n%4 = icmp eq i64 %2, %3\n%5 = zext i1 %4 to i32\nret i32 %5\n}"}, "define dso_local i32 @iolooper_is_read(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\n%5 = load i32, ptr %4, align 4\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.TYPE_3__, ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\n%9 = call i32 @FD_ISSET(i32 noundef %5, i32 noundef %8)\nret i32 %9\n}": {"base_truth": "define dso_local i32 @iolooper_is_read(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @FD_ISSET(i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codellama": "define dso_local i32 @iolooper_is_read(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @FD_ISSET(i32 noundef %1, i32 noundef %2)\nret i32 %3\n}", "codegemma": "define dso_local i32 @iolooper_is_read(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call i32 @FD_ISSET(i32 noundef %1, i32 noundef %2)\nret i32 %3\n}"}, "define internal void @do_idle() {\n%1 = load i32, ptr @sda_hi, align 4\n%2 = load i32, ptr @scl_hi, align 4\n%3 = load i32, ptr @vcc_off, align 4\nret void\n}": {"base_truth": "define internal void @do_idle() {\nB:\nret void\n}", "codellama": "define internal void @do_idle() {\nB:\nret void\n}", "codegemma": "define internal void @do_idle() {\nB:\nret void\n}"}, "define dso_local void @isOdd(i32 noundef %0) {\n%2 = alloca i32, align 4\nstore i32 %0, ptr %2, align 4\n%3 = load i32, ptr %2, align 4\n%4 = srem i32 %3, 2\n%5 = icmp eq i32 %4, 0\nbr i1 %5, label %6, label %8\n\n6:\n%7 = call i32 @printf(ptr noundef @.str)\nbr label %10\n\n8:\n%9 = call i32 @printf(ptr noundef @.str.1)\nbr label %10\n\n10:\nret void\n}": {"base_truth": "define dso_local void @isOdd(i32 noundef %0) {\nB:\n%1 = and i32 %0, 1\n%2 = icmp eq i32 %1, 0\n%3 = select i1 %2, ptr @.str, ptr @.str.1\n%4 = tail call i32 @printf(ptr noundef nonnull %3)\nret void\n}", "codellama": "define dso_local void @isOdd(i32 noundef %0) {\nB:\n%1 = and i32 %0, 1\n%2 = icmp eq i32 %1, 0\n%3 = select i1 %2, ptr @.str, ptr @.str.1\n%4 = tail call i32 @printf(ptr noundef nonnull %3)\nret void\n}", "codegemma": "define dso_local void @isOdd(i32 noundef %0) {\nB:\n%1 = and i32 %0, 1\n%2 = icmp eq i32 %1, 0\n%3 = select i1 %2, ptr @.str, ptr @.str.1\n%4 = tail call i32 @printf(ptr noundef nonnull %3)\nret void\n}"}, "define internal i32 @ice_vc_add_vlan_msg(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @ice_vc_process_vlan_msg(ptr noundef %5, ptr noundef %6, i32 noundef 1)\nret i32 %7\n}": {"base_truth": "define internal i32 @ice_vc_add_vlan_msg(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @ice_vc_process_vlan_msg(ptr noundef %0, ptr noundef %1, i32 noundef 1)\nret i32 %2\n}", "codellama": "define internal i32 @ice_vc_add_vlan_msg(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @ice_vc_process_vlan_msg(ptr noundef %0, ptr noundef %1, i32 noundef 1)\nret i32 %2\n}", "codegemma": "define internal i32 @ice_vc_add_vlan_msg(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @ice_vc_process_vlan_msg(ptr noundef %0, ptr noundef %1, i32 noundef 1)\nret i32 %2\n}"}, "define internal void @adp5588_gpio_remove(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret void\n}": {"base_truth": "define internal void @adp5588_gpio_remove(ptr nocapture noundef %0) {\nB:\nret void\n}", "codellama": "define internal void @adp5588_gpio_remove(ptr nocapture noundef %0) {\nB:\nret void\n}", "codegemma": "define internal void @adp5588_gpio_remove(ptr nocapture noundef %0) {\nB:\nret void\n}"}, "define dso_local i32 @si_dpm_late_enable(ptr noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %4)\n%6 = load ptr, ptr %3, align 8\n%7 = call i32 @si_set_temperature_range(ptr noundef %6)\nstore i32 %7, ptr %4, align 4\n%8 = load i32, ptr %4, align 4\n%9 = icmp ne i32 %8, 0\nbr i1 %9, label %10, label %12\n\n10:\n%11 = load i32, ptr %4, align 4\nstore i32 %11, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %14\n\n12:\n%13 = load i32, ptr %4, align 4\nstore i32 %13, ptr %2, align 4\nstore i32 1, ptr %5, align 4\nbr label %14\n\n14:\ncall void @llvm.lifetime.end.p0(i64 4, ptr %4)\n%15 = load i32, ptr %2, align 4\nret i32 %15\n}": {"base_truth": "define dso_local i32 @si_dpm_late_enable(ptr noundef %0) {\nB:\n%1 = tail call i32 @si_set_temperature_range(ptr noundef %0)\nret i32 %1\n}", "codellama": "define dso_local i32 @si_dpm_late_enable(ptr noundef %0) {\nB:\n%1 = tail call i32 @si_set_temperature_range(ptr noundef %0)\nret i32 %1\n}", "codegemma": "define dso_local i32 @si_dpm_late_enable(ptr noundef %0) {\nB:\n%1 = tail call i32 @si_set_temperature_range(ptr noundef %0)\nret i32 %1\n}"}, "define dso_local void @test_make_arbre_fichier() {\n%1 = alloca ptr, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %1)\n%2 = call ptr @make_arbre_fichier(ptr noundef @.str)\nstore ptr %2, ptr %1, align 8\n%3 = load ptr, ptr %1, align 8\n%4 = call i32 @affiche_noeud_simple(ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %1)\nret void\n}": {"base_truth": "define dso_local void @test_make_arbre_fichier() {\nB:\n%0 = tail call ptr @make_arbre_fichier(ptr noundef nonnull @.str)\n%1 = tail call i32 @affiche_noeud_simple(ptr noundef %0)\nret void\n}", "codellama": "define dso_local void @test_make_arbre_fichier() {\nB:\n%0 = tail call ptr @make_arbre_fichier(ptr noundef nonnull @.str)\n%1 = tail call i32 @affiche_noeud_simple(ptr noundef %0)\nret void\n}", "codegemma": "define dso_local void @test_make_arbre_fichier() {\nB:\n%0 = tail call ptr @make_arbre_fichier(ptr noundef nonnull @.str)\n%1 = tail call i32 @affiche_noeud_simple(ptr noundef %0)\nret void\n}"}, "define internal i32 @modifier_color_encoding_is_set(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i64, ptr %4, align 8\n%6 = icmp ne i64 %5, 0\n%7 = zext i1 %6 to i32\nret i32 %7\n}": {"base_truth": "define internal i32 @modifier_color_encoding_is_set(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp ne i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codellama": "define internal i32 @modifier_color_encoding_is_set(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp ne i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}", "codegemma": "define internal i32 @modifier_color_encoding_is_set(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i64, ptr %0, align 8\n%2 = icmp ne i64 %1, 0\n%3 = zext i1 %2 to i32\nret i32 %3\n}"}, "define dso_local i32 @pa_context_get_source_info_by_index() {\n%1 = alloca i32, align 4\n%2 = call i32 @printf(ptr noundef @.str)\n%3 = load i32, ptr %1, align 4\nret i32 %3\n}": {"base_truth": "define dso_local i32 @pa_context_get_source_info_by_index() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 undef\n}", "codellama": "define dso_local i32 @pa_context_get_source_info_by_index() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 undef\n}", "codegemma": "define dso_local i32 @pa_context_get_source_info_by_index() {\nB:\n%0 = tail call i32 @printf(ptr noundef nonnull @.str)\nret i32 undef\n}"}, "define dso_local void @pixel_sad_x3_8x16(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef %5) {\n%7 = alloca ptr, align 8\n%8 = alloca ptr, align 8\n%9 = alloca ptr, align 8\n%10 = alloca ptr, align 8\n%11 = alloca i64, align 8\n%12 = alloca ptr, align 8\nstore ptr %0, ptr %7, align 8\nstore ptr %1, ptr %8, align 8\nstore ptr %2, ptr %9, align 8\nstore ptr %3, ptr %10, align 8\nstore i64 %4, ptr %11, align 8\nstore ptr %5, ptr %12, align 8\n%13 = load ptr, ptr %7, align 8\n%14 = load ptr, ptr %8, align 8\n%15 = load i64, ptr %11, align 8\n%16 = call i32 @pixel_sad_8x16(ptr noundef %13, i32 noundef 16, ptr noundef %14, i64 noundef %15)\n%17 = load ptr, ptr %12, align 8\n%18 = getelementptr inbounds i32, ptr %17, i64 0\nstore i32 %16, ptr %18, align 4\n%19 = load ptr, ptr %7, align 8\n%20 = load ptr, ptr %9, align 8\n%21 = load i64, ptr %11, align 8\n%22 = call i32 @pixel_sad_8x16(ptr noundef %19, i32 noundef 16, ptr noundef %20, i64 noundef %21)\n%23 = load ptr, ptr %12, align 8\n%24 = getelementptr inbounds i32, ptr %23, i64 1\nstore i32 %22, ptr %24, align 4\n%25 = load ptr, ptr %7, align 8\n%26 = load ptr, ptr %10, align 8\n%27 = load i64, ptr %11, align 8\n%28 = call i32 @pixel_sad_8x16(ptr noundef %25, i32 noundef 16, ptr noundef %26, i64 noundef %27)\n%29 = load ptr, ptr %12, align 8\n%30 = getelementptr inbounds i32, ptr %29, i64 2\nstore i32 %28, ptr %30, align 4\nret void\n}": {"base_truth": "define dso_local void @pixel_sad_x3_8x16(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr nocapture noundef writeonly %5) {\nB:\n%6 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %1, i64 noundef %4)\nstore i32 %6, ptr %5, align 4\n%7 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %2, i64 noundef %4)\n%8 = getelementptr inbounds i32, ptr %5, i64 1\nstore i32 %7, ptr %8, align 4\n%9 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %3, i64 noundef %4)\n%10 = getelementptr inbounds i32, ptr %5, i64 2\nstore i32 %9, ptr %10, align 4\nret void\n}", "codellama": "define dso_local void @pixel_sad_x3_8x16(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr nocapture noundef writeonly %5) {\nB:\n%6 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %1, i64 noundef %4)\nstore i32 %6, ptr %5, align 4\n%7 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %2, i64 noundef %4)\n%8 = getelementptr inbounds i32, ptr %5, i64 1\nstore i32 %7, ptr %8, align 4\n%9 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %3, i64 noundef %4)\n%10 = getelementptr inbounds i32, ptr %5, i64 2\nstore i32 %9, ptr %10, align 4\nret void\n}", "codegemma": "define dso_local void @pixel_sad_x3_8x16(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr nocapture noundef writeonly %5) {\nB:\n%6 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %1, i64 noundef %4)\nstore i32 %6, ptr %5, align 4\n%7 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %2, i64 noundef %4)\n%8 = getelementptr inbounds i32, ptr %5, i64 1\nstore i32 %7, ptr %8, align 4\n%9 = tail call i32 @pixel_sad_8x16(ptr noundef %0, i32 noundef 16, ptr noundef %3, i64 noundef %4)\n%10 = getelementptr inbounds i32, ptr %5, i64 2\nstore i32 %9, ptr %10, align 4\nret void\n}"}, "define internal i32 @tps65910_rtc_alarm_irq_enable(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\n%6 = alloca i32, align 4\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%7 = load ptr, ptr %3, align 8\n%8 = getelementptr inbounds %struct.device ptr %7, i32 0, i32 0\n%9 = load i32, ptr %8, align 4\n%10 = call ptr @dev_get_drvdata(i32 noundef %9)\nstore ptr %10, ptr %5, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %6)\nstore i32 0, ptr %6, align 4\n%11 = load i32, ptr %4, align 4\n%12 = icmp ne i32 %11, 0\nbr i1 %12, label %13, label %15\n\n13:\n%14 = load i32, ptr @TPS65910_RTC_INTERRUPTS_IT_ALARM, align 4\nstore i32 %14, ptr %6, align 4\nbr label %15\n\n15:\n%16 = load ptr, ptr %5, align 8\n%17 = getelementptr inbounds %struct.tps65910 ptr %16, i32 0, i32 0\n%18 = load i32, ptr %17, align 4\n%19 = load i32, ptr @TPS65910_RTC_INTERRUPTS, align 4\n%20 = load i32, ptr %6, align 4\n%21 = call i32 @regmap_write(i32 noundef %18, i32 noundef %19, i32 noundef %20)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %6)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 %21\n}": {"base_truth": "define internal i32 @tps65910_rtc_alarm_irq_enable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @dev_get_drvdata(i32 noundef %2)\n%4 = icmp eq i32 %1, 0\n%5 = load i32, ptr @TPS65910_RTC_INTERRUPTS_IT_ALARM, align 4\n%6 = select i1 %4, i32 0, i32 %5\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @TPS65910_RTC_INTERRUPTS, align 4\n%9 = tail call i32 @regmap_write(i32 noundef %7, i32 noundef %8, i32 noundef %6)\nret i32 %9\n}", "codellama": "define internal i32 @tps65910_rtc_alarm_irq_enable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @dev_get_drvdata(i32 noundef %2)\n%4 = icmp eq i32 %1, 0\n%5 = load i32, ptr @TPS65910_RTC_INTERRUPTS_IT_ALARM, align 4\n%6 = select i1 %4, i32 0, i32 %5\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @TPS65910_RTC_INTERRUPTS, align 4\n%9 = tail call i32 @regmap_write(i32 noundef %7, i32 noundef %8, i32 noundef %6)\nret i32 %9\n}", "codegemma": "define internal i32 @tps65910_rtc_alarm_irq_enable(ptr nocapture noundef readonly %0, i32 noundef %1) {\nB:\n%2 = load i32, ptr %0, align 4\n%3 = tail call ptr @dev_get_drvdata(i32 noundef %2)\n%4 = icmp eq i32 %1, 0\n%5 = load i32, ptr @TPS65910_RTC_INTERRUPTS_IT_ALARM, align 4\n%6 = select i1 %4, i32 0, i32 %5\n%7 = load i32, ptr %3, align 4\n%8 = load i32, ptr @TPS65910_RTC_INTERRUPTS, align 4\n%9 = tail call i32 @regmap_write(i32 noundef %7, i32 noundef %8, i32 noundef %6)\nret i32 %9\n}"}, "define dso_local void @destroy_win(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @wborder(ptr noundef %3, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32)\n%5 = load ptr, ptr %2, align 8\n%6 = call i32 @wrefresh(ptr noundef %5)\n%7 = load ptr, ptr %2, align 8\n%8 = call i32 @delwin(ptr noundef %7)\n%9 = call i32 (...) @endwin()\n%10 = call i32 (...) @refresh()\nret void\n}": {"base_truth": "define dso_local void @destroy_win(ptr noundef %0) {\nB:\n%1 = tail call i32 @wborder(ptr noundef %0, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32)\n%2 = tail call i32 @wrefresh(ptr noundef %0)\n%3 = tail call i32 @delwin(ptr noundef %0)\n%4 = tail call i32 (...) @endwin()\n%5 = tail call i32 (...) @refresh()\nret void\n}", "codellama": "define dso_local void @destroy_win(ptr noundef %0) {\nB:\n%1 = tail call i32 @wborder(ptr noundef %0, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32)\n%2 = tail call i32 @wrefresh(ptr noundef %0)\n%3 = tail call i32 @delwin(ptr noundef %0)\n%4 = tail call i32 (...) @endwin()\n%5 = tail call i32 (...) @refresh()\nret void\n}", "codegemma": "define dso_local void @destroy_win(ptr noundef %0) {\nB:\n%1 = tail call i32 @wborder(ptr noundef %0, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32, i8 noundef signext 32)\n%2 = tail call i32 @wrefresh(ptr noundef %0)\n%3 = tail call i32 @delwin(ptr noundef %0)\n%4 = tail call i32 (...) @endwin()\n%5 = tail call i32 (...) @refresh()\nret void\n}"}, "define dso_local signext i8 @HUMIDITY_GET_DATA() {\n%1 = call signext i8 (...) @TOSH_READ_HUM_SDA_PIN()\nret i8 %1\n}": {"base_truth": "define dso_local signext i8 @HUMIDITY_GET_DATA() {\nB:\n%0 = tail call signext i8 (...) @TOSH_READ_HUM_SDA_PIN()\nret i8 %0\n}", "codellama": "define dso_local signext i8 @HUMIDITY_GET_DATA() {\nB:\n%0 = tail call signext i8 (...) @TOSH_READ_HUM_SDA_PIN()\nret i8 %0\n}", "codegemma": "define dso_local signext i8 @HUMIDITY_GET_DATA() {\nB:\n%0 = tail call signext i8 (...) @TOSH_READ_HUM_SDA_PIN()\nret i8 %0\n}"}, "define internal i32 @mv88e1xxx_intr_clear(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = load i32, ptr @MV88E1XXX_INTR_STATUS, align 4\n%6 = call i32 @mdio_read(ptr noundef %4, i32 noundef 0, i32 noundef %5, ptr noundef %3)\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %6\n}": {"base_truth": "define internal i32 @mv88e1xxx_intr_clear(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr @MV88E1XXX_INTR_STATUS, align 4\n%3 = call i32 @mdio_read(ptr noundef %0, i32 noundef 0, i32 noundef %2, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %3\n}", "codellama": "define internal i32 @mv88e1xxx_intr_clear(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr @MV88E1XXX_INTR_STATUS, align 4\n%3 = call i32 @mdio_read(ptr noundef %0, i32 noundef 0, i32 noundef %2, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %3\n}", "codegemma": "define internal i32 @mv88e1xxx_intr_clear(ptr noundef %0) {\nB:\n%1 = alloca i32, align 4\ncall void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)\n%2 = load i32, ptr @MV88E1XXX_INTR_STATUS, align 4\n%3 = call i32 @mdio_read(ptr noundef %0, i32 noundef 0, i32 noundef %2, ptr noundef nonnull %1)\ncall void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)\nret i32 %3\n}"}, "define internal void @mlxsw_sp_nexthop4_fini(ptr noundef %0, ptr noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore ptr %1, ptr %4, align 8\n%5 = load ptr, ptr %3, align 8\n%6 = load ptr, ptr %4, align 8\n%7 = call i32 @mlxsw_sp_nexthop4_type_fini(ptr noundef %5, ptr noundef %6)\n%8 = load ptr, ptr %4, align 8\n%9 = getelementptr inbounds %struct.mlxsw_sp_nexthop ptr %8, i32 0, i32 0\n%10 = call i32 @list_del(ptr noundef %9)\n%11 = load ptr, ptr %3, align 8\n%12 = load ptr, ptr %4, align 8\n%13 = call i32 @mlxsw_sp_nexthop_counter_free(ptr noundef %11, ptr noundef %12)\n%14 = load ptr, ptr %3, align 8\n%15 = load ptr, ptr %4, align 8\n%16 = call i32 @mlxsw_sp_nexthop_remove(ptr noundef %14, ptr noundef %15)\nret void\n}": {"base_truth": "define internal void @mlxsw_sp_nexthop4_fini(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @mlxsw_sp_nexthop4_type_fini(ptr noundef %0, ptr noundef %1)\n%3 = tail call i32 @list_del(ptr noundef %1)\n%4 = tail call i32 @mlxsw_sp_nexthop_counter_free(ptr noundef %0, ptr noundef %1)\n%5 = tail call i32 @mlxsw_sp_nexthop_remove(ptr noundef %0, ptr noundef %1)\nret void\n}", "codellama": "define internal void @mlxsw_sp_nexthop4_fini(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @mlxsw_sp_nexthop4_type_fini(ptr noundef %0, ptr noundef %1)\n%3 = tail call i32 @list_del(ptr noundef %1)\n%4 = tail call i32 @mlxsw_sp_nexthop_counter_free(ptr noundef %0, ptr noundef %1)\n%5 = tail call i32 @mlxsw_sp_nexthop_remove(ptr noundef %0, ptr noundef %1)\nret void\n}", "codegemma": "define internal void @mlxsw_sp_nexthop4_fini(ptr noundef %0, ptr noundef %1) {\nB:\n%2 = tail call i32 @mlxsw_sp_nexthop4_type_fini(ptr noundef %0, ptr noundef %1)\n%3 = tail call i32 @list_del(ptr noundef %1)\n%4 = tail call i32 @mlxsw_sp_nexthop_counter_free(ptr noundef %0, ptr noundef %1)\n%5 = tail call i32 @mlxsw_sp_nexthop_remove(ptr noundef %0, ptr noundef %1)\nret void\n}"}, "define internal i64 @clk_pxa3xx_core_get_rate(ptr noundef %0, i64 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i64, align 8\nstore ptr %0, ptr %3, align 8\nstore i64 %1, ptr %4, align 8\n%5 = load i64, ptr %4, align 8\nret i64 %5\n}": {"base_truth": "define internal i64 @clk_pxa3xx_core_get_rate(ptr nocapture noundef readnone %0, i64 noundef returned %1) {\nB:\nret i64 %1\n}", "codellama": "define internal i64 @clk_pxa3xx_core_get_rate(ptr nocapture noundef readnone %0, i64 noundef returned %1) {\nB:\nret i64 %1\n}", "codegemma": "define internal i64 @clk_pxa3xx_core_get_rate(ptr nocapture noundef readnone %0, i64 noundef returned %1) {\nB:\nret i64 %1\n}"}, "define internal i32 @ccp_aes_xts_encrypt(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = call i32 @ccp_aes_xts_crypt(ptr noundef %3, i32 noundef 1)\nret i32 %4\n}": {"base_truth": "define internal i32 @ccp_aes_xts_encrypt(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccp_aes_xts_crypt(ptr noundef %0, i32 noundef 1)\nret i32 %1\n}", "codellama": "define internal i32 @ccp_aes_xts_encrypt(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccp_aes_xts_crypt(ptr noundef %0, i32 noundef 1)\nret i32 %1\n}", "codegemma": "define internal i32 @ccp_aes_xts_encrypt(ptr noundef %0) {\nB:\n%1 = tail call i32 @ccp_aes_xts_crypt(ptr noundef %0, i32 noundef 1)\nret i32 %1\n}"}, "define internal i32 @idt_ntb_db_set_mask(ptr noundef %0, i32 noundef %1) {\n%3 = alloca ptr, align 8\n%4 = alloca i32, align 4\n%5 = alloca ptr, align 8\nstore ptr %0, ptr %3, align 8\nstore i32 %1, ptr %4, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = load ptr, ptr %3, align 8\n%7 = call ptr @to_ndev_ntb(ptr noundef %6)\nstore ptr %7, ptr %5, align 8\n%8 = load ptr, ptr %5, align 8\n%9 = load i32, ptr @IDT_NT_INDBELLMSK, align 4\n%10 = load ptr, ptr %5, align 8\n%11 = getelementptr inbounds %struct.idt_ntb_dev ptr %10, i32 0, i32 0\n%12 = load i32, ptr @IDT_DBELL_MASK, align 4\n%13 = load i32, ptr %4, align 4\n%14 = call i32 @idt_reg_set_bits(ptr noundef %8, i32 noundef %9, ptr noundef %11, i32 noundef %12, i32 noundef %13)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 %14\n}": {"base_truth": "define internal i32 @idt_ntb_db_set_mask(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @to_ndev_ntb(ptr noundef %0)\n%3 = load i32, ptr @IDT_NT_INDBELLMSK, align 4\n%4 = load i32, ptr @IDT_DBELL_MASK, align 4\n%5 = tail call i32 @idt_reg_set_bits(ptr noundef %2, i32 noundef %3, ptr noundef %2, i32 noundef %4, i32 noundef %1)\nret i32 %5\n}", "codellama": "define internal i32 @idt_ntb_db_set_mask(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @to_ndev_ntb(ptr noundef %0)\n%3 = load i32, ptr @IDT_NT_INDBELLMSK, align 4\n%4 = load i32, ptr @IDT_DBELL_MASK, align 4\n%5 = tail call i32 @idt_reg_set_bits(ptr noundef %2, i32 noundef %3, ptr noundef %2, i32 noundef %4, i32 noundef %1)\nret i32 %5\n}", "codegemma": "define internal i32 @idt_ntb_db_set_mask(ptr noundef %0, i32 noundef %1) {\nB:\n%2 = tail call ptr @to_ndev_ntb(ptr noundef %0)\n%3 = load i32, ptr @IDT_NT_INDBELLMSK, align 4\n%4 = load i32, ptr @IDT_DBELL_MASK, align 4\n%5 = tail call i32 @idt_reg_set_bits(ptr noundef %2, i32 noundef %3, ptr noundef %2, i32 noundef %4, i32 noundef %1)\nret i32 %5\n}"}, "define internal i32 @digits_of(i32 noundef %0) {\n%2 = alloca i32, align 4\n%3 = alloca [80 x i8], align 16\nstore i32 %0, ptr %2, align 4\ncall void @llvm.lifetime.start.p0(i64 80, ptr %3)\n%4 = getelementptr inbounds [80 x i8], ptr %3, i64 0, i64 0\n%5 = load i32, ptr %2, align 4\n%6 = call i32 @sprintf(ptr noundef %4, ptr noundef @.str, i32 noundef %5)\n%7 = getelementptr inbounds [80 x i8], ptr %3, i64 0, i64 0\n%8 = call i64 @strlen(ptr noundef %7)\n%9 = trunc i64 %8 to i32\ncall void @llvm.lifetime.end.p0(i64 80, ptr %3)\nret i32 %9\n}": {"base_truth": "define internal i32 @digits_of(i32 noundef %0) {\nB:\n%1 = alloca [80 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 80, ptr nonnull %1)\n%2 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef %0)\n%3 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1)\n%4 = trunc i64 %3 to i32\ncall void @llvm.lifetime.end.p0(i64 80, ptr nonnull %1)\nret i32 %4\n}", "codellama": "define internal i32 @digits_of(i32 noundef %0) {\nB:\n%1 = alloca [80 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 80, ptr nonnull %1)\n%2 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef %0)\n%3 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1)\n%4 = trunc i64 %3 to i32\ncall void @llvm.lifetime.end.p0(i64 80, ptr nonnull %1)\nret i32 %4\n}", "codegemma": "define internal i32 @digits_of(i32 noundef %0) {\nB:\n%1 = alloca [80 x i8], align 16\ncall void @llvm.lifetime.start.p0(i64 80, ptr nonnull %1)\n%2 = call i32 @sprintf(ptr noundef nonnull %1, ptr noundef nonnull @.str, i32 noundef %0)\n%3 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1)\n%4 = trunc i64 %3 to i32\ncall void @llvm.lifetime.end.p0(i64 80, ptr nonnull %1)\nret i32 %4\n}"}, "define internal i32 @vpfe_resume(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret i32 -1\n}": {"base_truth": "define internal i32 @vpfe_resume(ptr nocapture noundef readnone %0) {\nB:\nret i32 -1\n}", "codellama": "define internal i32 @vpfe_resume(ptr nocapture noundef readnone %0) {\nB:\nret i32 -1\n}", "codegemma": "define internal i32 @vpfe_resume(ptr nocapture noundef readnone %0) {\nB:\nret i32 -1\n}"}, "define dso_local i32 @saa7164_getcurrentfirmwareversion(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca i32, align 4\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 4, ptr %3)\n%4 = load i32, ptr @SAA_DEVICE_VERSION, align 4\n%5 = call i32 @saa7164_readl(i32 noundef %4)\nstore i32 %5, ptr %3, align 4\n%6 = load i32, ptr %3, align 4\n%7 = and i32 %6, 64512\n%8 = ashr i32 %7, 10\n%9 = load i32, ptr %3, align 4\n%10 = and i32 %9, 992\n%11 = ashr i32 %10, 5\n%12 = load i32, ptr %3, align 4\n%13 = and i32 %12, 31\n%14 = load i32, ptr %3, align 4\n%15 = and i32 %14, -65536\n%16 = lshr i32 %15, 16\n%17 = load i32, ptr %3, align 4\n%18 = call i32 @dprintk(i32 noundef 1, ptr noundef @.str, i32 noundef %8, i32 noundef %11, i32 noundef %13, i32 noundef %16, i32 noundef %17)\n%19 = load i32, ptr %3, align 4\ncall void @llvm.lifetime.end.p0(i64 4, ptr %3)\nret i32 %19\n}": {"base_truth": "define dso_local i32 @saa7164_getcurrentfirmwareversion(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @SAA_DEVICE_VERSION, align 4\n%2 = tail call i32 @saa7164_readl(i32 noundef %1)\n%3 = lshr i32 %2, 10\n%4 = and i32 %3, 63\n%5 = lshr i32 %2, 5\n%6 = and i32 %5, 31\n%7 = and i32 %2, 31\n%8 = lshr i32 %2, 16\n%9 = tail call i32 @dprintk(i32 noundef 1, ptr noundef nonnull @.str, i32 noundef %4, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %2)\nret i32 %2\n}", "codellama": "define dso_local i32 @saa7164_getcurrentfirmwareversion(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @SAA_DEVICE_VERSION, align 4\n%2 = tail call i32 @saa7164_readl(i32 noundef %1)\n%3 = lshr i32 %2, 10\n%4 = and i32 %3, 31\n%5 = lshr i32 %2, 5\n%6 = and i32 %5, 31\n%7 = lshr i32 %2, 16\n%8 = and i32 %7, 31\n%9 = tail call i32 @dprintk(i32 noundef 1, ptr noundef nonnull @.str, i32 noundef %4, i32 noundef %6, i32 noundef %8, i32 noundef %8, i32 noundef %2)\nret i32 %2\n}", "codegemma": "define dso_local i32 @saa7164_getcurrentfirmwareversion(ptr nocapture noundef readnone %0) {\nB:\n%1 = load i32, ptr @SAA_DEVICE_VERSION, align 4\n%2 = tail call i32 @saa7164_readl(i32 noundef %1)\n%3 = lshr i32 %2, 10\n%4 = and i32 %3, 64512\n%5 = lshr i32 %2, 5\n%6 = and i32 %5, 992\n%7 = and i32 %2, 31\n%8 = lshr i32 %2, 16\n%9 = tail call i32 @dprintk(i32 noundef 1, ptr noundef nonnull @.str, i32 noundef %4, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %2)\nret i32 %2\n}"}, "define dso_local ptr @fb_DylibLoad(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\nret ptr null\n}": {"base_truth": "define dso_local noalias ptr @fb_DylibLoad(ptr nocapture noundef readnone %0) {\nB:\nret ptr null\n}", "codellama": "define dso_local noalias ptr @fb_DylibLoad(ptr nocapture noundef readnone %0) {\nB:\nret ptr null\n}", "codegemma": "define dso_local noalias ptr @fb_DylibLoad(ptr nocapture noundef readnone %0) {\nB:\nret ptr null\n}"}, "define internal i32 @nfp6000_area_phys(ptr noundef %0) {\n%2 = alloca ptr, align 8\n%3 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %3)\n%4 = load ptr, ptr %2, align 8\n%5 = call ptr @nfp_cpp_area_priv(ptr noundef %4)\nstore ptr %5, ptr %3, align 8\n%6 = load ptr, ptr %3, align 8\n%7 = getelementptr inbounds %struct.nfp6000_area_priv ptr %6, i32 0, i32 0\n%8 = load i32, ptr %7, align 4\ncall void @llvm.lifetime.end.p0(i64 8, ptr %3)\nret i32 %8\n}": {"base_truth": "define internal i32 @nfp6000_area_phys(ptr noundef %0) {\nB:\n%1 = tail call ptr @nfp_cpp_area_priv(ptr noundef %0)\n%2 = load i32, ptr %1, align 4\nret i32 %2\n}", "codellama": "define internal i32 @nfp6000_area_phys(ptr noundef %0) {\nB:\n%1 = tail call ptr @nfp_cpp_area_priv(ptr noundef %0)\n%2 = load i32, ptr %1, align 4\nret i32 %2\n}", "codegemma": "define internal i32 @nfp6000_area_phys(ptr noundef %0) {\nB:\n%1 = tail call ptr @nfp_cpp_area_priv(ptr noundef %0)\n%2 = load i32, ptr %1, align 4\nret i32 %2\n}"}, "define dso_local i32 @eseed(i64 noundef %0) {\n%2 = alloca i64, align 8\nstore i64 %0, ptr %2, align 8\n%3 = load i64, ptr %2, align 8\n%4 = trunc i64 %3 to i32\n%5 = shl i32 %4, 16\n%6 = or i32 %5, 13070\nret i32 %6\n}": {"base_truth": "define dso_local i32 @eseed(i64 noundef %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = shl i32 %1, 16\n%3 = or i32 %2, 13070\nret i32 %3\n}", "codellama": "define dso_local i32 @eseed(i64 noundef %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = shl i32 %1, 16\n%3 = or i32 %2, 13070\nret i32 %3\n}", "codegemma": "define dso_local i32 @eseed(i64 noundef %0) {\nB:\n%1 = trunc i64 %0 to i32\n%2 = shl i32 %1, 16\n%3 = or i32 %2, 13070\nret i32 %3\n}"}, "define dso_local i32 @hss_size(ptr noundef %0) {\n%2 = alloca ptr, align 8\nstore ptr %0, ptr %2, align 8\n%3 = load ptr, ptr %2, align 8\n%4 = getelementptr inbounds %struct.TYPE_3__, ptr %3, i32 0, i32 0\n%5 = load i32, ptr %4, align 4\nret i32 %5\n}": {"base_truth": "define dso_local i32 @hss_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codellama": "define dso_local i32 @hss_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}", "codegemma": "define dso_local i32 @hss_size(ptr nocapture noundef readonly %0) {\nB:\n%1 = load i32, ptr %0, align 4\nret i32 %1\n}"}, "define dso_local i32 @ls_wait_input_on_fd(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\n%3 = alloca i32, align 4\n%4 = alloca double, align 8\n%5 = alloca %struct.pollfd align 4\nstore i32 %0, ptr %3, align 4\nstore double %1, ptr %4, align 8\ncall void @llvm.lifetime.start.p0(i64 8, ptr %5)\n%6 = getelementptr inbounds %struct.pollfd ptr %5, i32 0, i32 0\n%7 = load i32, ptr %3, align 4\nstore i32 %7, ptr %6, align 4\n%8 = getelementptr inbounds %struct.pollfd ptr %5, i32 0, i32 1\n%9 = load i32, ptr @POLLIN, align 4\nstore i32 %9, ptr %8, align 4\n%10 = load double, ptr %4, align 8\n%11 = call i32 @ls_poll(ptr noundef %5, i32 noundef 1, double noundef nofpclass(nan inf) %10)\ncall void @llvm.lifetime.end.p0(i64 8, ptr %5)\nret i32 %11\n}": {"base_truth": "define dso_local i32 @ls_wait_input_on_fd(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = alloca %struct.pollfd, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\nstore i32 %0, ptr %2, align 4\n%3 = getelementptr inbounds %struct.pollfd, ptr %2, i64 0, i32 1\n%4 = load i32, ptr @POLLIN, align 4\nstore i32 %4, ptr %3, align 4\n%5 = call i32 @ls_poll(ptr noundef nonnull %2, i32 noundef 1, double noundef nofpclass(nan inf) %1)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret i32 %5\n}", "codellama": "define dso_local i32 @ls_wait_input_on_fd(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = alloca %struct.pollfd, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\nstore i32 %0, ptr %2, align 4\n%3 = getelementptr inbounds %struct.pollfd, ptr %2, i64 0, i32 1\n%4 = load i32, ptr @POLLIN, align 4\nstore i32 %4, ptr %3, align 4\n%5 = call i32 @ls_poll(ptr noundef nonnull %2, i32 noundef 1, double noundef nofpclass(nan inf) %1)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret i32 %5\n}", "codegemma": "define dso_local i32 @ls_wait_input_on_fd(i32 noundef %0, double noundef nofpclass(nan inf) %1) {\nB:\n%2 = alloca %struct.pollfd, align 4\ncall void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)\nstore i32 %0, ptr %2, align 4\n%3 = getelementptr inbounds %struct.pollfd, ptr %2, i64 0, i32 1\n%4 = load i32, ptr @POLLIN, align 4\nstore i32 %4, ptr %3, align 4\n%5 = call i32 @ls_poll(ptr noundef nonnull %2, i32 noundef 1, double noundef nofpclass(nan inf) %1)\ncall void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)\nret i32 %5\n}"}}